<!DOCTYPE html>













<html class="theme-next gemini" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">

<meta name="google-site-verification" content="jgw73iXouBAJcOuff0yi9vdSNDecBSOUXacsHJszpmo" />
<meta name="baidu-site-verification" content="xyf9WD2vvl" />











<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/apple-icon-57x57.png?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_body":"slideDownIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="001. Two SumDescription: 求出能组合出目标数的两个元素Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one s">
<meta name="keywords" content="算法刷题">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode算法题(Easy)">
<meta property="og:url" content="https://hellozhaozheng.github.io/z_post/面试-算法刷题-LeetCode-1/index.html">
<meta property="og:site_name" content="从零开始的BLOG">
<meta property="og:description" content="001. Two SumDescription: 求出能组合出目标数的两个元素Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one s">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://wx1.sinaimg.cn/large/d7b90c85ly1fxlbg7qyk9j21cs0nwq4u.jpg">
<meta property="og:image" content="http://wx3.sinaimg.cn/large/d7b90c85ly1fxngsjxjyag20cd0a9q6x.gif">
<meta property="og:updated_time" content="2019-03-28T02:31:40.695Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode算法题(Easy)">
<meta name="twitter:description" content="001. Two SumDescription: 求出能组合出目标数的两个元素Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one s">
<meta name="twitter:image" content="https://wx1.sinaimg.cn/large/d7b90c85ly1fxlbg7qyk9j21cs0nwq4u.jpg">






  <link rel="canonical" href="https://hellozhaozheng.github.io/z_post/面试-算法刷题-LeetCode-1/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>LeetCode算法题(Easy) | 从零开始的BLOG</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?21a4899cc63d3c11a3d90ac58074a19c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">从零开始的BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">与其感慨路难行，不如马上出发</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档<span class="badge">263</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-计算机视觉">
    <a href="/categories/计算机视觉/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tripadvisor"></i> <br />计算机视觉</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-深度学习">
    <a href="/categories/深度学习/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-drupal"></i> <br />深度学习</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-caffe2">
    <a href="/categories/Caffe2/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-coffee"></i> <br />Caffe2</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-pytorch">
    <a href="/categories/PyTorch/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-free-code-camp"></i> <br />PyTorch</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-c++">
    <a href="/categories/Cpp/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-codiepie"></i> <br />C++</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-python">
    <a href="/categories/Python/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-product-hunt"></i> <br />Python</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-项目">
    <a href="/categories/项目/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-connectdevelop"></i> <br />项目</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-cuda">
    <a href="/categories/CUDA/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-braille"></i> <br />CUDA</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-其他">
    <a href="/categories/其他/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />其他</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签<span class="badge">40</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于我</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />站内搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="站内搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  
  
    
      
    
    <a href="https://github.com/hellozhaozheng" class="github-corner" target="_blank" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg>
    
      </a>
    



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hellozhaozheng.github.io/z_post/面试-算法刷题-LeetCode-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZeroZone">
      <meta itemprop="description" content="并不是什么厉害的地方<br>只是一个安静的学习角落">
      <meta itemprop="image" content="/images/avatar_zz.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始的BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">LeetCode算法题(Easy)
              
            
          </h1>
        

        <div class="post-meta">
	
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-01 08:32:03" itemprop="dateCreated datePublished" datetime="2018-10-01T08:32:03+08:00">2018-10-01</time>
            

            
          </span>

	  
  	    <span class="post-updated">
    		&nbsp; | &nbsp; 更新于
    		<time itemprop="dateUpdated" datetime="2019-03-28T10:31:40+08:00" content="2019-03-28">
      		  2019-03-28
    		</time>
  	  </span>
	  

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon"
            >
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">82k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1:15</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="001-Two-Sum"><a href="#001-Two-Sum" class="headerlink" title="001. Two Sum"></a>001. Two Sum</h1><h2 id="Description-求出能组合出目标数的两个元素"><a href="#Description-求出能组合出目标数的两个元素" class="headerlink" title="Description: 求出能组合出目标数的两个元素"></a>Description: 求出能组合出目标数的两个元素</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong>exactly one solution</strong>, and you may not use the same element twice.</p>
<p>Example:</p>
<p>Given nums = [2, 7, 11, 15], target = 9,</p>
<p>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>
<h2 id="解法一-穷举"><a href="#解法一-穷举" class="headerlink" title="解法一: 穷举"></a>解法一: 穷举</h2><p>时间复杂度: $O(n^2)$<br>空间复杂度: $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;nums.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res =&#123;i,j&#125;;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-哈希表-两次遍历"><a href="#解法二-哈希表-两次遍历" class="headerlink" title="解法二 : 哈希表, 两次遍历"></a>解法二 : 哈希表, 两次遍历</h2><p><strong>注意, 题目中说数组的解恰好只有一个, 这是一种很强的假设, 解法二在面对有多个解时, 也只会输出一个</strong><br>这里要特别注意: 同一个元素不能使用两次, 但是数组中的元素是可以重复的, 重复的元素看作是两个元素. hash表中最终存储的将会是重复元素的最后一个下标, 因此, 在进行比较时, 使用 <code>i!= nums_map[target-nums[i]]</code> 来判断它们是否为同一个元素, 而不能使用<code>nums_map[nums[i]] != nums_map[target-nums[i]]</code></p>
<p>时间复杂度: $O(n)$  遍历两次<br>空间复杂度: $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; nums_map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;nums.size(); i++)&#123;</span><br><span class="line">            nums_map.insert(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span> ; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums_map.count(target-nums[i]) == <span class="number">1</span> &amp;&amp; i!= nums_map[target-nums[i]])&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = &#123;i, nums_map[target-nums[i]]&#125;; <span class="comment">//这里一定要用i,而不能用nums_map[nums[i]] , 上面也同理</span></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-哈希表-一次遍历"><a href="#解法三-哈希表-一次遍历" class="headerlink" title="解法三: 哈希表 一次遍历"></a>解法三: 哈希表 一次遍历</h2><p>事实上, 可以将hash表的插入和查找对应元素的操作放在 一个循环里, 这样就只需要进行一次遍历</p>
<p>时间复杂度: $O(n)$  遍历一次<br>空间复杂度: $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; nums_map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums_map.count(target-nums[i]) == <span class="number">1</span> &amp;&amp; i!= nums_map[target-nums[i]])&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = &#123;i, nums_map[target-nums[i]]&#125;;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            nums_map.insert(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h2><p>How would you approach the problem if the input array is very large (but limited range) and cannot fit in the memory ? This is a follow-up question for this problem.</p>
<h1 id="007-Reverse-Integer"><a href="#007-Reverse-Integer" class="headerlink" title="007. Reverse Integer"></a>007. Reverse Integer</h1><h2 id="Description-将数字逆置"><a href="#Description-将数字逆置" class="headerlink" title="Description: 将数字逆置"></a>Description: 将数字逆置</h2><p>Given a 32-bit signed integer, reverse digits of an integer.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-取余数"><a href="#解法一-取余数" class="headerlink" title="解法一: 取余数"></a>解法一: 取余数</h2><p>这道题本身不难, 只要不断对x的绝对值取余数, 就可以得到反转的整数, 但是, 该题的核心考察点在于边界条件的判断, 稍不注意, 很容易漏解(如果不进行边界判断, 即使写出了解决方法, 面试官也很不满意)</p>
<ul>
<li>x为0</li>
<li>x反转后的值,超过了int型数据的表示范围, 检查方法是先用long存储, 然后看情况决定返回值正负.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">int</span> abs_x = <span class="built_in">abs</span>(x);</span><br><span class="line">        <span class="keyword">int</span> sign_x = x&gt;<span class="number">0</span>? <span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>; <span class="comment">// 为了看int是否越界,特意将res声明为long型</span></span><br><span class="line">        <span class="keyword">while</span>( abs_x!=<span class="number">0</span> )&#123;</span><br><span class="line">            res = res*<span class="number">10</span> + abs_x%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(res &gt; INT_MAX || res &lt; INT_MIN) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//这一句就是最主要的考察点,看int是否越界</span></span><br><span class="line">            abs_x = abs_x/<span class="number">10</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sign_x ==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>-res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="013-Roman-to-Integer"><a href="#013-Roman-to-Integer" class="headerlink" title="013. Roman to Integer"></a>013. Roman to Integer</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p>
<p>Symbol       Value<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>
<p>I can be placed before V (5) and X (10) to make 4 and 9.<br>X can be placed before L (50) and C (100) to make 40 and 90.<br>C can be placed before D (500) and M (1000) to make 400 and 900.<br>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>
<p>Example 1:</p>
<p>Input: “III”<br>Output: 3<br>Example 2:</p>
<p>Input: “IV”<br>Output: 4<br>Example 3:</p>
<p>Input: “IX”<br>Output: 9<br>Example 4:</p>
<p>Input: “LVIII”<br>Output: 58<br>Explanation: L = 50, V= 5, III = 3.<br>Example 5:</p>
<p>Input: “MCMXCIV”<br>Output: 1994<br>Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</p>
<h2 id="解法一-顺序扫描"><a href="#解法一-顺序扫描" class="headerlink" title="解法一: 顺序扫描"></a>解法一: 顺序扫描</h2><p>时间复杂度: $O(n)$</p>
<p>顺序扫描, 如果当前字符比下一个字符小, 说明是 ‘4’ 或 ‘9’ 的情况, 用下一个字符的值减去当前字符的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; roman_char;</span><br><span class="line">        roman_char[<span class="string">'I'</span>] = <span class="number">1</span>;</span><br><span class="line">        roman_char[<span class="string">'V'</span>] = <span class="number">5</span>;</span><br><span class="line">        roman_char[<span class="string">'X'</span>] = <span class="number">10</span>;</span><br><span class="line">        roman_char[<span class="string">'L'</span>] = <span class="number">50</span>;</span><br><span class="line">        roman_char[<span class="string">'C'</span>] = <span class="number">100</span>;</span><br><span class="line">        roman_char[<span class="string">'D'</span>] = <span class="number">500</span>;</span><br><span class="line">        roman_char[<span class="string">'M'</span>] = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;s.size() ; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( i&lt;s.size()<span class="number">-1</span> &amp;&amp; roman_char[s[i]] &lt; roman_char[s[i+<span class="number">1</span>]])&#123;</span><br><span class="line">                res += roman_char[s[i+<span class="number">1</span>]]-roman_char[s[i]];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res += roman_char[s[i]];       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展问题-异常检测"><a href="#扩展问题-异常检测" class="headerlink" title="扩展问题: 异常检测"></a>扩展问题: 异常检测</h2><p>上面的解法虽然可以通过OJ, 但是此题还需要进行特别的异常诊断, 即要能够判断出当前输入的罗马输出是否合法! 如 “IVIV” 就是典型的不合法输入, 对于此输入, 上面的程序会输出 , 这显然不正确</p>
<h1 id="014-Longest-Common-Prefix"><a href="#014-Longest-Common-Prefix" class="headerlink" title="014. Longest Common Prefix"></a>014. Longest Common Prefix</h1><h2 id="Description-最长公共前缀"><a href="#Description-最长公共前缀" class="headerlink" title="Description: 最长公共前缀"></a>Description: 最长公共前缀</h2><p>Write a function to find the longest common prefix string amongst an array of strings.<br>If there is no common prefix, return an empty string “”.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>All given inputs are in lowercase letters a-z.</p>
<h2 id="解法一-顺序比较"><a href="#解法一-顺序比较" class="headerlink" title="解法一: 顺序比较"></a>解法一: 顺序比较</h2><p><strong>时间复杂度:</strong> $O(S)$, $S$ 为所有字符串中的字符总数<br><strong>空间复杂度:</strong> $O(1)$, 没有使用额外的空间</p>
<p>暴力求解, 先求第一个字符串与第二个字符串最长公共前缀, 然后利用该前缀与第三个字符串比较, 知道公共前缀为空或者比较完所有字符串.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.size()==<span class="number">0</span> || strs[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;strs.size() &amp;&amp; !prefix.empty(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;prefix.size()&amp;&amp;j&lt;strs[i].size()</span><br><span class="line">                 &amp;&amp;prefix[j] == strs[i][j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            prefix = prefix.substr(<span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-垂直比较"><a href="#解法二-垂直比较" class="headerlink" title="解法二: 垂直比较"></a>解法二: 垂直比较</h2><p><strong>时间复杂度:</strong> $O(S)$, $S$ 为所有字符串中的字符总数, 最好情况下复杂度为 $O(n\min(s)$, $\min(s)$ 为字符串数组中的最短字符串长度.<br><strong>空间复杂度:</strong> $O(1)$, 没有使用额外的空间</p>
<p>顺序比较所有字符串的值, 直到遇到第一次不相等的位置, 然后输出前面的公共前缀, 需要额外注意处理以下几种特殊情况:<br>输入</p>
<ul>
<li>输入为: [] 或 [“”]  应该直接返回””</li>
<li>输入为: [“abc”]   应该直接返回”abc”</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() ==<span class="number">0</span> || strs[<span class="number">0</span>]==<span class="string">""</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() ==<span class="number">1</span> ) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k&lt;strs.size(); k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[<span class="number">0</span>][i] != strs[k][i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span>) <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>,i);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="020-Valid-Parentheses"><a href="#020-Valid-Parentheses" class="headerlink" title="020. Valid Parentheses"></a>020. Valid Parentheses</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.<br>An input string is valid if:<br>Open brackets must be closed by the same type of brackets.<br>Open brackets must be closed in the correct order.<br>Note that an empty string is also considered valid.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;([)]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-栈"><a href="#解法一-栈" class="headerlink" title="解法一: 栈"></a>解法一: 栈</h2><p>时间复杂度: $O(n)$<br>空间复杂度: $O(n)$</p>
<p><strong>写法一:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s_brack;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c=<span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>) c=<span class="string">'('</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">']'</span>) c=<span class="string">'['</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">'&#125;'</span>) c=<span class="string">'&#123;'</span>;</span><br><span class="line">            <span class="keyword">if</span>(!s_brack.empty() &amp;&amp; c ==  s_brack.top()) s_brack.pop();</span><br><span class="line">            <span class="keyword">else</span> s_brack.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s_brack.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>写法二:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; parent;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'('</span> || c==<span class="string">'&#123;'</span> || c==<span class="string">'['</span>)</span><br><span class="line">                parent.push(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(parent.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((c==<span class="string">')'</span> &amp;&amp; parent.top()==<span class="string">'('</span>) ||</span><br><span class="line">                    (c==<span class="string">'&#125;'</span> &amp;&amp; parent.top()==<span class="string">'&#123;'</span>) ||</span><br><span class="line">                    (c==<span class="string">']'</span> &amp;&amp; parent.top()==<span class="string">'['</span>))&#123;</span><br><span class="line">                parent.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent.empty() ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="021-Merge-Two-Sorted-Lists"><a href="#021-Merge-Two-Sorted-Lists" class="headerlink" title="021. Merge Two Sorted Lists"></a>021. Merge Two Sorted Lists</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p>Example:</p>
<p>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<h2 id="解法一-遍历融合"><a href="#解法一-遍历融合" class="headerlink" title="解法一: 遍历融合"></a>解法一: 遍历融合</h2><p>时间复杂度: $O(min(m,n))$</p>
<p>空间复杂度: $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* head=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur= cur-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="literal">nullptr</span>) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面开关头结点的过程过于复杂, 可以用<code>dummy</code>指针简化这个过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="literal">nullptr</span>) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="026-Remove-Duplicates-from-Sorted-Array"><a href="#026-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="026. Remove Duplicates from Sorted Array"></a>026. Remove Duplicates from Sorted Array</h1><h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一:"></a>解法一:</h2><p>遍历,  两种写法, 后者相当精简</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> same = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == same)&#123;</span><br><span class="line">                nums.erase(nums.begin()+i);</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                same = nums[i];</span><br><span class="line">                length++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&gt;nums[length<span class="number">-1</span>])</span><br><span class="line">                nums[length++]=n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="028-Implement-strStr"><a href="#028-Implement-strStr" class="headerlink" title="028. Implement strStr()"></a>028. Implement strStr()</h1><p>字符串匹配算法, 更详细的解析请看<a href="../面试-算法刷题-算法题集合/#字符串匹配算法">字符串匹配算法解析</a></p>
<h2 id="description-KMP-判断是否为子串"><a href="#description-KMP-判断是否为子串" class="headerlink" title="description: KMP, 判断是否为子串"></a>description: KMP, 判断是否为子串</h2><p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
<p>Example 1:</p>
<p>Input: haystack = “hello”, needle = “ll”<br>Output: 2<br>Example 2:</p>
<p>Input: haystack = “aaaaa”, needle = “bba”<br>Output: -1<br>Clarification:</p>
<p>What should we return when needle is an empty string? This is a great question to ask during an interview.</p>
<p>For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf().</p>
<h2 id="解法一-暴力"><a href="#解法一-暴力" class="headerlink" title="解法一: 暴力"></a>解法一: 暴力</h2><h2 id="解法二-KMP"><a href="#解法二-KMP" class="headerlink" title="解法二: KMP"></a>解法二: KMP</h2><p>求解next数组: 求解某个位置 $k$ 的next数组值是一个循环的过程, 需要不断检查以 <strong>位置 $k-1$ 的next值</strong> 为下标的元素的 <strong>下一位元素</strong> 与 <strong>当前位置 $k$ 元素</strong> 是否相等, 如果相等, 则 <strong>next[k] = next[k-1]+1</strong>, 如果不相等, 则</p>
<h1 id="038-Count-and-Say"><a href="#038-Count-and-Say" class="headerlink" title="038. Count and Say"></a>038. Count and Say</h1><h2 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h2><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p>
<ol>
<li>1</li>
<li>11</li>
<li>21</li>
<li>1211</li>
<li>111221<br>1 is read off as “one 1” or 11.<br>11 is read off as “two 1s” or 21.<br>21 is read off as “one 2, then one 1” or 1211.</li>
</ol>
<p>Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.</p>
<p>Note: Each term of the sequence of integers will be represented as a string.</p>
<h2 id="解法一-依次查看上一次的数字"><a href="#解法一-依次查看上一次的数字" class="headerlink" title="解法一: 依次查看上一次的数字"></a>解法一: 依次查看上一次的数字</h2><p><strong>时间复杂度:</strong> $O(nm)$  m为数字字符串的长度<br><strong>空间复杂度:</strong> $O(m)$</p>
<p>每次根据上一次的数字更新当前的数字字符串, 如此迭代直到达到指定次数</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string countAndSay(int n) &#123;</span><br><span class="line">        string res=<span class="string">"1"</span>;</span><br><span class="line">        int i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">            string tmp;</span><br><span class="line">            <span class="keyword">for</span>(int u=<span class="number">0</span>; u&lt;res.size(); u++)&#123;</span><br><span class="line">                char c=res[u];</span><br><span class="line">                int count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(u+<span class="number">1</span>&lt;res.size() &amp;&amp; res[u+<span class="number">1</span>]==c)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    u++;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp += to_string(count)+c;   </span><br><span class="line">            &#125;</span><br><span class="line">            res.swap(tmp);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="053-Maximum-Subarray"><a href="#053-Maximum-Subarray" class="headerlink" title="053. Maximum Subarray"></a>053. Maximum Subarray</h1><p>连续子数组的最大和</p>
<h2 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h2><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p>Example:</p>
<p>Input: [-2,1,-3,4,-1,2,1,-5,4],<br>Output: 6<br>Explanation: [4,-1,2,1] has the largest sum = 6.<br>Follow up:</p>
<p>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<h2 id="解法-记录当前最大值"><a href="#解法-记录当前最大值" class="headerlink" title="解法: 记录当前最大值"></a>解法: 记录当前最大值</h2><p><strong>时间复杂度:</strong> $O(n)$<br>根据数组性质，设置两个变量，一个记录当前的最大值，一个记录当前的子序列之和。首先，如果当前子序列之和为负，那么就是说，从当前位置开始的子序列，比从之前位置开始的子序列大，那么就可以不考虑从之前位置开始的子序列，之前累计的和也被抛弃</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_sum = INT_MIN;  <span class="comment">//数组有可能全负, 所以不能赋值为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; max_sum) max_sum = num; <span class="comment">//主要是为了预防数组中全是负数的情况</span></span><br><span class="line">            sum += num;</span><br><span class="line">            <span class="keyword">if</span>(sum!=<span class="number">0</span> &amp;&amp; sum&gt;max_sum) max_sum = sum; <span class="comment">// sum!=0 , 为了预防数组全负时, 0一定大于sum, 造成的错解</span></span><br><span class="line">            <span class="keyword">if</span>(sum &lt;<span class="number">0</span>) sum =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>更简洁的写法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmpRes = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmpRes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                tmpRes = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmpRes += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">std</span>::max(res, tmpRes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="066-Plus-One"><a href="#066-Plus-One" class="headerlink" title="066. Plus One"></a>066. Plus One</h1><p>数组代表一个整数, 模拟整数的加法</p>
<h2 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h2><p>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
<p>Example 1:</p>
<p>Input: [1,2,3]<br>Output: [1,2,4]<br>Explanation: The array represents the integer 123.<br>Example 2:</p>
<p>Input: [4,3,2,1]<br>Output: [4,3,2,2]<br>Explanation: The array represents the integer 4321.</p>
<h2 id="解法一-直接模拟"><a href="#解法一-直接模拟" class="headerlink" title="解法一: 直接模拟"></a>解法一: 直接模拟</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>, last_i = digits.size()<span class="number">-1</span>;</span><br><span class="line">        digits[last_i] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(digits[last_i] &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            digits[last_i] = <span class="number">0</span>;</span><br><span class="line">            carry=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = last_i<span class="number">-1</span>; i&gt;=<span class="number">0</span> &amp;&amp; carry ; i--)&#123;</span><br><span class="line">            digits[i] += carry;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] &gt; <span class="number">9</span>)</span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>) digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>另一种写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = digits.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cur=digits.size()<span class="number">-1</span>; cur&gt;=<span class="number">0</span>; cur--)&#123;</span><br><span class="line">            digits[cur] += one + carry;</span><br><span class="line">            one = <span class="number">0</span>;</span><br><span class="line">            carry = digits[cur] / <span class="number">10</span>;</span><br><span class="line">            digits[cur] = digits[cur] % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry) digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-不使用加法-更快更简单-击败100"><a href="#解法二-不使用加法-更快更简单-击败100" class="headerlink" title="解法二: 不使用加法(更快更简单, 击败100%)"></a>解法二: 不使用加法(更快更简单, 击败100%)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;digits) &#123;   <span class="comment">//未考虑前缀0的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = digits.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)   </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] != <span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                digits[i] ++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(digits[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="069-Sqrt-x"><a href="#069-Sqrt-x" class="headerlink" title="069. Sqrt(x)"></a>069. Sqrt(x)</h1><p>实现开方算法</p>
<h2 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h2><p>Implement int sqrt(int x).</p>
<p>Compute and return the square root of x, where x is guaranteed to be a non-negative integer.</p>
<p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-二分法"><a href="#解法一-二分法" class="headerlink" title="解法一: 二分法"></a>解法一: 二分法</h2><p><strong>时间复杂度:</strong> $O(logn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> low=<span class="number">0</span>, high=x;</span><br><span class="line">        <span class="keyword">double</span> res = high;</span><br><span class="line">        <span class="keyword">while</span>( <span class="built_in">std</span>::<span class="built_in">abs</span>(res*res - x) &gt; <span class="number">0.00001</span> )&#123;</span><br><span class="line">            <span class="keyword">if</span>(res*res &gt; x)&#123;</span><br><span class="line">                high = res;</span><br><span class="line">                res = (low+high)/<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = res;</span><br><span class="line">                res = (low+high)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ceil</span>(res)*<span class="built_in">ceil</span>(res)==x) <span class="keyword">return</span> <span class="built_in">ceil</span>(res); <span class="comment">// 为了能够正确截断, 必须加上此句</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-牛顿迭代法"><a href="#解法二-牛顿迭代法" class="headerlink" title="解法二: 牛顿迭代法"></a>解法二: 牛顿迭代法</h2><p><strong>时间复杂度:</strong> $O(logn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>相当于求解 $f(res)=res^2 - x = 0$ 中 $res$ 的解. 则对于任意一点 $(res, f(res))$, 都有切线方程:</p>
<script type="math/tex; mode=display">f(res) - 0 = f'(res)(res-res')</script><p>其中, $res’$ 是该直线与 $x$ 轴的交点. 令新的 $res$ 为该值, 就可以不断逼近 $f(res)$ 的零点, $res’$ 的值为:</p>
<script type="math/tex; mode=display">res' = res- \frac{f(res)}{f'(res)} = res- \frac{res^2-x}{2\times res} = \frac{res^2 + x}{2\times res}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = x;</span><br><span class="line">        <span class="keyword">while</span>( <span class="built_in">std</span>::<span class="built_in">abs</span>(res*res - x) &gt; <span class="number">0.00001</span> )&#123;</span><br><span class="line">            res = (res*res+x) / (<span class="number">2</span>*res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ceil</span>(res)*<span class="built_in">ceil</span>(res)==x) <span class="keyword">return</span> <span class="built_in">ceil</span>(res); <span class="comment">// 为了能够正确截断, 必须加上此句</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-按位检索"><a href="#解法三-按位检索" class="headerlink" title="解法三: 按位检索"></a>解法三: 按位检索</h2><p><strong>时间复杂度:</strong> $O(logn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>由于本题要返回的是整数, 而上面的两种方法都是针对double类型的精确开根方法, 时间复杂度为 $O(logn)$, 实际上, 当只需要返回整数时, 我们可以按整数的位进行检索, 而整数总共只有32位(传入的x位int型, 所以开根后不可能超过int), 因此时间复杂度只有 $O(32)$ , 也就是 $O(1)$.</p>
<p><strong>注意:</strong> 由于该方法是首先找到比 x 大的那一位, 因此有可能超过int上限, 所以要换成long整型</p>
<p>找到后依然需要进行二分查找来找到最终的返回值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( <span class="keyword">long</span>(<span class="number">1</span>&lt;&lt;h) * <span class="keyword">long</span>(<span class="number">1</span>&lt;&lt;h) &lt;= x) h++;</span><br><span class="line">        <span class="keyword">long</span> b = <span class="number">1</span>&lt;&lt;(h<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>( b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (res+b) * (res+b) &lt;= x)</span><br><span class="line">                res += b;</span><br><span class="line">            b = b/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="070-Climbing-Stairs"><a href="#070-Climbing-Stairs" class="headerlink" title="070. Climbing Stairs"></a>070. Climbing Stairs</h1><p>实际上就是斐波那契数列, 更具体分析可看牛客的跳台阶</p>
<h2 id="Description-8"><a href="#Description-8" class="headerlink" title="Description"></a>Description</h2><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>Note: Given n will be a positive integer.</p>
<p>Example 1:</p>
<p>Input: 2<br>Output: 2<br>Explanation: There are two ways to climb to the top.</p>
<ol>
<li>1 step + 1 step</li>
<li>2 steps<br>Example 2:</li>
</ol>
<p>Input: 3<br>Output: 3<br>Explanation: There are three ways to climb to the top.</p>
<ol>
<li>1 step + 1 step + 1 step</li>
<li>1 step + 2 steps</li>
<li>2 steps + 1 step</li>
</ol>
<h2 id="解法一-递归"><a href="#解法一-递归" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><h2 id="解法二-迭代"><a href="#解法二-迭代" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n2;</span><br><span class="line">            n2 = n1+n2;</span><br><span class="line">            n1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="088-Merge-Sorted-Array"><a href="#088-Merge-Sorted-Array" class="headerlink" title="088. Merge Sorted Array"></a>088. Merge Sorted Array</h1><p>融合两个有序数组, 其中第一个数组的元素长度为n, 第二个为m, 题目假设第一个数组的空间为n+m.</p>
<h2 id="Description-9"><a href="#Description-9" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-后移-插入融合"><a href="#解法一-后移-插入融合" class="headerlink" title="解法一: 后移+插入融合"></a>解法一: 后移+插入融合</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =n+m<span class="number">-1</span>; i&gt;=n; i--)</span><br><span class="line">            nums1[i]=nums1[i-n];</span><br><span class="line">        <span class="comment">//for(int i =n; i&lt;n+m; i++) 注意, 这样写是有问题的, 例如对于 [1,2,3,4,0], 这种情况, 从前往后的复制方法会造成元素覆盖</span></span><br><span class="line">          <span class="comment">//  nums1[i]=nums1[i-n];</span></span><br><span class="line">        <span class="keyword">int</span> i =n, j=<span class="number">0</span>, k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n+m &amp;&amp; j&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                nums1[k] = nums1[i];</span><br><span class="line">                k++; i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[k] = nums2[j];</span><br><span class="line">                k++; j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n+m)</span><br><span class="line">            nums1[k++] = nums1[i++];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n)</span><br><span class="line">            nums1[k++] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a>101. Symmetric Tree</h1><p>判断一个二叉树是否为对称的.(与自身镜像相等)</p>
<h2 id="Description-10"><a href="#Description-10" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree [1,2,2,3,4,4,3] is symmetric:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure></p>
<p>But the following [1,2,2,null,3,null,3] is not:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>Bonus points if you could solve it both recursively and iteratively.</p>
<h2 id="解法一-递归-1"><a href="#解法一-递归-1" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(n)$ , 遍历了整个树中的每个节点一次<br><strong>空间复杂度:</strong> $O(n)$ , 调用递归的次数与树的高度有关, 在最差的情况下, 树的高度为n.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymHelper(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymHelper</span><span class="params">(TreeNode* subRoot1, TreeNode* subRoot2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subRoot1 == <span class="literal">nullptr</span> &amp;&amp; subRoot2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(subRoot1 == <span class="literal">nullptr</span> || subRoot2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(subRoot1-&gt;val != subRoot2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> b1 = isSymHelper(subRoot1-&gt;left, subRoot2-&gt;right);</span><br><span class="line">        <span class="keyword">bool</span> b2 = isSymHelper(subRoot1-&gt;right, subRoot2-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> b1&amp;&amp;b2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>更整洁的写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_sym</span><span class="params">(TreeNode* t1, TreeNode* t2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="literal">nullptr</span> &amp;&amp; t2==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="literal">nullptr</span> || t2==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1-&gt;val == t2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> is_sym(t1-&gt;left, t2-&gt;right) &amp;&amp; is_sym(t2-&gt;left, t1-&gt;right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> is_sym(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-迭代-1"><a href="#解法二-迭代-1" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p><strong>时间复杂度:</strong> $O(n)$ , 遍历了整个树中的每个节点一次<br><strong>空间复杂度:</strong> $O(n)$ , 层次遍历创建了两个队列, 其大小总和刚好为n. (有一种说法是: 层次遍历我们最多只会同时保存两层的节点数, 而最后一层的节点数最多为 $logn$, 所以空间复杂度实际上是 $O(logn)$ (常数项被约掉), 这种说法对吗??)</p>
<p>层次遍历, 注意不应该左子树和右子树做非空检查, 因此判断是否对称时, 需要包含节点为空的情况.(因为不需要知道当前的深度, 所以也不用维护深度信息)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q1;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q2;</span><br><span class="line">        q1.push(root-&gt;left);</span><br><span class="line">        q2.push(root-&gt;right);</span><br><span class="line">        TreeNode * cur1, * cur2;</span><br><span class="line">        <span class="keyword">while</span>(!q1.empty() &amp;&amp; !q2.empty())&#123;</span><br><span class="line">            cur1 = q1.front(); q1.pop();</span><br><span class="line">            cur2 = q2.front(); q2.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur1==<span class="literal">nullptr</span> &amp;&amp; cur2 ==<span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur1==<span class="literal">nullptr</span> || cur2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur1-&gt;val != cur2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            q1.push(cur1-&gt;left); q1.push(cur1-&gt;right);</span><br><span class="line">            q2.push(cur2-&gt;right); q2.push(cur2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-迭代"><a href="#解法三-迭代" class="headerlink" title="解法三: 迭代"></a>解法三: 迭代</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>只是用一个队列, 对每一层都进行回文检查<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode*&gt; queueTree;</span><br><span class="line">        queueTree.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!queueTree.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = queueTree.size();</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = queueTree.front();</span><br><span class="line">                queueTree.pop();</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    vec.push_back(<span class="number">0.5</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    vec.push_back(node-&gt;val);</span><br><span class="line">                    queueTree.push(node-&gt;left);</span><br><span class="line">                    queueTree.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> n = vec.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vec[i] != vec[n - i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a>104. Maximum Depth of Binary Tree</h1><p>求二叉树的最大深度(树的深度)</p>
<h2 id="Description-11"><a href="#Description-11" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p>Example:</p>
<p>Given binary tree [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p>
<p>return its depth = 3.</p>
<h2 id="解法一-层次遍历"><a href="#解法一-层次遍历" class="headerlink" title="解法一: 层次遍历"></a>解法一: 层次遍历</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        TreeNode* cur_node;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> layer_len = q.size();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;layer_len; i++)&#123;</span><br><span class="line">                cur_node = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;left!=<span class="literal">nullptr</span>) q.push(cur_node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;right!=<span class="literal">nullptr</span>) q.push(cur_node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-递归"><a href="#解法二-递归" class="headerlink" title="解法二: 递归"></a>解法二: 递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left_height = height(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right_height = height(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+max(left_height, right_height);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree"></a>108. Convert Sorted Array to Binary Search Tree</h1><p>根据 <strong>有序数组</strong> 构造平衡二叉搜索树(不唯一, 只要符合规则即可)</p>
<h2 id="Description-12"><a href="#Description-12" class="headerlink" title="Description"></a>Description</h2><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given the sorted array: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-递归构造"><a href="#解法一-递归构造" class="headerlink" title="解法一: 递归构造"></a>解法一: 递归构造</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$, 递归了n次(每个节点都被访问了一次)</p>
<p>由于题目给的条件是 <strong>有序数组</strong> , 因此大大降低了了构造难度, 可以每次将数组的中间位置作为根节点, 然后分别将两边的数组作为一个新的子数组进行构造, 无需考虑插入新节点引起的二叉搜索树不平衡的问题.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> construct_BST(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">construct_BST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low&gt;high) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root-&gt;left = construct_BST(nums, low, mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = construct_BST(nums, mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-迭代-2"><a href="#解法二-迭代-2" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p><strong>时间复杂度:</strong> $O(n)$, 只不过需要遍历两次树的size<br><strong>空间复杂度:</strong> $O(n)$, 层次遍历的队列和中根遍历的栈</p>
<p>先用层次遍历构造一个完全二叉树(以却确保树是平衡的), 然后在利用中根遍历对树中的每个元素进行赋值.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tree_len = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(tree_len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        q.push(root); tree_len--;</span><br><span class="line">        TreeNode* cur_node;</span><br><span class="line">        <span class="keyword">int</span> layer_len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(tree_len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            layer_len *= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;layer_len &amp;&amp; tree_len&gt;<span class="number">0</span>; i++)&#123;</span><br><span class="line">                cur_node = q.front(); q.pop();</span><br><span class="line">                TreeNode* left = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                cur_node-&gt;left = left;</span><br><span class="line">                q.push(cur_node-&gt;left); tree_len--;</span><br><span class="line">                <span class="keyword">if</span>(tree_len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    TreeNode *right = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                    cur_node-&gt;right = right;</span><br><span class="line">                    q.push(cur_node-&gt;right); tree_len--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        cur_node = root;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty() || cur_node!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur_node!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s.push(cur_node);</span><br><span class="line">                cur_node = cur_node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">                cur_node = s.top(); s.pop();</span><br><span class="line">                cur_node-&gt;val =nums[i++];</span><br><span class="line">                cur_node = cur_node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-迭代-只中根遍历一次"><a href="#解法三-迭代-只中根遍历一次" class="headerlink" title="解法三: 迭代(只中根遍历一次)"></a>解法三: 迭代(只中根遍历一次)</h2><p>【链接】Loading…<br><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/discuss/35218/Java-Iterative-Solution" target="_blank" rel="noopener">https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/discuss/35218/Java-Iterative-Solution</a></p>
<h1 id="111-minimum-depth-of-binary-tree"><a href="#111-minimum-depth-of-binary-tree" class="headerlink" title="111. minimum depth of binary tree"></a>111. minimum depth of binary tree</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一:"></a>解法一:</h2><p>层次优先遍历,遇到的首个叶子结点(左右子树为空)即为最短的深度</p>
<p>注意:</p>
<p>利用while内嵌for循环的方式, 可以省去对每个结点depth的维护, 只需要每次进入for循环之前, depth++即可(因为一个for循环会将当前层所有的结点都入队列, for循环结束后, 意味着进入了下一层, 所以depth++即可)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int run(TreeNode *root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q_node;</span><br><span class="line">        if(root==nullptr) return 0;</span><br><span class="line">        q_node.push(root);</span><br><span class="line">        int depth = 0;</span><br><span class="line">        while(!q_node.empty())&#123;</span><br><span class="line">            const int size = q_node.size();</span><br><span class="line">            depth++;</span><br><span class="line">            for(int i = 0; i&lt; size; i++)&#123;</span><br><span class="line">                TreeNode* node = q_node.front(); q_node.pop();</span><br><span class="line">                if(node-&gt;left!=nullptr) q_node.push(node-&gt;left);</span><br><span class="line">                if(node-&gt;right!=nullptr) q_node.push(node-&gt;right);</span><br><span class="line">                if(node-&gt;left==nullptr &amp;&amp; node-&gt;right == nullptr) return depth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-递归-1"><a href="#解法二-递归-1" class="headerlink" title="解法二(递归):"></a>解法二(递归):</h2><p>让当前结点为空, 则当前结点深度为0, 若当前结点左子树为空, 则当前结点深度等于左子树深度, 反之 ,等于右子树深度. 若当前结点左右子树均不为空, 则当前结点的 <strong>最小深度</strong> 等于左右子树深度 <strong>较小者</strong> 加1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root== <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> run(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right ==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> run(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> depth1=run(root-&gt;left);</span><br><span class="line">            <span class="keyword">int</span> depth2=run(root-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> depth1&lt;depth2 ? depth1+<span class="number">1</span> : depth2+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118. Pascal’s Triangle"></a>118. Pascal’s Triangle</h1><p>Pascal 三角形</p>
<h2 id="Description-13"><a href="#Description-13" class="headerlink" title="Description"></a>Description</h2><p>Given a non-negative integer numRows, generate the first numRows of Pascal’s triangle.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-按照三角形的性质进行赋值"><a href="#解法一-按照三角形的性质进行赋值" class="headerlink" title="解法一: 按照三角形的性质进行赋值"></a>解法一: 按照三角形的性质进行赋值</h2><p>赋值时, 每一行的两端都是1, 无需重复赋值, 注意控制好边界条件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;numRows; i++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(i+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i; j++)&#123; <span class="comment">// 两边默认为1, 无需重复赋值</span></span><br><span class="line">                temp[j] = res[i<span class="number">-1</span>][j<span class="number">-1</span>]+res[i<span class="number">-1</span>][j];<span class="comment">// i和j的值只有在大于1时才会进入循环, 所以无需担心i-1或j-1&lt;0</span></span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h1><p>获取最大的股票利润</p>
<h2 id="Description-14"><a href="#Description-14" class="headerlink" title="Description"></a>Description</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Note that you cannot sell a stock before you buy one.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit = 0.</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-穷举-1"><a href="#解法一-穷举-1" class="headerlink" title="解法一: 穷举"></a>解法一: 穷举</h2><p>计算所有可能性, $O(n^2)$</p>
<h2 id="解法二-一次遍历"><a href="#解法二-一次遍历" class="headerlink" title="解法二: 一次遍历"></a>解法二: 一次遍历</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>维护两个变量 <code>min_price</code> 和 <code>max_profit</code>, 每次检查元素, 一方面如果当前价格更低, 则更改 <code>min_price</code> 变量, 另一方面如果当前利润超过 <code>max_profit</code>, 则更新之.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_price=prices[<span class="number">0</span>], max_profit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt;= min_price)&#123;</span><br><span class="line">                min_price = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]-min_price &gt; max_profit) max_profit = prices[i]-min_price;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>同样也是一次遍历, 下面的写法更加简洁, 我们这里记录一个变量 <code>buy</code>, 用来指示可能的买入下标, 之后, 如果下一个价格比 <code>buy</code> 对应的价格高, 我们就尝试更新最大利润, 否则, 就改变 <code>buy</code> 到当前的价格下标</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[buy] &lt; prices[i])&#123;</span><br><span class="line">                maxfit = max(maxfit, prices[i] - prices[buy]);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                buy = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>实际上, 我们只需要用一个变量记录迄今为止遇到的最小的股票值即可, 然后对于每一个新值, 我们都更新最高利润和最小值即可, 代码如下:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> low = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> p : prices) &#123;</span><br><span class="line">            res = <span class="built_in">std</span>::max(res, p - low);</span><br><span class="line">            low = <span class="built_in">std</span>::min(low, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h1><p>可以多次交易, 统计最大利润和</p>
<h2 id="Description-15"><a href="#Description-15" class="headerlink" title="Description"></a>Description</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>
<p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit = 0.</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-用变量维护最低价格"><a href="#解法一-用变量维护最低价格" class="headerlink" title="解法一: 用变量维护最低价格"></a>解法一: 用变量维护最低价格</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>寻找递增序列, 一旦出现递减的情况, 则说明应该及时卖出, 并将 <code>min_price</code> 重新赋值. 因为最后一个元素后面没有值来判断是否递减, 因此需要对最后一个元素进行单独判断<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size() ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min_price = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sum_profit = <span class="number">0</span>, pre_price=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; pre_price)&#123; <span class="comment">//如果小于之前的price, 则说明此时应该卖出</span></span><br><span class="line">                sum_profit += pre_price-min_price; <span class="comment">//计算卖出利润</span></span><br><span class="line">                min_price = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            pre_price = prices[i];</span><br><span class="line">            <span class="keyword">if</span>(i==prices.size()<span class="number">-1</span> &amp;&amp; prices[i] &gt; min_price) <span class="comment">//到了最后一个元素, 查看是否应该卖出</span></span><br><span class="line">                sum_profit += prices[i] - min_price;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>同样和上一道题一样, 利用 <code>buy</code> 可以更加整洁的实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[buy] &lt; prices[i])</span><br><span class="line">                max_profit += prices[i] - prices[buy];</span><br><span class="line">            buy = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-每两个相邻数字当做一次交易"><a href="#解法二-每两个相邻数字当做一次交易" class="headerlink" title="解法二: 每两个相邻数字当做一次交易"></a>解法二: 每两个相邻数字当做一次交易</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>实际上和解法一本质相同, 只不过在累加利润上有一点小区别.<br>该解法是将每两个相邻数字看做是一次交易, 如果后者大于前者, 说明应该执行交易, 并累加交易所的利润.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Cclass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum_profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span> ; i&lt;prices.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i<span class="number">-1</span>]) sum_profit += prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125 Valid Palindrome"></a>125 Valid Palindrome</h1><p>判断是否为回文子串</p>
<h2 id="Description-16"><a href="#Description-16" class="headerlink" title="Description"></a>Description</h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p>Note: For the purpose of this problem, we define empty string as valid palindrome.</p>
<p>Example 1:</p>
<p>Input: “A man, a plan, a canal: Panama”<br>Output: true<br>Example 2:</p>
<p>Input: “race a car”<br>Output: false</p>
<h2 id="解法一-前后两个指示变量-向中间遍历判断"><a href="#解法一-前后两个指示变量-向中间遍历判断" class="headerlink" title="解法一: 前后两个指示变量, 向中间遍历判断"></a>解法一: 前后两个指示变量, 向中间遍历判断</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历一次<br><strong>空间复杂度:</strong> $O(1)$, 只额外用了两个变量</p>
<p>需要注意的是将大小写字母转换成同大写或者同小写的形式再进行判断</p>
<p><strong>写法一:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=s.size()<span class="number">-1</span>; i&lt;j; )&#123;</span><br><span class="line">            <span class="keyword">if</span>(is_alphanumeric(s[i]) == <span class="literal">false</span>)&#123;</span><br><span class="line">                i++; <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(is_alphanumeric(s[j]) == <span class="literal">false</span>)&#123;</span><br><span class="line">                j--; <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">std</span>::<span class="built_in">tolower</span>(s[i]) != <span class="built_in">std</span>::<span class="built_in">tolower</span>(s[j])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i++; j--;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_alphanumeric</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">'a'</span> &amp;&amp; c&lt;=<span class="string">'z'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">'A'</span> &amp;&amp; c&lt;=<span class="string">'Z'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>写法二</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=s.size()<span class="number">-1</span>; i&lt;=j;i++,j-- )&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;s.size() &amp;&amp; is_alphanumeric(s[i]) == <span class="literal">false</span>) i++;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; is_alphanumeric(s[j]) == <span class="literal">false</span>) j--;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">std</span>::<span class="built_in">tolower</span>(s[i]) != <span class="built_in">std</span>::<span class="built_in">tolower</span>(s[j])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_alphanumeric</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">'a'</span> &amp;&amp; c&lt;=<span class="string">'z'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">'A'</span> &amp;&amp; c&lt;=<span class="string">'Z'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136. Single Number"></a>136. Single Number</h1><p>数组中有一个数字出现了1次(奇数次), 其他均出现了2次(偶数次), 找到出现1次(奇数次)的数字.</p>
<h2 id="Description-17"><a href="#Description-17" class="headerlink" title="Description"></a>Description</h2><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</p>
<p>Note:</p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>Example 1:</p>
<p>Input: [2,2,1]<br>Output: 1<br>Example 2:</p>
<p>Input: [4,1,2,1,2]<br>Output: 4</p>
<h2 id="解法一-哈希"><a href="#解法一-哈希" class="headerlink" title="解法一: 哈希"></a>解法一: 哈希</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(n)$, 哈希表额外空间</p>
<p>遍历数组, 对于每一个数, 如果当前的数存在于hash表中, 则将表中哈希删除, 如果不存在, 则添加到哈希表中, 最终, 哈希表中存在的值就是只出现一次的值</p>
<h2 id="解法二-数学公式"><a href="#解法二-数学公式" class="headerlink" title="解法二: 数学公式"></a>解法二: 数学公式</h2><p><script type="math/tex">2\times (a + b + c) - (a+b+a+b+c) = c</script>.</p>
<p>将数组中的元素转换为 <code>set</code>(无重复元素), 然后利用上面的公式纠结<br><strong>时间复杂度:</strong> $O(n + n)=O(n)$, 转换为 <code>set</code> 需要 $O(n), 公式求解遍历也需要 $O(n)$<br><strong>空间复杂度:</strong> $O(n)$. <code>set</code> 所占额外空间</p>
<h2 id="解法三-异或"><a href="#解法三-异或" class="headerlink" title="解法三: 异或"></a>解法三: 异或</h2><p>任何数和0异或不变, 和自身异或变为0<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">            res ^= num;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>其他更多扩展问题可看剑指Offer<a href="../面试-算法刷题-剑指offer">第40题</a>.</strong></p>
<h1 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a>141. Linked List Cycle</h1><h2 id="Description-18"><a href="#Description-18" class="headerlink" title="Description"></a>Description</h2><p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<h2 id="解法一-Floyd-Cycle-Floyd-判圈算法"><a href="#解法一-Floyd-Cycle-Floyd-判圈算法" class="headerlink" title="解法一: Floyd Cycle(Floyd 判圈算法)"></a>解法一: Floyd Cycle(Floyd 判圈算法)</h2><p><strong>时间复杂度:</strong> $O(n+k)$, 可以认为是$O(n)$,  $n$ 为链表长度, $k$ 为环长<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>从头结点开始，slow每次走一步，fast每次走两步，那么只要有环，slow和fast就一定会在环中的某个节点处相遇，如果无环，则fast一定先到达空指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> <span class="keyword">or</span> head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast <span class="keyword">and</span> fast!=<span class="literal">nullptr</span> <span class="keyword">and</span> fast-&gt;next != <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> slow == fast ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* slow=head, *fast=head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span> &amp;&amp; slow != fast)&#123;</span><br><span class="line">            slow= slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更多扩展见牛客第55题, 链表中环的入口节点</p>
<h1 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155. Min Stack"></a>155. Min Stack</h1><p>获取栈中最小的元素</p>
<h2 id="Description-19"><a href="#Description-19" class="headerlink" title="Description"></a>Description</h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<p>push(x) — Push element x onto stack.<br>pop() — Removes the element on top of the stack.<br>top() — Get the top element.<br>getMin() — Retrieve the minimum element in the stack.<br>Example:<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   —&gt; Returns -3.<br>minStack.pop();<br>minStack.top();      —&gt; Returns 0.<br>minStack.getMin();   —&gt; Returns -2.</p>
<h2 id="解法一-两个栈"><a href="#解法一-两个栈" class="headerlink" title="解法一: 两个栈"></a>解法一: 两个栈</h2><p><strong>时间复杂度:</strong> $O(1)$<br><strong>空间复杂度:</strong> $O(n)$, 两个栈</p>
<p>申请两个栈, 一个栈正常操作, 另一个栈只有当当前元素小于或等于栈顶元素时才入栈</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line">    MinStack()&#123;       </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.push(x);</span><br><span class="line">        <span class="keyword">if</span>(s2.empty() || x &lt;= s2.top()) s2.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.top() == s2.top()) s2.pop();</span><br><span class="line">        s1.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a>160. Intersection of Two Linked Lists</h1><p>两个链表的第一个公共节点</p>
<h2 id="Description-20"><a href="#Description-20" class="headerlink" title="Description"></a>Description</h2><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure></p>
<p>begin to intersect at node c1.</p>
<p>Notes:</p>
<p>If the two linked lists have no intersection at all, return null.<br>The linked lists must retain their original structure after the function returns.<br>You may assume there are no cycles anywhere in the entire linked structure.<br>Your code should preferably run in O(n) time and use only O(1) memory.</p>
<h2 id="解法一：栈"><a href="#解法一：栈" class="headerlink" title="解法一：栈"></a>解法一：栈</h2><p><strong>时间复杂度:</strong> $O(m+n)$, 遍历两个链表<br><strong>空间复杂度:</strong> $O(m+n)$, 两个栈</p>
<p>分析公共子节点的特点，首先，是单向链表，因此，从第一个公共子节点开始，后面的都是一样的，所以最好是能从链表的最后一项还是比较。但由于是单向链表，因此只能从头访问，从能访问最后的节点。 <strong>就像是先进先出一样</strong>  因此，考虑用两个辅助栈来帮助实现～</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; s1;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; s2;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* cur = pHead1; cur!=<span class="literal">nullptr</span>; cur = cur-&gt;next)&#123;</span><br><span class="line">            s1.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* cur = pHead2; cur!=<span class="literal">nullptr</span>; cur = cur-&gt;next)&#123;</span><br><span class="line">            s2.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* firstCN = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s1.empty() &amp;&amp; !s2.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.top() == s2.top())&#123;</span><br><span class="line">                firstCN = s1.top();</span><br><span class="line">                s1.pop();</span><br><span class="line">                s2.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> firstCN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-常数空间复杂度"><a href="#解法二-常数空间复杂度" class="headerlink" title="解法二: 常数空间复杂度"></a>解法二: 常数空间复杂度</h2><p><strong>时间复杂度:</strong> $O(m+n)$, 遍历两次<br><strong>空间复杂度:</strong> $O(1)$, 不使用额外空间</p>
<p>首先遍历得到两个链表的长度, 然后先让长链表前进长度差个节点, 接着两个链表共同向前遍历, 当相遇时即为第一个公共节点.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lengthA = <span class="number">0</span>;</span><br><span class="line">        ListNode* nodeA = headA;</span><br><span class="line">        <span class="keyword">while</span> (nodeA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nodeA = nodeA-&gt;next;</span><br><span class="line">            lengthA++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lengthB = <span class="number">0</span>;</span><br><span class="line">        ListNode* nodeB = headB;</span><br><span class="line">        <span class="keyword">while</span> (nodeB != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nodeB = nodeB-&gt;next;</span><br><span class="line">            lengthB++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* longNode = lengthA &gt; lengthB ? headA : headB;</span><br><span class="line">        ListNode* shortNode = lengthA &gt; lengthB ? headB : headA;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">std</span>::<span class="built_in">abs</span>(lengthA - lengthB);</span><br><span class="line">        <span class="keyword">while</span> (l--) &#123;</span><br><span class="line">            longNode = longNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (shortNode != longNode) &#123;</span><br><span class="line">            shortNode = shortNode-&gt;next;</span><br><span class="line">            longNode = longNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shortNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169 Majority Element"></a>169 Majority Element</h1><h2 id="Description-找出数组中超过一半的数字"><a href="#Description-找出数组中超过一半的数字" class="headerlink" title="Description: 找出数组中超过一半的数字"></a>Description: 找出数组中超过一半的数字</h2><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p>Example 1:</p>
<p>Input: [3,2,3]<br>Output: 3<br>Example 2:</p>
<p>Input: [2,2,1,1,1,2,2]<br>Output: 2</p>
<p><strong>题目中指明了该数字一定存在, 所以无需进行count检查, 如果该数字有可能不存在, 则根据情况需要进行 $O(n)$ 复杂度的count检查(即检查当前的数字是否出现了大于 n/2 次).</strong></p>
<h2 id="解法一-排序"><a href="#解法一-排序" class="headerlink" title="解法一: 排序"></a>解法一: 排序</h2><p><strong>时间复杂度:</strong> $O(nlogn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>先排序, 然后取中间元素, 即为 majority element.<br>(如有需要可进行count检查, $O(n)$)</p>
<h2 id="解法二-哈希"><a href="#解法二-哈希" class="headerlink" title="解法二: 哈希"></a>解法二: 哈希</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>每个元素的值为哈希的 key, 每个元素出现的次数为哈希的 value, 如果某个 key 的 value 大于 n/2, 则该元素即为 majority element.<br>哈希法记录的元素的出现次数, 所以无需进行 count 检查.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt; <span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num: nums)&#123;</span><br><span class="line">            hash[num]++;</span><br><span class="line">            <span class="keyword">if</span>(hash[num] &gt; nums.size()/<span class="number">2</span>) <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-同增异减"><a href="#解法三-同增异减" class="headerlink" title="解法三: 同增异减"></a>解法三: 同增异减</h2><p>如果数组中存在这样一个数，那么这个数的出现次数一定大于其他所有数的出现次数总和，因此，设置两个变量，一个 cur_num 用来存储当前数组中的可能解，另一个 count 为统计差值. 即每遇到一个和可能解相同的元素, 就 count++, 否则, count—. 如果 count=0, 则说明当前的可能解已经注定不是最终的解, 则令新的元素为可能解.<br>最终, 对可能解进行 $O(n)$ 的 count 检查, 判断是否存在 majority element (题目假设一定存在, 所以可以不做此检查).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> major = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == major) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    major = num;</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> major; <span class="comment">// 因为题目保证major一定存在, 所以可以直接返回, 否则的话还需要再判断major的个数是否大于 n/2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-随机"><a href="#解法四-随机" class="headerlink" title="解法四: 随机"></a>解法四: 随机</h2><p>如果确定数组中存在 majority element 的话, 则我们可以从数组中随机选取一个元素, 并判断这个元素是否为 majority element.  这种解法依赖于统计学的概率知识, 实际的时间复杂度与数组的组成规律有关.</p>
<h1 id="171-Excel-Sheet-Column-Number"><a href="#171-Excel-Sheet-Column-Number" class="headerlink" title="171. Excel Sheet Column Number"></a>171. Excel Sheet Column Number</h1><h2 id="Description-Excel列表数字"><a href="#Description-Excel列表数字" class="headerlink" title="Description: Excel列表数字"></a>Description: Excel列表数字</h2><p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>
<p>For example:</p>
<pre><code>A -&gt; 1
B -&gt; 2
C -&gt; 3
...
Z -&gt; 26
AA -&gt; 27
AB -&gt; 28
...
</code></pre><p>Example 1:</p>
<p>Input: “A”<br>Output: 1<br>Example 2:</p>
<p>Input: “AB”<br>Output: 28<br>Example 3:</p>
<p>Input: “ZY”<br>Output: 701</p>
<h2 id="解法一-遍历字符串"><a href="#解法一-遍历字符串" class="headerlink" title="解法一: 遍历字符串"></a>解法一: 遍历字符串</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            res += res*<span class="number">25</span> + <span class="keyword">int</span>(c-<span class="string">'A'</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="172-Factorial-Trailing-Zeroes"><a href="#172-Factorial-Trailing-Zeroes" class="headerlink" title="172. Factorial Trailing Zeroes"></a>172. Factorial Trailing Zeroes</h1><h2 id="Description-阶乘的尾部含有0的个数"><a href="#Description-阶乘的尾部含有0的个数" class="headerlink" title="Description: 阶乘的尾部含有0的个数"></a>Description: 阶乘的尾部含有0的个数</h2><h2 id="解法一-统计5的个数"><a href="#解法一-统计5的个数" class="headerlink" title="解法一: 统计5的个数"></a>解法一: 统计5的个数</h2><p><strong>首先, 求出阶乘值在取余求0个数的方法肯定不可以, 阶乘会轻松溢出(n=13时就已经 int 溢出了)</strong></p>
<p><strong>时间复杂度:</strong> $O(logn)$, 以5位基数<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>因为尾部的0只可能来自于 $2\times 5$ 这样的数, 对于 $n$ 的阶乘 $1\times 2\times 3\times, …, n$ 来说, $2$ 一定是充足的, 所以我们只需要统计 $5$ 的个数就可以.<br>统计时, 每个5个数字会出现一次5, 每隔25个数字会额外出现一次5, 每个125个数字又会额外出现一次5…, 如此循环下去, 最终5的个数就是尾部0的个数.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i =<span class="number">5</span>; n/i &gt;<span class="number">0</span>; i*=<span class="number">5</span>)&#123;</span><br><span class="line">            <span class="comment">//注意这里的i的字节数一定要大于n, 因为n有可能为INT_MAX, 而 n/i &gt;0 时, i必须&gt;n</span></span><br><span class="line">            res += n/i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-另一个角度"><a href="#解法二-另一个角度" class="headerlink" title="解法二: 另一个角度"></a>解法二: 另一个角度</h2><p><strong>时间复杂度:</strong> $O(logn)$, 以5位基数<br><strong>空间复杂度:</strong> $O(1)$ (迭代), $O(logn)$ (递归需额外空间)</p>
<p>核心思想是相同的, 同样是统计5的出现个数, 只不过这里我们是先求出 n 中 5 的倍数, 然后再求 n/5 中 5 的倍数, 实际上这里就是相当于求 n 中 25 的倍数. 因此, 和解法一是相同的, 只不过解法二因为是通过减小 n, 而不是增大 i (5,25,125,..)的方式来统计 5 个数, 因此解法二有个好处就是可以不使用 <code>long</code> 类型的变量, 下面分别是该方法的递归实现和迭代实现.</p>
<p><strong>递归:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &lt; <span class="number">5</span> ? <span class="number">0</span> : n / <span class="number">5</span> + trailingZeroes(n / <span class="number">5</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>迭代:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;        </span><br><span class="line">        <span class="keyword">while</span>(n&gt;=<span class="number">5</span>)&#123;</span><br><span class="line">            res += n/<span class="number">5</span>;</span><br><span class="line">            n /= <span class="number">5</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="189-Rotate-Array"><a href="#189-Rotate-Array" class="headerlink" title="189. Rotate Array"></a>189. Rotate Array</h1><h2 id="Description-循环右移数组"><a href="#Description-循环右移数组" class="headerlink" title="Description: 循环右移数组"></a>Description: 循环右移数组</h2><p>Given an array, rotate the array to the right by k steps, where k is non-negative.</p>
<p>Example 1:</p>
<p>Input: [1,2,3,4,5,6,7] and k = 3<br>Output: [5,6,7,1,2,3,4]<br>Explanation:<br>rotate 1 steps to the right: [7,1,2,3,4,5,6]<br>rotate 2 steps to the right: [6,7,1,2,3,4,5]<br>rotate 3 steps to the right: [5,6,7,1,2,3,4]</p>
<p>Example 2:</p>
<p>Input: [-1,-100,3,99] and k = 2<br>Output: [3,99,-1,-100]<br>Explanation:<br>rotate 1 steps to the right: [99,-1,-100,3]<br>rotate 2 steps to the right: [3,99,-1,-100]</p>
<p>Note:<br>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.<br>Could you do it in-place with O(1) extra space?</p>
<h2 id="解法一-暴力-1"><a href="#解法一-暴力-1" class="headerlink" title="解法一: 暴力"></a>解法一: 暴力</h2><p><strong>时间复杂度:</strong> $O(nk)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>所有的数字每次移动一步, 攻移动 k 次. 超时</p>
<h2 id="解法二-使用额外数组"><a href="#解法二-使用额外数组" class="headerlink" title="解法二: 使用额外数组"></a>解法二: 使用额外数组</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>申请一个长度相等的数组, 复制原数组中的 $i$ 号元素到新数组中的 $i+k$ 号位置.</p>
<h2 id="解法三-循环置换"><a href="#解法三-循环置换" class="headerlink" title="解法三: 循环置换"></a>解法三: 循环置换</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历一次<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>每次直接将元素放置在正确的位置, 放置前, 需要用一个临时变量将被放置的元素保存起来以防止覆盖, 然后将临时变量的元素再直接放到正确的位置, 循环进行, 知道临时变量指向了最开始的变量, 然后再继续从下一个元素开始这个过程. 在代码中设置一个 <code>count</code> 变量, 用来统计放置的次数, 当次数等于数组长度时, 说明已经完成移动.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start=<span class="number">0</span>; count&lt;nums.size(); start++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur_pos = start;</span><br><span class="line">            <span class="keyword">int</span> cur_val = nums[start];</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> next_pos = (cur_pos + k) % nums.size();</span><br><span class="line">                <span class="keyword">int</span> temp = nums[next_pos];</span><br><span class="line">                nums[next_pos] = cur_val;</span><br><span class="line">                cur_pos = next_pos;</span><br><span class="line">                cur_val = temp;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">while</span>(start!=cur_pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-reverse"><a href="#解法四-reverse" class="headerlink" title="解法四: reverse"></a>解法四: reverse</h2><p><strong>时间复杂度:</strong> $O(n)$, 调用扫除 reverse 函数<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::reverse(nums.begin(), nums.end()-k);</span><br><span class="line">        <span class="built_in">std</span>::reverse(nums.end()-k, nums.end());</span><br><span class="line">        <span class="built_in">std</span>::reverse(nums.begin(), nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="190-Reverse-Bits"><a href="#190-Reverse-Bits" class="headerlink" title="190. Reverse Bits"></a>190. Reverse Bits</h1><h2 id="Description-按位逆置"><a href="#Description-按位逆置" class="headerlink" title="Description: 按位逆置"></a>Description: 按位逆置</h2><p>Reverse bits of a given 32 bits unsigned integer.</p>
<p>Example:</p>
<p>Input: 43261596<br>Output: 964176192<br>Explanation: 43261596 represented in binary as 00000010100101000001111010011100,<br>             return 964176192 represented in binary as 00111001011110000010100101000000.<br>Follow up:<br>If this function is called many times, how would you optimize it?</p>
<h2 id="解法一-按位进行32次操作"><a href="#解法一-按位进行32次操作" class="headerlink" title="解法一: 按位进行32次操作"></a>解法一: 按位进行32次操作</h2><p>每次取 <code>n</code> 的最后一位, 如果为 1, 则令<code>res</code>左移一位并加一, 如果为0, 则只左移一位. 进行32次(<code>n</code>的32位).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> res= <span class="number">0</span>;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">            res = (res&lt;&lt;<span class="number">1</span>) | ((n&gt;&gt;i)&amp;<span class="number">1</span>); <span class="comment">//res = (res&lt;&lt;1) | (n&amp;1); n = (n&gt;&gt;1);            </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-按位二分进行5次操作"><a href="#解法二-按位二分进行5次操作" class="headerlink" title="解法二: 按位二分进行5次操作"></a>解法二: 按位二分进行5次操作</h2><p>先将前16位和后16位交换(利用位移和位操作实现)<br>然后再将16位中的前8位和后8位交换<br>然后再将8位中的前4位和后4位交换<br>然后再将4位中的前2位和后2位交换<br>最后将2位中的前1位和后1位交换.</p>
<p>上述交换全部采用位操作实现, 因此, 速度上有所优化.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">        n = (n&gt;&gt;<span class="number">16</span>) | (n&lt;&lt;<span class="number">16</span>);</span><br><span class="line">        n = ( ((n &amp; <span class="number">0xff00ff00</span>)&gt;&gt;<span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>)&lt;&lt;<span class="number">8</span>) );</span><br><span class="line">        n = ( ((n &amp; <span class="number">0xf0f0f0f0</span>)&gt;&gt;<span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>)&lt;&lt;<span class="number">4</span>) );</span><br><span class="line">        n = ( ((n &amp; <span class="number">0xcccccccc</span>)&gt;&gt;<span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>)&lt;&lt;<span class="number">2</span>) );</span><br><span class="line">        n = ( ((n &amp; <span class="number">0xaaaaaaaa</span>)&gt;&gt;<span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>)&lt;&lt;<span class="number">1</span>) );</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="191-Number-of-1-Bits"><a href="#191-Number-of-1-Bits" class="headerlink" title="191. Number of 1 Bits"></a>191. Number of 1 Bits</h1><h2 id="Description-统计二进制中1的个数"><a href="#Description-统计二进制中1的个数" class="headerlink" title="Description: 统计二进制中1的个数"></a>Description: 统计二进制中1的个数</h2><p>Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the Hamming weight).</p>
<p>Example 1:</p>
<p>Input: 11<br>Output: 3<br>Explanation: Integer 11 has binary representation 00000000000000000000000000001011<br>Example 2:</p>
<p>Input: 128<br>Output: 1<br>Explanation: Integer 128 has binary representation 00000000000000000000000010000000</p>
<h2 id="解法一-逐位统计"><a href="#解法一-逐位统计" class="headerlink" title="解法一: 逐位统计"></a>解法一: 逐位统计</h2><p><strong>时间复杂度:</strong> $O(1)$, 循环32次<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>查看每一位上的二进制是否为1, 若为1, 则<code>count++</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (n &amp; (<span class="number">1</span>&lt;&lt;i)) != <span class="number">0</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-和-n-1-按位与"><a href="#解法二-和-n-1-按位与" class="headerlink" title="解法二: 和 $n-1$ 按位与"></a>解法二: 和 $n-1$ 按位与</h2><p><strong>时间复杂度:</strong> $O(1)$, 循环次数为二进制中1的个数.<br><strong>空间复杂度:</strong> $O(1)$</p>
<p><img src="https://wx1.sinaimg.cn/large/d7b90c85ly1fxlbg7qyk9j21cs0nwq4u.jpg" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n&amp;(n<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a>198. House Robber</h1><h2 id="Description-房屋小偷获取最大收益"><a href="#Description-房屋小偷获取最大收益" class="headerlink" title="Description: 房屋小偷获取最大收益"></a>Description: 房屋小偷获取最大收益</h2><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<p>Example 1:</p>
<p>Input: [1,2,3,1]<br>Output: 4<br>Explanation:<br>Rob house 1 (money = 1) and then rob house 3 (money = 3).<br>Total amount you can rob = 1 + 3 = 4.<br>Example 2:</p>
<p>Input: [2,7,9,3,1]<br>Output: 12<br>Explanation:<br>Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).<br>Total amount you can rob = 2 + 9 + 1 = 12.</p>
<h2 id="解法一-DP"><a href="#解法一-DP" class="headerlink" title="解法一: DP"></a>解法一: DP</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>依据 DP 的思想, 对于一个任意价格的房子, 我们有两种选择: 偷或不偷. 如果选择不偷, 那么前 $(i+1)$ 个房子的最大收益, 就应该是前 $i$ 个房子的最大收益(偷或者不偷第 $i$ 个房子收益中的较大者), 如果选择偷, 那么就不能偷第 $i$ 个房子.<br>根据上面的描述, 我们可以维护两个变量 <code>cur_rob</code> 和 <code>cur_nrob</code>, 前者代表偷第 $i$ 个房子的收益, 后者代表不偷第 $i$ 个房子的收益, 则最大收益就应该为二者中的较大者. 详细代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur_rob=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_nrob=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = cur_nrob;</span><br><span class="line">            cur_nrob = <span class="built_in">std</span>::max(cur_rob, cur_nrob);            </span><br><span class="line">            cur_rob = temp+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(cur_rob, cur_nrob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-根据房屋的编号奇偶性"><a href="#解法二-根据房屋的编号奇偶性" class="headerlink" title="解法二: 根据房屋的编号奇偶性"></a>解法二: 根据房屋的编号奇偶性</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>因为偷取的房屋不能相邻, 因此我们可以维护两个变量, <code>even</code> 是前偶数个房屋的最大收益, <code>odd</code> 是前奇数个房屋的最大收益, 对于任意的一个新来的房屋, 如果该新房屋的编号为奇数, 那么它的最大收益就是 <code>odd+new</code> 和 <code>even</code> 当中的较大者(因为不能相邻, 所以只能令 <code>odd+new</code>). 对于偶数的情况同理. 最终返回 <code>odd</code> 和 <code>even</code> 的较大者.(因为有可能包含最后一个元素, 也有可能不包含) 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> odd=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> even=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>) even = <span class="built_in">std</span>::max(odd, even+nums[i]);</span><br><span class="line">            <span class="keyword">else</span> odd = <span class="built_in">std</span>::max(odd+nums[i], even);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(odd, even);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="202. Happy Number"></a>202. Happy Number</h1><h2 id="Description-判断一个数字是否是-Happer-Number"><a href="#Description-判断一个数字是否是-Happer-Number" class="headerlink" title="Description: 判断一个数字是否是 Happer Number"></a>Description: 判断一个数字是否是 Happer Number</h2><p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p>Example:</p>
<p>Input: 19<br>Output: true<br>Explanation:<br>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1</p>
<h2 id="解法一-模拟计算过程"><a href="#解法一-模拟计算过程" class="headerlink" title="解法一: 模拟计算过程"></a>解法一: 模拟计算过程</h2><p><strong>时间复杂度:</strong> $O(logn)$, 基数为10<br><strong>空间复杂度:</strong> 未知, 取决于无序集合的size.</p>
<p>按照题目中的逻辑, 模拟整个计算过程, 如果出现1, 则返回 <code>true</code>, 如果出现循环(即在集合中发现已存在元素), 则返回 <code>false</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; num_set;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">1</span> &amp;&amp; num_set.find(n)==num_set.end())&#123;</span><br><span class="line">            num_set.insert(n);</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">                temp += (n%<span class="number">10</span>) * (n%<span class="number">10</span>);</span><br><span class="line">                n = n/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-Floyd-判圈算法"><a href="#解法二-Floyd-判圈算法" class="headerlink" title="解法二: Floyd 判圈算法"></a>解法二: Floyd 判圈算法</h2><p><strong>时间复杂度:</strong> $O(logn)$, 时间复杂度不变<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>利用 Floyd 判圈算法维护两个变量 <code>slow</code> 和 <code>fast</code>, <code>fast</code> 每次都比 <code>flow</code> 多走一步, 那么, 当 <code>fast==1</code> 时, 说明应该返回 <code>true</code>, 当 <code>slow==fast</code> 时, 说明存在循环, 应该返回 <code>false</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow=n, fast=n;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = digitSquareSum(slow);</span><br><span class="line">            fast = digitSquareSum(fast);</span><br><span class="line">            fast = digitSquareSum(fast);</span><br><span class="line">        &#125;<span class="keyword">while</span>(fast!=<span class="number">1</span> &amp;&amp; slow!=fast);</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">digitSquareSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            temp += (n%<span class="number">10</span>) * (n%<span class="number">10</span>);</span><br><span class="line">            n = n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="204-Count-Primes"><a href="#204-Count-Primes" class="headerlink" title="204. Count Primes"></a>204. Count Primes</h1><h2 id="Description-素数的个数"><a href="#Description-素数的个数" class="headerlink" title="Description: 素数的个数"></a>Description: 素数的个数</h2><p>Count the number of prime numbers less than a non-negative number, n.</p>
<p>Example:</p>
<p>Input: 10<br>Output: 4<br>Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.</p>
<h2 id="解法一-填充非素数"><a href="#解法一-填充非素数" class="headerlink" title="解法一: 填充非素数"></a>解法一: 填充非素数</h2><p><strong>时间复杂度:</strong> $O(n)$, 至多遍历两次 $n$ 大小的数组, 可优化为只遍历一次.<br><strong>空间复杂度:</strong> $O(n)$, 申请了 $n$ 大小的一维布尔数组来标识是否为负数</p>
<p><img src="http://wx3.sinaimg.cn/large/d7b90c85ly1fxngsjxjyag20cd0a9q6x.gif" alt=""></p>
<p>如上图, 我们从 $2\times 2$ 开始填充, 将所有能与2相乘切乘积小于 $n$ 的数对应下标置为 <code>false</code>, 然后从 $3\times 3$ 开始填充(注意不是从 $3\times 2$, 因为这样会与前面的 $2\times 3$ 重复), 接着从 $4\times 4$ 开始填充, 因此, 填充的开始位置最大为 $\sqrt{n}$. 另外需要注意的是, 0 和 1 均不是素数.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> div_n = <span class="built_in">sqrt</span>(n)+<span class="number">1</span>; <span class="comment">// 注意这里是开根号</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; is_primes(n, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;div_n; i++)&#123;            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i*i; j&lt;n; j+=i)&#123;</span><br><span class="line">                is_primes[j]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res_count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> primes : is_primes)&#123;</span><br><span class="line">            <span class="keyword">if</span>(primes==<span class="literal">true</span>) res_count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res_count<span class="number">-2</span>; <span class="comment">//去掉0和1的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>优化1: 因为任何一个合数都可以拆分成素数的乘积, 因此我们只在当前元素为素数的时候才开始填充, 例如, 对于4, 我们不填充16, 20, ..等数字, 因为这些数字在开始元素为2的时候已经填充过了. 因此, 可以避免这些重复填充, 减少迭代次数, 代码如下(多加了一条<code>if</code>语句).</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> div_n = <span class="built_in">sqrt</span>(n)+<span class="number">1</span>; <span class="comment">// 注意这里是开根号</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; is_primes(n, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;div_n; i++)&#123;    </span><br><span class="line">            <span class="keyword">if</span>(is_primes[i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i*i; j&lt;n; j+=i)&#123;</span><br><span class="line">                    is_primes[j]=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::count(is_primes.begin(), is_primes.end(), <span class="literal">true</span>)<span class="number">-2</span>; <span class="comment">//去掉0和1的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>优化2: 只遍历一次.</strong> 首先我们将判断数组<code>isPrime</code>的初始状态设为<code>true</code>, 这样, 每次只在遇到奇数时才检查其是否为素数, 如果该奇数是素数, 那么就将该奇数的倍数全部置为非素数, 同时, 将速度的count加1. 这样, 不仅可以减少判断次数(不再判断偶数), 同时可以在一次遍历的时间内完成素数统计.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; isPrime(n, <span class="literal">true</span>); <span class="comment">// 默认全是素数</span></span><br><span class="line">        <span class="keyword">int</span> upper = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(n); <span class="comment">// 控制 i*i, 防止越界</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 判断 0 ~ n-1 是否为素数, 当 n = 2 时, 返回0</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">// 2 也为素数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i+=<span class="number">2</span>) &#123; <span class="comment">// 只有奇数才有可能是速度, 并且 1 不是素数</span></span><br><span class="line">            <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; upper) <span class="keyword">continue</span>; <span class="comment">// 这里必须进行判断, 否则 i*i 有可能越界</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i*i; j &lt; n; j+=i) &#123; <span class="comment">// 将 i 的倍数全部置为非素数</span></span><br><span class="line">                    isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h1><h2 id="Description-逆置链表"><a href="#Description-逆置链表" class="headerlink" title="Description: 逆置链表"></a>Description: 逆置链表</h2><p>Reverse a singly linked list.</p>
<p>Example:</p>
<p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<h2 id="解法一-迭代"><a href="#解法一-迭代" class="headerlink" title="解法一: 迭代"></a>解法一: 迭代</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历一次链表<br><strong>空间复杂度:</strong> $O(1)$, 借助3个复制指针完成逆置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* next = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-递归-2"><a href="#解法二-递归-2" class="headerlink" title="解法二: 递归"></a>解法二: 递归</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(n)$, 迭代需要占用 $O(n)$ 大小的栈空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *P = reverseList(head-&gt;next); <span class="comment">//令下一个开始的节点逆置, 返回新链表的头结点</span></span><br><span class="line">        head-&gt;next-&gt;next = head; <span class="comment">// 将当前节点逆置</span></span><br><span class="line">        head-&gt;next=<span class="literal">nullptr</span>; <span class="comment">// 将当前节点的下一个置空, 主要是处理新的尾节点, 其他节点的next会在递归中正确赋值</span></span><br><span class="line">        <span class="keyword">return</span> P; <span class="comment">//返回新的头结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="217-Contains-Duplicate"><a href="#217-Contains-Duplicate" class="headerlink" title="217. Contains Duplicate"></a>217. Contains Duplicate</h1><h2 id="Description-判断数组中是否有重复元素"><a href="#Description-判断数组中是否有重复元素" class="headerlink" title="Description: 判断数组中是否有重复元素"></a>Description: 判断数组中是否有重复元素</h2><p>Given an array of integers, find if the array contains any duplicates.</p>
<p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<p>Example 1:</p>
<p>Input: [1,2,3,1]<br>Output: true<br>Example 2:</p>
<p>Input: [1,2,3,4]<br>Output: false<br>Example 3:</p>
<p>Input: [1,1,1,3,3,4,3,2,4,2]<br>Output: true</p>
<h2 id="解法一-暴力-2"><a href="#解法一-暴力-2" class="headerlink" title="解法一: 暴力"></a>解法一: 暴力</h2><p><strong>时间复杂度:</strong> $O(n^2)$, 暴力求解, 双重循环<br><strong>空间复杂度:</strong> $O(1)$, 无需额外空间</p>
<p>时间超限, 无法通过 OJ</p>
<h2 id="解法二-排序-遍历"><a href="#解法二-排序-遍历" class="headerlink" title="解法二: 排序+遍历"></a>解法二: 排序+遍历</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 先排序, 然后遍历看是否有相邻元素相等, 即 $O(nlogn + n)$, 也就是 $O(nlogn)$.<br><strong>空间复杂度:</strong> $O(1)$, 基于不同的排序算法决定, 使用堆排序则为 $O(1)$.</p>
<h2 id="解法三-unordered-set-哈希"><a href="#解法三-unordered-set-哈希" class="headerlink" title="解法三: unordered_set(哈希)"></a>解法三: unordered_set(哈希)</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历一遍数组, 在 unordered_set 中查询的复杂度为常数<br><strong>空间复杂度:</strong> $O(n)$, unordered_set占用额外空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; nums_set;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums_set.find(num) == nums_set.end())</span><br><span class="line">                nums_set.insert(num);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234. Palindrome Linked List"></a>234. Palindrome Linked List</h1><h2 id="Description-回文链表判断"><a href="#Description-回文链表判断" class="headerlink" title="Description: 回文链表判断"></a>Description: 回文链表判断</h2><p>Given a singly linked list, determine if it is a palindrome.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p><strong>Follow up:</strong><br>Could you do it in O(n) time and O(1) space?</p>
<h2 id="解法一-借助辅助数组"><a href="#解法一-借助辅助数组" class="headerlink" title="解法一: 借助辅助数组"></a>解法一: 借助辅助数组</h2><p><strong>时间复杂度:</strong> $O(n)$, 两次遍历<br><strong>空间复杂度:</strong> $O(n)$, 额外数组</p>
<p>最简单的做法就是遍历链表, 将其转换成一个可随机访问的数组, 然后进行回文串的判断.</p>
<h2 id="解法二-不借助辅助数组"><a href="#解法二-不借助辅助数组" class="headerlink" title="解法二: 不借助辅助数组"></a>解法二: 不借助辅助数组</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>先利用两个指针变量<code>slow</code>和<code>fast</code>找到链表的中点(<code>slow</code>每次走一步, <code>fast</code>每次走两步), 然后将后半段逆置, 接着将前半段和后半段进行比较. 最后根据具体需要将链表后半段复原. (在实际工作中, 不存在 $O(1)$ 空间复杂度的解法, 因为通常情况下是不允许修改链表的值的).</p>
<p><strong>不复原链表:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = node-&gt;next;</span><br><span class="line">            node-&gt;next = prev;</span><br><span class="line">            prev = node;</span><br><span class="line">            node = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast != <span class="literal">nullptr</span>) &#123; <span class="comment">// 奇数个节点, 始终令slow指向后半段的开始节点</span></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = reverseList(slow); <span class="comment">// 令slow指向后半段逆置后的开始节点</span></span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;val == slow-&gt;val) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow == <span class="literal">nullptr</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复原链表:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span> &amp;&amp; fast-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *rail = slow; <span class="comment">// 记录前半段的最后一个节点, 以便复原链表</span></span><br><span class="line">        slow = slow-&gt;next; <span class="comment">// 令slow指向回文串后半段的第一个节点</span></span><br><span class="line">        ListNode *rhead = reverseList(slow); <span class="comment">// 令fast 指向回文串后半段逆置后的连接头(奇数回文串时, 中间的节点算作前半段)</span></span><br><span class="line">        slow = head;</span><br><span class="line">        fast = rhead;</span><br><span class="line">        <span class="keyword">bool</span> res=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow!=<span class="literal">nullptr</span> &amp;&amp; fast!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;val != fast-&gt;val)&#123;</span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;        </span><br><span class="line">        rail-&gt;next = reverseList(rhead); <span class="comment">// 复原链表</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *cur)</span></span>&#123;</span><br><span class="line">        ListNode* next = cur-&gt;next;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">            <span class="keyword">if</span>(next!=<span class="literal">nullptr</span>) next = next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="237-Delete-Node-in-a-Linked-List"><a href="#237-Delete-Node-in-a-Linked-List" class="headerlink" title="237. Delete Node in a Linked List"></a>237. Delete Node in a Linked List</h1><h2 id="Description-删除链表中的某个节点"><a href="#Description-删除链表中的某个节点" class="headerlink" title="Description: 删除链表中的某个节点"></a>Description: 删除链表中的某个节点</h2><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Given linked list — head = [4,5,1,9], which looks like following:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 -&gt; 5 -&gt; 1 -&gt; 9</span><br></pre></td></tr></table></figure></p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [4,5,1,9], node = 5</span><br><span class="line">Output: [4,1,9]</span><br><span class="line">Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [4,5,1,9], node = 1</span><br><span class="line">Output: [4,5,9]</span><br><span class="line">Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>The linked list will have at least two elements.<br>All of the nodes’ values will be unique.<br>The given node will not be the tail and it will always be a valid node of the linked list.<br>Do not return anything from your function.</p>
<h2 id="解法一-复制-跳过节点"><a href="#解法一-复制-跳过节点" class="headerlink" title="解法一: 复制+跳过节点"></a>解法一: 复制+跳过节点</h2><p><strong>时间复杂度:</strong> $O(1)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>这是一道非常取巧(也可以说是投机)的题, 题目给的参数是需要删除的节点指针, 同时该指针不会是最后一个节点, 因此我们可以利用先复制, 再跳过的方式实现删除.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">c<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val; <span class="comment">// 题目假设node 不是最后一个节点</span></span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next; <span class="comment">// 跳过node节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242. Valid Anagram"></a>242. Valid Anagram</h1><p>变位词: 改变某个词或短语的字母顺序后构成的新词或短语</p>
<h2 id="Description-判断变位词"><a href="#Description-判断变位词" class="headerlink" title="Description: 判断变位词"></a>Description: 判断变位词</h2><p>Given two strings s and t , write a function to determine if t is an anagram of s.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>You may assume the string contains only lowercase alphabets.</p>
<p><strong>Follow up:</strong><br>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p>
<h2 id="解法一-排序-1"><a href="#解法一-排序-1" class="headerlink" title="解法一: 排序"></a>解法一: 排序</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 对两个字符串进行排序<br><strong>空间复杂度:</strong> $O(1)$, 可以原地排序, 不占用额外空间</p>
<p>对两个字符串排序后, 看是否相等. 该方式可以无缝的解决 Follow up 中的问题.</p>
<h2 id="解法二-哈希表"><a href="#解法二-哈希表" class="headerlink" title="解法二: 哈希表"></a>解法二: 哈希表</h2><p><strong>时间复杂度:</strong> $O(n1+n2)$, $n1$, $n2$ 分别为两个字符串的长度, 二者必须相等, 否则一定不是变位词.<br><strong>空间复杂度:</strong> $O(1)$, 哈希表的 size 为 26, 常数级</p>
<p>构造一个字母哈希表, 先统计</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() != t.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> ana_hash[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            ana_hash[c-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : t)&#123;</span><br><span class="line">            ana_hash[c-<span class="string">'a'</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (ana_hash[c-<span class="string">'a'</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        因为长度相等, 所以一旦不是异构词, 就一定会出现某个哈希位上的值小于0的情况, 因此无需在这里再次判断</span></span><br><span class="line"><span class="comment">        for(auto i : ana_hash)&#123;</span></span><br><span class="line"><span class="comment">            if(i != 0) return false;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解答-Follow-up"><a href="#解答-Follow-up" class="headerlink" title="解答 Follow up:"></a>解答 Follow up:</h2><p>用 <code>unordered_map</code> 来代替数组哈希表, 此时复杂度与输入的字符种类数目有关, 哈希表的空间复杂度变成 $O(n)$.</p>
<h1 id="268-Missing-Number"><a href="#268-Missing-Number" class="headerlink" title="268. Missing Number"></a>268. Missing Number</h1><h2 id="Description-缺失的数字"><a href="#Description-缺失的数字" class="headerlink" title="Description: 缺失的数字"></a>Description: 缺失的数字</h2><p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p>
<p>Example 1:</p>
<p>Input: [3,0,1]<br>Output: 2<br>Example 2:</p>
<p>Input: [9,6,4,2,3,5,7,0,1]<br>Output: 8<br>Note:<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p>
<h2 id="解法一-排序-2"><a href="#解法一-排序-2" class="headerlink" title="解法一: 排序"></a>解法一: 排序</h2><p><strong>时间复杂度:</strong> $O(nlogn)$<br><strong>空间复杂度:</strong> $O(1)$ 或 $O(n)$</p>
<h2 id="解法二-哈希表-1"><a href="#解法二-哈希表-1" class="headerlink" title="解法二: 哈希表"></a>解法二: 哈希表</h2><p><strong>时间复杂度:</strong> $O(n)$, 两次遍历, 第一次构建哈希, 第二次查询缺失数字<br><strong>空间复杂度:</strong> $O(n)$, 哈希表所占空间</p>
<p>另一种解法: 用下表做哈希, 将数字放置在与下标相同的位置上, 最终放错位置的元素的下标就是缺失的数字, 如果位置都正确, 则缺失 n. 复杂度与哈希表相同, 代码实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != nums[i] &amp;&amp; nums[i] &lt; n) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[i], nums[nums[i]]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != nums[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-异或-1"><a href="#解法三-异或-1" class="headerlink" title="解法三: 异或"></a>解法三: 异或</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(1)$, 无需额外空间</p>
<p>因为题目是从 <code>0, 1, 2, ..., n</code> 共 $n+1$ 个数字中选出了 $n$ 个不相同的数字, 因此, 如果将 $n+1$ 大小的数组和 $n$ 大小的数组合并成一个大数组, 那么在大数组中, 除了那个缺失的数字以外, 所有的数字都恰好出现了两次, 因此题目变成了求数组中出现一次的唯一数字, 此时可以利用异或在 $O(n)$ 时间复杂度内解决.</p>
<p><strong>该解法还可以解决丢失两个数字, 丢失三个数字的情况, 具体可参考用异或解决奇数偶数数字的问题.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> res = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            res = res ^ i ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-高斯求和公式"><a href="#解法四-高斯求和公式" class="headerlink" title="解法四: 高斯求和公式"></a>解法四: 高斯求和公式</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(1)$, 无需任何额外空间</p>
<p>前 $n$ 项和的求和公式为: $1+2+3+\cdots+n = \frac{(n+1)n}{2}$<br>因此, 我们只需要计算出当前数组的和, 然后在计算当前和与高斯和之间的差即可.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> gauss_sum = n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">            sum += num;</span><br><span class="line">        <span class="keyword">return</span> gauss_sum - sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="283-Move-Zeroes"><a href="#283-Move-Zeroes" class="headerlink" title="283. Move Zeroes"></a>283. Move Zeroes</h1><h2 id="Description-将-0-移动到最后-保持其他元素相对位置不变"><a href="#Description-将-0-移动到最后-保持其他元素相对位置不变" class="headerlink" title="Description: 将 0 移动到最后, 保持其他元素相对位置不变"></a>Description: 将 0 移动到最后, 保持其他元素相对位置不变</h2><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>Example:</p>
<p>Input: [0,1,0,3,12]<br>Output: [1,3,12,0,0]<br>Note:</p>
<p>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.</p>
<h2 id="解法一-交换法"><a href="#解法一-交换法" class="headerlink" title="解法一: 交换法"></a>解法一: 交换法</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$, 无需额外空间</p>
<p>利用交换将不符合要求的元素交换, 具体做法如下:</p>
<ol>
<li>令 <code>i</code> 指向第一个 0 元素;</li>
<li>令 <code>j</code> 指向 <code>i</code> 之后的第一个非 0 元素; (注意 <code>j</code> 必须在 <code>i</code> 的后面才能执行交换)</li>
<li>交换 <code>i</code> 和 <code>j</code> 指向的元素, 更新 <code>i</code> 和 <code>j</code> 的值.</li>
<li>重复以上步骤, 直到 <code>j</code> 越界.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums[i]!=<span class="number">0</span>) i++;</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">while</span>(nums[j]==<span class="number">0</span>) j++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.size())&#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(nums[i], nums[j]);</span><br><span class="line">            <span class="keyword">while</span>(nums[i]!=<span class="number">0</span>) i++;</span><br><span class="line">            j = i;</span><br><span class="line">            <span class="keyword">while</span>(nums[j]==<span class="number">0</span>) j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-更简洁的交换法"><a href="#解法二-更简洁的交换法" class="headerlink" title="解法二: 更简洁的交换法"></a>解法二: 更简洁的交换法</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>这道题可以从另一个角度来理解, 即可以看做是要将所有的非 0 元素保持相对位置不变地移动到数组的前面, 那么我们可以遍历数组, 并用一个变量 <code>i</code> 来记录当前元素之前的非 0 元素的个数, 那么如果当前元素为非 0 元素, 则可以令当前元素与 <code>nums[i]</code> 交换, 同时 <code>i++</code>, 这样便可以同时保证将非 0 元素移动到数组前以及保持相对位置不变两个条件.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        for(int i=0, j=0; j&lt;nums.size(); j++)&#123;</span><br><span class="line">            if(nums[j] != 0)&#123;</span><br><span class="line">                std::swap(nums[i], nums[j]);</span><br><span class="line">                i++; // 非0元素个数加1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="326-Power-of-Three"><a href="#326-Power-of-Three" class="headerlink" title="326. Power of Three"></a>326. Power of Three</h1><h2 id="Description-三的幂次"><a href="#Description-三的幂次" class="headerlink" title="Description: 三的幂次"></a>Description: 三的幂次</h2><p>Given an integer, write a function to determine if it is a power of three.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 27</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 0</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 9</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 45</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-自下而上-超时"><a href="#解法一-自下而上-超时" class="headerlink" title="解法一: 自下而上(超时)"></a>解法一: 自下而上(超时)</h2><p><strong>时间复杂度:</strong> $O(logn)$, 计算3的幂次, 总共需要计算 $log_3n$ 次<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>该方法从 3 开始, 逐渐计算 3 的幂次, 但是由于对于任何数都要计算 $log3n$ 次, 故当数很大时会超时</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">pow</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">pow</span> &lt; n)&#123;</span><br><span class="line">            <span class="built_in">pow</span> = <span class="built_in">pow</span>*<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>==n ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-自上而下"><a href="#解法二-自上而下" class="headerlink" title="解法二: 自上而下"></a>解法二: 自上而下</h2><p><strong>时间复杂度:</strong> $O(logn)$, 利用除法判断是否能整除 3, 当不能整除时, 可以提前退出, 起到剪枝效果, 最多需要计算 $log_3n$ 次<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>解法一采用的自下而上的乘法方法对于任何的数字都需要进行 $log_3n$ 次乘法才能判断是否为 3 的幂次, 这显然是不需要的, 我们只需要利用除法, 不断判断是否能被 3 整除即可, 一旦发现不能整除, 则肯定不是 3 的幂次, 可提前退出, 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;        </span><br><span class="line">        <span class="keyword">while</span> (n%<span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-进制转换-不使用循环或迭代"><a href="#解法三-进制转换-不使用循环或迭代" class="headerlink" title="解法三: 进制转换(不使用循环或迭代)"></a>解法三: 进制转换(不使用循环或迭代)</h2><p>十进制的 pow 形式为: 10, 100, 1000 (分别代表十, 一百, 一千)<br>二进制的 pow 形式为: 10, 100, 1000 (分别代表二, 四, 八)<br>因此我们可以推出三进制的形式为: 10, 100, 1000 (分别代表三, 九, 二十七)</p>
<p>故此, 我们可以将十进制先转换成三进制, 然后判断三进制形式是否首位为一, 其他位均为零, 如果满足, 则说明当前的数字是三的幂次. 该方法不需要循环和迭代(实际上在转换的过程仍然使用了循环和迭代).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="344-Reverse-String"><a href="#344-Reverse-String" class="headerlink" title="344. Reverse String"></a>344. Reverse String</h1><h2 id="Description-反转字符串"><a href="#Description-反转字符串" class="headerlink" title="Description: 反转字符串"></a>Description: 反转字符串</h2><p>Write a function that takes a string as input and returns the string reversed.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;hello&quot;</span><br><span class="line">Output: &quot;olleh&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: &quot;amanaP :lanac a ,nalp a ,nam A&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-使用-reverse-函数"><a href="#解法一-使用-reverse-函数" class="headerlink" title="解法一: 使用 reverse 函数"></a>解法一: 使用 reverse 函数</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;        </span><br><span class="line">        <span class="built_in">std</span>::reverse(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-基于-swap"><a href="#解法二-基于-swap" class="headerlink" title="解法二: 基于 swap"></a>解法二: 基于 swap</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(s[i], s[len<span class="number">-1</span>-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="350-Intersection-of-Two-Arrays-II"><a href="#350-Intersection-of-Two-Arrays-II" class="headerlink" title="350. Intersection of Two Arrays II"></a>350. Intersection of Two Arrays II</h1><h2 id="Description-求两数组的交集"><a href="#Description-求两数组的交集" class="headerlink" title="Description: 求两数组的交集"></a>Description: 求两数组的交集</h2><p>Given two arrays, write a function to compute their intersection.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">Output: [2,2]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">Output: [4,9]</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>Each element in the result should appear as many times as it shows in both arrays.<br>The result can be in any order.</p>
<p><strong>Follow up:</strong></p>
<ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
<li>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?</li>
<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>
</ul>
<h2 id="解法一-哈希-1"><a href="#解法一-哈希-1" class="headerlink" title="解法一: 哈希"></a>解法一: 哈希</h2><p><strong>时间复杂度:</strong> $O(n1+n2)$, 构建哈希表和查询哈希表, 需要将两数组的元素都遍历一次<br><strong>空间复杂度:</strong> $O(n1)$, 用 <code>nums1</code> 构建哈希表, 然后用 <code>nums2</code> 进行查询.(也可以多做一步判断, 选择用数组长度较小数组来构建哈希表, 减少空间复杂度)</p>
<p>用一个数组构建哈希表, 哈希表的键为元素值, 哈希表的值为元素的出现次数, 然后用另一个数组的元素对哈希表进行查询, 如果能找到, 则将该元素加入结果数组 <code>res</code>, 并将哈希表对应键的值减一, 如果减到零, 则删除该键.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash; <span class="comment">// 构建哈希</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num : nums1) hash[num]++;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.find(num) != hash.end())&#123;</span><br><span class="line">                res.push_back(num);</span><br><span class="line">                hash[num]--;</span><br><span class="line">                <span class="keyword">if</span>(hash[num]==<span class="number">0</span>) hash.erase(num); <span class="comment">// 当键对应值为0时, 将该键擦除                    </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-排序"><a href="#解法二-排序" class="headerlink" title="解法二: 排序"></a>解法二: 排序</h2><p><strong>时间复杂度:</strong> $O(n1logn1 + n2logn2 + n1 + n2) = max(n1, n2)\times log(max(n1, n2))$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums1.begin(), nums1.end());</span><br><span class="line">        <span class="built_in">std</span>::sort(nums2.begin(), nums2.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i1=<span class="number">0</span>, i2=<span class="number">0</span>; <span class="comment">// 设置两个指示变量</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(i1&lt;nums1.size() &amp;&amp; i2&lt;nums2.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i1] == nums2[i2])&#123;</span><br><span class="line">                res.push_back(nums1[i1]);</span><br><span class="line">                i1++;</span><br><span class="line">                i2++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i1] &lt; nums2[i2])</span><br><span class="line">                i1++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i2++;                </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up"></a>Follow up</h2><h3 id="当给定数组已经有序时"><a href="#当给定数组已经有序时" class="headerlink" title="当给定数组已经有序时"></a>当给定数组已经有序时</h3><p>可以设置两个指示变量, 分别指向两个数组, 然后按照指向元素的大小关系进行判断并递进, 这样, 时间复杂度为 $O(n1+n2)$, 空间复杂度为 $O(1)$, 代码可见解法二.</p>
<h3 id="当-nums1-远远小于-nums2-时"><a href="#当-nums1-远远小于-nums2-时" class="headerlink" title="当 nums1 远远小于 nums2 时"></a>当 <code>nums1</code> 远远小于 <code>nums2</code> 时</h3><p>正如前面所说, 选用元素数量较少的数组来构建哈希表, 可以降低空间复杂度</p>
<h3 id="如果-nums2-存放在磁盘上-同时内存不足以加载整个-nums2-数组"><a href="#如果-nums2-存放在磁盘上-同时内存不足以加载整个-nums2-数组" class="headerlink" title="如果 nums2 存放在磁盘上, 同时内存不足以加载整个 nums2 数组"></a>如果 <code>nums2</code> 存放在磁盘上, 同时内存不足以加载整个 <code>nums2</code> 数组</h3><p>将 <code>nums2</code> 分片, 逐个求交集, 最后再合并</p>
<h1 id="371-Sum-of-Two-Integers"><a href="#371-Sum-of-Two-Integers" class="headerlink" title="371. Sum of Two Integers"></a>371. Sum of Two Integers</h1><h2 id="Description-不用加减乘除做加法"><a href="#Description-不用加减乘除做加法" class="headerlink" title="Description: 不用加减乘除做加法"></a>Description: 不用加减乘除做加法</h2><p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a = 1, b = 2</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a = -2, b = 3</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-位操作-递归"><a href="#解法一-位操作-递归" class="headerlink" title="解法一: 位操作(递归)"></a>解法一: 位操作(递归)</h2><p>对于两个数相加, 例如 759+674, 在计算机中我们可以按照如下步骤求解:</p>
<ol>
<li>不考虑进位, 相加得到 323;</li>
<li>只考虑进位, 进位为 1110;</li>
<li>将上面两个数字相加, 得到 1433, 即为最终结果</li>
</ol>
<p>因此, 我们可以用 <strong>异或</strong> 求得不考虑进位的加, 用 <strong>与操作</strong> 来得到当前数字的进位, 由于进位与数字相加后, 有可能产生新的进位, 所以我们还要假设将新的进位加上, 直到进位位为0, 此时可以此时返回当前的和, 代码如下所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a ; <span class="comment">// 如果进位为0, 则可直接返回</span></span><br><span class="line">        <span class="keyword">int</span> sum = a ^ b; <span class="comment">// 计算不带进位的加法</span></span><br><span class="line">        <span class="keyword">int</span> carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;  <span class="comment">// 计算进位</span></span><br><span class="line">        <span class="keyword">return</span> getSum(sum, carry); <span class="comment">// 结合并返回        </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>上面的代码可以简化成一行:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> b==<span class="number">0</span> ? a : getSum(a^b, (a&amp;b)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-位操作-迭代"><a href="#解法二-位操作-迭代" class="headerlink" title="解法二: 位操作(迭代)"></a>解法二: 位操作(迭代)</h2><p>思路和解法一相同, 只不过写成了迭代的形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = a ^ b; <span class="comment">// 不考虑进位的加</span></span><br><span class="line">            b = (a&amp;b) &lt;&lt; <span class="number">1</span>; <span class="comment">// 进位</span></span><br><span class="line">            a = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="387-First-Unique-Character-in-a-String"><a href="#387-First-Unique-Character-in-a-String" class="headerlink" title="387. First Unique Character in a String"></a>387. First Unique Character in a String</h1><h2 id="Description-寻找字符串中的首个不重复字符"><a href="#Description-寻找字符串中的首个不重复字符" class="headerlink" title="Description: 寻找字符串中的首个不重复字符"></a>Description: 寻找字符串中的首个不重复字符</h2><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p>
<p>Examples:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;leetcode&quot;</span><br><span class="line">return 0.</span><br><span class="line"></span><br><span class="line">s = &quot;loveleetcode&quot;,</span><br><span class="line">return 2.</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong> You may assume the string contain only lowercase letters.</p>
<h2 id="解法一-哈希表"><a href="#解法一-哈希表" class="headerlink" title="解法一: 哈希表"></a>解法一: 哈希表</h2><p><strong>时间复杂度:</strong> $O(n+n)=O(n)$, 第一个 $n$ 用于建立哈希表, 第二个 $n$ 用于查询首个出现次数为 1 的字符, $n$ 为字符串的长度<br><strong>空间复杂度:</strong> $O(26)$, 哈希表的大小为字符集的大小 26 (如果是 unicode 字符, 就为 256).</p>
<p>遍历两边字符串, 第一遍构建哈希表, 第二遍按照字符串序列查询, 遇到值 1 的字符出现时, 就将其下标返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            hash[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[s[i]]==<span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="412. Fizz Buzz"></a>412. Fizz Buzz</h1><h2 id="Description-输出指定字符串"><a href="#Description-输出指定字符串" class="headerlink" title="Description: 输出指定字符串"></a>Description: 输出指定字符串</h2><p>Write a program that outputs the string representation of numbers from 1 to n.</p>
<p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">n = 15,</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">[</span><br><span class="line">    &quot;1&quot;,</span><br><span class="line">    &quot;2&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;4&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;7&quot;,</span><br><span class="line">    &quot;8&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;11&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;13&quot;,</span><br><span class="line">    &quot;14&quot;,</span><br><span class="line">    &quot;FizzBuzz&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-条件判断直接输出"><a href="#解法一-条件判断直接输出" class="headerlink" title="解法一: 条件判断直接输出"></a>解法一: 条件判断直接输出</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; fizzBuzz(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">15</span>==<span class="number">0</span>)</span><br><span class="line">                res.push_back(<span class="string">"FizzBuzz"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">5</span>==<span class="number">0</span>)</span><br><span class="line">                res.push_back(<span class="string">"Buzz"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">                res.push_back(<span class="string">"Fizz"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.push_back(<span class="built_in">std</span>::to_string(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法刷题/" rel="tag"><i class="fa fa-tag"></i> 算法刷题</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/z_post/面试-Cpp基础问题/" rel="prev" title="C++ 基础问题汇总">
                <i class="fa fa-chevron-left"></i> C++ 基础问题汇总
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/z_post/深度学习-反向传播算法完整推导/" rel="next" title="反向传播算法完整推导">
                反向传播算法完整推导 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar_zz.png"
                alt="ZeroZone" />
            
              <p class="site-author-name" itemprop="name">ZeroZone</p>
              <p class="site-description motion-element" itemprop="description">并不是什么厉害的地方<br>只是一个安静的学习角落</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">263</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/hellozhaozheng" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:hellozhaozheng@foxmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/ksws0292756" title="零域CSDN博客" target="_blank">零域CSDN博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://xinghanzzy.github.io/" title="BoXiao的博客" target="_blank">BoXiao的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://oldpan.me/" title="Oldpan的博客" target="_blank">Oldpan的博客</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#001-Two-Sum"><span class="nav-text">001. Two Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-求出能组合出目标数的两个元素"><span class="nav-text">Description: 求出能组合出目标数的两个元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-穷举"><span class="nav-text">解法一: 穷举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-哈希表-两次遍历"><span class="nav-text">解法二 : 哈希表, 两次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-哈希表-一次遍历"><span class="nav-text">解法三: 哈希表 一次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展问题"><span class="nav-text">扩展问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#007-Reverse-Integer"><span class="nav-text">007. Reverse Integer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-将数字逆置"><span class="nav-text">Description: 将数字逆置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-取余数"><span class="nav-text">解法一: 取余数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#013-Roman-to-Integer"><span class="nav-text">013. Roman to Integer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-顺序扫描"><span class="nav-text">解法一: 顺序扫描</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展问题-异常检测"><span class="nav-text">扩展问题: 异常检测</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#014-Longest-Common-Prefix"><span class="nav-text">014. Longest Common Prefix</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-最长公共前缀"><span class="nav-text">Description: 最长公共前缀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-顺序比较"><span class="nav-text">解法一: 顺序比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-垂直比较"><span class="nav-text">解法二: 垂直比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#020-Valid-Parentheses"><span class="nav-text">020. Valid Parentheses</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-1"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-栈"><span class="nav-text">解法一: 栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#021-Merge-Two-Sorted-Lists"><span class="nav-text">021. Merge Two Sorted Lists</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-2"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-遍历融合"><span class="nav-text">解法一: 遍历融合</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#026-Remove-Duplicates-from-Sorted-Array"><span class="nav-text">026. Remove Duplicates from Sorted Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-3"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一"><span class="nav-text">解法一:</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#028-Implement-strStr"><span class="nav-text">028. Implement strStr()</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#description-KMP-判断是否为子串"><span class="nav-text">description: KMP, 判断是否为子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-暴力"><span class="nav-text">解法一: 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-KMP"><span class="nav-text">解法二: KMP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#038-Count-and-Say"><span class="nav-text">038. Count and Say</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-4"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-依次查看上一次的数字"><span class="nav-text">解法一: 依次查看上一次的数字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#053-Maximum-Subarray"><span class="nav-text">053. Maximum Subarray</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-5"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-记录当前最大值"><span class="nav-text">解法: 记录当前最大值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#066-Plus-One"><span class="nav-text">066. Plus One</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-6"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-直接模拟"><span class="nav-text">解法一: 直接模拟</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-不使用加法-更快更简单-击败100"><span class="nav-text">解法二: 不使用加法(更快更简单, 击败100%)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#069-Sqrt-x"><span class="nav-text">069. Sqrt(x)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-7"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-二分法"><span class="nav-text">解法一: 二分法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-牛顿迭代法"><span class="nav-text">解法二: 牛顿迭代法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-按位检索"><span class="nav-text">解法三: 按位检索</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#070-Climbing-Stairs"><span class="nav-text">070. Climbing Stairs</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-8"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#088-Merge-Sorted-Array"><span class="nav-text">088. Merge Sorted Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-9"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-后移-插入融合"><span class="nav-text">解法一: 后移+插入融合</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#101-Symmetric-Tree"><span class="nav-text">101. Symmetric Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-10"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-1"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-1"><span class="nav-text">解法二: 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-迭代"><span class="nav-text">解法三: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#104-Maximum-Depth-of-Binary-Tree"><span class="nav-text">104. Maximum Depth of Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-11"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-层次遍历"><span class="nav-text">解法一: 层次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-递归"><span class="nav-text">解法二: 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#108-Convert-Sorted-Array-to-Binary-Search-Tree"><span class="nav-text">108. Convert Sorted Array to Binary Search Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-12"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归构造"><span class="nav-text">解法一: 递归构造</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-2"><span class="nav-text">解法二: 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-迭代-只中根遍历一次"><span class="nav-text">解法三: 迭代(只中根遍历一次)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#111-minimum-depth-of-binary-tree"><span class="nav-text">111. minimum depth of binary tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-1"><span class="nav-text">解法一:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-递归-1"><span class="nav-text">解法二(递归):</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#118-Pascal’s-Triangle"><span class="nav-text">118. Pascal’s Triangle</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-13"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-按照三角形的性质进行赋值"><span class="nav-text">解法一: 按照三角形的性质进行赋值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#121-Best-Time-to-Buy-and-Sell-Stock"><span class="nav-text">121. Best Time to Buy and Sell Stock</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-14"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-穷举-1"><span class="nav-text">解法一: 穷举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-一次遍历"><span class="nav-text">解法二: 一次遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#122-Best-Time-to-Buy-and-Sell-Stock-II"><span class="nav-text">122. Best Time to Buy and Sell Stock II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-15"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-用变量维护最低价格"><span class="nav-text">解法一: 用变量维护最低价格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-每两个相邻数字当做一次交易"><span class="nav-text">解法二: 每两个相邻数字当做一次交易</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#125-Valid-Palindrome"><span class="nav-text">125 Valid Palindrome</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-16"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-前后两个指示变量-向中间遍历判断"><span class="nav-text">解法一: 前后两个指示变量, 向中间遍历判断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#136-Single-Number"><span class="nav-text">136. Single Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-17"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希"><span class="nav-text">解法一: 哈希</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-数学公式"><span class="nav-text">解法二: 数学公式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-异或"><span class="nav-text">解法三: 异或</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#141-Linked-List-Cycle"><span class="nav-text">141. Linked List Cycle</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-18"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-Floyd-Cycle-Floyd-判圈算法"><span class="nav-text">解法一: Floyd Cycle(Floyd 判圈算法)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#155-Min-Stack"><span class="nav-text">155. Min Stack</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-19"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-两个栈"><span class="nav-text">解法一: 两个栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#160-Intersection-of-Two-Linked-Lists"><span class="nav-text">160. Intersection of Two Linked Lists</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-20"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：栈"><span class="nav-text">解法一：栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-常数空间复杂度"><span class="nav-text">解法二: 常数空间复杂度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#169-Majority-Element"><span class="nav-text">169 Majority Element</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-找出数组中超过一半的数字"><span class="nav-text">Description: 找出数组中超过一半的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-排序"><span class="nav-text">解法一: 排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-哈希"><span class="nav-text">解法二: 哈希</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-同增异减"><span class="nav-text">解法三: 同增异减</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-随机"><span class="nav-text">解法四: 随机</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#171-Excel-Sheet-Column-Number"><span class="nav-text">171. Excel Sheet Column Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-Excel列表数字"><span class="nav-text">Description: Excel列表数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-遍历字符串"><span class="nav-text">解法一: 遍历字符串</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#172-Factorial-Trailing-Zeroes"><span class="nav-text">172. Factorial Trailing Zeroes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-阶乘的尾部含有0的个数"><span class="nav-text">Description: 阶乘的尾部含有0的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-统计5的个数"><span class="nav-text">解法一: 统计5的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-另一个角度"><span class="nav-text">解法二: 另一个角度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#189-Rotate-Array"><span class="nav-text">189. Rotate Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-循环右移数组"><span class="nav-text">Description: 循环右移数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-暴力-1"><span class="nav-text">解法一: 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-使用额外数组"><span class="nav-text">解法二: 使用额外数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-循环置换"><span class="nav-text">解法三: 循环置换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-reverse"><span class="nav-text">解法四: reverse</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#190-Reverse-Bits"><span class="nav-text">190. Reverse Bits</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-按位逆置"><span class="nav-text">Description: 按位逆置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-按位进行32次操作"><span class="nav-text">解法一: 按位进行32次操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-按位二分进行5次操作"><span class="nav-text">解法二: 按位二分进行5次操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#191-Number-of-1-Bits"><span class="nav-text">191. Number of 1 Bits</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-统计二进制中1的个数"><span class="nav-text">Description: 统计二进制中1的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-逐位统计"><span class="nav-text">解法一: 逐位统计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-和-n-1-按位与"><span class="nav-text">解法二: 和 $n-1$ 按位与</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#198-House-Robber"><span class="nav-text">198. House Robber</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-房屋小偷获取最大收益"><span class="nav-text">Description: 房屋小偷获取最大收益</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-DP"><span class="nav-text">解法一: DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-根据房屋的编号奇偶性"><span class="nav-text">解法二: 根据房屋的编号奇偶性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#202-Happy-Number"><span class="nav-text">202. Happy Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-判断一个数字是否是-Happer-Number"><span class="nav-text">Description: 判断一个数字是否是 Happer Number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-模拟计算过程"><span class="nav-text">解法一: 模拟计算过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-Floyd-判圈算法"><span class="nav-text">解法二: Floyd 判圈算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#204-Count-Primes"><span class="nav-text">204. Count Primes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-素数的个数"><span class="nav-text">Description: 素数的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-填充非素数"><span class="nav-text">解法一: 填充非素数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#206-Reverse-Linked-List"><span class="nav-text">206. Reverse Linked List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-逆置链表"><span class="nav-text">Description: 逆置链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-迭代"><span class="nav-text">解法一: 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-递归-2"><span class="nav-text">解法二: 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#217-Contains-Duplicate"><span class="nav-text">217. Contains Duplicate</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-判断数组中是否有重复元素"><span class="nav-text">Description: 判断数组中是否有重复元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-暴力-2"><span class="nav-text">解法一: 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-排序-遍历"><span class="nav-text">解法二: 排序+遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-unordered-set-哈希"><span class="nav-text">解法三: unordered_set(哈希)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#234-Palindrome-Linked-List"><span class="nav-text">234. Palindrome Linked List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-回文链表判断"><span class="nav-text">Description: 回文链表判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-借助辅助数组"><span class="nav-text">解法一: 借助辅助数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-不借助辅助数组"><span class="nav-text">解法二: 不借助辅助数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#237-Delete-Node-in-a-Linked-List"><span class="nav-text">237. Delete Node in a Linked List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-删除链表中的某个节点"><span class="nav-text">Description: 删除链表中的某个节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-复制-跳过节点"><span class="nav-text">解法一: 复制+跳过节点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#242-Valid-Anagram"><span class="nav-text">242. Valid Anagram</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-判断变位词"><span class="nav-text">Description: 判断变位词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-排序-1"><span class="nav-text">解法一: 排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-哈希表"><span class="nav-text">解法二: 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解答-Follow-up"><span class="nav-text">解答 Follow up:</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#268-Missing-Number"><span class="nav-text">268. Missing Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-缺失的数字"><span class="nav-text">Description: 缺失的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-排序-2"><span class="nav-text">解法一: 排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-哈希表-1"><span class="nav-text">解法二: 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-异或-1"><span class="nav-text">解法三: 异或</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-高斯求和公式"><span class="nav-text">解法四: 高斯求和公式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#283-Move-Zeroes"><span class="nav-text">283. Move Zeroes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-将-0-移动到最后-保持其他元素相对位置不变"><span class="nav-text">Description: 将 0 移动到最后, 保持其他元素相对位置不变</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-交换法"><span class="nav-text">解法一: 交换法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-更简洁的交换法"><span class="nav-text">解法二: 更简洁的交换法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#326-Power-of-Three"><span class="nav-text">326. Power of Three</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-三的幂次"><span class="nav-text">Description: 三的幂次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-自下而上-超时"><span class="nav-text">解法一: 自下而上(超时)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-自上而下"><span class="nav-text">解法二: 自上而下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-进制转换-不使用循环或迭代"><span class="nav-text">解法三: 进制转换(不使用循环或迭代)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#344-Reverse-String"><span class="nav-text">344. Reverse String</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-反转字符串"><span class="nav-text">Description: 反转字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-使用-reverse-函数"><span class="nav-text">解法一: 使用 reverse 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-基于-swap"><span class="nav-text">解法二: 基于 swap</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#350-Intersection-of-Two-Arrays-II"><span class="nav-text">350. Intersection of Two Arrays II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-求两数组的交集"><span class="nav-text">Description: 求两数组的交集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希-1"><span class="nav-text">解法一: 哈希</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-排序"><span class="nav-text">解法二: 排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Follow-up"><span class="nav-text">Follow up</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#当给定数组已经有序时"><span class="nav-text">当给定数组已经有序时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#当-nums1-远远小于-nums2-时"><span class="nav-text">当 nums1 远远小于 nums2 时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果-nums2-存放在磁盘上-同时内存不足以加载整个-nums2-数组"><span class="nav-text">如果 nums2 存放在磁盘上, 同时内存不足以加载整个 nums2 数组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#371-Sum-of-Two-Integers"><span class="nav-text">371. Sum of Two Integers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-不用加减乘除做加法"><span class="nav-text">Description: 不用加减乘除做加法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-位操作-递归"><span class="nav-text">解法一: 位操作(递归)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-位操作-迭代"><span class="nav-text">解法二: 位操作(迭代)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#387-First-Unique-Character-in-a-String"><span class="nav-text">387. First Unique Character in a String</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-寻找字符串中的首个不重复字符"><span class="nav-text">Description: 寻找字符串中的首个不重复字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希表"><span class="nav-text">解法一: 哈希表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#412-Fizz-Buzz"><span class="nav-text">412. Fizz Buzz</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-输出指定字符串"><span class="nav-text">Description: 输出指定字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-条件判断直接输出"><span class="nav-text">解法一: 条件判断直接输出</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZeroZone</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">2.5m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">37:45</span>
  
</div>










  <div class="footer-custom">勤练带来力量</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  





  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


</body>
</html>
