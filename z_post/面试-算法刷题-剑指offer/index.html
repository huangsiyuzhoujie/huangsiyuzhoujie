<!DOCTYPE html>













<html class="theme-next gemini" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">

<meta name="google-site-verification" content="jgw73iXouBAJcOuff0yi9vdSNDecBSOUXacsHJszpmo" />
<meta name="baidu-site-verification" content="xyf9WD2vvl" />











<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/apple-icon-57x57.png?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_body":"slideDownIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="1. 二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数 解法一: 每一行用一次二分时间复杂度: $O(nlogn)$ (该复杂度无法通过牛客OJ) 123456789101112131415class Solution &amp;#123;p">
<meta name="keywords" content="算法刷题">
<meta property="og:type" content="article">
<meta property="og:title" content="《剑指offer》">
<meta property="og:url" content="https://hellozhaozheng.github.io/z_post/面试-算法刷题-剑指offer/index.html">
<meta property="og:site_name" content="从零开始的BLOG">
<meta property="og:description" content="1. 二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数 解法一: 每一行用一次二分时间复杂度: $O(nlogn)$ (该复杂度无法通过牛客OJ) 123456789101112131415class Solution &amp;#123;p">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-03-21T05:25:08.313Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《剑指offer》">
<meta name="twitter:description" content="1. 二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数 解法一: 每一行用一次二分时间复杂度: $O(nlogn)$ (该复杂度无法通过牛客OJ) 123456789101112131415class Solution &amp;#123;p">






  <link rel="canonical" href="https://hellozhaozheng.github.io/z_post/面试-算法刷题-剑指offer/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>《剑指offer》 | 从零开始的BLOG</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?21a4899cc63d3c11a3d90ac58074a19c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">从零开始的BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">与其感慨路难行，不如马上出发</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档<span class="badge">263</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-计算机视觉">
    <a href="/categories/计算机视觉/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tripadvisor"></i> <br />计算机视觉</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-深度学习">
    <a href="/categories/深度学习/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-drupal"></i> <br />深度学习</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-caffe2">
    <a href="/categories/Caffe2/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-coffee"></i> <br />Caffe2</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-pytorch">
    <a href="/categories/PyTorch/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-free-code-camp"></i> <br />PyTorch</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-c++">
    <a href="/categories/Cpp/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-codiepie"></i> <br />C++</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-python">
    <a href="/categories/Python/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-product-hunt"></i> <br />Python</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-项目">
    <a href="/categories/项目/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-connectdevelop"></i> <br />项目</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-cuda">
    <a href="/categories/CUDA/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-braille"></i> <br />CUDA</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-其他">
    <a href="/categories/其他/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />其他</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签<span class="badge">40</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于我</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />站内搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="站内搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  
  
    
      
    
    <a href="https://github.com/hellozhaozheng" class="github-corner" target="_blank" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg>
    
      </a>
    



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hellozhaozheng.github.io/z_post/面试-算法刷题-剑指offer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZeroZone">
      <meta itemprop="description" content="并不是什么厉害的地方<br>只是一个安静的学习角落">
      <meta itemprop="image" content="/images/avatar_zz.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始的BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《剑指offer》
              
            
          </h1>
        

        <div class="post-meta">
	
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-26 07:48:58" itemprop="dateCreated datePublished" datetime="2018-08-26T07:48:58+08:00">2018-08-26</time>
            

            
          </span>

	  
  	    <span class="post-updated">
    		&nbsp; | &nbsp; 更新于
    		<time itemprop="dateUpdated" datetime="2019-03-21T13:25:08+08:00" content="2019-03-21">
      		  2019-03-21
    		</time>
  	  </span>
	  

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon"
            >
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">125k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1:54</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1. 二维数组中的查找"></a>1. 二维数组中的查找</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数</p>
<h2 id="解法一-每一行用一次二分"><a href="#解法一-每一行用一次二分" class="headerlink" title="解法一: 每一行用一次二分"></a>解法一: 每一行用一次二分</h2><p><strong>时间复杂度:</strong> $O(nlogn)$ (该复杂度无法通过牛客OJ)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="built_in">array</span>.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> low = <span class="number">0</span>, high = <span class="built_in">array</span>[i].size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (low+high) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; <span class="built_in">array</span>[i][mid]) low = mid;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; <span class="built_in">array</span>[i][mid]) high = mid;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每一行二分需要 logn 的时间, 总共有n行.</p>
<h2 id="解法二-从左下角开始"><a href="#解法二-从左下角开始" class="headerlink" title="解法二: 从左下角开始"></a>解法二: 从左下角开始</h2><p><strong>时间复杂度:</strong> $O(n+m)$, 最多走 $n+m$ 步, $n$ 和 $m$ 分别为矩阵的宽和高<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>从左下角开始, 向右为大数方向, 向上为小数方向, 每次至少移动一位, 总共需要移动n次</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">array</span>.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>, len = <span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j &lt; len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; <span class="built_in">array</span>[i][j]) j++;  <span class="comment">// target在大数方向</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; <span class="built_in">array</span>[i][j]) i--;  <span class="comment">// target在小数方向</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<h2 id="解法-从前向后记录空格，从后向前替换空格"><a href="#解法-从前向后记录空格，从后向前替换空格" class="headerlink" title="解法: 从前向后记录空格，从后向前替换空格"></a>解法: 从前向后记录空格，从后向前替换空格</h2><p><strong>时间复杂度:</strong>  $O(n)$</p>
<p>需要注意, 如果替换的空间超过了length的申请空间, 则需要重新申请空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> white_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> char_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> *s = str;</span><br><span class="line">        <span class="keyword">while</span>(*s!=<span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*s == <span class="string">' '</span>) white_count++;</span><br><span class="line">            <span class="keyword">else</span> char_count++;</span><br><span class="line">            s++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>* res_str = str;</span><br><span class="line">        <span class="keyword">if</span>(char_count + white_count*<span class="number">3</span> &gt;length)</span><br><span class="line">            res_str = <span class="keyword">new</span> <span class="keyword">char</span>[char_count+white_count*<span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> old_length = char_count+white_count+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> new_length = char_count+white_count*<span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(old_length &gt;=<span class="number">0</span> &amp;&amp; new_length &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[old_length] != <span class="string">' '</span>)&#123;</span><br><span class="line">                res_str[new_length--]=str[old_length--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                old_length--;</span><br><span class="line">                res_str[new_length--]=<span class="string">'0'</span>;</span><br><span class="line">                res_str[new_length--]=<span class="string">'2'</span>;</span><br><span class="line">                res_str[new_length--]=<span class="string">'%'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        str = res_str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3.从尾到头打印链表"></a>3.从尾到头打印链表</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-reverse"><a href="#解法一-reverse" class="headerlink" title="解法一: reverse"></a>解法一: reverse</h2><p><strong>时间复杂度:</strong>  $O(n)$<br><strong>空间复杂度:</strong>  $O(n)$</p>
<p>顺序访问, 然后将vector里面的元素逆置.  这两部操作时间复杂度皆为 $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            res.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-swap-实际上依然是reverse"><a href="#解法二-swap-实际上依然是reverse" class="headerlink" title="解法二: swap (实际上依然是reverse)"></a>解法二: swap (实际上依然是reverse)</h2><p><strong>时间复杂度:</strong>  $O(n)$<br><strong>空间复杂度:</strong>  $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            res.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (res.size()<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> len = res.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;=mid;i++)</span><br><span class="line">            <span class="built_in">std</span>::swap(res[i], res[len-i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-栈"><a href="#解法三-栈" class="headerlink" title="解法三: 栈"></a>解法三: 栈</h2><p><strong>时间复杂度:</strong>  $O(n)$<br><strong>空间复杂度:</strong>  $O(2n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            s.push(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            res.push_back(s.top());</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4.重建二叉树"></a>4.重建二叉树</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p> <strong>首先需要注意一点的是: 这里前序和中序不能包含重复的元素, 否则无法确定前序和中序中节点的对应关系</strong></p>
<h2 id="解法一-递归"><a href="#解法一-递归" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(<br><strong>空间复杂度:</strong></p>
<p>根据前序和中序的对应关系, 利用递归完成构建, 构建时, 先构建当前节点, 然后是左右子树.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(pre, <span class="number">0</span>, pre.size()<span class="number">-1</span>, vin, <span class="number">0</span>, vin.size()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pre, <span class="keyword">int</span> pre_i, <span class="keyword">int</span> pre_j, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vin, <span class="keyword">int</span> vin_i, <span class="keyword">int</span> vin_j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre_i &gt; pre_j || vin_i &gt; vin_j) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode( pre[pre_i] ); <span class="comment">// 当前节点</span></span><br><span class="line">        <span class="keyword">int</span> v = vin_i;</span><br><span class="line">        <span class="keyword">while</span>(pre[pre_i] != vin[v]) v++; <span class="comment">//找到前序在中序中的对应节点, 这里可以用哈希表来改进查找的复杂度</span></span><br><span class="line">        node-&gt;left = helper(pre, pre_i+<span class="number">1</span>, pre_i+v-vin_i, vin, vin_i, v<span class="number">-1</span>);</span><br><span class="line">        node-&gt;right = helper(pre, pre_i+v-vin_i+<span class="number">1</span>, pre_j, vin, v+<span class="number">1</span>, vin_j);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代"><a href="#解法二-迭代" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; tree_stack;</span><br><span class="line">        <span class="keyword">if</span>(pre.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode * root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        tree_stack.push(root);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;pre.size() ; i++)&#123;</span><br><span class="line">            TreeNode * cur_node = tree_stack.top();</span><br><span class="line">            <span class="keyword">if</span>(cur_node-&gt;val != vin[index])&#123;</span><br><span class="line">                cur_node-&gt;left = <span class="keyword">new</span> TreeNode(pre[i]);</span><br><span class="line">                tree_stack.push(cur_node-&gt;left);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>( !tree_stack.empty() &amp;&amp; tree_stack.top()-&gt;val == vin[index])&#123; <span class="comment">// 注意, 这里不能用cur_node, 而必须用tree_stack.top()</span></span><br><span class="line">                    cur_node = tree_stack.top(); tree_stack.pop(); index++;</span><br><span class="line">                &#125;</span><br><span class="line">                cur_node-&gt;right = <span class="keyword">new</span> TreeNode(pre[i]);</span><br><span class="line">                tree_stack.push(cur_node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="5-用两个栈实现队列"><a href="#5-用两个栈实现队列" class="headerlink" title="5.用两个栈实现队列"></a>5.用两个栈实现队列</h1><h1 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6.旋转数组的最小数字"></a>6.旋转数组的最小数字</h1><h1 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7.斐波那契数列"></a>7.斐波那契数列</h1><script type="math/tex; mode=display">f(n) = \begin{cases} 0, & n=0 \\ 1, & n=1(或2) \\ f(n-1)+f(n-2), & n>2 \end{cases}</script><h2 id="解法一-递归-超时-超内存"><a href="#解法一-递归-超时-超内存" class="headerlink" title="解法一: 递归(超时,超内存)"></a>解法一: 递归(超时,超内存)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">1</span> || number==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> jumpFloor(number<span class="number">-1</span>)+jumpFloor(number<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代-1"><a href="#解法二-迭代-1" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n1=<span class="number">1</span>, n2=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n2;</span><br><span class="line">            n2 = n2+n1;</span><br><span class="line">            n1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代-2"><a href="#解法二-迭代-2" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><h1 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8.跳台阶"></a>8.跳台阶</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<h2 id="解法一-递归-超时-超内存-1"><a href="#解法一-递归-超时-超内存-1" class="headerlink" title="解法一: 递归(超时, 超内存)"></a>解法一: 递归(超时, 超内存)</h2><p>设n个台阶的跳法有 $f(n)$ 种, 当青蛙跳上一个台阶后, 剩下的走法就是只有n-1个台阶的走法, 因此就是 $f(n-1)$ , 同理, 如果当前跳了2个台阶, 那么剩下的就是f(n-2), 因此有以下公式:</p>
<script type="math/tex; mode=display">f(n) = \begin{cases} 1, & n=1 \\ 2, & n=2 \\ f(n-1) + f(n-2) & n>1 \end{cases}</script><p>从上可以看出, 这道题就是斐波那契数列的变种, 不同之处在于初始值不同(因为台阶为2时, 有两种跳法), 因此解法同上.</p>
<h2 id="解法二-迭代-3"><a href="#解法二-迭代-3" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=number; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=n2;</span><br><span class="line">            n2 = n2 + n1;</span><br><span class="line">            n1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9.变态跳台阶"></a>9.变态跳台阶</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h2 id="解法一-递归-1"><a href="#解法一-递归-1" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p>对于n个台阶, 可以跳1次, 2次, …., n次, 那么对应的剩下的台阶的跳法就有 $f(n-1), f(n-2), …, f(n-n)$ 种, 所以有下式:</p>
<script type="math/tex; mode=display">f(n) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2) + f(n-1) = f(n-1) + f(n-1)</script><script type="math/tex; mode=display">f(n) = \begin{cases} 1, & n=0 \\ 1, & n=1 \\ 2*f(n-1), & n>=2 \end{cases}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> jumpFloorII(number<span class="number">-1</span>) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10.矩形覆盖"></a>10.矩形覆盖</h1><p>对于 $n \times 2$ 大小的矩形, 可以竖着排列一个 $2\times 1$ 矩形, 或者横着排列上下两个 $2\times 1$ 的矩形, 那么对应的剩下的矩形面积就分别为 $(n-1) \times 2$ 和 $(n-2) \times 2$, 所以有下式:</p>
<script type="math/tex; mode=display">f(n) = \begin{cases} 1, & n=1 \\ 2, & n=2 \\ f(n-1) + f(n-2) & n>1 \end{cases}</script><h2 id="解法一-递归-超时"><a href="#解法一-递归-超时" class="headerlink" title="解法一: 递归(超时)"></a>解法一: 递归(超时)</h2><h2 id="解法二-迭代-4"><a href="#解法二-迭代-4" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n1=<span class="number">1</span>, n2=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=number; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n2;</span><br><span class="line">            n2 = n2+n1;</span><br><span class="line">            n1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11.二进制中1的个数"></a>11.二进制中1的个数</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<h2 id="解法一-按位与-amp"><a href="#解法一-按位与-amp" class="headerlink" title="解法一: 按位与&amp;"></a>解法一: 按位与<code>&amp;</code></h2><p><strong>时间复杂度:</strong> $O(1)$, 因为最多比较32次(long为64次)<br><strong>空间复杂度:</strong> $O(1)$</p>
<p><strong>注意:</strong> <code>(n&amp;i)</code> 一定要带括号, 因为它的优先级比<code>==, !=</code> 等符号低.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>( i!=<span class="number">0</span> )&#123;</span><br><span class="line">             <span class="keyword">if</span>( (n&amp;i) != <span class="number">0</span>) count++; <span class="comment">// 注意, 这里的判断条件是 !=0, 并且 n&amp;i 一定要带括号</span></span><br><span class="line">             i = i &lt;&lt; <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-n-amp-n-1"><a href="#解法二-n-amp-n-1" class="headerlink" title="解法二: n&amp;(n-1)"></a>解法二: <code>n&amp;(n-1)</code></h2><p>一个整数 $n$, 将其与 $n-1$ 按位逻辑与, 得到的数刚好是将 $n$ 最右边的1置为0(其他位不变), 那么一个数有多少个1, 就可以进行多少次这样的操作.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">             n = n&amp;(n<span class="number">-1</span>);</span><br><span class="line">             count++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12.数值的整数次方"></a>12.数值的整数次方</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<h2 id="解法一-递归-2"><a href="#解法一-递归-2" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p>当n为偶数时: $x^n = x^{n/2} \times x^{n/2}$<br>当n为奇数时: $x^n = x\times x^{n/2} \times x^{n/2}$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">int</span> un = <span class="built_in">abs</span>(n);  <span class="comment">//注意这里必须是 unsigned类型, 就算是long , 也必须带unsigned, 主要是因为abs(INT_MIN)仍为负数INT_MIN!</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">        <span class="keyword">return</span> (un%<span class="number">2</span>==<span class="number">0</span>) ? myPow(x*x, un/<span class="number">2</span>) : x*myPow(x*x, un/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-非递归"><a href="#解法二-非递归" class="headerlink" title="解法二: 非递归"></a>解法二: 非递归</h2><p>n要么为偶数, 要么为奇数, 就算为奇数, 也可以拆分成 $x\times x^{n-1}$ 的形式, 对于偶数n, 可以写成 $x^{n/2} \times x{n/2}$ 的形式, 对于 $x^{n/2}$, 可以继续按奇数偶数进行拆分. 举例来说, 对于x=2, n=10 , 可以写成 $2^{10} = 2^{5} \times 2^{5}$ 对于 $2^5$ , 可以写成, $2 \times 2^2 \times 2^2$, 可以看出, x每次与自身相乘后, n的次数就会变成原来二分之一, 这样, 可以用循环实现幂乘的操作, 如下所示.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">int</span> un = <span class="built_in">abs</span>(n);  <span class="comment">//注意这里必须是 unsigned类型, 就算是long , 也必须带unsigned, 主要是因为abs(INT_MIN)仍为负数INT_MIN!</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">        <span class="keyword">double</span> res =<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(un&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(un%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                res * = x;</span><br><span class="line">            &#125;</span><br><span class="line">            x * =x;</span><br><span class="line">            un /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13.调整数组顺序使奇数位于偶数前面"></a>13.调整数组顺序使奇数位于偶数前面</h1><h1 id="14-链表中倒数第k个节点"><a href="#14-链表中倒数第k个节点" class="headerlink" title="14.链表中倒数第k个节点"></a>14.链表中倒数第k个节点</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p>
<h2 id="解法一-两个指针"><a href="#解法一-两个指针" class="headerlink" title="解法一: 两个指针"></a>解法一: 两个指针</h2><p><strong>时间复杂度:</strong> $O(n)$  遍历一次<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* p1 = pListHead, * p2 = pListHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p2==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p1 = p1-&gt;next; p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="15-反转链表"><a href="#15-反转链表" class="headerlink" title="15.反转链表"></a>15.反转链表</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<h2 id="解法一-两个指针pre和cur"><a href="#解法一-两个指针pre和cur" class="headerlink" title="解法一: 两个指针pre和cur"></a>解法一: 两个指针pre和cur</h2><p><strong>时间复杂度:</strong> $O(n)$ 一次遍历<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>利用两个指针<code>pre</code>和<code>cur</code>维持当前节点和前一个节点, 然后执行反转操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = pHead;</span><br><span class="line">        <span class="keyword">while</span>(pHead != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur = pHead;</span><br><span class="line">            pHead = pHead-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="16-合并两个排序的链表"><a href="#16-合并两个排序的链表" class="headerlink" title="16.合并两个排序的链表"></a>16.合并两个排序的链表</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<h2 id="解法一-原地合并"><a href="#解法一-原地合并" class="headerlink" title="解法一: 原地合并"></a>解法一: 原地合并</h2><p>用辅助指针head申请一个指向头结点的指针, 并用cur维护当前节点, 通过比较大小进行插入合并<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> pHead1;</span><br><span class="line">        ListNode * head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode * cur = head;</span><br><span class="line">        <span class="keyword">while</span>(pHead1!=<span class="literal">nullptr</span> &amp;&amp; pHead2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pHead1-&gt;val &lt; pHead2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = pHead1;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                pHead1 = pHead1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = pHead2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                pHead2 = pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pHead1!=<span class="literal">nullptr</span>) cur-&gt;next = pHead1;</span><br><span class="line">        <span class="keyword">if</span>(pHead2!=<span class="literal">nullptr</span>) cur-&gt;next = pHead2;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-递归"><a href="#解法二-递归" class="headerlink" title="解法二: 递归"></a>解法二: 递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1==<span class="literal">nullptr</span>) <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead2==<span class="literal">nullptr</span>) <span class="keyword">return</span> pHead1;</span><br><span class="line">        <span class="keyword">if</span>(pHead1-&gt;val &lt; pHead2-&gt;val)&#123;</span><br><span class="line">            pHead1-&gt;next = Merge(pHead1-&gt;next, pHead2);</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pHead2-&gt;next = Merge(pHead1, pHead2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="17-树的子结构"><a href="#17-树的子结构" class="headerlink" title="17.树的子结构"></a>17.树的子结构</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<h2 id="解法一-非递归"><a href="#解法一-非递归" class="headerlink" title="解法一: 非递归"></a>解法一: 非递归</h2><p>每找到一个相等的节点, 就判断就是为子树</p>
<p>采用的是先根遍历的非递归写法, 在入栈之前就进行判断.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode * &gt; pre_root;</span><br><span class="line">        <span class="keyword">while</span>(!pre_root.empty() || pRoot1!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(pRoot1!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pRoot1-&gt;val == pRoot2-&gt;val &amp;&amp; is_subtree(pRoot1, pRoot2))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                pre_root.push(pRoot1);</span><br><span class="line">                pRoot1 = pRoot1-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!pre_root.empty())&#123;</span><br><span class="line">                pRoot1 = pre_root.top(); pre_root.pop();</span><br><span class="line">                pRoot1 = pRoot1-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_subtree</span><span class="params">(TreeNode * pRoot1, TreeNode * pRoot2)</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode * &gt; pre_root;</span><br><span class="line">        <span class="keyword">while</span>(!pre_root.empty() || pRoot2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(pRoot2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pRoot1==<span class="literal">nullptr</span> || pRoot2-&gt;val != pRoot1-&gt;val)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                pre_root.push(pRoot1);</span><br><span class="line">                pre_root.push(pRoot2);</span><br><span class="line">                pRoot1 = pRoot1-&gt;left;</span><br><span class="line">                pRoot2 = pRoot2-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!pre_root.empty())&#123;</span><br><span class="line">                pRoot2 = pre_root.top(); pre_root.pop(); <span class="comment">// 注意入栈与出栈的顺序要刚好相反</span></span><br><span class="line">                pRoot1 = pre_root.top(); pre_root.pop();</span><br><span class="line">                pRoot1 = pRoot1-&gt;right;</span><br><span class="line">                pRoot2 = pRoot2-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-递归-1"><a href="#解法二-递归-1" class="headerlink" title="解法二: 递归"></a>解法二: 递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">false</span>; <span class="comment">//用result变量来记录是否已经是子树, 如果result一旦为true, 就直接返回, 不用再继续递归</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot1 != <span class="literal">nullptr</span> &amp;&amp; pRoot2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            result = is_subtree(pRoot1,pRoot2);</span><br><span class="line">            <span class="keyword">if</span>(!result) result = HasSubtree(pRoot1-&gt;left, pRoot2);</span><br><span class="line">            <span class="keyword">if</span>(!result) result = HasSubtree(pRoot1-&gt;right, pRoot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_subtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot2 == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1==<span class="literal">nullptr</span> || pRoot2-&gt;val != pRoot1-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> is_subtree(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; is_subtree(pRoot1-&gt;right, pRoot2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18.二叉树的镜像"></a>18.二叉树的镜像</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。<br>输入描述:<br>二叉树的镜像定义：源二叉树<br>            8<br>           /  \<br>          6   10<br>         / \  / \<br>        5  7 9 11<br>        镜像二叉树<br>            8<br>           /  \<br>          10   6<br>         / \  / \<br>        11 9 7  5</p>
<h2 id="解法一-递归-3"><a href="#解法一-递归-3" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p>先根遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode * pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        TreeNode * temp = pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right = temp;</span><br><span class="line">        Mirror(pRoot-&gt;left);</span><br><span class="line">        Mirror(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-非递归-1"><a href="#解法二-非递归-1" class="headerlink" title="解法二: 非递归"></a>解法二: 非递归</h2><p>先根遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode * pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode * &gt; pre_root;</span><br><span class="line">        TreeNode * cur = pRoot;</span><br><span class="line">        <span class="keyword">while</span>(!pre_root.empty() || cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                TreeNode * temp = cur-&gt;left;</span><br><span class="line">                cur-&gt;left = cur-&gt;right;</span><br><span class="line">                cur-&gt;right = temp;</span><br><span class="line">                pre_root.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!pre_root.empty())&#123;</span><br><span class="line">                cur = pre_root.top(); pre_root.pop();</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="19-顺时针打印矩阵"><a href="#19-顺时针打印矩阵" class="headerlink" title="19.顺时针打印矩阵"></a>19.顺时针打印矩阵</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<h2 id="解法一-按层打印"><a href="#解法一-按层打印" class="headerlink" title="解法一: 按层打印"></a>解法一: 按层打印</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>按照层从外而内进行打印, 需要注意层的边界条件, 以及上下层和左右层之间不能重复.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span> ||matrix[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size(), col = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> layers = (<span class="built_in">std</span>::min(row,col) + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> layer=<span class="number">0</span>; layer&lt;layers; layer++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=layer, j=layer; j&lt; col-layer; j++ )</span><br><span class="line">                res.push_back(matrix[i][j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=layer+<span class="number">1</span>, j=col-layer<span class="number">-1</span>; i&lt;row-layer<span class="number">-1</span>; i++)</span><br><span class="line">                res.push_back(matrix[i][j]);</span><br><span class="line">            <span class="comment">// 这里的 i &gt; (row-1)/2 也可以写作 layer != row-1-layer, 避免上下重复</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=row-layer<span class="number">-1</span>, j=col-layer<span class="number">-1</span>; i &gt; (row<span class="number">-1</span>)/<span class="number">2</span> &amp;&amp; j &gt;=layer; j--)</span><br><span class="line">                res.push_back(matrix[i][j]);</span><br><span class="line">            <span class="comment">// 这里的 j &lt; col/2 也可以写作 layer != col-1-layer, 避免左右重复</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=row-layer<span class="number">-2</span>, j=layer; j &lt; col/<span class="number">2</span> &amp;&amp;  i&gt;layer; i--)</span><br><span class="line">                res.push_back(matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="20-包含min函数的栈"><a href="#20-包含min函数的栈" class="headerlink" title="20.包含min函数的栈"></a>20.包含min函数的栈</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
<h2 id="解法-利用辅助栈实现"><a href="#解法-利用辅助栈实现" class="headerlink" title="解法: 利用辅助栈实现"></a>解法: 利用辅助栈实现</h2><p>应用一个辅助栈，压的时候，如果A栈的压入比B栈压入大，B栈不压，，，，小于等于，AB栈同时压入，出栈，如果，AB栈顶元素不等，A出，B不出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1,s2;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        s1.push(value);</span><br><span class="line">        <span class="keyword">if</span>(s2.empty()) s2.push(value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s1.top() &lt;= s2.top()) s2.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.top()==s2.top()) s2.pop();</span><br><span class="line">        s1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="21-栈的压入、弹出序列"><a href="#21-栈的压入、弹出序列" class="headerlink" title="21.栈的压入、弹出序列"></a>21.栈的压入、弹出序列</h1><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<h2 id="解法-模拟栈的压入-弹出"><a href="#解法-模拟栈的压入-弹出" class="headerlink" title="解法: 模拟栈的压入, 弹出"></a>解法: 模拟栈的压入, 弹出</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(pushV.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s.push(pushV[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.top() != popV[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;pushV.size())</span><br><span class="line">                    s.push(pushV[j++]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>更简洁的写法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(pushV.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;pushV.size() ;)&#123;</span><br><span class="line">            s.push(pushV[i++]);</span><br><span class="line">            <span class="keyword">while</span>(j&lt;popV.size() &amp;&amp; s.top() == popV[j])&#123;s.pop(); j++;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22.从上往下打印二叉树"></a>22.从上往下打印二叉树</h1><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<h2 id="解法-层次遍历"><a href="#解法-层次遍历" class="headerlink" title="解法: 层次遍历"></a>解法: 层次遍历</h2><p>用一个变量<code>cur_len</code>来维护当前层的节点数, 这样就无序额外存储层深等其他信息.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode*&gt; q_tree;</span><br><span class="line">        q_tree.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q_tree.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> cur_len = q_tree.size(); <span class="comment">// 获取当前层节点数目</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cur_len; i++)&#123; <span class="comment">//直到遍历完当前层节点</span></span><br><span class="line">                TreeNode* cur_node = q_tree.front(); q_tree.pop();</span><br><span class="line">                res.push_back(cur_node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;left != <span class="literal">nullptr</span>) q_tree.push(cur_node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;right != <span class="literal">nullptr</span>) q_tree.push(cur_node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="23-二叉搜索树的后序遍历序列"><a href="#23-二叉搜索树的后序遍历序列" class="headerlink" title="23.二叉搜索树的后序遍历序列"></a>23.二叉搜索树的后序遍历序列</h1><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<h2 id="解法-根据后序序列的特性设计递归判断规则"><a href="#解法-根据后序序列的特性设计递归判断规则" class="headerlink" title="解法: 根据后序序列的特性设计递归判断规则"></a>解法: 根据后序序列的特性设计递归判断规则</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(sequence, <span class="number">0</span>, sequence.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;sequence, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=end) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_i = start;</span><br><span class="line">        <span class="keyword">while</span>(cur_i &lt; end &amp;&amp; sequence[cur_i] &lt; sequence[end]) cur_i++;</span><br><span class="line">        <span class="keyword">int</span> mid = cur_i;</span><br><span class="line">        <span class="keyword">while</span>(cur_i &lt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[cur_i] &lt;sequence[end]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            cur_i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> b1 = helper(sequence, start, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">bool</span> b2 = helper(sequence, mid, end<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> b1&amp;&amp;b2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="24-二叉树中和为某一值的路径"><a href="#24-二叉树中和为某一值的路径" class="headerlink" title="24.二叉树中和为某一值的路径"></a>24.二叉树中和为某一值的路径</h1><h2 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
<h2 id="解法一-递归解法"><a href="#解法一-递归解法" class="headerlink" title="解法一: 递归解法"></a>解法一: 递归解法</h2><p>先根遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v_list;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="keyword">int</span> cur_number = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        cur_number += root-&gt;val;</span><br><span class="line">        v_list.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(cur_number == expectNumber &amp;&amp; root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">            res.push_back(v_list);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span> ) FindPath(root-&gt;left, expectNumber);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span>) FindPath(root-&gt;right, expectNumber);</span><br><span class="line">        cur_number -= root-&gt;val;</span><br><span class="line">        v_list.pop_back();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>另一种写法:</strong> 通过减法控制当前的和<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v_list;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="comment">//int cur_number = 0;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        expectNumber -= root-&gt;val; <span class="comment">// 注意这里是减法</span></span><br><span class="line">        v_list.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == expectNumber &amp;&amp; root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span>) <span class="comment">//条件语句变为 0 == expectNumber</span></span><br><span class="line">            res.push_back(v_list);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span> ) FindPath(root-&gt;left, expectNumber);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span>) FindPath(root-&gt;right, expectNumber);</span><br><span class="line">        <span class="comment">//cur_number -= root-&gt;val; //注意, 可以不加这条语句</span></span><br><span class="line">        v_list.pop_back();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-非递归-2"><a href="#解法二-非递归-2" class="headerlink" title="解法二: 非递归"></a>解法二: 非递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">非递归法：后序遍历</span></span><br><span class="line"><span class="comment">1.进栈时候，把值同时压入路径的向量数组，修正路径的和</span></span><br><span class="line"><span class="comment">2.出栈时候，先判断和是否相等，且该节点是否是叶节点，</span></span><br><span class="line"><span class="comment">判断完成后保持和栈一致，抛出路径，修改路径的和</span></span><br><span class="line"><span class="comment">3.向量数组和栈的操作要保持一致</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root, <span class="keyword">int</span> expectNumber) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">while</span> (root || !s.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (root)&#123;</span><br><span class="line">                s.push(root); v.push_back(root-&gt;val); expectNumber -= root-&gt;val;</span><br><span class="line">                <span class="comment">//能左就左，否则向右</span></span><br><span class="line">                root = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            root = s.top();</span><br><span class="line">            <span class="keyword">if</span> (expectNumber == <span class="number">0</span> &amp;&amp; root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                res.push_back(v);</span><br><span class="line">            s.pop(); v.pop_back(); expectNumber += root-&gt;val;</span><br><span class="line">            <span class="comment">//右子数没遍历就遍历，如果遍历就强迫出栈</span></span><br><span class="line">            <span class="keyword">if</span> (!s.empty() &amp;&amp; s.top()-&gt;left == root)</span><br><span class="line">                root = s.top()-&gt;right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                root = <span class="literal">NULL</span>;<span class="comment">//强迫出栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="25-复杂链表的复制"><a href="#25-复杂链表的复制" class="headerlink" title="25.复杂链表的复制"></a>25.复杂链表的复制</h1><h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>链表的复制不同于其他复制，在进行链表复制时，必须创建新的节点，同时，不能通过<code>newnode-&gt;next = oldnode-next</code>对新节点进行赋值，这是因为这样赋值会使新链表指向旧链表的节点，造成混乱。</p>
<h2 id="正确解题思路："><a href="#正确解题思路：" class="headerlink" title="正确解题思路："></a>正确解题思路：</h2><ul>
<li>先对原链表中的每一个节点进行复制，将复制的节点插入到原节点之后，比如原链表是<code>A-&gt;B-&gt;C</code>，则复制后应该变成<code>A-&gt;A1-&gt;B-&gt;B1-&gt;C-&gt;C1</code>。</li>
<li>再按照原始链表中随机指针的指向，对新节点的随机指针进行赋值。</li>
<li>将链表拆分</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    struct RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment">    RandomListNode(int x) :</span></span><br><span class="line"><span class="comment">            label(x), next(NULL), random(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//少考虑这种情况会发生段错误</span></span><br><span class="line">        RandomListNode* curnode = pHead;</span><br><span class="line">        <span class="comment">//C++允许在声明结构变量时省略关键字struct，但是C不允许</span></span><br><span class="line">        <span class="keyword">while</span>(curnode!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            RandomListNode* clonenode = <span class="keyword">new</span> RandomListNode(curnode-&gt;label);</span><br><span class="line">            clonenode-&gt;next = curnode-&gt;next;</span><br><span class="line">            curnode-&gt;next = clonenode;</span><br><span class="line">            curnode = clonenode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curnode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(curnode!=<span class="literal">NULL</span>)&#123; <span class="comment">// 因为random有可能指向前面的节点, 所以必须在拆分链表之前进行random指针的赋值, 而不能在拆分链表的同时进行赋值</span></span><br><span class="line">            <span class="keyword">if</span>(curnode-&gt;random!=<span class="literal">NULL</span>)&#123;  <span class="comment">//少考虑这种情况会不满足个别用例</span></span><br><span class="line">                curnode-&gt;next-&gt;random = curnode-&gt;random-&gt;next;</span><br><span class="line">                curnode = curnode-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                curnode-&gt;next-&gt;random = <span class="literal">NULL</span>;</span><br><span class="line">                curnode = curnode-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curnode = pHead;</span><br><span class="line">        RandomListNode* newhead = pHead-&gt;next;</span><br><span class="line">        RandomListNode* newcur = pHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(curnode!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newcur-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                curnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curnode-&gt;next = newcur-&gt;next;</span><br><span class="line">            newcur-&gt;next = newcur-&gt;next-&gt;next;</span><br><span class="line">            curnode = curnode-&gt;next;</span><br><span class="line">            newcur = newcur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="26-二叉搜索树与双向链表"><a href="#26-二叉搜索树与双向链表" class="headerlink" title="26.二叉搜索树与双向链表"></a>26.二叉搜索树与双向链表</h1><h2 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的节点，只能调整树中结点指针的指向。</p>
<h2 id="解法一：自己的思路"><a href="#解法一：自己的思路" class="headerlink" title="解法一：自己的思路"></a>解法一：自己的思路</h2><p>后序遍历，递归实现，首先将左子树全部变成有序的，然后将右子树全部变成有序的。由于在返回时，返回的是左右子树的根节点，因此，在将当前根节点与左右子树拼接时，需要移动到左子树的最后一个元素上（最大），与当前根节点的left拼接。对于右子树，要移动到右子树的第一个元素上（最小），与当前根节点的right拼接。</p>
<p>这里有一个需要注意的地方，以下两种声明方式，指针一定要初始化之后才能使用，会使代码结果表现不同，前者超时，后者通过</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* pre,* next;</span><br><span class="line">TreeNode* pre=<span class="literal">nullptr</span>,* next=<span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* node = recurve(pRootOfTree);</span><br><span class="line">        <span class="keyword">while</span>(node-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">recurve</span><span class="params">(TreeNode* pRootOfTree)</span></span>&#123;</span><br><span class="line">        TreeNode* pre=<span class="literal">nullptr</span>,* next=<span class="literal">nullptr</span>; <span class="comment">// 这里，如果没有指定nullptr，则程序会超时！！！</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span>!=pRootOfTree-&gt;left)</span><br><span class="line">            pre = recurve(pRootOfTree-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span>!=pRootOfTree-&gt;right)</span><br><span class="line">            next = recurve(pRootOfTree-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(pre-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">                pre=pre-&gt;right;</span><br><span class="line">            pRootOfTree-&gt;left = pre;</span><br><span class="line">            pre-&gt;right = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(next-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">                next = next-&gt;left;</span><br><span class="line">            pRootOfTree-&gt;right = next;</span><br><span class="line">            next-&gt;left = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二：中序遍历，递归实现"><a href="#解法二：中序遍历，递归实现" class="headerlink" title="解法二：中序遍历，递归实现"></a>解法二：中序遍历，递归实现</h2><p>由于对搜索二叉树来说，中序遍历的结果就是有序的，因此，只需要通过维护一个prenode指针来标记当前节点的上一个节点即可完成双向有序链表。</p>
<p>注意，这里有一个非常关键的点，那就是<code>TreeNode*&amp; prenode</code>，如果少了<code>&amp;</code>引用标识，则结果错误！具体原因看文章关于<code>*&amp;</code>和<code>*</code>的联系和区别。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* prenode = <span class="literal">nullptr</span>;</span><br><span class="line">        recurve(pRootOfTree,prenode);</span><br><span class="line">        <span class="keyword">while</span>(pRootOfTree-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            pRootOfTree = pRootOfTree-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recurve</span><span class="params">(TreeNode* root, TreeNode*&amp; prenode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            recurve(root-&gt;left,prenode);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = prenode;</span><br><span class="line">        <span class="keyword">if</span>(prenode!=<span class="literal">nullptr</span>) prenode-&gt;right = root;</span><br><span class="line">        prenode = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">            recurve(root-&gt;right,prenode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法三：中序遍历，非递归实现"><a href="#解法三：中序遍历，非递归实现" class="headerlink" title="解法三：中序遍历，非递归实现"></a>解法三：中序遍历，非递归实现</h2><p>基于中序遍历的非递归方法，思路与解法二一致。</p>
<p><del><strong>但是这里有个疑问，为什么使用下面的代码会发生段错误。</strong></del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(pRootOfTree-&gt;left!=nullptr)</span><br><span class="line">    pRootOfTree = pRootOfTree-&gt;left;</span><br><span class="line">return pRootOfTree;</span><br><span class="line"></span><br><span class="line">发生段错误的原因主要是因为没有对pRootOfTree进行空指针检查,</span><br><span class="line">就直接使用了该指针的成员变量, 访问了本不存在的内存, 从而造成</span><br><span class="line">了段错误, 修改方法是在程序前加上空指针检查</span><br></pre></td></tr></table></figure></p>
<p>以下代码额外设置了一个指针指向第一个节点，以避免使用上面代码带来的段错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S_node;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="literal">nullptr</span>) <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        TreeNode* P = pRootOfTree;</span><br><span class="line">        <span class="comment">// TreeNode* node = pRootOfTree; 进行了空指针检查, 所以不用再使用这个指针了, 下面也是同理</span></span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(P!=<span class="literal">nullptr</span>||!S_node.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(P!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                S_node.push(P);</span><br><span class="line">                P = P-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!S_node.empty())&#123;</span><br><span class="line">                P = S_node.top();</span><br><span class="line">                P-&gt;left = pre;</span><br><span class="line">                <span class="keyword">if</span>(pre!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pre-&gt;right = P;</span><br><span class="line">                &#125;<span class="comment">//else</span></span><br><span class="line">                    <span class="comment">//node = P;</span></span><br><span class="line">                pre = P;</span><br><span class="line">                S_node.pop();</span><br><span class="line">                P = P-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pRootOfTree-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            pRootOfTree = pRootOfTree-&gt;left;</span><br><span class="line">        <span class="comment">//return node;</span></span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>另一种看起来逻辑性更好的写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="literal">nullptr</span>) <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s_tree;</span><br><span class="line">        TreeNode* cur_node = pRootOfTree;</span><br><span class="line">        TreeNode* head = <span class="literal">nullptr</span>; <span class="comment">//双向链表的头指针</span></span><br><span class="line">        TreeNode* pre_node = <span class="literal">nullptr</span>; <span class="comment">//双向链表的pre指针</span></span><br><span class="line">        <span class="keyword">while</span>(!s_tree.empty() || cur_node!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur_node!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s_tree.push(cur_node);</span><br><span class="line">                cur_node = cur_node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s_tree.empty())&#123;</span><br><span class="line">                cur_node = s_tree.top(); s_tree.pop();</span><br><span class="line">                <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    head = cur_node;</span><br><span class="line">                    pre_node = head;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre_node-&gt;right = cur_node;</span><br><span class="line">                    cur_node-&gt;left = pre_node;</span><br><span class="line">                    pre_node = cur_node;</span><br><span class="line">                &#125;</span><br><span class="line">                cur_node = cur_node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="27-字符串的排列"><a href="#27-字符串的排列" class="headerlink" title="27.字符串的排列"></a>27.字符串的排列</h1><h2 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a，b，c所能排列出来的所有字符串abc，acb，bac，cab和cab。</p>
<h2 id="解法一-递归思路（没想到）："><a href="#解法一-递归思路（没想到）：" class="headerlink" title="解法一: 递归思路（没想到）："></a>解法一: 递归思路（没想到）：</h2><p>将一个字符串看成两个部分，前一部分为首位字母，剩下的是后一部分。通过将首位字母与后一部分的所有字符交换（包括跟自己交换），可以得到第一个位置的所有可能情况。然后，再将剩下的部分看作是一个新的字符串，同样将剩余部分分成两部分，其中，第一部分是剩余部分的首位。如此，可以按照递归进行处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//bool my_sort(string s1, string s2)&#123; return s1&lt;s2;&#125;;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v_string;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">""</span>) <span class="keyword">return</span> v_string;</span><br><span class="line">        PermutationHelp(v_string, <span class="number">0</span>, str);</span><br><span class="line">        <span class="built_in">std</span>::sort(v_string.begin(), v_string.end());</span><br><span class="line">        <span class="keyword">return</span> v_string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PermutationHelp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; v_string, <span class="keyword">int</span> pos, <span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        <span class="comment">/* if(pos == 0 )&#123;</span></span><br><span class="line"><span class="comment">            v_string.push_back(str);</span></span><br><span class="line"><span class="comment">            PermutationHelp(v_string, pos+1, str);</span></span><br><span class="line"><span class="comment">        &#125; \*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里i=pos而不是pos+1的原因是：如果用pos+1,会导致丟解，即自己与自己交换的那种情况没有继续向下递归</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=pos; i&lt;str.length(); i++)&#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(str.at(pos), str.at(i));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">std</span>::count(v_string.begin(), v_string.end(), str) == <span class="number">0</span>) <span class="comment">// 重复检查, 这里需要遍历, 会大大提高程序复杂度</span></span><br><span class="line">                v_string.push_back(str);</span><br><span class="line">            PermutationHelp(v_string, pos+<span class="number">1</span>, str);</span><br><span class="line">            <span class="comment">//std::swap(str.at(pos), str.at(i));</span></span><br><span class="line">            <span class="comment">//能够注释本行的原因是因为上面已经利用count进行了重复检查. 但是实际上, 这是一种不太好的做法, 更好的写法在下面, 无需进行count重复检查</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>更简洁的写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="string">""</span>) <span class="keyword">return</span> res;</span><br><span class="line">        permute_helper(res, <span class="number">0</span>, str);</span><br><span class="line">        <span class="built_in">std</span>::sort(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permute_helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res, <span class="keyword">int</span> pos , <span class="built_in">string</span> &amp;str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == str.size())</span><br><span class="line">            res.push_back(str); <span class="comment">// 注意, 这里是在pos==str.size()才将str放入res中, 这与上面的逻辑看起来好像有些矛盾</span></span><br><span class="line">            <span class="comment">// 实际上, 当pos==str.size()时, 包含了所有可能情况, 即一次交换也没有发生(只与自身交换), 或者交换了某些位置等情况</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i&lt;str.size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str[pos] == str[i] &amp;&amp; pos!=i) <span class="keyword">continue</span>; <span class="comment">//防止重复出现, 如"aa", 则只输出一个 [a,a]</span></span><br><span class="line">                <span class="built_in">std</span>::swap(str[pos], str[i]);</span><br><span class="line">                permute_helper(res, pos+<span class="number">1</span>, str);</span><br><span class="line">                <span class="built_in">std</span>::swap(str[pos], str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-迭代-5"><a href="#解法二-迭代-5" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p>对于已经排列好的n-1个字符, 如果来了第n个字符, 则这个字符可以插入到n-1个字符的n个位置上, 注意控制字符是否重复, 即对于”aaaaa”来说, 如果新来的字符为’a’, 则这个’a’只有一种插法, 因此, 我们做判断: a与位置i(0~3)上的字符如果相等, 则不插入, 故而a只会插入到位置4上.(虽然位置4不存在, 但是插入时是能以超尾位置插入的)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res(<span class="number">1</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">""</span>) &#123;res.pop_back(); <span class="keyword">return</span> res;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.size(); i++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res_tmp(<span class="built_in">std</span>::move(res));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;res_tmp.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;=res_tmp[<span class="number">0</span>].size(); k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(k&lt;res_tmp[<span class="number">0</span>].size() &amp;&amp; str[i] == res_tmp[j][k]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">//跳过重复排列, 例如将a插入a的两端,只选择插一端即可(a插入1位置), 另一端跳过(a插入0位置)</span></span><br><span class="line">                    <span class="built_in">string</span> str_tmp = res_tmp[j];</span><br><span class="line">                    str_tmp.insert(k, <span class="number">1</span>, str[i]);</span><br><span class="line">                    res.push_back(str_tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="28-数组中出现次数超过一半的数字"><a href="#28-数组中出现次数超过一半的数字" class="headerlink" title="28.数组中出现次数超过一半的数字"></a>28.数组中出现次数超过一半的数字</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h2 id="思路一：如果数组是有序的，那么，出现次数超过数组长度一半的数字一定位于数组的中间位置，如果中间位置的数字出现次数小于数组长度的一半，那么就不存在。该方法需要进行排序，所以算法时间复杂度为-nlog-n-。"><a href="#思路一：如果数组是有序的，那么，出现次数超过数组长度一半的数字一定位于数组的中间位置，如果中间位置的数字出现次数小于数组长度的一半，那么就不存在。该方法需要进行排序，所以算法时间复杂度为-nlog-n-。" class="headerlink" title="思路一：如果数组是有序的，那么，出现次数超过数组长度一半的数字一定位于数组的中间位置，如果中间位置的数字出现次数小于数组长度的一半，那么就不存在。该方法需要进行排序，所以算法时间复杂度为 $nlog(n)$ 。"></a>思路一：如果数组是有序的，那么，出现次数超过数组长度一半的数字一定位于数组的中间位置，如果中间位置的数字出现次数小于数组长度的一半，那么就不存在。该方法需要进行排序，所以算法时间复杂度为 $nlog(n)$ 。</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//bool mysort(int a, int b) &#123;return a&lt;b;&#125;</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; counts;</span><br><span class="line">            <span class="built_in">std</span>::sort(numbers.begin(), numbers.end());</span><br><span class="line">            <span class="keyword">int</span> n = <span class="built_in">std</span>::count(numbers.begin(), numbers.end(), numbers.at((<span class="keyword">int</span>)numbers.size()/<span class="number">2</span>));</span><br><span class="line">            <span class="keyword">if</span> (n &gt; numbers.size()/<span class="number">2</span>) <span class="keyword">return</span> numbers.at((<span class="keyword">int</span>)numbers.size()/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="思路二：Patition"><a href="#思路二：Patition" class="headerlink" title="思路二：Patition"></a>思路二：Patition</h2><p>根据快排的思想，由于该数字一定在数组的中间位置，那么可以借助Partition来实现，随机选一个数字进行Partition，如果返回的mid索引最终停在N/2处，那么该索引对应的数字就有可能是答案，此时，只需统计该数字的出现次数即可。</p>
<p><del>该方法的时间复杂度是 $O(n)$ ，因为只会执行一边的Partition，并不会执行另一边.</del></p>
<p>Partition的时间复杂度为 $O(n)$, 找到<code>mid == numbers.size()/2</code>的复杂度为 $O(logn)$, 因此总的时间复杂度为 $O(nlogn)$.</p>
<p>需要注意，具体在代码中看</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mysort</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a&lt;b;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> high = numbers.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = Partition(numbers, low, high);</span><br><span class="line">        <span class="keyword">while</span>(mid != numbers.size()/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid &lt; numbers.size()/<span class="number">2</span>)&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                mid = Partition(numbers, low, high);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                mid = Partition(numbers,low, high);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">std</span>::count(numbers.begin(), numbers.end(), numbers.at(mid)) &gt; numbers.size()/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> numbers.at(mid);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = numbers.at(low);</span><br><span class="line">        <span class="keyword">int</span> mid = low;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; p &lt; numbers.at(high)) high--;</span><br><span class="line">		<span class="comment">//这里如果p用的是&lt;,则需要下面的low++逻辑，否则，会陷入死循环，如果用的是&lt;=，则在返回时，会返回首个元素的坐标</span></span><br><span class="line">            numbers.at(low) = numbers.at(high);</span><br><span class="line">            <span class="keyword">if</span>(low!=high) low++;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; p &gt; numbers.at(low)) low++;</span><br><span class="line">            numbers.at(high) = numbers.at(low);</span><br><span class="line">            <span class="keyword">if</span>(low!=high) high--;</span><br><span class="line">        &#125;</span><br><span class="line">        numbers.at(low) = p;</span><br><span class="line">        <span class="keyword">if</span>(low == high) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="思路三：同增异减"><a href="#思路三：同增异减" class="headerlink" title="思路三：同增异减"></a>思路三：同增异减</h2><p>如果数组中存在这样一个数，那么这个数的出现次数一定大于其他所有数的出现次数总和，因此，设置两个变量，一个number用来存储数组中的第一个数，另一个num置为1,如果下一个数与number数相同，则num加一，否则减1,如果num被减为0,那么number转而存储下一个数，同时将num置为1。</p>
<p>这样，如果存在这个数，最终这个数一定为number，且num大于1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个解法是错误的, 不论怎么处理, 最后都要做count&gt;half的检查, 这个方法能通过牛客的原因是因为牛客官方测例不够, 对于&#123;2,2,3,3,5,5&#125;的情况, 很明显应该输出0, 但是这个方法输出的是5</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number = numbers.at(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = numbers.begin()+<span class="number">1</span>; iter != numbers.end(); iter++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>)&#123; <span class="comment">//这里与下面的区别之一是，一定要放在for训练内部的前面</span></span><br><span class="line">                number = * (iter<span class="number">-1</span>); <span class="comment">//区别之二这里如果使用iter-1,则无须在最后做count检查</span></span><br><span class="line">                num = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(number == * iter) num++;</span><br><span class="line">            <span class="keyword">else</span> num--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num &gt;= <span class="number">1</span>) <span class="keyword">return</span> number; <span class="comment">//这里，num只需要&gt;=1 即可，仔细想一想这是为什么，为啥用了iter-1,就不用检查count。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number = numbers.at(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;numbers.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">                number = numbers[i<span class="number">-1</span>];</span><br><span class="line">                num=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(number == numbers[i]) num++;</span><br><span class="line">            <span class="keyword">else</span> num--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count(numbers.begin(), numbers.end(), number) &gt; numbers.size()/<span class="number">2</span>) <span class="keyword">return</span> number;</span><br><span class="line">        <span class="comment">//由于上面用的是iter，所以最终的num为1的数，只是有可能是我们要得数字，因此，需要进行检查。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="29-最小的K个数"><a href="#29-最小的K个数" class="headerlink" title="29.最小的K个数"></a>29.最小的K个数</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><p>输入n个整数，找出最小的K个数，例如输入4,5,1,6,2,7,3,8，则输出1,2,3,4。</p>
<p>一定要考虑边界情况：</p>
<ul>
<li>数组为空</li>
<li>k大于数组size</li>
<li>k小于0</li>
</ul>
<h2 id="思路一：最直接的想法，就是先对数组排序，然后输出前k个数。复杂度为-nlog-n-n-。-快排"><a href="#思路一：最直接的想法，就是先对数组排序，然后输出前k个数。复杂度为-nlog-n-n-。-快排" class="headerlink" title="思路一：最直接的想法，就是先对数组排序，然后输出前k个数。复杂度为 $nlog(n) + n$ 。 快排"></a>思路一：最直接的想法，就是先对数组排序，然后输出前k个数。复杂度为 $nlog(n) + n$ 。 快排</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; k_input;</span><br><span class="line">        if(k &gt; input.size() || input.size()&lt;=0) return k_input;</span><br><span class="line">        int low = 0;</span><br><span class="line">        int high = input.size()-1;</span><br><span class="line">        quickSort(input, low, high);</span><br><span class="line">        //vector&lt;int&gt; k_input(&amp;input.at(0), &amp;input.at(k-1));</span><br><span class="line">        for(int i=0; i&lt;k; i++) k_input.push_back(input.at(i));</span><br><span class="line">        return k_input;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void quickSort(vector&lt;int&gt;&amp; input, int low, int high)&#123;</span><br><span class="line">        int mid = Partition(input, low, high);</span><br><span class="line"></span><br><span class="line">        if(mid&lt;high)    quickSort(input, mid+1, high);</span><br><span class="line">        if(mid&gt;low)    quickSort(input, low, mid-1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int Partition(vector&lt;int&gt;&amp; input, int low, int high)&#123;</span><br><span class="line">        int p = input[low];</span><br><span class="line">        while(low&lt;high)&#123;</span><br><span class="line">            while(low&lt;high &amp;&amp; p&lt;=input[high]) high--;</span><br><span class="line">            input[low] = input[high];</span><br><span class="line">            while(low&lt;high &amp;&amp; p&gt;=input[low]) low++;</span><br><span class="line">            input[high] = input[low];</span><br><span class="line">        &#125;</span><br><span class="line">        input[low] = p;</span><br><span class="line">        return low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="思路二：遍历整个数组，将当前元素与k-input数组进行比较，按照顺序插入，并且超出k的部分删除，最终直接返回k-input。时间复杂度-O-nk-。（该思想与冒泡排序思想类似）。"><a href="#思路二：遍历整个数组，将当前元素与k-input数组进行比较，按照顺序插入，并且超出k的部分删除，最终直接返回k-input。时间复杂度-O-nk-。（该思想与冒泡排序思想类似）。" class="headerlink" title="思路二：遍历整个数组，将当前元素与k_input数组进行比较，按照顺序插入，并且超出k的部分删除，最终直接返回k_input。时间复杂度 $O(nk)$ 。（该思想与冒泡排序思想类似）。"></a>思路二：遍历整个数组，将当前元素与k_input数组进行比较，按照顺序插入，并且超出k的部分删除，最终直接返回k_input。时间复杂度 $O(nk)$ 。（该思想与冒泡排序思想类似）。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; k_input;</span><br><span class="line">        if(k&gt;input.size() || input.size()&lt;=0) return k_input;</span><br><span class="line">        k_input.push_back(input.at(0));</span><br><span class="line">        for(auto iter = input.begin()+1; iter!=input.end(); iter++)&#123;</span><br><span class="line">            for(int i =0 ;i&lt;k; i++)&#123;</span><br><span class="line">                if(i == k_input.size())&#123;</span><br><span class="line">                    k_input.push_back(*iter);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;else if(*iter &lt; k_input.at(i))&#123;</span><br><span class="line">                    k_input.insert(k_input.begin()+i, *iter);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(k_input.size() &gt; k) k_input.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return k_input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-大顶堆"><a href="#解法三-大顶堆" class="headerlink" title="解法三: 大顶堆"></a>解法三: 大顶堆</h2><p>遍历数组, 维护一个大顶堆, 每遇到一个比堆顶小的数, 就将其插入大顶堆 (如果是找最大的k个数, 就用小顶堆)</p>
<p>时间复杂度: $O(nlogk)$<br>空间复杂度: $O(k)$</p>
<p>借助<code>priority_queue</code>数据结构<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span> || k&gt;input.size()) <span class="keyword">return</span> res; <span class="comment">// 边界条件检查, 是否会出现段错误或输出结果错误</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;input.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;k) q.push(input[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(input[i] &lt; q.top())&#123;</span><br><span class="line">                q.pop(); q.push(input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            res.push_back(q.top());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>利用数组实现堆</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec_heap, <span class="keyword">int</span> index, <span class="keyword">int</span> heap_size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max=index;</span><br><span class="line">        <span class="keyword">int</span> left=index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = index*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;heap_size &amp;&amp; vec_heap[max] &lt; vec_heap[left])&#123;</span><br><span class="line">            <span class="comment">//int temp = max; // 无需交换max和left, 只需记录max的值即可, 下面的right同理</span></span><br><span class="line">            max = left;</span><br><span class="line">            <span class="comment">//left = temp;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;heap_size &amp;&amp; vec_heap[max] &lt; vec_heap[right])&#123;</span><br><span class="line">            <span class="comment">//int temp = max;</span></span><br><span class="line">            max = right;</span><br><span class="line">            <span class="comment">//right = temp;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index != max)&#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(vec_heap[index], vec_heap[max]);</span><br><span class="line">            heapify(vec_heap, max, heap_size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span> || k &gt; input.size()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;k;i++)&#123;</span><br><span class="line">            res.push_back(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>; i&gt;=<span class="number">0</span>;i--)&#123; <span class="comment">//初始化堆</span></span><br><span class="line">            heapify(res, i, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; input.size(); i++)&#123; <span class="comment">//i要从k开始, 因为k之前的已经是堆了</span></span><br><span class="line">            <span class="keyword">if</span>(input[i] &lt; res[<span class="number">0</span>])&#123;</span><br><span class="line">                res[<span class="number">0</span>] = input[i];</span><br><span class="line">                heapify(res, <span class="number">0</span>, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = res.size()<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(res[<span class="number">0</span>], res[i]);</span><br><span class="line">            heapify(res, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>另一种写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec_heap, <span class="keyword">int</span> index, <span class="keyword">int</span> heap_size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = index;</span><br><span class="line">        <span class="keyword">int</span> left = index*<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = index*<span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; heap_size &amp;&amp; vec_heap[left] &gt; vec_heap[max])</span><br><span class="line">            max=left;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; heap_size &amp;&amp; vec_heap[right] &gt; vec_heap[max])</span><br><span class="line">            max=right;</span><br><span class="line">        <span class="keyword">if</span>(max!=index)&#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(vec_heap[max], vec_heap[index]);</span><br><span class="line">            heapify(vec_heap, max, heap_size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span> || k&gt;input.size()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            heapify(input, i,k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k; i&lt;input.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(input[i] &lt; input[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="comment">//std::swap(input[i], input[0]);</span></span><br><span class="line">                input[<span class="number">0</span>] = input[i];</span><br><span class="line">                heapify(input, <span class="number">0</span>, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            res.push_back(input[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">std</span>::swap(input[<span class="number">0</span>], input[i]);</span><br><span class="line">            heapify(input, <span class="number">0</span>, i); <span class="comment">// i变小, 所以从k-1开始</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法四-快速选择算法"><a href="#解法四-快速选择算法" class="headerlink" title="解法四: 快速选择算法"></a>解法四: 快速选择算法</h2><p><strong>时间复杂度:</strong> 平均为 $O(n)$</p>
<p>复杂度分析: 每次都会扔掉一半, 所以每次进行检查的元素个数为之前的一半, 所有时间复杂度大致为:</p>
<script type="math/tex; mode=display">T(n) = n + n/2 + n/8 + ... + (n/2)^k = n*(1-2^{-k})/(1-2^{-1}) = 2n</script><p>也就是说, 只要枢纽元素的选择使得两边的元素数量尽可能均衡, 就可以得到 $O(n)$ 的时间复杂度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span> || k&gt;input.size()) <span class="keyword">return</span> res;</span><br><span class="line">        quick_select(input, <span class="number">0</span>, input.size()<span class="number">-1</span>, k);</span><br><span class="line">        <span class="comment">//运行完 quick_select 以后, k之前的元素都比k位置上的元素小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">            res.push_back(input[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_select</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> P = vec[low]</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P&lt;=vec[high]) high--;</span><br><span class="line">            vec[low] = vec[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P&gt;=vec[low]) low++;</span><br><span class="line">            vec[high] = vec[low];</span><br><span class="line">        &#125;</span><br><span class="line">        vec[low] = P; <span class="comment">//此时, low所处位置为枢纽元P, low之前的都小于P, low之后的都大于P</span></span><br><span class="line">        <span class="keyword">if</span>(low == k<span class="number">-1</span>) <span class="keyword">return</span>; <span class="comment">//如果low所处位刚好为k-1, 则从这之前的k个元素一定是最小的(包括vec[low]自身)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( k &lt; low) quick_select(vec, <span class="number">0</span>, low, k);</span><br><span class="line">        <span class="keyword">else</span> quick_select(vec, low+<span class="number">1</span>, high, k);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="问题扩展-1"><a href="#问题扩展-1" class="headerlink" title="问题扩展 1"></a>问题扩展 1</h2><p>输入是两个整数数组, 他们任意两个数的和有可以组成一个数组, 求这个和中的前k个数</p>
<p><strong>分析:</strong></p>
<ol>
<li>假设两个整数数组为A和B, 各有N个元素, 任意两个数的和组成的数组C就有 $N^2$ 个, 那么可以把这些和看成N个有序数列, 由此, 问题就转变成了在这 $N^2$ 个有序数列里, 找到前k个最小的元素.<ul>
<li>A[1]+B[1] &lt;= A[1]+B[2] &lt;= A[1]+B[3] &lt;= …</li>
<li>A[2]+B[1] &lt;= A[2]+B[2] &lt;= A[2]+B[3] &lt;= …</li>
<li>…</li>
<li>A[N]+B[1] &lt;= A[N]+B[2] &lt;= A[N]+B[3] &lt;= …</li>
</ul>
</li>
</ol>
<h2 id="问题扩展-2"><a href="#问题扩展-2" class="headerlink" title="问题扩展 2"></a>问题扩展 2</h2><p>有两个序列A和B都按照升序排列, 对于 1&lt;=i,j&lt;=k, 求k个最小的(ai+bj), 要求算法尽量高效.</p>
<h1 id="30-连续子数组的最大和"><a href="#30-连续子数组的最大和" class="headerlink" title="30.连续子数组的最大和"></a>30.连续子数组的最大和</h1><h2 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h2><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p>
<h2 id="解法一：穷举"><a href="#解法一：穷举" class="headerlink" title="解法一：穷举"></a>解法一：穷举</h2><p>穷举遍历，时间复杂度 $O(n^2)$ 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">        int max=array.at(0);</span><br><span class="line">        for(auto iter=array.begin(); iter!=array.end(); iter++)&#123;</span><br><span class="line">            //if(*iter &gt; 0)&#123;</span><br><span class="line">                int temp = 0;</span><br><span class="line">                for(auto it = iter; it!=array.end(); it++)&#123;</span><br><span class="line">                    temp += *it;</span><br><span class="line">                    if(temp &gt; max)</span><br><span class="line">                        max = temp;</span><br><span class="line">                //&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另一种写法(感觉更好理解些)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> max_sum = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cur_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : <span class="built_in">array</span>)&#123;</span><br><span class="line">            cur_sum += x;</span><br><span class="line">            <span class="keyword">if</span>(cur_sum &gt; max_sum) <span class="comment">// 更新max_sum</span></span><br><span class="line">                max_sum = cur_sum;</span><br><span class="line">            <span class="keyword">if</span>(cur_sum &lt; <span class="number">0</span>) <span class="comment">// 如果当前和为负, 则重置cur_sum</span></span><br><span class="line">                cur_sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二：最优-两个变量记录sum"><a href="#解法二：最优-两个变量记录sum" class="headerlink" title="解法二：最优-两个变量记录sum"></a>解法二：最优-两个变量记录sum</h2><p>$O(n)$ 的方法，根据数组性质，设置两个变量，一个记录当前的最大值，一个记录当前的子序列之和。首先，如果当前子序列之和为负，那么就是说，从当前位置开始的子序列，比从之前位置开始的子序列大，那么就可以不考虑从之前位置开始的子序列，之前累计的和也被抛弃。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_sum = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cur_sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">array</span>.size(); i++)&#123;</span><br><span class="line">            cur_sum += <span class="built_in">array</span>[i];</span><br><span class="line">            <span class="keyword">if</span>(cur_sum &gt; max_sum) max_sum = cur_sum;</span><br><span class="line">            <span class="keyword">if</span>(cur_sum &lt; <span class="number">0</span>) cur_sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三：dp"><a href="#解法三：dp" class="headerlink" title="解法三：dp"></a>解法三：dp</h2><p>动态规划。与解法二的思路异曲同工，核心思想可有下述公式表示。 $f(i)代表以第i个数字结尾的子数组的连续最大和$</p>
<script type="math/tex; mode=display">f(x)=
\begin{cases}
pData[i]& {i=0 或者f(i-1)\le 0} \\
f(i-1)+pData[i]& {i\ne 0 并且 f(i-1) > 0}
\end{cases}</script><p>上面的形式是递归的，通常情况下都用递归的方式来分析动态规划问题，但最终都会基于循环去编码。  上述公式对应的非递归形式就是思路二的代码。</p>
<p>递归写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">        int max = array.at(0);</span><br><span class="line">        f(array, array.size()-1, max);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int f(vector&lt;int&gt;&amp; array, int i, int&amp; max)&#123;</span><br><span class="line">        if(i==0) return array.at(0);</span><br><span class="line">        int f1  = f(array, i-1, max);</span><br><span class="line">        if(f1&lt;0)</span><br><span class="line">            f1 = array.at(i);</span><br><span class="line">        else&#123;</span><br><span class="line">            f1 = f1+ array.at(i);</span><br><span class="line">        &#125;</span><br><span class="line">        if(f1&gt; max) max =f1;</span><br><span class="line">        return f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="31-整数中1出现的次数（从1到整数n中1出现的次数）"><a href="#31-整数中1出现的次数（从1到整数n中1出现的次数）" class="headerlink" title="31.整数中1出现的次数（从1到整数n中1出现的次数）"></a>31.整数中1出现的次数（从1到整数n中1出现的次数）</h1><h2 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h2><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p>
<h2 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h2><p><strong>时间复杂度:</strong> $O(nm)$, m为数字的长度</p>
<p>直接借助C++函数，先将int转换成string，然后count计算string里面‘1’的个数。（这种方法可能面试不会满意，可以提一下，不过肯定有其他方法）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count_1 = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> str = <span class="built_in">std</span>::to_string(i);</span><br><span class="line">            count_1 += <span class="built_in">std</span>::count(str.begin(), str.end(), <span class="string">'1'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count_1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h2><p>对每个数字进行除和求余的运算，得到每个数字中1的个数，然后将个数相加。 该方法的复杂度为 $O(nlogn)$ ，该种思想过于直接，时间复杂度较高，属于次等方案。（注意：这里的log底数按理说是10 ，但说大O记法是不考虑常数的，所以直接表示成log就可以）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count =<span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span> ;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> i1 = has1(i);</span><br><span class="line">            <span class="keyword">if</span>(i1)</span><br><span class="line">                count+=i1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">has1</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num%<span class="number">10</span> == <span class="number">1</span>)</span><br><span class="line">                count++;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h2><p><strong>时间复杂度:</strong>  $O(logn)$</p>
<p>设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上为1的情况有多少种进行分析</p>
<p>根据设定的整数位置，对n进行分割，分为两部分，高位n/i，低位n%i</p>
<p>当i表示百位，且百位对应的数&gt;=2时,如n=31456,i=100，则a=314,b=56，此时百位为1的情况有a/10+1=32（最高两位0~31，百位为1,共32种），每一种都包含100个连续的点，即共有(a%10+1) * 100种情况百位为1</p>
<p>当i表示百位，且百位对应的数为1时，如n=31156， i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)种情况是包含100个连续点，当最高两位为31（即a=311），本次只对应部分情况00~56，共b+1种，所有点加起来共有（a%10*100）+(b+1)种情况可以是百位为1</p>
<p>当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的情况有a/10=31种（最高两位0~30）</p>
<p>综合以上三种情况，当百位对应0或2时，有(a+8)/10次包含所有100个点，当百位为1时，即(a%10==1)为真时，另外需要增加部分情况b+1种</p>
<p>之所以补8，是因为当百位为0 或者 1 时，则a/10==(a+8)/10，当百位&gt;=2，补8会产生进位位，效果等同于(a/10+1)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i&lt;=n; i*=<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = n/i;</span><br><span class="line">            <span class="keyword">int</span> b = n%i;</span><br><span class="line">            count+=(a+<span class="number">8</span>)/<span class="number">10</span>*i+(<span class="keyword">int</span>)(a%<span class="number">10</span>==<span class="number">1</span>)*(b+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>这种方法是一种通用解法, 可以用来求解<code>整数0~n中x的出现次数</code>, 其中, x 代表1~9中(0的情况貌似也差不多?)的任意一个数, 通用写法如下</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n ;i = i*<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = n/i;</span><br><span class="line">            <span class="keyword">int</span> b = n%i;</span><br><span class="line">            count += (a+(<span class="number">10</span>-x<span class="number">-1</span>))/<span class="number">10</span> * i + (<span class="keyword">int</span>)(a%<span class="number">10</span>==x) * (b+<span class="number">1</span>); <span class="comment">//在这里根据x的值, 可以求得不同情况下的解, 例如, 若要求8的出现次数, 则为:count += (a+1)/10 * i + (int)(a%10==8) * (b+1);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法四："><a href="#解法四：" class="headerlink" title="解法四："></a>解法四：</h2><p>剑指offer的递归方法，没看懂，感觉好像有错误？</p>
<h1 id="32-把数组排成最小的数"><a href="#32-把数组排成最小的数" class="headerlink" title="32.把数组排成最小的数"></a>32.把数组排成最小的数</h1><h2 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h2 id="难点："><a href="#难点：" class="headerlink" title="难点："></a>难点：</h2><ol>
<li>找出一个新的排序规则，同时要证明这个排序规则是有效的</li>
<li>看到将两个int整数拼接在一起，就应该想到大数问题</li>
</ol>
<h2 id="解法一：-1"><a href="#解法一：-1" class="headerlink" title="解法一："></a>解法一：</h2><p>主要考虑如何制定一个合理的判断规则：</p>
<p><strong>比较两个字符串s1, s2大小的时候，先将它们拼接起来，比较s1+s2,和s2+s1那个大，如果s1+s2大，那说明s2应该放前面，所以按这个规则，s2就应该排在s1前面。</strong></p>
<p>基于上面的规则，首先将<code>vector&lt;int&gt;</code>转换成对应的<code>vector&lt;string&gt;</code>，然后直接利用快排进行排序，最后将排好序的字符串向量拼接输出。</p>
<p>时间复杂度为主要在排序，因此为 $O(nlogn)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str_numbers;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=numbers.begin(); it!=numbers.end(); it++)&#123;</span><br><span class="line">            str_numbers.push_back(<span class="built_in">std</span>::to_string(*it));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = numbers.size()<span class="number">-1</span>;</span><br><span class="line">        quickSort(str_numbers, low, high);</span><br><span class="line">        <span class="built_in">string</span> s=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = str_numbers.begin(); it != str_numbers.end(); it++)&#123;</span><br><span class="line">            s+=*it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; str_numbers, <span class="keyword">int</span> low , <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = Partition(str_numbers, low, high);</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;high) quickSort(str_numbers,mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">if</span>(mid&gt;low) quickSort(str_numbers, low, mid<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; str_numbers, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> p = str_numbers.at(low);</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="built_in">string</span> s1= p + str_numbers.at(high);</span><br><span class="line">            <span class="built_in">string</span> s2= str_numbers.at(high) + p;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; s1.compare(s2) &lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                high--;</span><br><span class="line">                s1 = p + str_numbers.at(high);</span><br><span class="line">                s2 = str_numbers.at(high) + p;</span><br><span class="line">            &#125;</span><br><span class="line">            str_numbers.at(low) = str_numbers.at(high);</span><br><span class="line"></span><br><span class="line">            s1 = p + str_numbers.at(low);</span><br><span class="line">            s2 = str_numbers.at(low) + p;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; s1.compare(s2) &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                low++;</span><br><span class="line">                s1 = p + str_numbers.at(low);</span><br><span class="line">                s2 = str_numbers.at(low) + p;</span><br><span class="line">            &#125;</span><br><span class="line">            str_numbers.at(high) = str_numbers.at(low);</span><br><span class="line">        &#125;</span><br><span class="line">        str_numbers.at(low) = p;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>更整洁的写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> sa = <span class="built_in">std</span>::to_string(a);</span><br><span class="line">        <span class="built_in">string</span> sb = <span class="built_in">std</span>::to_string(b);</span><br><span class="line">        <span class="keyword">return</span> sa+sb &lt;= sb+sa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>; <span class="comment">//!!!!少了这句话会产生段错误</span></span><br><span class="line">        quick_sort(numbers, <span class="number">0</span>, numbers.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers)</span><br><span class="line">            res += <span class="built_in">std</span>::to_string(num);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;numbers, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> P = numbers[low];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; cmp(P, numbers[high])) high--;</span><br><span class="line">            numbers[low] = numbers[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; cmp(numbers[low], P)) low++;</span><br><span class="line">            numbers[high] = numbers[low];</span><br><span class="line">        &#125;</span><br><span class="line">        numbers[low] = P;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;numbers, <span class="keyword">int</span> low , <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = partition(numbers, low, high);</span><br><span class="line">        <span class="keyword">if</span>(low&lt;mid) quick_sort(numbers, low, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;high) quick_sort(numbers, mid+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>用C++的内置排序函数:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">            <span class="built_in">string</span> sa = <span class="built_in">std</span>::to_string(a);</span><br><span class="line">            <span class="built_in">string</span> sb = <span class="built_in">std</span>::to_string(b);</span><br><span class="line">            <span class="keyword">return</span> sa+sb &lt; sb+sa;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;cmp;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(numbers.begin(), numbers.end(), cmp);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : numbers)</span><br><span class="line">            res += <span class="built_in">std</span>::to_string(num);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="33-丑数"><a href="#33-丑数" class="headerlink" title="33.丑数"></a>33.丑数</h1><h2 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h2><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数</p>
<h2 id="解法一：穷举判断"><a href="#解法一：穷举判断" class="headerlink" title="解法一：穷举判断"></a>解法一：穷举判断</h2><p>最简单的方法，就是对所有整数进行判断，该方法很容易超时</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ugly=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;index)&#123;</span><br><span class="line">            <span class="keyword">if</span>(IsUgly(num))&#123;</span><br><span class="line">                i++;</span><br><span class="line">                ugly = num;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsUgly</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            num /=<span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">            num /= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">5</span>==<span class="number">0</span>)</span><br><span class="line">            num /= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二：根据丑数性质构造丑数"><a href="#解法二：根据丑数性质构造丑数" class="headerlink" title="解法二：根据丑数性质构造丑数"></a>解法二：根据丑数性质构造丑数</h2><p><strong>时间复杂度:</strong> $O(n^2)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>用空间换时间，用一个数组将之前的丑数都存起来，然后，在判断下一个丑数时，不用对逐个整数判断，而只是与丑数和2,3,5的乘积进行判断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 使用指针时，一定要千万注意，指针会改变指向地址的值，使得其他指向该地址的指针，其指向的值也跟着变！</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>* UglyArray = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        UglyArray[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ;i &lt; index; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> *Ugly2 = UglyArray;</span><br><span class="line">            <span class="keyword">int</span> *Ugly3 = UglyArray;</span><br><span class="line">            <span class="keyword">int</span> *Ugly5 = UglyArray;</span><br><span class="line">            <span class="keyword">while</span>(*Ugly2 * <span class="number">2</span> &lt;= UglyArray[i<span class="number">-1</span>])</span><br><span class="line">                Ugly2++;</span><br><span class="line">            <span class="keyword">while</span>(*Ugly3 * <span class="number">3</span> &lt;= UglyArray[i<span class="number">-1</span>])</span><br><span class="line">                Ugly3++;</span><br><span class="line">            <span class="keyword">while</span>(*Ugly5 * <span class="number">5</span>&lt;= UglyArray[i<span class="number">-1</span>])</span><br><span class="line">                Ugly5++;</span><br><span class="line">            UglyArray[i] = Min(*Ugly2 *<span class="number">2</span>, *Ugly3 *<span class="number">3</span>, *Ugly5 *<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = UglyArray[index<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">delete</span>[] UglyArray;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b,<span class="keyword">const</span> <span class="keyword">int</span>&amp; c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = a&lt;b? a:b;</span><br><span class="line">        <span class="keyword">return</span> x&lt;c? x:c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//*</span></span><br></pre></td></tr></table></figure>
<h2 id="解法三-最优"><a href="#解法三-最优" class="headerlink" title="解法三: 最优"></a>解法三: 最优</h2><p>解法二的思路是正确的, 但是代码的实习上有重复计算, 例如, 最开始丑数集合为 {1}, 经过三次循环后, 丑数集合为 {1, 2, 3, 5}, 此时, 当进行第四次循环时,  会重复计算 1×2, 1×3, 1×5. 根据丑数的定义, 从 1 开始, 可以得到 2,3,5 这三个丑数, 然后从 2,3,5 开始(此时不用管1了), 可以得到 4,6,10,6,9,15,10,15,25 九个丑数, 根据这个思路, 我们可以指定三个变量来指示当前应该与2,3,5相乘的丑数, 而不是从第一个丑数开始遍历.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ugly_numbers(index);</span><br><span class="line">        ugly_numbers[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t2=<span class="number">0</span>, t3=<span class="number">0</span>, t5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;index; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ugly_num = <span class="built_in">std</span>::min( ugly_numbers[t2]*<span class="number">2</span>, <span class="built_in">std</span>::min(ugly_numbers[t3]*<span class="number">3</span>, ugly_numbers[t5]*<span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span>(ugly_num == ugly_numbers[t2]*<span class="number">2</span>) t2++;</span><br><span class="line">            <span class="comment">// 因为新增的最小丑数为 t2指示的丑数与2相乘, 所以t2之前的数都不可能再与2相乘组成新的丑数, 所以无需检查t2之前的数</span></span><br><span class="line">            <span class="keyword">if</span>(ugly_num == ugly_numbers[t3]*<span class="number">3</span>) t3++;</span><br><span class="line">            <span class="comment">// 注意, 这里没有用else if 的原因是, 可能会出现重复的情况, 对于这种情况, 重复的指示器都要++, 避免将重复的丑数添加到数组中</span></span><br><span class="line">            <span class="keyword">if</span>(ugly_num == ugly_numbers[t5]*<span class="number">5</span>) t5++;</span><br><span class="line">            ugly_numbers[i] = ugly_num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ugly_numbers[index<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="34-第一个只出现一次的字符"><a href="#34-第一个只出现一次的字符" class="headerlink" title="34.第一个只出现一次的字符"></a>34.第一个只出现一次的字符</h1><h2 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）</p>
<h2 id="解法一（自想）"><a href="#解法一（自想）" class="headerlink" title="解法一（自想）"></a>解法一（自想）</h2><p>每遇到一个字符，判断其是否是第一次出现，如果是则将它存在一个vector once里面，如果不是，则判断该字符是否在另一个vector more里面，如果没在，则该once中的该字符转移到mul里面，接着判断下一个字符。最终，输出once里面的首个元素。</p>
<p>该方法时间复杂度为 $O(n^2)$，并不令人满意。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; once_char;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; mul_char;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> isfirst = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it = once_char.begin(); it!=once_char.end(); it++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str[*it] == str[i])&#123;</span><br><span class="line">                    isfirst = <span class="literal">false</span>;</span><br><span class="line">                    once_char.erase(it);</span><br><span class="line">                    mul_char.push_back(str[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isfirst)&#123;</span><br><span class="line">                <span class="keyword">auto</span> mul_it = find(mul_char.begin(), mul_char.end(), str[i]);</span><br><span class="line">                <span class="keyword">if</span>(mul_it != mul_char.end())</span><br><span class="line">                    isfirst = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isfirst)&#123;</span><br><span class="line">                once_char.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(once_char.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> once_char.front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二：牛客"><a href="#解法二：牛客" class="headerlink" title="解法二：牛客"></a>解法二：牛客</h2><p>借助哈希表，时间复杂度为 $O(n)$。哈希表的构造可以用256大小的数组实现，字符对应的int值可作为哈希表的索引，表内的内容存储了该字符出现的次数。总共需要遍历两次字符串，第一次更新数组内字符出现的次数，第二次找到首个出现次数为1的字符。空间复杂度为 $O(1)$ （256是常数）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash_map[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">            hash_map[i] = <span class="number">0</span>; <span class="comment">//若少了初始化数组，则通不过，经过验证，数组默认内部不是0,而是随机数？</span></span><br><span class="line">       <span class="comment">//有一种更标准初始化为0的方法，无需显式while循环：int hash_map[256]= &#123;0&#125;;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class="line">            hash_map[<span class="keyword">int</span>(str[i])]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash_map[<span class="keyword">int</span>(str[i])] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="35-数组中的逆序对"><a href="#35-数组中的逆序对" class="headerlink" title="35.数组中的逆序对"></a>35.数组中的逆序对</h1><h2 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007<br>输入描述:</p>
<p>题目保证输入的数组中没有的相同的数字</p>
<p>数据范围：</p>
<pre><code>对于%50的数据,size&lt;=10^4

对于%75的数据,size&lt;=10^5

对于%100的数据,size&lt;=2*10^5
</code></pre><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>仔细思考，这道题的P的数量会非常大，对于长度为n的数组，其P值最大可为 $\frac{n(n-1)}{2}$ 个。根据体重给出的数据，n最大可为 $2\times 10^5$ ，因此，P最大为 $\frac{2\times 10^5\times(2\times10^5 -1)}{2} \approx 2\times 10^{10}$,因此，使用int类型的数据时，有可能超过限制。所以，要使用long！( int类型数据范围为-21 4748 3648 到 21 4748 3647, 数量级在 $10^9$ 左右)</p>
<h2 id="解法一（自）"><a href="#解法一（自）" class="headerlink" title="解法一（自）"></a>解法一（自）</h2><p>  暴力求解，时间复杂度 $O(n^2)$ ，这样做肯定不行</p>
<h2 id="解法二（剑指）-归并排序-递归实现"><a href="#解法二（剑指）-归并排序-递归实现" class="headerlink" title="解法二（剑指）: 归并排序, 递归实现"></a>解法二（剑指）: 归并排序, 递归实现</h2><p>将数组中的元素进行归并排序, 排序的时候, 如果前面子数组的元素大于后面的元素, 那么可以组成的逆序对的数量就是后面元素剩余的元素数量(两个子数组各自都已经排好序).</p>
<h3 id="这里需要注意的几点："><a href="#这里需要注意的几点：" class="headerlink" title="这里需要注意的几点："></a>这里需要注意的几点：</h3><ol>
<li>初始化是，将data数据复制到temp中，然后在递归时，将data和temp数组交换传递，可以不用在数组融合时，将temp中的数据复制到data中， 减少计算次数</li>
<li>数组融合时使用的while循环，条件均为 $&lt;=$ 或  $&gt;=$。</li>
<li>每次得到P的一部分时，都进行取余数，可保证P的值不会过大。（但还是要用long型整数）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (data.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp= data;</span><br><span class="line">      <span class="comment">//int P=0;</span></span><br><span class="line">      <span class="keyword">long</span> P = mergeSort(data,temp, <span class="number">0</span>, data.size()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> P%<span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (last + first)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">long</span> inv1=<span class="number">0</span>,inv2=<span class="number">0</span>,inv=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(first&lt; last)&#123;</span><br><span class="line">        <span class="comment">//这里，首先temp和data相同，因此对于mergeSort来说，可以顺序颠倒</span></span><br><span class="line">        <span class="comment">//此时相当于把temp当前真实数组，而data当作了缓存空间</span></span><br><span class="line">        <span class="comment">//经过mergeSort后，data里面数据就是分别排好序的</span></span><br><span class="line">        <span class="comment">//所以传向mergeArray时，要把data放前面，把temp放后面</span></span><br><span class="line">          inv1 = mergeSort(temp, data, first, mid);  <span class="comment">//必须temp在前, 因为temp是已经将子数组排序过的</span></span><br><span class="line">          inv2 = mergeSort(temp, data, mid+<span class="number">1</span>, last);</span><br><span class="line">          inv = mergeArray(data, temp, first, mid, mid+<span class="number">1</span>, last); <span class="comment">//此处data在前的原因是经过mergeSort以后, data变成了排序号的.</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//上面这种写法的可读性不好, 如果在mergArray函数里面, 使data = temp , 就能写出下面这种可读性较好的形式(但是由于多了赋值操作, 在牛客上会超时). 但是使用for循环只复制需要复制的部分, 就不会超时</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          inv1 = mergeSort(data, temp, first, mid);</span></span><br><span class="line"><span class="comment">          inv2 = mergeSort(data, temp, mid+1, last);</span></span><br><span class="line"><span class="comment">          inv = mergeArray(data, temp, first, mid, mid+1, last);</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (inv1+inv2+inv)%<span class="number">1000000007</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">mergeArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> first1,<span class="keyword">int</span> last1,<span class="keyword">int</span> first2,<span class="keyword">int</span> last2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">long</span> <span class="keyword">int</span> inv = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> t = last2;</span><br><span class="line">      <span class="keyword">int</span> i = last1;</span><br><span class="line">      <span class="keyword">int</span> j = last2;</span><br><span class="line">      <span class="keyword">while</span>(i&gt;=first1 &amp;&amp; j&gt;=first2)&#123;</span><br><span class="line">          <span class="keyword">if</span>(data.at(i) &gt; data.at(j))&#123;</span><br><span class="line">              temp.at(t) = data.at(i);</span><br><span class="line">              inv += j-first2+<span class="number">1</span>;;</span><br><span class="line">              i--;</span><br><span class="line">              t--;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              temp.at(t) = data.at(j);</span><br><span class="line">              j--;</span><br><span class="line">              t--;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(i&gt;=first1)&#123;</span><br><span class="line">          temp.at(t) = data.at(i);</span><br><span class="line">          t--;</span><br><span class="line">          i--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(j&gt;=first2)&#123;</span><br><span class="line">          temp.at(t) = data.at(j);</span><br><span class="line">          j--;</span><br><span class="line">          t--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// data=temp;  //这个赋值操作会使得代码整体的可读性较好, 但是可能会超时</span></span><br><span class="line">      <span class="comment">/*for(int i=first1; i&lt;=last2; i++)</span></span><br><span class="line"><span class="comment">            data[i] = temp[i]; //这种复制每次只会复制一部分, 故而没有超时</span></span><br><span class="line"><span class="comment">      */</span>  </span><br><span class="line">      <span class="keyword">return</span> inv%<span class="number">1000000007</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三（剑指）-归并排序-迭代实现"><a href="#解法三（剑指）-归并排序-迭代实现" class="headerlink" title="解法三（剑指）: 归并排序, 迭代实现"></a>解法三（剑指）: 归并排序, 迭代实现</h2><h1 id="36-两个链表的第一个公共节点"><a href="#36-两个链表的第一个公共节点" class="headerlink" title="36.两个链表的第一个公共节点"></a>36.两个链表的第一个公共节点</h1><h2 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个链表，找出它们的第一个公共结点。</p>
<h2 id="解法一：栈"><a href="#解法一：栈" class="headerlink" title="解法一：栈"></a>解法一：栈</h2><p><strong>时间复杂度:</strong> $O(m+n)$, 遍历两个链表<br><strong>空间复杂度:</strong> $O(m+n)$, 两个栈</p>
<p>分析公共子节点的特点，首先，是单向链表，因此，从第一个公共子节点开始，后面的都是一样的，所以最好是能从链表的最后一项还是比较。但由于是单向链表，因此只能从头访问，从能访问最后的节点。 <strong>就像是先进先出一样</strong>  因此，考虑用两个辅助栈来帮助实现～</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; s1;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; s2;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* cur = pHead1; cur!=<span class="literal">nullptr</span>; cur = cur-&gt;next)&#123;</span><br><span class="line">            s1.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* cur = pHead2; cur!=<span class="literal">nullptr</span>; cur = cur-&gt;next)&#123;</span><br><span class="line">            s2.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* firstCN = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s1.empty() &amp;&amp; !s2.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.top() == s2.top())&#123;</span><br><span class="line">                firstCN = s1.top();</span><br><span class="line">                s1.pop();</span><br><span class="line">                s2.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> firstCN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="解法二-常数空间复杂度"><a href="#解法二-常数空间复杂度" class="headerlink" title="解法二: 常数空间复杂度"></a>解法二: 常数空间复杂度</h1><p><strong>时间复杂度:</strong> $O(m+n)$, 遍历两次<br><strong>空间复杂度:</strong> $O(1)$, 不使用额外空间</p>
<p>首先遍历得到两个链表的长度, 然后先让长链表前进长度差个节点, 接着两个链表共同向前遍历, 当相遇时即为第一个公共节点.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="literal">nullptr</span> || headB==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> lenA = <span class="number">0</span>;</span><br><span class="line">        ListNode *curA = headA;</span><br><span class="line">        <span class="keyword">while</span>(curA !=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lenB = <span class="number">0</span>;</span><br><span class="line">        ListNode *curB = headB;</span><br><span class="line">        <span class="keyword">while</span>(curB != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lenA &gt; lenB)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = lenA-lenB;</span><br><span class="line">            curA = headA;</span><br><span class="line">            <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">                curA = curA-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            curB = headB;</span><br><span class="line">            <span class="keyword">while</span>(curA!=<span class="literal">nullptr</span> &amp;&amp; curB!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curA == curB) <span class="keyword">return</span> curA;</span><br><span class="line">                curA = curA-&gt;next;</span><br><span class="line">                curB = curB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> len = lenB-lenA;</span><br><span class="line">            curB = headB;</span><br><span class="line">            <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">                curB = curB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = headA;</span><br><span class="line">            <span class="keyword">while</span>(curA!=<span class="literal">nullptr</span> &amp;&amp; curB!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curA == curB) <span class="keyword">return</span> curA;</span><br><span class="line">                curA = curA-&gt;next;</span><br><span class="line">                curB = curB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="37-数字在排序数组中出现的次数"><a href="#37-数字在排序数组中出现的次数" class="headerlink" title="37.数字在排序数组中出现的次数"></a>37.数字在排序数组中出现的次数</h1><h2 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h2><p>统计一个数字在排序数组中出现的次数。</p>
<h2 id="解法一（自想）-1"><a href="#解法一（自想）-1" class="headerlink" title="解法一（自想）"></a>解法一（自想）</h2><p>先利用二分查找找到该数字的下标，然后统计该数字左右两边的相等数的个数，虽然二分查找的时间复杂度为$O(logn)$，但是在对该数左右两边查看相等数个数时，时间复杂度为 $O(n)$，因此，最终的时间复杂度应为 $O(n)$ 。 （这样的复杂度不会让面试官满意）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(data.size() == <span class="number">0</span>) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">int</span> index = binarySearch(data, k, <span class="number">0</span>, data.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = index<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(index&lt;data.size() &amp;&amp; data.at(index) == k)&#123;</span><br><span class="line">                index++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; data.at(i) == k)&#123;</span><br><span class="line">                i--;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> num, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first == last)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data.at(first) == num) <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (first+last)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(data.at(mid) == num) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data.at(mid) &gt; num) <span class="keyword">return</span> binarySearch(data, num ,first, mid);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> binarySearch(data, num, mid+<span class="number">1</span>, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二：牛客-1"><a href="#解法二：牛客-1" class="headerlink" title="解法二：牛客"></a>解法二：牛客</h2><p>分析上面的方法，时间复杂度高的主要原因来自于最后的顺序检索。设想一下，如果知道目标数字出现的第一个位置和最后一个位置，是否就不用再进行顺序检索了？  于是，可以将二分查找算法改成分别查找目标数字的首次出现位置和末次出现位置。也就是说，如果mid上的数字等于num，同时mid-1（mid&gt;0）上的数字不等于num，则mid为首次出现位置，否则，首次出现位置就应该还在前半段，同理，末次出现位置也是相似的道理。</p>
<p>结合以上讨论，将二分查找分成两个函数，分别找首次和末次位置，这样时间复杂度就是 $O(logn)$，无需进行顺序查找。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(data.size() == <span class="number">0</span>) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">int</span> index1 = binarySearchFirst(data, k, <span class="number">0</span>, data.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> index2 = binarySearchLast(data, k, <span class="number">0</span>, data.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(index1 == <span class="number">-1</span> || index2 == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> index2-index1+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearchFirst</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> num, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first &gt; last) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (first+last)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(data.at(mid) == num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid == <span class="number">0</span> || data.at(mid<span class="number">-1</span>) != num)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> binarySearchFirst(data, num ,first, mid<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data.at(mid) &gt; num) <span class="keyword">return</span> binarySearchFirst(data, num ,first, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> binarySearchFirst(data, num, mid+<span class="number">1</span>, last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearchLast</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> num, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first &gt; last) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (first+last)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(data.at(mid) == num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid==last || data.at(mid+<span class="number">1</span>)!=num)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> binarySearchLast(data, num, mid+<span class="number">1</span>, last);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data.at(mid) &gt; num) <span class="keyword">return</span> binarySearchLast(data, num ,first, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> binarySearchLast(data, num, mid+<span class="number">1</span>, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-解法二的非递归实现-更简洁易懂"><a href="#解法三-解法二的非递归实现-更简洁易懂" class="headerlink" title="解法三: 解法二的非递归实现(更简洁易懂)"></a>解法三: 解法二的非递归实现(更简洁易懂)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = data.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> first_k = <span class="number">-1</span>, last_k = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(data.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[mid] &lt; k) low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid; <span class="comment">//在data[mid] == k时并不退出, 而是继续判断, 知道low==high时, 才会退出, 此时 low 和 high 都应指向最左侧的k值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(data[low] != k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> first_k = low;</span><br><span class="line">        high = data.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low+high+<span class="number">1</span>)/<span class="number">2</span>; <span class="comment">// 因为只有 high 会移动到mid的下一位, 而low是等于mid的, 所以必须让mid更偏向右侧, 上面的逻辑也是同理, 希望让mid更偏向左侧</span></span><br><span class="line">            <span class="keyword">if</span>(k &lt; data[mid]) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        last_k = low;</span><br><span class="line">        <span class="keyword">return</span> last_k - first_k + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-寻找插入位置"><a href="#解法四-寻找插入位置" class="headerlink" title="解法四: 寻找插入位置"></a>解法四: 寻找插入位置</h2><p>因为data中都是整数，所以可以稍微变一下，不是搜索k的两个位置，而是搜索 k-0.5 和 k+0.5 这两个数应该插入的位置，然后相减即可。因为数组中不存在 k-0.5 和 k+0.5 这两个数, 因此, 我们只需不断二分查找, 直到 low &gt; high 为止即可.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> binary(data, k+<span class="number">0.5</span>) - binary(data, k<span class="number">-0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binary</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;data, <span class="keyword">double</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low =<span class="number">0</span> , high = data.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123; <span class="comment">// 这里的等于号是必不可少的</span></span><br><span class="line">            <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[mid] &lt; k) low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="38-二叉树的深度"><a href="#38-二叉树的深度" class="headerlink" title="38.二叉树的深度"></a>38.二叉树的深度</h1><h2 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<h2 id="解法一-非递归-1"><a href="#解法一-非递归-1" class="headerlink" title="解法一: 非递归"></a>解法一: 非递归</h2><p>利用<del>BFS广度优先遍历</del>（错了，树没有广度遍历，这个应该叫层次遍历），<del>结合一个专门存储当前节点所处深度的队列实现</del> 利用一个<code>layer_count</code>变量来记录当前层总共的节点数, 每次当<code>pop</code>了当前节点数个节点后, <code>depth</code>都会增1，最终的树深度，就应该等于<del>广度优先遍</del>层次遍历历最后一个访问节点所处的深度。（因为这肯定是最后一层，也就是最深的一层）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; tree_q;</span><br><span class="line">        tree_q.push(pRoot);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!tree_q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> layer_count = tree_q.size(); <span class="comment">//记录当前层共有多少节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt;layer_count; i++)&#123; <span class="comment">// 根据当前层节点进行pop</span></span><br><span class="line">                TreeNode* cur_node = tree_q.front(); tree_q.pop();</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;left != <span class="literal">nullptr</span>) tree_q.push(cur_node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;right != <span class="literal">nullptr</span>) tree_q.push(cur_node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二：牛客-2"><a href="#解法二：牛客-2" class="headerlink" title="解法二：牛客"></a>解法二：牛客</h2><p>二叉树中的某个节点的深度，就是其左子树深度和右子树深度较大者+1 ， 二叉树的深度就是根节点的深度，所以，利用递归的思想实现。（代码简洁，但是复杂复杂度好像和广度优先一样，都是n？ 是这样吗？）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> depth1 = <span class="number">1</span>, depth2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;left!=<span class="literal">nullptr</span>) depth1 = TreeDepth(pRoot-&gt;left)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;right!=<span class="literal">nullptr</span>) depth2 = TreeDepth(pRoot-&gt;right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> depth1&gt;depth2 ? depth1 : depth2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更简洁的写法:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max( TreeDepth(pRoot-&gt;left)+<span class="number">1</span>, TreeDepth(pRoot-&gt;right)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="39-平衡二叉树"><a href="#39-平衡二叉树" class="headerlink" title="39.平衡二叉树"></a>39.平衡二叉树</h1><h2 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<h2 id="解法一（自想）-2"><a href="#解法一（自想）-2" class="headerlink" title="解法一（自想）"></a>解法一（自想）</h2><p><strong>时间复杂度:</strong> $O(n)$, 每个节点至多访问一次<br><strong>空间复杂度:</strong> $O(n)$, 有可能需要进行 n 次递归</p>
<p>将题目看作是求左右子树的深度，如果深度差超过1,那么就不是二叉树，返回一个特殊的标识（-1），这种方法属于一边遍历，一边判断，只需要遍历每个节点一次，通过递归实现。时间复杂度为 $O(logn)$</p>
<p><strong>有一种“不太好”的方法是每遇到一个节点，就单独求一次这个节点对应的树的深度，这种做法要遍历一个节点很多次，是一种典型的不令人满意的做法, 下面的做法采用了剪枝, 使得对每个节点至多访问一次, 是较好的做法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tdepth = treeDepth(pRoot);</span><br><span class="line">        <span class="keyword">if</span>(tdepth!=<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftdepth = treeDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(leftdepth == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightdepth = treeDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(rightdepth == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(leftdepth-rightdepth) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> max(leftdepth,rightdepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更凝练的写法:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tree_depth(pRoot)==<span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tree_depth</span><span class="params">(TreeNode* pRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left_depth = tree_depth(pRoot-&gt;left); <span class="comment">//注意, 这里没有 +1,</span></span><br><span class="line">        <span class="keyword">if</span>(left_depth==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 在这里直接断left_depth判断, 如果发现=-1,就一路返回, 无需再求右子树深度</span></span><br><span class="line">        <span class="keyword">int</span> right_depth = tree_depth(pRoot-&gt;right); <span class="comment">//注意, 这里没有 +1</span></span><br><span class="line">        <span class="keyword">if</span>(right_depth==<span class="number">-1</span> || <span class="built_in">abs</span>(left_depth-right_depth) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> max(left_depth, right_depth) + <span class="number">1</span>; <span class="comment">// 注意, 这有一定要有+1, 因为树深度就等于左右子树最大深度+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="40-数组中只出现一次的数字"><a href="#40-数组中只出现一次的数字" class="headerlink" title="40.数组中只出现一次的数字"></a>40.数组中只出现一次的数字</h1><h2 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</p>
<p>（暴力解法就不提了，肯定不是最优。）</p>
<h2 id="解法一：异或"><a href="#解法一：异或" class="headerlink" title="解法一：异或"></a>解法一：异或</h2><p>注：异或运算符还可以实现无中间变量的两个数字互换：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">4</span>;</span><br><span class="line">a = a^b; <span class="comment">// a = 2^4 = 6</span></span><br><span class="line">b = a^b; <span class="comment">// b = 6^4 = 2</span></span><br><span class="line">a = a^b; <span class="comment">// a = 6^2 = 4</span></span><br><span class="line"><span class="comment">//同理有</span></span><br><span class="line">a = a + b; <span class="comment">// a = 2+4 = 6</span></span><br><span class="line">a = a - b; <span class="comment">// b = 6-4 = 2</span></span><br><span class="line">a = a - b; <span class="comment">// a = 6-2 = 4</span></span><br></pre></td></tr></table></figure></p>
<p>异或运算的性质：任何一个数字异或它自己都等于0 。与0异或则保留原值<br>也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了。</p>
<p><strong>（这里不限定是一次，只要是奇数次都可以）</strong></p>
<p>本题数列中，有两个出现一次的数字，第一次先全部异或，得到的结果是两个一次数字的异或值，该异或值至少有一位的值为1 (即在这一位上, 两个数字一个为0, 一个为1), 因此，找到这一位，然后根据这一位这数组分成两拨，如此一来，每一拨都变成了上面的简单情况。</p>
<p>（同理，如果有N个一次数字，可以通过不断分拨的方法解决, 例如, 如果有3个一次数字, 则找了为1的那一位, 可以将其分成具有2个一次数字和具有一个一次数字的两拨数组）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span> * num1,<span class="keyword">int</span> * num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.size() &lt; <span class="number">2</span> ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> xor_res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : data)</span><br><span class="line">            xor_res ^= x;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( (xor_res &amp; i) == <span class="number">0</span>) <span class="comment">// 按位异或的优先级小于 '==' 的优先级, 因此一定要用括号括起来</span></span><br><span class="line">            i = i&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        *num1=<span class="number">0</span>, *num2=<span class="number">0</span>; <span class="comment">//return;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : data)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (x &amp; i) != <span class="number">0</span>)  <span class="comment">// 按位与的优先级小于 '!=' , 所以必须用括号</span></span><br><span class="line">                *num1 = *num1 ^ x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *num2 = *num2 ^ x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展-数组中只有一个数出现一次，其他数都出现了2次，找出这个数字"><a href="#扩展-数组中只有一个数出现一次，其他数都出现了2次，找出这个数字" class="headerlink" title="扩展: 数组中只有一个数出现一次，其他数都出现了2次，找出这个数字"></a>扩展: 数组中只有一个数出现一次，其他数都出现了2次，找出这个数字</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find1From2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> len = a.size(), res = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">         res = res ^ a[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展-数组中只有一个数出现一次，其他数字都出现了3次-奇数次-，找出这个数字"><a href="#扩展-数组中只有一个数出现一次，其他数字都出现了3次-奇数次-，找出这个数字" class="headerlink" title="扩展: 数组中只有一个数出现一次，其他数字都出现了3次(奇数次)，找出这个数字"></a>扩展: 数组中只有一个数出现一次，其他数字都出现了3次(奇数次)，找出这个数字</h2><p>例如数组a[]={2,4,4,4,6,6,6};结果则返回2；思路则是利用位运算，因为其他数字都出现了三次，那么他们的二进制相同位上1的个数则是3的倍数，这样的话，最后统计完3的倍数的位清0，剩下的1则都是那个只出现一次的数的位。<br>(也可以先统计每一位上面1的个数, 最后模3取余)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find1From3</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *bits = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>]; <span class="comment">//因为整数一般为4字节, 32位</span></span><br><span class="line">    <span class="keyword">int</span> len = a.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++)&#123;</span><br><span class="line">            bits[j] = bits[j] + ( (a[i]&gt;&gt;j) &amp; <span class="number">1</span>); # 注意这里的括号是必不可少的, 因为 &amp; 的优先级比 + 低得多</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bits[i] % <span class="number">3</span> !=<span class="number">0</span>)&#123;</span><br><span class="line">            res = res | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] bits;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出, 这是一种比较通用的解法, 可以求解某个数字出现一次, 而其他数字出现n次的情况(如果n为偶数, 建议用异或实现).</p>
<h1 id="41-和为S的连续正数序列"><a href="#41-和为S的连续正数序列" class="headerlink" title="41.和为S的连续正数序列"></a>41.和为S的连续正数序列</h1><h2 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h2><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!<br>输出描述:<br>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p>
<h2 id="解法一（自想）-3"><a href="#解法一（自想）-3" class="headerlink" title="解法一（自想）"></a>解法一（自想）</h2><p>设置两个变量记录当前序列的start位置和end位置，判断当前序列的和:</p>
<ul>
<li>如果=sum，则存储当前序列，并将start+1,序列前进;</li>
<li>如果&gt;sum,将应减去序列中的最小值，也就是start指向位置的值，然后start+1;</li>
<li>如果&lt;sum，则应该再加上下一个值，也就是end指向的值。</li>
</ul>
<p>然后再进行上面的循环，直到start指向的位置值为(sum+1)/2,此时就已经不可能出现和为sum的连续序列了。该方法时间复杂度为$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; results;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> end =start; start &lt;= sum/<span class="number">2</span> ;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp == sum)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numseq;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i&lt;end; i++)&#123;</span><br><span class="line">                    numseq.push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">                results.push_back(numseq);</span><br><span class="line">                tmp -=start; <span class="comment">// 需要注意这里的顺序, 一定要先减去了 start 以后, 才能执行 start++</span></span><br><span class="line">                start++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( tmp &gt; sum)&#123;</span><br><span class="line">                tmp -= start;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                tmp += end;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-等差序列求和公式"><a href="#解法二-等差序列求和公式" class="headerlink" title="解法二: 等差序列求和公式"></a>解法二: 等差序列求和公式</h2><h1 id="42-和为S的两个数字"><a href="#42-和为S的两个数字" class="headerlink" title="42.和为S的两个数字"></a>42.和为S的两个数字</h1><h2 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。<br>输出描述:<br>对应每个测试案例，输出两个数，小的先输出。</p>
<h2 id="解法一（自想）-4"><a href="#解法一（自想）-4" class="headerlink" title="解法一（自想）"></a>解法一（自想）</h2><p>设置两个变量，分别指向数组的第一个位置和最后一个位置，然后将这两个变量所指位置的值相加，分以下三种情况：</p>
<ul>
<li><code>=sum;</code> <del>判断二者乘积是否比当前最小值小，如果是，则改变最小值的持有值。 不管是否小，都将num1++</del> 实际上, 根本无需判断是否比当前最小值小, 因为对于和相同的两组数, 数字差值较大的那一组的成绩一定小于数字差值较小的, 因此, 只要找到符合和为sum条件的两个数字, 即可直接返回, 无需进行任何额外判断.</li>
<li><code>&gt;sum; num2--;</code></li>
<li><code>&lt;sum; num1++;</code><br>循环以上三步直到 <code>num1&gt;=num2</code>。最后判断minnum1和minnum2的值，如果二者相等，说明数组里面不存在这样的数对儿，返回空vector，若不相等，则输出这两个值。</li>
</ul>
<p>结论证明：<br>假设：找到两组满足条件的数组对 $（x，y）$、$（x+a,y-a）$，其中（ $x+y=S, 0&lt;a&lt;y-x$ ）</p>
<script type="math/tex; mode=display">x*y-[(x+a)(y-a)]=x*y-x*y-(y-x)a+a2=a[a-(y-x)]</script><p>因为 $0&lt;a&lt;y-x$ ,所以 $a-(y-x)&lt;0$ ,所以 $a[a-(y-x)]&lt;0$<br>因此 $(x,y)$ 乘积一定比 $(x+a,y-a)$ 小</p>
<p>当第一次找到符合条件的两个数字时, 它们的乘积就一定是最小的, 所以可以直接退出.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; FindNumbersWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>,<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = <span class="built_in">array</span>.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//在使用容器的back()方法访问时，必须要确保容器不是空的，否则会出现段错误（访问越界）</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[low] + <span class="built_in">array</span>[high] == sum)&#123; <span class="comment">//首次找到就可返回</span></span><br><span class="line">                res.push_back(<span class="built_in">array</span>[low]);</span><br><span class="line">                res.push_back(<span class="built_in">array</span>[high]);</span><br><span class="line">                <span class="keyword">return</span> res; <span class="comment">//首次找到就可返回</span></span><br><span class="line">                low++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[low] + <span class="built_in">array</span>[high] &lt; sum)</span><br><span class="line">                low++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="43-左旋转字符串"><a href="#43-左旋转字符串" class="headerlink" title="43.左旋转字符串"></a>43.左旋转字符串</h1><h2 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<h2 id="解法一（自想）：利用str-substr-pos-n"><a href="#解法一（自想）：利用str-substr-pos-n" class="headerlink" title="解法一（自想）：利用str.substr(pos,n)"></a>解法一（自想）：利用str.substr(pos,n)</h2><p><strong>注意：</strong></p>
<p>这道题看似简单，实则很容易考虑不全，主要需注意以下几点：</p>
<ul>
<li>n大于str.length()的情况</li>
<li>str.length()=0的情况</li>
<li>n为负数的情况（虽然这里牛客没考虑，我觉得题里没说正数，所以是有负数的可能的）</li>
</ul>
<p><strong>越是简单的题，越要注意各种情况的考虑，因为这种题的考察点就是考虑是否全面，而不是题怎么解</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;=str.length())  n = n % str.length();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>) n = str.size() + n; 左移n位(负), 等于右移-n位, 等于左移size+n位</span><br><span class="line">        res=str.substr(n);</span><br><span class="line">        res += str.substr(<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二（牛客）：反转"><a href="#解法二（牛客）：反转" class="headerlink" title="解法二（牛客）：反转"></a>解法二（牛客）：反转</h2><p>利用多次反转的方法，首先将字符串按照n的位置分成两部分，然后进行以下三步（abcdefg，2）：</p>
<ul>
<li>反转前一部分：ba</li>
<li>反转后一部分：gfed</li>
<li>反转整个字符串：bagfed -&gt; defgab</li>
</ul>
<p>时间复杂度也为$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">my_inverse</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="keyword">int</span> start, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i&lt;=mid; i++)&#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(str[i], str[high-i+start]); <span class="comment">// 这里注意交换时的下标, 因为i是从start开始的, 所以高位的下标应该为high-(i-start)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>) n = str.size() + n; <span class="comment">//左移n位(负), 等于右移-n位, 等于左移size+n位</span></span><br><span class="line">        <span class="keyword">if</span> (n&gt;=str.length())  n = n % str.length();</span><br><span class="line">        my_inverse(str, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">        my_inverse(str, n, str.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//return str;</span></span><br><span class="line">        my_inverse(str, <span class="number">0</span>, str.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>利用 <code>std::reverse()</code> 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;=str.length())  n = n % str.length();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>) n = str.size() + n; <span class="comment">//左移-n位, 等于右移n位, 等于左移size-n位</span></span><br><span class="line">        <span class="built_in">std</span>::reverse(str.begin(), str.begin()+n);</span><br><span class="line">        <span class="built_in">std</span>::reverse(str.begin()+n, str.end());</span><br><span class="line">        <span class="built_in">std</span>::reverse(str.begin(), str.end());</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="44-翻转单词顺序列"><a href="#44-翻转单词顺序列" class="headerlink" title="44.翻转单词顺序列"></a>44.翻转单词顺序列</h1><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<h2 id="解法一-土办法"><a href="#解法一-土办法" class="headerlink" title="解法一: 土办法"></a>解法一: 土办法</h2><p>设值两个标记i，j，都从字符串的最后一位开始，如果当前字符不是空格，那么i指向下一个，直到遇到空格为止，此时，将i到j范围内字符提取出来，然后把令j=i。重复以上过程，直到i=0为止。 该解法时间复杂度为 $O(n)$ 而且只需遍历一边字符串。</p>
<p>但是空间复杂度也为 $O(n)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">ReverseSentence</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = str.length()<span class="number">-1</span>, j=str.length()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; )&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span>)&#123;<span class="comment">//这里注意不能用双引号,双引号代表字符串,在C++内部,""与''表示的是不同的东西</span></span><br><span class="line">                res += str.substr(i+<span class="number">1</span>,j-i);</span><br><span class="line">                res += <span class="string">" "</span>;</span><br><span class="line">                i--;</span><br><span class="line">                j = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                res += str.substr(i,j-i+<span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二（牛客）：利用reverse执行两次反转"><a href="#解法二（牛客）：利用reverse执行两次反转" class="headerlink" title="解法二（牛客）：利用reverse执行两次反转"></a>解法二（牛客）：利用reverse执行两次反转</h2><p>首先反转整个字符串，然后以空格为间隔，反转每个单词。时间复杂度也是$O(n)$ (遍历两次).<br>空间复杂度为 $O(1)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">ReverseSentence</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::reverse(str.begin(), str.end());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;=str.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[j] == <span class="string">' '</span> || j == str.size())&#123;</span><br><span class="line">                <span class="built_in">std</span>::reverse(str.begin()+i, str.begin()+j);</span><br><span class="line">                i=j+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="45-扑克牌顺子"><a href="#45-扑克牌顺子" class="headerlink" title="45.扑克牌顺子"></a>45.扑克牌顺子</h1><h2 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h2><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张)他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>
<h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意:"></a>注意:</h2><p>该题目需要注意：1123 这样的顺序返回的是false</p>
<h2 id="解法一-自想"><a href="#解法一-自想" class="headerlink" title="解法一(自想):"></a>解法一(自想):</h2><p>分析能组成顺子的数字的特征，首先，最大的数字和最小的数字他们的差一定要比numbers的size小，否则，肯定连不了顺子。比如12345和2300等。其次，如果数组中出现非0的重复数字，那么也一定不是顺子。因此，代码可以这样写：</p>
<ul>
<li>找出非0的最大值和最小值</li>
<li>在找最值的时候顺便利用最简单的hash表来存储每个数字出现的次数，hash表长度为14，key值为数字，value值为key值出现的次数，如果value出现&gt;1的情况，则直接返回false</li>
<li>做判断，如果max-min&lt; numbers.size()，则返回true，否则返回false。</li>
</ul>
<p>以上程序时间复杂度为$O(n)$ ，并且只需要遍历一次numbers。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(numbers[i] == <span class="number">0</span>) i++;</span><br><span class="line">        <span class="keyword">int</span> min=numbers.at(i);</span><br><span class="line">        <span class="keyword">int</span> max = numbers.at(i);</span><br><span class="line">        <span class="keyword">int</span> zeronum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">14</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = numbers.begin(); it!=numbers.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*it &lt; min &amp;&amp; *it!=<span class="number">0</span>) min = *it;</span><br><span class="line">            <span class="keyword">if</span>(*it &gt; max) max = *it;</span><br><span class="line">            <span class="keyword">if</span>(*it == <span class="number">0</span>) zeronum++;</span><br><span class="line">            count[*it]++;</span><br><span class="line">            <span class="keyword">if</span>(*it != <span class="number">0</span> &amp;&amp; count[*it] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max-min &lt;= numbers.size() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面对max和min赋值的时候, 有可能会出现需要遍历n次的情况, 用下面的方法稍微改进一下(复杂度不变), 要注意不论是max还是min, 都不能为0.(全0的情况时, 会返回true)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> poke_hash[<span class="number">14</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> max_poke = INT_MIN, min_poke = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item : numbers)&#123;</span><br><span class="line">            poke_hash[item]++;</span><br><span class="line">            <span class="keyword">if</span>(item!=<span class="number">0</span> &amp;&amp; poke_hash[item]&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(item!=<span class="number">0</span> &amp;&amp; item &lt; min_poke) min_poke = item;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(item!=<span class="number">0</span> &amp;&amp; item &gt; max_poke) max_poke = item;</span><br><span class="line">            <span class="keyword">if</span>(max_poke!=INT_MIN &amp;&amp; min_poke!=INT_MAX &amp;&amp; max_poke - min_poke &gt;= numbers.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>另一种写法, 可以让判断条件不用写的那么复杂, 推荐使用这种写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = numbers.size();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> hash_map[<span class="number">13</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> min=INT_MAX, max=INT_MIN, zero=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : numbers)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(hash_map[n<span class="number">-1</span>]&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;min) min = n;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n&gt;max) max = n;</span><br><span class="line">            <span class="keyword">if</span>(min!=INT_MAX &amp;&amp; max!=INT_MIN &amp;&amp; max-min&gt;=len) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//如果发现已经不可能出现顺子, 则提前退出</span></span><br><span class="line">            hash_map[n<span class="number">-1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min==INT_MAX || max==INT_MIN) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(max - min &lt;len) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二（牛客）：排序"><a href="#解法二（牛客）：排序" class="headerlink" title="解法二（牛客）：排序"></a>解法二（牛客）：排序</h2><p>先排序，在统计0的个数，再用0填补空缺，时间复杂度为 $O(nlogn)$ 不如上面的方法好。</p>
<h1 id="46-圆圈中最后剩下的数：约瑟夫（Josephuse）环问题"><a href="#46-圆圈中最后剩下的数：约瑟夫（Josephuse）环问题" class="headerlink" title="46.圆圈中最后剩下的数：约瑟夫（Josephuse）环问题"></a>46.圆圈中最后剩下的数：约瑟夫（Josephuse）环问题</h1><h2 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h2><p>0,1,…,n-1这n个数字排成一个圆圈，从数字0开始每次删除m-1处的数字，然后从这个数字的下一位继续从0开始，删除m-1处的数字，求出圆圈里剩下的最后一个数字</p>
<h2 id="解法一（自想）：利用vector维护动态数组模拟约瑟夫环"><a href="#解法一（自想）：利用vector维护动态数组模拟约瑟夫环" class="headerlink" title="解法一（自想）：利用vector维护动态数组模拟约瑟夫环"></a>解法一（自想）：利用vector维护动态数组模拟约瑟夫环</h2><p>利用一个vector维护一个动态数组，数组内的内容是每个孩子的编号，每次要删除的节点位置，都在index+m-1处，如果index+m-1超过了数组的大小，则对数组的size求余即可。该算法是最简单的一种思路，vector或list在删除时，由于要将后面的元素向前挪，所以erase的时间<br>复杂度为 $O(n)$ ，因此，总的时间复杂度为$O(n^2)$。</p>
<p>空间复杂度为 $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span> || m&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; joseph_ring;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            joseph_ring.push_back(i);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(joseph_ring.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            index = (index+m<span class="number">-1</span>) % joseph_ring.size();</span><br><span class="line">            joseph_ring.erase(joseph_ring.begin() + index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> joseph_ring[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二（牛客）：经典解法，用环形链表模拟圆圈"><a href="#解法二（牛客）：经典解法，用环形链表模拟圆圈" class="headerlink" title="解法二（牛客）：经典解法，用环形链表模拟圆圈"></a>解法二（牛客）：经典解法，用环形链表模拟圆圈</h2><p>可以用<code>std::list</code>或者<code>std::vector</code>来模拟一个环形链表，由于它们本身不是循环的，因此需要记得手动实现循环逻辑（其实就是解法一）</p>
<p>如果要求不可以使用标准模板库里面的数据容器来模拟环形链表，那么可以自己设计结构体类型，实现一个循环链表。</p>
<p>这里由于链表随机在删除节点时的时间复杂度为 $O(1)$ , 但是无法进行随机访问，只能顺序访问，因此删除时需要先顺序移动到该节点上才行, 所以要时间复杂度仍然为$O(n^2)$</p>
<p>空间复杂度为$O(n)$。</p>
<h2 id="解法三（牛客）："><a href="#解法三（牛客）：" class="headerlink" title="解法三（牛客）："></a>解法三（牛客）：</h2><p>分析每次删除时的数字规律，总结出以下公式，按照公式编写递归或非递归程序，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$ 。</p>
<script type="math/tex; mode=display">f(n) = \begin{cases} 0 & n=1 \\  [f(n-1,m)+m]\%n & n>1 \end{cases}</script><p>思考过程：当把第m个数(下标为m-1)去掉以后, 就只剩下了n-1个数, 此时, 再从下标m开始, 继续进行大小为n-1的约瑟夫环问题. 这里假设我们已经知道了大小为n-1的约瑟夫环问题的解为下标 $x’$, 则 $x’$ 在大小为n的约瑟夫环问题里面的下标应该为: $x = (x’ + m) % n$ . 由此式即可得到上面的递归公式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span> || m&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_n=<span class="number">1</span>, res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur_n &lt;= n)&#123;<span class="comment">// 注意是&lt;=, 因为此处的i代表的是size, 必须要一直计算到i==n为止</span></span><br><span class="line">            res = (res+m) % cur_n; <span class="comment">//注意是要除以cur_n, 而不是n</span></span><br><span class="line">            cur_n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">递归写法</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span> || m&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (LastRemaining_Solution(n<span class="number">-1</span>,m)+m)%n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="47-非常规法求前n项和"><a href="#47-非常规法求前n项和" class="headerlink" title="47.非常规法求前n项和"></a>47.非常规法求前n项和</h1><h2 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>这道题本身没有实际意义，侧重考察发散性思维和对C++相关机制的理解程度。</p>
<h2 id="解法一：构造函数"><a href="#解法一：构造函数" class="headerlink" title="解法一：构造函数"></a>解法一：构造函数</h2><p>每声明一个对象，则构造函数都被调用一次，因此，可以借助静态变量来在构造函数内部实现累加操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sum</span>&#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i ;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> s;</span><br><span class="line">        sum()&#123;i++; s+=i;&#125;;</span><br><span class="line">        ~sum()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            s = <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">int</span> sum::i =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum::s = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        sum::<span class="built_in">set</span>();</span><br><span class="line">        sum a[n];</span><br><span class="line">        <span class="keyword">return</span> sum::s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二：虚函数"><a href="#解法二：虚函数" class="headerlink" title="解法二：虚函数"></a>解法二：虚函数</h2><p>利用虚函数来模拟递归函数，可以在两个类中分别定义函数，其中一个函数充当递归函数的角色，另一个函数处理终止递归的情况，然后在两个函数里二选一。</p>
<p>这里用到了一个小trick，那就是对于整型变量n，执行<code>!!n</code>以后，可以将其转换成布尔值（0和1）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">A* Array[<span class="number">2</span>];  <span class="comment">//这里必须为指针，否则不会进入B的sum 函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">return</span> Array[!!n]-&gt;sum(n<span class="number">-1</span>) + n;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">a</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">b</span>;</span></span><br><span class="line">        Array[<span class="number">0</span>] = &amp;a;</span><br><span class="line">        Array[<span class="number">1</span>] = &amp;b;</span><br><span class="line">        <span class="keyword">return</span> Array[<span class="number">1</span>]-&gt;sum(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面用了虚函数，那么使用普通的函数可以吗？答案是否定的，因为使用普通函数时，无法同时调用两个类的函数，最终只会调用A类的sum函数。</p>
<h2 id="解法三：函数指针"><a href="#解法三：函数指针" class="headerlink" title="解法三：函数指针"></a>解法三：函数指针</h2><p>同样是上面的思想，不过改为使用函数指针来实现两个函数模拟递归</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*fun[<span class="number">2</span>])</span><span class="params">(<span class="keyword">int</span> n)</span> </span>= &#123;A,B&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fun[!!n](n<span class="number">-1</span>) + n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> B(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四：模板类"><a href="#解法四：模板类" class="headerlink" title="解法四：模板类"></a>解法四：模板类</h2><p>使用模板类完成递归，这种方法有一个很大的缺点就是整个过程是在编译阶段完成的，因此无法使用动态的n，而必须是在编译期间就能确定的常量，另外，编译器对递归编译代码的递归深度也是有限制的，所以n不能太大。</p>
<h1 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48.不用加减乘除做加法"></a>48.不用加减乘除做加法</h1><h1 id="49-把字符串转换成整数"><a href="#49-把字符串转换成整数" class="headerlink" title="49.把字符串转换成整数"></a>49.把字符串转换成整数</h1><h2 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。<br>输入描述:</p>
<p>输入一个字符串,包括数字字母符号,可以为空</p>
<p>输出描述:</p>
<p>如果是合法的数值表达则返回该数字，否则返回0</p>
<h2 id="解法一（自想）："><a href="#解法一（自想）：" class="headerlink" title="解法一（自想）："></a>解法一（自想）：</h2><p>从头开始逐个字符遍历，每次遇到一个“数字”，就将之间的res×10，然后再加上这个数字。需要特别注意“-123”，“+123”等情况。 时间复杂度为 $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>  res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> negative = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            negative=<span class="literal">true</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'+'</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; str.length() ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( str[i] &gt;= <span class="string">'0'</span> &amp;&amp; str[i] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                res = res*<span class="number">10</span> + (<span class="keyword">int</span>)(str[i] - <span class="string">'0'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(negative) res = <span class="number">0</span> - res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h2><p>上面的代码虽然已经解决了牛客的题，但是有几点是需要特别注意的！</p>
<p>首先，题目很简单，所以这道题的考察点只在于是否将所有情况都考虑到了，以下是一些可能的情况，日后再遇到一定要想起来：</p>
<ul>
<li>首先考虑如何返回错误，首先不能使用可以转换成数值类型（int，bool，char）的数据直接指明错误（比如返回0，无法得知到底是错误当时真的是0），由此，可以创建一个全局的错误变量，如果要返回错误，则返回0并且将该变量状态改变。</li>
<li>非数字类符号不全是错误输出，如：<code>+123</code>、<code>-123</code></li>
<li>只输入<code>+</code>和<code>-</code>时，要返回错误</li>
<li><code>string str==&quot;&quot;</code>时，也要返回错误</li>
<li>如果为<code>char str*</code>，则要判断指针是否为空</li>
<li>一定要考虑数值溢出情况（当转换的数字大于最大正数，小于最小负数时，会溢出）</li>
</ul>
<h1 id="50-数组中重复的数字"><a href="#50-数组中重复的数字" class="headerlink" title="50.数组中重复的数字"></a>50.数组中重复的数字</h1><h2 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<h2 id="解法一：暴力"><a href="#解法一：暴力" class="headerlink" title="解法一：暴力"></a>解法一：暴力</h2><p>对于每个数组中的数字，都到前面的数字中去寻找是否有重复的。</p>
<p>时间复杂度： $O(n^2)$  空间复杂度： $O(1)$</p>
<h2 id="解法二：哈希"><a href="#解法二：哈希" class="headerlink" title="解法二：哈希"></a>解法二：哈希</h2><p>建立长度为n的哈希表，每次遇到一个数字x，就在hash[x]增1，如果此时hash[x]变为2，那么就说明有重复。</p>
<p>时间复杂度： $O(n)$  空间复杂度： $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//        numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//        length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//        duplication: (Output) the duplicated number in the array number</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hash(length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; length; i++)&#123;</span><br><span class="line">            hash[numbers[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(hash[numbers[i]] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><h1 id="51-构建乘积数组"><a href="#51-构建乘积数组" class="headerlink" title="51.构建乘积数组"></a>51.构建乘积数组</h1><h2 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p>
<h2 id="解法一（自想）：-1"><a href="#解法一（自想）：-1" class="headerlink" title="解法一（自想）："></a>解法一（自想）：</h2><p>将乘积看成两段，前i-1项的乘积，和后n-i项的乘积，分开计算，最终合并。<br>时间复杂度： $O(n)$   空间复杂度： $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; multiply(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = A.begin(); it!=A.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it!=A.begin()) tmp *= *(it<span class="number">-1</span>);</span><br><span class="line">            B.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = A.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=A.size()<span class="number">-1</span>) tmp *= A.at(i+<span class="number">1</span>);</span><br><span class="line">            B.at(i) *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="52-正则表达式匹配"><a href="#52-正则表达式匹配" class="headerlink" title="52.正则表达式匹配"></a>52.正则表达式匹配</h1><h2 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来匹配包括<code>.</code>和<code>*</code>的正则表达式。模式中的字符<code>.</code>表示任意一个字符，而<code>*</code>表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>aaa</code>与模式<code>a.a</code>和<code>ab*ac*a</code>匹配，但是与<code>aa.a</code>和<code>ab*a</code>均不匹配</p>
<h2 id="解法一：（牛客）"><a href="#解法一：（牛客）" class="headerlink" title="解法一：（牛客）"></a>解法一：（牛客）</h2><p>主要分两种情况：</p>
<ul>
<li>当前字符的下一个字符不是<code>*</code></li>
<li>当前字符的字一个字符是<code>*</code></li>
</ul>
<p>对于第一种情况：直接判断是否相等（包含‘.’的情况）</p>
<p>对于第二种情况，需要分情况讨论：</p>
<ul>
<li>当前字符与pattern当前字符不相等，则patter当前只能出现零次，调用<code>match(str, pattern+2)</code></li>
<li>当前字符与pattern字符相等（包含‘.’的情况），则pattern的选择有两种，出现零次，或者出现一次以上，这两种情况都必须考虑，否则会丢解，如（aab和a.*ab），因此，需要调用<code>match(str, pattern+2) || match(str+1, pattern)</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( *str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>( *str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( *(pattern+<span class="number">1</span>) != <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*str!=<span class="string">'\0'</span> &amp;&amp; (*str == *pattern || *pattern==<span class="string">'.'</span>))  <span class="comment">//  *str的条件不能丢</span></span><br><span class="line">                <span class="keyword">return</span> match(str+<span class="number">1</span>, pattern+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(*str!=<span class="string">'\0'</span> &amp;&amp; (*str == *pattern || *pattern==<span class="string">'.'</span>))  <span class="comment">//这里的if else组合语句是必须的，否则会在不能出现多次时，函数仍然考虑出现多次的情况，造成误解</span></span><br><span class="line">                <span class="keyword">return</span> match(str, pattern+<span class="number">2</span>) || match(str+<span class="number">1</span>, pattern);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> match(str, pattern+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="53-表示数值的字符串"><a href="#53-表示数值的字符串" class="headerlink" title="53.表示数值的字符串"></a>53.表示数值的字符串</h1><h2 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<h2 id="解法一（自想）：-2"><a href="#解法一（自想）：-2" class="headerlink" title="解法一（自想）："></a>解法一（自想）：</h2><p>没有难点，考察点主要在于各种情况的考虑（以下均为false）：</p>
<ul>
<li>+</li>
<li>-</li>
<li>+12.2.2</li>
<li>12e</li>
<li>12e-</li>
<li>12E+4.3</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isNumeric(char* string)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*string == &apos;\0&apos;) return false;</span><br><span class="line">        if(*string == &apos;+&apos; || *string == &apos;-&apos;)</span><br><span class="line">            string++;</span><br><span class="line">        if(*string == &apos;\0&apos;)</span><br><span class="line">            return false;</span><br><span class="line">        int point_count = 0;</span><br><span class="line">        while( (*string &gt;= &apos;0&apos; &amp;&amp; *string &lt;= &apos;9&apos;)</span><br><span class="line">             || *string == &apos;.&apos;)&#123;</span><br><span class="line">            if (*string == &apos;.&apos;) point_count++;</span><br><span class="line">            if (point_count &gt; 1) return false;</span><br><span class="line">            string++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(*string == &apos;\0&apos;)</span><br><span class="line">            return true;</span><br><span class="line">        if(*string == &apos;e&apos; || *string == &apos;E&apos;)</span><br><span class="line">            string++;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">        if(*string == &apos;\0&apos;)</span><br><span class="line">            return false;</span><br><span class="line">        if(*string == &apos;+&apos; || *string == &apos;-&apos;)</span><br><span class="line">            string++;</span><br><span class="line">        if(*string == &apos;\0&apos;)</span><br><span class="line">            return false;</span><br><span class="line">        while( *string &gt;= &apos;0&apos; &amp;&amp; *string &lt;= &apos;9&apos; )</span><br><span class="line">            string++;</span><br><span class="line">        if(*string != &apos;\0&apos;)</span><br><span class="line">            return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="54-字符流中第一个不重复的字符"><a href="#54-字符流中第一个不重复的字符" class="headerlink" title="54.字符流中第一个不重复的字符"></a>54.字符流中第一个不重复的字符</h1><h2 id="解法一（牛客）：哈希表"><a href="#解法一（牛客）：哈希表" class="headerlink" title="解法一（牛客）：哈希表"></a>解法一（牛客）：哈希表</h2><p>建立一个哈希表和一个char数组（均为256大小），哈希表存储每个字符出现的次数，key为char，value为次数，数组存储所有 <strong>曾经</strong> 出现过一次的字符。</p>
<p>时间复杂度 $O(n)$  空间复杂度 $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="keyword">char</span> hash_c[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> first_c[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> index =<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        hash_c[ch]++;</span><br><span class="line">        <span class="keyword">if</span>(hash_c[ch] == <span class="number">1</span>)&#123;</span><br><span class="line">            *(first_c+index) = ch;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;index; i++)</span><br><span class="line">            <span class="keyword">if</span> (hash_c[*(first_c+i)] == <span class="number">1</span>) <span class="keyword">return</span> *(first_c+i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><span id="55"></span></p>
<h1 id="55-链表中环的入口节点"><a href="#55-链表中环的入口节点" class="headerlink" title="55.链表中环的入口节点"></a>55.链表中环的入口节点</h1><h2 id="解法一（牛客）-FLoyd-的乌龟和兔子"><a href="#解法一（牛客）-FLoyd-的乌龟和兔子" class="headerlink" title="解法一（牛客）: FLoyd 的乌龟和兔子"></a>解法一（牛客）: FLoyd 的乌龟和兔子</h2><p>假设有环，并且环中的节点数为n，那么只要设值两个指针，一个slow指针指向头结点，另一个fast指针指向第n+1个节点，然后每次slow指针和fast指针都增1，那么肯定会在环的头部相遇（因为fast刚好比slow领先了一个环的长度）</p>
<p>因此，首先需要判断是否有环，思路是：从头结点开始，slow每次走一步，fast每次走两步，那么只要有环，slow和fast就一定会在环中的某个节点处相遇，如果无环，则fast一定先到达空指针</p>
<p>判断有环后，令fast从当前节点开始，继续往下走（每次走一步），并记录步数，最终遇到slow时的步数就是环的长度. 求得环长后, 先令 <code>fast</code> 走环长距离, 然后再令 <code>slow</code> 和 <code>fast</code> 共同前进, 最终, 相遇点即为开始点.</p>
<p>该方法时间复杂度为 $O(n)$  空间复杂度为  $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* slow = pHead;</span><br><span class="line">        ListNode* fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(slow!=<span class="literal">nullptr</span> &amp;&amp; fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span> || fast-&gt;next-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123; <span class="comment">// 求环长</span></span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(step&gt;<span class="number">0</span>)&#123;<span class="comment">// 先让 fast 走环长距离</span></span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            step--;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = pHead;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123; <span class="comment">// 相遇点即为开始点</span></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-优化解法一"><a href="#解法二-优化解法一" class="headerlink" title="解法二: 优化解法一"></a>解法二: 优化解法一</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p><a href="https://blog.csdn.net/dawn_after_dark/article/details/82564271" target="_blank" rel="noopener">https://blog.csdn.net/dawn_after_dark/article/details/82564271</a></p>
<p><strong>比解法一更简洁的写法:</strong><br>上面在求环的开始节点时, 是先求环长, 再让 <code>fast</code> 走环长距离, 然后 <code>slow</code> 和 <code>fast</code> 同步前进, 最终相遇点即为开始点, 这么写比较容易理解, 但难免有些繁琐. 实际上, 我们只需要令 <code>fast=slow</code>, 然后再让 <code>slow</code> 从头开始, 即 <code>slow=0</code>, 接着令 <code>fast</code> 和 <code>slow</code> 同步前进, 那么相遇点就是开始节点. 该性质的证明如下:</p>
<p>假设链表首部到环入口点距离为 $x$, 环长为 $c$, 两者在环内相交的点距离环的入口为 $a$, <code>slow</code> 表示慢指针走的距离, <code>fast</code> 表示快指针走的距离, $n$, $m$ 分别表示快慢指针在相遇时已经走得多少环. $2\times slow = fast$ (因为快指针的速度是慢指针速度的2倍). 那么, 则有下面的公式关系:</p>
<script type="math/tex; mode=display">slow = x + mc + a</script><script type="math/tex; mode=display">fast = x + nc + a</script><script type="math/tex; mode=display">2\times slow = 2(x+mc+a) = x+nc+a = fast</script><script type="math/tex; mode=display">x = (n-2m)c - a = (n-2m-1)c + c - a</script><p>因此, 可以看出链表首部到环入口的距离实则为 $环长倍数+ c-a$, 而此时的环内相遇点 <code>slow</code> 要从当前位置再次回到环入口点所需要的步数也为 $环长倍数+ c-a$, 因此可以采用共同前进的方法, 并且相交点一定为环入口点, 代码如下所示.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *fast = pHead;</span><br><span class="line">        ListNode *slow = pHead;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>) <span class="keyword">return</span> fast; <span class="comment">// 不存在环</span></span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>) <span class="keyword">return</span> fast; <span class="comment">// 不存在环</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(slow!=fast);</span><br><span class="line"></span><br><span class="line">        fast = slow;</span><br><span class="line">        slow = pHead;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next; <span class="comment">// 共同前进</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三（牛客）：-断链法"><a href="#解法三（牛客）：-断链法" class="headerlink" title="解法三（牛客）： 断链法"></a>解法三（牛客）： 断链法</h2><p>同理，先判断有环无环</p>
<p>然后记录两个指针，一个当前节点指针cur，一个相邻祖先指针pre，每经过一个节点时，都将pre指针的next置为nullptr，则当cur的next为空时，既为环的首个节点。</p>
<p>该方法的时间复杂度为O(n)，且只需遍历两次，且第二次遍历的时候正好遍历n个节点，但是缺点是会破坏链结构，补救办法是使用额外的标记来替代断链，但是这样会增加额外空间开销</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* slow = pHead;</span><br><span class="line">        ListNode* fast = pHead;</span><br><span class="line">        <span class="keyword">if</span>(slow == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow!=<span class="literal">nullptr</span> &amp;&amp; fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span> || fast-&gt;next-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pHead-&gt;next == pHead) <span class="keyword">return</span> pHead;  <span class="comment">//需要特别考虑只有一个节点并且自己组成环的情况</span></span><br><span class="line">        slow = pHead;</span><br><span class="line">        fast = pHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            slow = fast;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="56-删除链表中重复的结点"><a href="#56-删除链表中重复的结点" class="headerlink" title="56.删除链表中重复的结点"></a>56.删除链表中重复的结点</h1><h2 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<h2 id="解法一（自想）：-3"><a href="#解法一（自想）：-3" class="headerlink" title="解法一（自想）："></a>解法一（自想）：</h2><p>这道题本身比较简单，只需要维护一个pre指针和cur指针，分别指向前一个结点和当前结点，如果当前结点和下一个结点的值相等，那么就删除当前结点，最后我pre指针的next值设置为指向未重复的结点</p>
<p>但是！本题恶心了我很久，一直报段错误，主要原因是有的结点没有做空判断，就访问了结点的val或者next成员，此时如果结点是空的，那么就会报段错误，主要有以下这么几个情况：</p>
<ul>
<li>头结点本身就是重复的，这个需要删除头结点，另外判断是否重复时，还要检查头结点的下一个结点是否为空，如果为空，则不能访问其val值，否则，报段错误</li>
<li>在进行重复判断时，访问<code>cur-&gt;next-&gt;val</code>时，需要先判断<code>cur-&gt;next</code>是否为空，如果为空，则不能访问其val值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pHead == nullptr || pHead-&gt;next == nullptr) return pHead;</span><br><span class="line">        ListNode* newHead = new ListNode(0); //  建立一个新的结点，其next用于标识头结点，以便在头结点重复时，指向新的头结点</span><br><span class="line">        newHead-&gt;next = pHead;</span><br><span class="line">        ListNode* cur = pHead;</span><br><span class="line">        ListNode* pre = newHead;</span><br><span class="line"></span><br><span class="line">        while(cur != nullptr &amp;&amp; cur-&gt;next !=nullptr)&#123;   // 注意   这里一定必须是 &amp;&amp; ，如果是|| ，则下面有可能会访问到空结点的val，造成段错误</span><br><span class="line"></span><br><span class="line">            if(cur-&gt;val == cur-&gt;next-&gt;val)&#123;</span><br><span class="line">                ListNode* dup = cur-&gt;next;</span><br><span class="line">                while(cur-&gt;val == dup-&gt;val &amp;&amp; dup!=nullptr)&#123;  // 同理，让验证所有欲访问的结点不为空</span><br><span class="line">                    dup = dup-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = dup;</span><br><span class="line">                pre-&gt;next = cur;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return newHead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="57-二叉树的下一个节点"><a href="#57-二叉树的下一个节点" class="headerlink" title="57.二叉树的下一个节点"></a>57.二叉树的下一个节点</h1><h1 id="58-对称的二叉树"><a href="#58-对称的二叉树" class="headerlink" title="58.对称的二叉树"></a>58.对称的二叉树</h1><h2 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="　题目描述"></a>　题目描述</h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<h2 id="解法一（牛客）：递归"><a href="#解法一（牛客）：递归" class="headerlink" title="解法一（牛客）：递归"></a>解法一（牛客）：递归</h2><p>要判断一个树是否对称，需要判断其树的左右子节点是否相等，同时还要判断左子树的右子树和右子树的左子树是否相等，以及左子树的左子树和右子树的右子树是否相等，然后如此递归解之：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymHelper(pRoot-&gt;left, pRoot-&gt;right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymHelper</span><span class="params">(TreeNode* subRoot1, TreeNode* subRoot2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subRoot1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> subRoot2==<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(subRoot2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(subRoot1-&gt;val != subRoot2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> b1 = isSymHelper(subRoot1-&gt;right, subRoot2-&gt;left);</span><br><span class="line">        <span class="keyword">bool</span> b2 = isSymHelper(subRoot1-&gt;left, subRoot2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> b1&amp;&amp;b2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二（牛客）：非递归"><a href="#解法二（牛客）：非递归" class="headerlink" title="解法二（牛客）：非递归"></a>解法二（牛客）：非递归</h2><p>关键还是知道怎么样才能判断一个<br>二叉树是否对称，只要采用前序、中序、后序、层次遍历等任何一种遍历方法，分为先左后右和先<br>右后左两种方法，只要两次结果相等就说明这棵树是一颗对称二叉树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//以下为层次遍历</span><br><span class="line">//与普通遍历不同的是，对于这道题，必须要把左右子树都存入到queue中，不论是否为空，因为只有这样才能将整个二叉树的结构存储起来，以便判断</span><br><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetrical(TreeNode* pRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q1;</span><br><span class="line">        queue&lt;TreeNode*&gt; q2;</span><br><span class="line">        if( nullptr==pRoot) return true;</span><br><span class="line">        q1.push(pRoot);</span><br><span class="line">        q2.push(pRoot);</span><br><span class="line">        TreeNode* cur1;</span><br><span class="line">        TreeNode* cur2;</span><br><span class="line">        while(!q1.empty() &amp;&amp; !q2.empty())&#123;</span><br><span class="line">            cur1 = q1.front(); q1.pop();</span><br><span class="line">            cur2 = q2.front(); q2.pop();</span><br><span class="line">            if(cur1 == cur2 &amp;&amp; nullptr == cur1)</span><br><span class="line">                continue;</span><br><span class="line">            if(nullptr == cur1 || nullptr == cur2)</span><br><span class="line">                return false;</span><br><span class="line">            if(cur1-&gt;val != cur2-&gt;val)</span><br><span class="line">                return false;</span><br><span class="line">            q1.push(cur1-&gt;left); q1.push(cur1-&gt;right);</span><br><span class="line">            q2.push(cur2-&gt;right); q2.push(cur2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三（牛客）：非递归"><a href="#解法三（牛客）：非递归" class="headerlink" title="解法三（牛客）：非递归"></a>解法三（牛客）：非递归</h2><p>=非递归算法，利用DFS和BFS===========================</p>
<p> BFS使用Queue来保存成对的节点</p>
<ol>
<li>出队的时候也是成对成对的<pre><code>       1.若都为空，继续；
        2.一个为空，返回false;
        3.不为空，比较当前值，值不等，返回false；
</code></pre><ol>
<li>确定入队顺序，每次入队都是成对成对的，如left.left， right.right ;left.rigth,right.left</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(pRoot-&gt;left); q.push(pRoot-&gt;right);</span><br><span class="line">        TreeNode* lnode; TreeNode* rnode;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            lnode = q.front(); q.pop();</span><br><span class="line">            rnode = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">nullptr</span> == lnode &amp;&amp; <span class="literal">nullptr</span> == rnode) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">nullptr</span> == lnode || <span class="literal">nullptr</span> == rnode) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(lnode-&gt;val != rnode-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            q.push(lnode-&gt;left); q.push(rnode-&gt;right);</span><br><span class="line">            q.push(lnode-&gt;right); q.push(rnode-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>DFS使用stack来保存成对的节点</p>
<ol>
<li>出栈的时候也是成对成对的 ，<pre><code>         1.若都为空，继续；
         2.一个为空，返回false;
         3.不为空，比较当前值，值不等，返回false；
</code></pre></li>
<li>确定入栈顺序，每次入栈都是成对成对的，如left.left， right.right ;left.rigth,right.left</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        s.push(pRoot-&gt;left);</span><br><span class="line">        s.push(pRoot-&gt;right);</span><br><span class="line">        TreeNode* lnode; TreeNode* rnode;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            rnode = s.top(); s.pop();</span><br><span class="line">            lnode = s.top(); s.pop();</span><br><span class="line">            <span class="keyword">if</span>( <span class="literal">nullptr</span>==lnode &amp;&amp; <span class="literal">nullptr</span> == rnode)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>( <span class="literal">nullptr</span> == lnode || <span class="literal">nullptr</span> == rnode)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(lnode-&gt;val != rnode-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            s.push(lnode-&gt;left); s.push(rnode-&gt;right);</span><br><span class="line">            s.push(lnode-&gt;right); s.push(rnode-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="59-按之字形顺序打印二叉树"><a href="#59-按之字形顺序打印二叉树" class="headerlink" title="59.按之字形顺序打印二叉树"></a>59.按之字形顺序打印二叉树</h1><h2 id="题目描述-44"><a href="#题目描述-44" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<h2 id="解法一（自想-差评）："><a href="#解法一（自想-差评）：" class="headerlink" title="解法一（自想, 差评）："></a>解法一（自想, 差评）：</h2><p>利用两个queue，一个用于层次遍历树节点，另一个用于存储对应节点的depth，然后每次访问节点时，都判断当前节点的层数，如果为奇数层，则将该层直接push back到结果向量中，如果为偶数，则将该层数据进行reverse后再push back到结果向量中。</p>
<p>时间复杂度为 $O(n^2)$  空间复杂度为 $O(n)$</p>
<p>需要注意的是最后一层的边界条件与其它层不同一样，需要专门判断以下，具体可以看下面的点注释。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q_node;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q_depth;</span><br><span class="line">        q_node.push(pRoot);</span><br><span class="line">        q_depth.push(<span class="number">1</span>);</span><br><span class="line">        TreeNode* cur; <span class="keyword">int</span> depth;</span><br><span class="line">        <span class="keyword">int</span> global_depth = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur_layer;</span><br><span class="line">        <span class="keyword">while</span>(!q_node.empty())&#123;</span><br><span class="line">            cur = q_node.front(); q_node.pop();</span><br><span class="line">            depth = q_depth.front(); q_depth.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                q_node.push(cur-&gt;left);</span><br><span class="line">                q_depth.push(depth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                q_node.push(cur-&gt;right);</span><br><span class="line">                q_depth.push(depth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(depth == global_depth)&#123;</span><br><span class="line">                cur_layer.push_back(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(q_node.empty())&#123;</span><br><span class="line">                  <span class="comment">// 对应最后一层的情况，当到了最后一层时，depth不会再继续增1了，</span></span><br><span class="line">                  <span class="comment">//所以不能通过global depth或depth的大小来判断是否进行pushback，</span></span><br><span class="line">                  <span class="comment">//需要通过看是否达到了最后一个节点来判断</span></span><br><span class="line">                    <span class="keyword">if</span>(global_depth % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                        res.push_back(cur_layer);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        reverse(cur_layer.begin(), cur_layer.end());</span><br><span class="line">                        res.push_back(cur_layer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(global_depth % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                    res.push_back(cur_layer);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    reverse(cur_layer.begin(), cur_layer.end());</span><br><span class="line">                    res.push_back(cur_layer);</span><br><span class="line">                &#125;</span><br><span class="line">                cur_layer.clear();</span><br><span class="line">                cur_layer.push_back(cur-&gt;val);</span><br><span class="line">                global_depth=depth;</span><br><span class="line">                <span class="keyword">if</span>(q_node.empty()) res.push_back(cur_layer);</span><br><span class="line">                <span class="comment">//这句话用于处理最后一层只有一个节点的情况，如果只有一个节点的话，</span></span><br><span class="line">                <span class="comment">//那么当前queue就为空，不会进入下一次循环，从而导致最后一层没有pushback进去</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二：利用reverse"><a href="#解法二：利用reverse" class="headerlink" title="解法二：利用reverse"></a>解法二：利用reverse</h2><p>同样的思路，另一种写法，更加简洁，通过while里面内置for循环，来保证每次for循环都会将一整层的节点放进队列中，无需额外的数组来存储depth信息<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">链接：https:<span class="comment">//www.nowcoder.com/questionTerminal/91b69814117f4e8097390d107d2efbe0</span></span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(pRoot);</span><br><span class="line">        <span class="keyword">bool</span> even = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">//将vec声明在内部，省去每次的clear操作，clear操作需要对vector进行遍历，并将每个元素置为null？</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> size = que.size(); <span class="comment">//当前存的节点数目就是这一层所有的节点，之前层的到已经被取出, 并且这一层的子节点还没有开始入队列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i)&#123; <span class="comment">//将该层所有节点的子节点入队列，同时当到达该层最后一个节点时终止</span></span><br><span class="line">                TreeNode* tmp = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                vec.push_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                    que.push(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                    que.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(even) <span class="comment">//根据奇偶标识判断是否需要reverse</span></span><br><span class="line">                <span class="built_in">std</span>::reverse(vec.begin(), vec.end());</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            even = !even;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法三-最优-不用reverse"><a href="#解法三-最优-不用reverse" class="headerlink" title="解法三: 最优(不用reverse)"></a>解法三: 最优(不用reverse)</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>在解法二中, 复杂度高的原因是因每次遇到偶数层的时候都要进行 reverse, 实际上, 当我们知道了该层的节点个数以后, 我们可以直接开辟一个指定大小的 vector, 然后根据下标随机访问来填入该层的节点值, 这样一来就不用进行 reverse, 并且空间复杂度与解法二相同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">bool</span> is_odd = <span class="literal">true</span>;</span><br><span class="line">        TreeNode* cur_node;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> layer_len = q.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur_layer(layer_len);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;layer_len; i++)&#123;</span><br><span class="line">                cur_node = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span>(is_odd==<span class="literal">true</span>)</span><br><span class="line">                    cur_layer[i] = cur_node-&gt;val;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cur_layer[layer_len<span class="number">-1</span>-i ] = cur_node-&gt;val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;left!=<span class="literal">nullptr</span>) q.push(cur_node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;right!=<span class="literal">nullptr</span>) q.push(cur_node-&gt;right);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(cur_layer);</span><br><span class="line">            is_odd = !is_odd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="60-把二叉树打印成多行"><a href="#60-把二叉树打印成多行" class="headerlink" title="60.把二叉树打印成多行"></a>60.把二叉树打印成多行</h1><h2 id="题目描述-45"><a href="#题目描述-45" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<h2 id="解法一（半自想）："><a href="#解法一（半自想）：" class="headerlink" title="解法一（半自想）："></a>解法一（半自想）：</h2><p>while循环加for循环，无需额外记录层数，具体看59题解法二分析</p>
<p>时间和空间复杂度为 $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">            <span class="keyword">if</span>(pRoot== <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="built_in">queue</span>&lt;TreeNode*&gt; q_node;</span><br><span class="line">            q_node.push(pRoot);</span><br><span class="line">            <span class="keyword">while</span>(!q_node.empty())&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur_layer;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> cur_size = q_node.size();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cur_size; i++)&#123;</span><br><span class="line">                    TreeNode* cur_node = q_node.front(); q_node.pop();</span><br><span class="line">                    cur_layer.push_back(cur_node-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(cur_node-&gt;left != <span class="literal">nullptr</span>) q_node.push(cur_node-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(cur_node-&gt;right != <span class="literal">nullptr</span>) q_node.push(cur_node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(cur_layer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="61-序列化二叉树"><a href="#61-序列化二叉树" class="headerlink" title="61.序列化二叉树"></a>61.序列化二叉树</h1><h1 id="62-二叉搜索树的第k个节点"><a href="#62-二叉搜索树的第k个节点" class="headerlink" title="62.二叉搜索树的第k个节点"></a>62.二叉搜索树的第k个节点</h1><h2 id="题目描述-46"><a href="#题目描述-46" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p>
<h2 id="解法一（自想）：-4"><a href="#解法一（自想）：-4" class="headerlink" title="解法一（自想）："></a>解法一（自想）：</h2><p>中根遍历，遍历到第k个节点时将其输出，如果k大于节点数量，输出nullptr, 时间复杂度 $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s_node;</span><br><span class="line">        TreeNode* P =  pRoot;</span><br><span class="line">        <span class="comment">//ctor&lt;TreeNode*&gt; vec_node;</span></span><br><span class="line">        <span class="keyword">int</span> cur_k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(P!=<span class="literal">nullptr</span> || !s_node.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(P!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s_node.push(P);</span><br><span class="line">                P = P-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!s_node.empty())&#123;</span><br><span class="line">                P = s_node.top(); s_node.pop();</span><br><span class="line">                cur_k++;</span><br><span class="line">                <span class="keyword">if</span>(cur_k == k) <span class="keyword">break</span>;</span><br><span class="line">                P = P-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur_k == k) <span class="keyword">return</span> P;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="63-数据流中的中位数"><a href="#63-数据流中的中位数" class="headerlink" title="63.数据流中的中位数"></a>63.数据流中的中位数</h1><h2 id="题目描述-47"><a href="#题目描述-47" class="headerlink" title="题目描述"></a>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<h2 id="解法一-自想-1"><a href="#解法一-自想-1" class="headerlink" title="解法一(自想):"></a>解法一(自想):</h2><p>插入时用vector的insert方法,按顺序插入,空间为 $O(n)$ ,时间复杂度为$O(n)$ 返回中位数时直接利用下标,时间复杂度和空间复杂度都为 $O(1)$.</p>
<p>这里关于vector的insert方法,有两个需要注意的点:</p>
<ul>
<li>it = vec.insert(it,num);  如果后序还要继续插入的话, 就必须将insert的结果重新赋值给it, 否则如果没有重新赋值而直接继续使用it的话,会导致段错误,  这里因为已经不需要继续插入了,所以可以用break直接跳出,无需赋值</li>
<li>插入时,如果num比vec里面所有的数都大, 那么会导致插入失败, 此时 ,应使用push_back将num插入到最后</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            vec.insert(vec.begin(), num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> is_insert=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=vec.begin(); it!=vec.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*it &gt; num)&#123;</span><br><span class="line">                vec.insert(it,num);</span><br><span class="line">                is_insert=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!is_insert) vec.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x1 = vec.size()/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> x2 = (vec.size()<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (vec[x1]+vec[x2])/<span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二:"></a>解法二:</h2><p>插入的时候不考虑排序,在查找中位数时可以使用基于Partition的方法,时间复杂度为 $O(n)$.</p>
<h2 id="解法三-AVL树"><a href="#解法三-AVL树" class="headerlink" title="解法三:AVL树"></a>解法三:AVL树</h2><p>插入时间复杂度为 $O(logn)$  找中位数时间复杂度为 $O(1)$</p>
<h2 id="解法四-牛客-用大顶堆和小顶堆"><a href="#解法四-牛客-用大顶堆和小顶堆" class="headerlink" title="解法四(牛客):用大顶堆和小顶堆"></a>解法四(牛客):用大顶堆和小顶堆</h2><p>思路:</p>
<p>如果能够保证数据容器左边的数据都小于右边的数据，这样即使左、右两边内部的数据没有排序，也可以根据左边最大的数及右边最小的数得到中位数。如何快速从一个容器中找出最大数？用最大堆实现这个数据容器，因为位于堆顶的就是最大的数据。同样，也可以快速从最小堆中找出最小数。　　因此可以用如下思路来解决这个问题：用一个最大堆实现左边的数据容器，用最小堆实现右边的数据容器。往堆中插入一个数据的时间效率是 O(logn)。由于只需 O(1)时间就可以得到位于堆顶的数据，因此得到中位数的时间效率是 O(1)。</p>
<p>首先要保证数据平均分配到两个堆中，因此两个堆中数据的数目之差不能超过 1</p>
<p>还要保证最大堆中里的所有数据都要小于最小堆中的数据</p>
<p>当数据的总数目是偶数时，按照前面分配的规则会把新的数据插入到最小堆中。如果此时新的数据比最大堆中的一些数据要小，怎么办呢？</p>
<p>可以先把新的数据插入到最大堆中，接着把最大堆中的最大的数字拿出来插入到最小堆中。由于最终插入到最小堆的数字是原最大堆中最大的数字，这样就保证了最小堆中的所有数字都大于最大堆中的数字。 当需要把一个数据插入到最大堆中，但这个数据小于最小堆里的一些数据时，这个情形和前面类似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::less&lt;<span class="keyword">int</span>&gt; &gt; q_max;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt; &gt; q_min;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( q_max.size()&gt; q_min.size() )&#123;</span><br><span class="line">            q_max.push(num);</span><br><span class="line">            <span class="keyword">int</span> tmp = q_max.top(); q_max.pop();</span><br><span class="line">            q_min.push(tmp);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            q_min.push(num);</span><br><span class="line">            <span class="keyword">int</span> tmp = q_min.top(); q_min.pop();</span><br><span class="line">            q_max.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res;</span><br><span class="line">        <span class="keyword">if</span>(q_max.size() == q_min.size())&#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = q_max.top();</span><br><span class="line">            <span class="keyword">int</span> x2 = q_min.top();</span><br><span class="line">            res = (x1+x2)/<span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res = q_max.top();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>插入时间复杂度为 $O(logn)$  找中位数时间复杂度为 $O(1)$</p>
<h1 id="64-滑动窗口的最大值"><a href="#64-滑动窗口的最大值" class="headerlink" title="64.滑动窗口的最大值"></a>64.滑动窗口的最大值</h1><h2 id="题目描述-48"><a href="#题目描述-48" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h2 id="解法一-自想-2"><a href="#解法一-自想-2" class="headerlink" title="解法一(自想):"></a>解法一(自想):</h2><p>用最直接的办法, 每次求出滑动窗口内的最大值, 然后存到max_res向量里面, 该方法时间复杂度为 $O(nm)$ . 空间为 $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; max_res;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> max_res; <span class="comment">//无符号整数, 要首先考虑size为0的情况, 否则会导致下面的程序数组越界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; num.size()-size+<span class="number">1</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp_max;</span><br><span class="line">            <span class="comment">//if(i&lt;num.size())  tmp_max = num[i]; //这里的if语句看起来是多余的, 实际上可以帮助进行数组越界检查, 有助于快速确定bug位置</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt; i+size ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[j] &gt; tmp_max) tmp_max = num[j]; <span class="comment">// 这里同样可以进行越界检查, 有助于bug定位, bug修复后可去掉</span></span><br><span class="line">            &#125;</span><br><span class="line">            max_res.push_back(tmp_max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-讨论区"><a href="#解法二-讨论区" class="headerlink" title="解法二(讨论区):"></a>解法二(讨论区):</h2><p>使用双端队列deque, 从下标0开始, 一直到n-1, 每次进行如下步骤:</p>
<ul>
<li>当前元素是否比队列中最后一个元素大, 如果大, 说明队列元素以后也不可能再成为较大值, 直接pop, 如此循环, 直到队列为空或者遇到比当前值大的元素</li>
<li>判断队列中队首的元素是否过期(若队空则直接下一步, 无需判断), 若过期, 则pop, 否则, 不管( 只看队首, 队内的元素是否过期不影响算法, 因为就算过期后面也会将其淘汰)</li>
<li>将当前元素的下标存到队尾</li>
<li>将新的队首元素存到结果向量max_res中</li>
</ul>
<p>注意: 队列里面存的是下标,  而不是元素本身的值,  后面在提到队列的元素值时,  均是指队列中存储的下标对应的元素值.</p>
<p>时间复杂度分析: 不是 $O(n*szie)$  而是 $O(n)$ ?</p>
<p>原因:  假设队列里面的正好包含size个元素(最多就为size个), 那么这三个元素对应的值一定是递减的,  因为如果不是递减中, 在进行第一个判断时, 就会将其移除,  此时, 如果新来了一个元素, 如果该元素值小于队列中所有的值, 那么就只可能进行一次判断, 而不是循环size次, 而如果均大于队列中的值, 那么队列中的元素个数就会变成1个,  这样, 在下次进行判断时, 只会与一个元素做判断,  如果是元素值位于中间, 那么下一次做判断的元素个数也会减少一部分, 综上, 内部while循环时, 相对于普通的循环嵌套,  该种循环可以认为是常数级(虽然还是与size的大小有关, 但是总体来说,  要做的判断次数比通常的循环小).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; max_res;</span><br><span class="line">        deque&lt;int&gt; dq_index;</span><br><span class="line">        for(int i =0; i&lt; num.size(); i++)&#123;</span><br><span class="line">            while(!dq_index.empty() &amp;&amp; num[i] &gt; num[dq_index.back()] )&#123;</span><br><span class="line">                dq_index.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            if(!dq_index.empty() &amp;&amp; i-dq_index.front()&gt;= size)</span><br><span class="line">                    dq_index.pop_front();</span><br><span class="line">            dq_index.push_back(i);</span><br><span class="line">            if(i&gt;=size-1)</span><br><span class="line">                max_res.push_back(num[dq_index.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        return max_res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="65-矩阵中的路径"><a href="#65-矩阵中的路径" class="headerlink" title="65.矩阵中的路径"></a>65.矩阵中的路径</h1><h2 id="题目描述-49"><a href="#题目描述-49" class="headerlink" title="题目描述"></a>题目描述</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一:"></a>解法一:</h2><p>这是一个可以用回朔法解决的典型题。首先，在矩阵中任选一个格子作为路径的起点。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符正好是ch，那么往相邻的格子寻找路径上的第i+1个字符。除在矩阵边界上的格子之外，其他格子都有4个相邻的格子。<br>重复这个过程直到路径上的所有字符都在矩阵中找到相应的位置。<br>　　由于回朔法的递归特性，路径可以被开成一个栈。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有找到第n+1个<br>字符，这个时候只要在路径上回到第n-1个字符，重新定位第n个字符。<br>　　由于路径不能重复进入矩阵的格子，还需要定义和字符矩阵大小一样的布尔值矩阵，用来标识路径是否已经进入每个格子。 当矩阵中坐标为（row,col）的<br>格子和路径字符串中相应的字符一样时，从4个相邻的格子(row,col-1),(row-1,col),(row,col+1)以及(row+1,col)中去定位路径字符串中下一个字符<br>如果4个相邻的格子都没有匹配字符串中下一个的字符，表明当前路径字符串中字符在矩阵中的定位不正确，我们需要回到前一个，然后重新定位。<br>　　一直重复这个过程，直到路径字符串上所有字符都在矩阵中找到合适的位置</p>
<p><strong>本题一定要注意边界条件即特殊情况的判断:</strong></p>
<ul>
<li>当矩阵所有元素一样时(这种情况一定要注意先)</li>
<li>当矩阵只有一个元素时(这两种情况要注意, 先进入递归程序, 然后再对flag矩阵进行判断, 否则, 当子串和矩阵大小一样时, 就无法判断到下一个字符是否==’\0’了)<br>-</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPath(char* matrix, int rows, int cols, char* str)</span><br><span class="line">    &#123;</span><br><span class="line">        if(str[0] == &apos;\0&apos;) return true;</span><br><span class="line"></span><br><span class="line">        int* flag_matrix = new int[rows*cols];</span><br><span class="line">        for(int i = 0; i&lt;rows; i++)&#123;</span><br><span class="line">            for(int j =0 ;j&lt;cols; j++)&#123;</span><br><span class="line">                flag_matrix[i*cols+j] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i&lt; rows; i++)&#123;</span><br><span class="line">            for(int j = 0;j&lt; cols; j++)&#123;</span><br><span class="line">                if(matrix[i*cols+j] == str[0])&#123;</span><br><span class="line">                    bool is_path = hasPath_helper(matrix,flag_matrix,i,j, rows, cols, str, 0);</span><br><span class="line">                    if(is_path)</span><br><span class="line">                        return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        delete []flag_matrix;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool hasPath_helper(char* matrix,int* flag_matrix, int i, int j, int rows, int cols, char* str,int x)&#123;</span><br><span class="line">        if(str[x] == &apos;\0&apos;) return true;</span><br><span class="line"></span><br><span class="line">        if(i&lt;0 || i&gt;=rows || j&lt;0 || j&gt;=cols) return false;</span><br><span class="line">        if(flag_matrix[i*cols+j] == 0 || matrix[i*cols+j] != str[x]) return false;</span><br><span class="line"></span><br><span class="line">        flag_matrix[i*cols+j] = 0;</span><br><span class="line">        bool is_path = hasPath_helper(matrix, flag_matrix, i, j-1, rows, cols, str, x+1) ||</span><br><span class="line">                       hasPath_helper(matrix, flag_matrix, i-1 , j, rows, cols, str, x+1) ||</span><br><span class="line">                       hasPath_helper(matrix, flag_matrix, i, j+1, rows, cols, str, x+1) ||</span><br><span class="line">                        hasPath_helper(matrix, flag_matrix, i+1, j, rows, cols, str, x+1);</span><br><span class="line">        flag_matrix[i*cols+j] = 1;</span><br><span class="line">        return is_path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="66-机器人的运动范围"><a href="#66-机器人的运动范围" class="headerlink" title="66.机器人的运动范围"></a>66.机器人的运动范围</h1><h2 id="题目描述-50"><a href="#题目描述-50" class="headerlink" title="题目描述"></a>题目描述</h2><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<h2 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一:"></a>解法一:</h2><p>回溯法, 如果当前节点的位数值满足要求, 那么从当前节点开始, 满足要求的格子数字应该等于” 1+左+右+上+下”, 其中方向代表这个方向上的满足要求的格子数.</p>
<p>注意每走过一次格子, 需要将flag矩阵中当前格子的标识设为”已走过(1)”,  并且, 由于此任务是统计符合条件的格子总数, 所以和一般的回溯法不同, 不能在递归结束后将该格子的标识重新复位(否则不同路径上回到同一个格子重复计数).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int mc_helper(int threshold,int cur_i, int cur_j, vector&lt; vector&lt;int&gt; &gt;&amp; flag_matrix)&#123;</span><br><span class="line">        int rows = flag_matrix.size();</span><br><span class="line">        int cols = flag_matrix[0].size();</span><br><span class="line">        int cur_val = cur_i/10 + cur_i%10 + cur_j/10 + cur_j%10;</span><br><span class="line"></span><br><span class="line">        if(cur_val &gt; threshold</span><br><span class="line">           || cur_i&lt;0 || cur_i &gt;=rows || cur_j&lt;0 || cur_j&gt;=cols</span><br><span class="line">           || flag_matrix[cur_i][cur_j]) return 0;</span><br><span class="line"></span><br><span class="line">        flag_matrix[cur_i][cur_j] = 1;</span><br><span class="line">        return 1 + mc_helper(threshold, cur_i, cur_j-1, flag_matrix)+</span><br><span class="line">                   mc_helper(threshold, cur_i, cur_j+1, flag_matrix)+</span><br><span class="line">                   mc_helper(threshold, cur_i-1, cur_j, flag_matrix)+</span><br><span class="line">                   mc_helper(threshold, cur_i+1, cur_j, flag_matrix);</span><br><span class="line">        //flag_matrix[cur_i][cur_j] = 0;</span><br><span class="line">        //return cur_count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int movingCount(int threshold, int rows, int cols)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if(rows&lt;=0 || cols&lt;=0) return 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        vector&lt; vector&lt;int&gt; &gt; flag_matrix(rows, vector&lt;int&gt;(cols));</span><br><span class="line">        int count = mc_helper(threshold,0, 0, flag_matrix);</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法刷题/" rel="tag"><i class="fa fa-tag"></i> 算法刷题</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/z_post/机器学习-聚类分析/" rel="prev" title="聚类分析">
                <i class="fa fa-chevron-left"></i> 聚类分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/z_post/计算机视觉-FCN-CVPR2015/" rel="next" title="FCN-CVPR2015">
                FCN-CVPR2015 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar_zz.png"
                alt="ZeroZone" />
            
              <p class="site-author-name" itemprop="name">ZeroZone</p>
              <p class="site-description motion-element" itemprop="description">并不是什么厉害的地方<br>只是一个安静的学习角落</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">263</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/hellozhaozheng" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:hellozhaozheng@foxmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/ksws0292756" title="零域CSDN博客" target="_blank">零域CSDN博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://xinghanzzy.github.io/" title="BoXiao的博客" target="_blank">BoXiao的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://oldpan.me/" title="Oldpan的博客" target="_blank">Oldpan的博客</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-二维数组中的查找"><span class="nav-text">1. 二维数组中的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-每一行用一次二分"><span class="nav-text">解法一: 每一行用一次二分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-从左下角开始"><span class="nav-text">解法二: 从左下角开始</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-替换空格"><span class="nav-text">2. 替换空格</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-1"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-从前向后记录空格，从后向前替换空格"><span class="nav-text">解法: 从前向后记录空格，从后向前替换空格</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-从尾到头打印链表"><span class="nav-text">3.从尾到头打印链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-2"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-reverse"><span class="nav-text">解法一: reverse</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-swap-实际上依然是reverse"><span class="nav-text">解法二: swap (实际上依然是reverse)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-栈"><span class="nav-text">解法三: 栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-重建二叉树"><span class="nav-text">4.重建二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-3"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-用两个栈实现队列"><span class="nav-text">5.用两个栈实现队列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-旋转数组的最小数字"><span class="nav-text">6.旋转数组的最小数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-斐波那契数列"><span class="nav-text">7.斐波那契数列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-超时-超内存"><span class="nav-text">解法一: 递归(超时,超内存)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-1"><span class="nav-text">解法二: 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-2"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-跳台阶"><span class="nav-text">8.跳台阶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-4"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-超时-超内存-1"><span class="nav-text">解法一: 递归(超时, 超内存)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-3"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-变态跳台阶"><span class="nav-text">9.变态跳台阶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-5"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-1"><span class="nav-text">解法一: 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-矩形覆盖"><span class="nav-text">10.矩形覆盖</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-超时"><span class="nav-text">解法一: 递归(超时)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-4"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-二进制中1的个数"><span class="nav-text">11.二进制中1的个数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-6"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-按位与-amp"><span class="nav-text">解法一: 按位与&amp;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-n-amp-n-1"><span class="nav-text">解法二: n&amp;(n-1)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-数值的整数次方"><span class="nav-text">12.数值的整数次方</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-7"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-2"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-非递归"><span class="nav-text">解法二: 非递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-调整数组顺序使奇数位于偶数前面"><span class="nav-text">13.调整数组顺序使奇数位于偶数前面</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-链表中倒数第k个节点"><span class="nav-text">14.链表中倒数第k个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-8"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-两个指针"><span class="nav-text">解法一: 两个指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-反转链表"><span class="nav-text">15.反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-9"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-两个指针pre和cur"><span class="nav-text">解法一: 两个指针pre和cur</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-合并两个排序的链表"><span class="nav-text">16.合并两个排序的链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-10"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-原地合并"><span class="nav-text">解法一: 原地合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-递归"><span class="nav-text">解法二: 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-树的子结构"><span class="nav-text">17.树的子结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-11"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-非递归"><span class="nav-text">解法一: 非递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-递归-1"><span class="nav-text">解法二: 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-二叉树的镜像"><span class="nav-text">18.二叉树的镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-12"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-3"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-非递归-1"><span class="nav-text">解法二: 非递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-顺时针打印矩阵"><span class="nav-text">19.顺时针打印矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-13"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-按层打印"><span class="nav-text">解法一: 按层打印</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-包含min函数的栈"><span class="nav-text">20.包含min函数的栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-14"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-利用辅助栈实现"><span class="nav-text">解法: 利用辅助栈实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-栈的压入、弹出序列"><span class="nav-text">21.栈的压入、弹出序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-15"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-模拟栈的压入-弹出"><span class="nav-text">解法: 模拟栈的压入, 弹出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-从上往下打印二叉树"><span class="nav-text">22.从上往下打印二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-16"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-层次遍历"><span class="nav-text">解法: 层次遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-二叉搜索树的后序遍历序列"><span class="nav-text">23.二叉搜索树的后序遍历序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-17"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-根据后序序列的特性设计递归判断规则"><span class="nav-text">解法: 根据后序序列的特性设计递归判断规则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-二叉树中和为某一值的路径"><span class="nav-text">24.二叉树中和为某一值的路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-18"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归解法"><span class="nav-text">解法一: 递归解法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-非递归-2"><span class="nav-text">解法二: 非递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25-复杂链表的复制"><span class="nav-text">25.复杂链表的复制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-19"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意"><span class="nav-text">注意</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正确解题思路："><span class="nav-text">正确解题思路：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-二叉搜索树与双向链表"><span class="nav-text">26.二叉搜索树与双向链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-20"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：自己的思路"><span class="nav-text">解法一：自己的思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：中序遍历，递归实现"><span class="nav-text">解法二：中序遍历，递归实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三：中序遍历，非递归实现"><span class="nav-text">解法三：中序遍历，非递归实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27-字符串的排列"><span class="nav-text">27.字符串的排列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-21"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归思路（没想到）："><span class="nav-text">解法一: 递归思路（没想到）：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-5"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28-数组中出现次数超过一半的数字"><span class="nav-text">28.数组中出现次数超过一半的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述："><span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思路一：如果数组是有序的，那么，出现次数超过数组长度一半的数字一定位于数组的中间位置，如果中间位置的数字出现次数小于数组长度的一半，那么就不存在。该方法需要进行排序，所以算法时间复杂度为-nlog-n-。"><span class="nav-text">思路一：如果数组是有序的，那么，出现次数超过数组长度一半的数字一定位于数组的中间位置，如果中间位置的数字出现次数小于数组长度的一半，那么就不存在。该方法需要进行排序，所以算法时间复杂度为 $nlog(n)$ 。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思路二：Patition"><span class="nav-text">思路二：Patition</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思路三：同增异减"><span class="nav-text">思路三：同增异减</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#29-最小的K个数"><span class="nav-text">29.最小的K个数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述：-1"><span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思路一：最直接的想法，就是先对数组排序，然后输出前k个数。复杂度为-nlog-n-n-。-快排"><span class="nav-text">思路一：最直接的想法，就是先对数组排序，然后输出前k个数。复杂度为 $nlog(n) + n$ 。 快排</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思路二：遍历整个数组，将当前元素与k-input数组进行比较，按照顺序插入，并且超出k的部分删除，最终直接返回k-input。时间复杂度-O-nk-。（该思想与冒泡排序思想类似）。"><span class="nav-text">思路二：遍历整个数组，将当前元素与k_input数组进行比较，按照顺序插入，并且超出k的部分删除，最终直接返回k_input。时间复杂度 $O(nk)$ 。（该思想与冒泡排序思想类似）。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-大顶堆"><span class="nav-text">解法三: 大顶堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-快速选择算法"><span class="nav-text">解法四: 快速选择算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问题扩展-1"><span class="nav-text">问题扩展 1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问题扩展-2"><span class="nav-text">问题扩展 2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#30-连续子数组的最大和"><span class="nav-text">30.连续子数组的最大和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-22"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：穷举"><span class="nav-text">解法一：穷举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：最优-两个变量记录sum"><span class="nav-text">解法二：最优-两个变量记录sum</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三：dp"><span class="nav-text">解法三：dp</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31-整数中1出现的次数（从1到整数n中1出现的次数）"><span class="nav-text">31.整数中1出现的次数（从1到整数n中1出现的次数）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-23"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一："><span class="nav-text">解法一：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二："><span class="nav-text">解法二：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三："><span class="nav-text">解法三：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四："><span class="nav-text">解法四：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#32-把数组排成最小的数"><span class="nav-text">32.把数组排成最小的数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述：-2"><span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#难点："><span class="nav-text">难点：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：-1"><span class="nav-text">解法一：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33-丑数"><span class="nav-text">33.丑数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述：-3"><span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：穷举判断"><span class="nav-text">解法一：穷举判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：根据丑数性质构造丑数"><span class="nav-text">解法二：根据丑数性质构造丑数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-最优"><span class="nav-text">解法三: 最优</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34-第一个只出现一次的字符"><span class="nav-text">34.第一个只出现一次的字符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-24"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）"><span class="nav-text">解法一（自想）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：牛客"><span class="nav-text">解法二：牛客</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#35-数组中的逆序对"><span class="nav-text">35.数组中的逆序对</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-25"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意："><span class="nav-text">注意：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自）"><span class="nav-text">解法一（自）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二（剑指）-归并排序-递归实现"><span class="nav-text">解法二（剑指）: 归并排序, 递归实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#这里需要注意的几点："><span class="nav-text">这里需要注意的几点：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三（剑指）-归并排序-迭代实现"><span class="nav-text">解法三（剑指）: 归并排序, 迭代实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#36-两个链表的第一个公共节点"><span class="nav-text">36.两个链表的第一个公共节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-26"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：栈"><span class="nav-text">解法一：栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#解法二-常数空间复杂度"><span class="nav-text">解法二: 常数空间复杂度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#37-数字在排序数组中出现的次数"><span class="nav-text">37.数字在排序数组中出现的次数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-27"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）-1"><span class="nav-text">解法一（自想）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：牛客-1"><span class="nav-text">解法二：牛客</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-解法二的非递归实现-更简洁易懂"><span class="nav-text">解法三: 解法二的非递归实现(更简洁易懂)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-寻找插入位置"><span class="nav-text">解法四: 寻找插入位置</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#38-二叉树的深度"><span class="nav-text">38.二叉树的深度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-28"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-非递归-1"><span class="nav-text">解法一: 非递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：牛客-2"><span class="nav-text">解法二：牛客</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39-平衡二叉树"><span class="nav-text">39.平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-29"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）-2"><span class="nav-text">解法一（自想）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40-数组中只出现一次的数字"><span class="nav-text">40.数组中只出现一次的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-30"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：异或"><span class="nav-text">解法一：异或</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展-数组中只有一个数出现一次，其他数都出现了2次，找出这个数字"><span class="nav-text">扩展: 数组中只有一个数出现一次，其他数都出现了2次，找出这个数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展-数组中只有一个数出现一次，其他数字都出现了3次-奇数次-，找出这个数字"><span class="nav-text">扩展: 数组中只有一个数出现一次，其他数字都出现了3次(奇数次)，找出这个数字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#41-和为S的连续正数序列"><span class="nav-text">41.和为S的连续正数序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-31"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）-3"><span class="nav-text">解法一（自想）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-等差序列求和公式"><span class="nav-text">解法二: 等差序列求和公式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#42-和为S的两个数字"><span class="nav-text">42.和为S的两个数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-32"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）-4"><span class="nav-text">解法一（自想）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#43-左旋转字符串"><span class="nav-text">43.左旋转字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-33"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）：利用str-substr-pos-n"><span class="nav-text">解法一（自想）：利用str.substr(pos,n)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二（牛客）：反转"><span class="nav-text">解法二（牛客）：反转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#44-翻转单词顺序列"><span class="nav-text">44.翻转单词顺序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-土办法"><span class="nav-text">解法一: 土办法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二（牛客）：利用reverse执行两次反转"><span class="nav-text">解法二（牛客）：利用reverse执行两次反转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#45-扑克牌顺子"><span class="nav-text">45.扑克牌顺子</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-34"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意-1"><span class="nav-text">注意:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-自想"><span class="nav-text">解法一(自想):</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二（牛客）：排序"><span class="nav-text">解法二（牛客）：排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#46-圆圈中最后剩下的数：约瑟夫（Josephuse）环问题"><span class="nav-text">46.圆圈中最后剩下的数：约瑟夫（Josephuse）环问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-35"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）：利用vector维护动态数组模拟约瑟夫环"><span class="nav-text">解法一（自想）：利用vector维护动态数组模拟约瑟夫环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二（牛客）：经典解法，用环形链表模拟圆圈"><span class="nav-text">解法二（牛客）：经典解法，用环形链表模拟圆圈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三（牛客）："><span class="nav-text">解法三（牛客）：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#47-非常规法求前n项和"><span class="nav-text">47.非常规法求前n项和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-36"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：构造函数"><span class="nav-text">解法一：构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：虚函数"><span class="nav-text">解法二：虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三：函数指针"><span class="nav-text">解法三：函数指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四：模板类"><span class="nav-text">解法四：模板类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#48-不用加减乘除做加法"><span class="nav-text">48.不用加减乘除做加法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#49-把字符串转换成整数"><span class="nav-text">49.把字符串转换成整数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-37"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）："><span class="nav-text">解法一（自想）：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意-2"><span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#50-数组中重复的数字"><span class="nav-text">50.数组中重复的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-38"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：暴力"><span class="nav-text">解法一：暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：哈希"><span class="nav-text">解法二：哈希</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三"><span class="nav-text">解法三</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#51-构建乘积数组"><span class="nav-text">51.构建乘积数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-39"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）：-1"><span class="nav-text">解法一（自想）：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#52-正则表达式匹配"><span class="nav-text">52.正则表达式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-40"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：（牛客）"><span class="nav-text">解法一：（牛客）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#53-表示数值的字符串"><span class="nav-text">53.表示数值的字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-41"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）：-2"><span class="nav-text">解法一（自想）：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#54-字符流中第一个不重复的字符"><span class="nav-text">54.字符流中第一个不重复的字符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（牛客）：哈希表"><span class="nav-text">解法一（牛客）：哈希表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#55-链表中环的入口节点"><span class="nav-text">55.链表中环的入口节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（牛客）-FLoyd-的乌龟和兔子"><span class="nav-text">解法一（牛客）: FLoyd 的乌龟和兔子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-优化解法一"><span class="nav-text">解法二: 优化解法一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三（牛客）：-断链法"><span class="nav-text">解法三（牛客）： 断链法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#56-删除链表中重复的结点"><span class="nav-text">56.删除链表中重复的结点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-42"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）：-3"><span class="nav-text">解法一（自想）：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#57-二叉树的下一个节点"><span class="nav-text">57.二叉树的下一个节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#58-对称的二叉树"><span class="nav-text">58.对称的二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-43"><span class="nav-text">　题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（牛客）：递归"><span class="nav-text">解法一（牛客）：递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二（牛客）：非递归"><span class="nav-text">解法二（牛客）：非递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三（牛客）：非递归"><span class="nav-text">解法三（牛客）：非递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#59-按之字形顺序打印二叉树"><span class="nav-text">59.按之字形顺序打印二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-44"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想-差评）："><span class="nav-text">解法一（自想, 差评）：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：利用reverse"><span class="nav-text">解法二：利用reverse</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-最优-不用reverse"><span class="nav-text">解法三: 最优(不用reverse)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#60-把二叉树打印成多行"><span class="nav-text">60.把二叉树打印成多行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-45"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（半自想）："><span class="nav-text">解法一（半自想）：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#61-序列化二叉树"><span class="nav-text">61.序列化二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#62-二叉搜索树的第k个节点"><span class="nav-text">62.二叉搜索树的第k个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-46"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一（自想）：-4"><span class="nav-text">解法一（自想）：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#63-数据流中的中位数"><span class="nav-text">63.数据流中的中位数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-47"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-自想-1"><span class="nav-text">解法一(自想):</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二"><span class="nav-text">解法二:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-AVL树"><span class="nav-text">解法三:AVL树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-牛客-用大顶堆和小顶堆"><span class="nav-text">解法四(牛客):用大顶堆和小顶堆</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#64-滑动窗口的最大值"><span class="nav-text">64.滑动窗口的最大值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-48"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-自想-2"><span class="nav-text">解法一(自想):</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-讨论区"><span class="nav-text">解法二(讨论区):</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#65-矩阵中的路径"><span class="nav-text">65.矩阵中的路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-49"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一"><span class="nav-text">解法一:</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#66-机器人的运动范围"><span class="nav-text">66.机器人的运动范围</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-50"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-1"><span class="nav-text">解法一:</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZeroZone</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">2.5m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">37:45</span>
  
</div>










  <div class="footer-custom">勤练带来力量</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  





  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


</body>
</html>
