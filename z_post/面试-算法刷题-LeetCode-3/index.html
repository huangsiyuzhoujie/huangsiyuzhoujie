<!DOCTYPE html>













<html class="theme-next gemini" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">

<meta name="google-site-verification" content="jgw73iXouBAJcOuff0yi9vdSNDecBSOUXacsHJszpmo" />
<meta name="baidu-site-verification" content="xyf9WD2vvl" />











<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/apple-icon-57x57.png?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_body":"slideDownIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="004. Median of Two Sorted ArraysDescription: 寻找两个有序数组的中位数There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time comple">
<meta name="keywords" content="算法刷题">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode算法题(Hard)">
<meta property="og:url" content="https://hellozhaozheng.github.io/z_post/面试-算法刷题-LeetCode-3/index.html">
<meta property="og:site_name" content="从零开始的BLOG">
<meta property="og:description" content="004. Median of Two Sorted ArraysDescription: 寻找两个有序数组的中位数There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time comple">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://wx3.sinaimg.cn/large/d7b90c85ly1fwj4ej0utpj20d904mglk.jpg">
<meta property="og:image" content="https://wx1.sinaimg.cn/large/d7b90c85ly1fx2pvbryaxj20if0l0js6.jpg">
<meta property="og:image" content="https://wx3.sinaimg.cn/large/d7b90c85ly1fx2qxg3740j20lf0j8t9r.jpg">
<meta property="og:image" content="https://wx4.sinaimg.cn/large/d7b90c85ly1fxr32nc4xoj215u0guq3p.jpg">
<meta property="og:updated_time" content="2019-07-07T12:30:35.590Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode算法题(Hard)">
<meta name="twitter:description" content="004. Median of Two Sorted ArraysDescription: 寻找两个有序数组的中位数There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time comple">
<meta name="twitter:image" content="https://wx3.sinaimg.cn/large/d7b90c85ly1fwj4ej0utpj20d904mglk.jpg">






  <link rel="canonical" href="https://hellozhaozheng.github.io/z_post/面试-算法刷题-LeetCode-3/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>LeetCode算法题(Hard) | 从零开始的BLOG</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?21a4899cc63d3c11a3d90ac58074a19c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">从零开始的BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">与其感慨路难行，不如马上出发</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档<span class="badge">263</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-计算机视觉">
    <a href="/categories/计算机视觉/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tripadvisor"></i> <br />计算机视觉</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-深度学习">
    <a href="/categories/深度学习/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-drupal"></i> <br />深度学习</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-caffe2">
    <a href="/categories/Caffe2/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-coffee"></i> <br />Caffe2</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-pytorch">
    <a href="/categories/PyTorch/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-free-code-camp"></i> <br />PyTorch</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-c++">
    <a href="/categories/Cpp/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-codiepie"></i> <br />C++</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-python">
    <a href="/categories/Python/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-product-hunt"></i> <br />Python</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-项目">
    <a href="/categories/项目/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-connectdevelop"></i> <br />项目</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-cuda">
    <a href="/categories/CUDA/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-braille"></i> <br />CUDA</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-其他">
    <a href="/categories/其他/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />其他</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签<span class="badge">40</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于我</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />站内搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="站内搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  
  
    
      
    
    <a href="https://github.com/hellozhaozheng" class="github-corner" target="_blank" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg>
    
      </a>
    



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hellozhaozheng.github.io/z_post/面试-算法刷题-LeetCode-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZeroZone">
      <meta itemprop="description" content="并不是什么厉害的地方<br>只是一个安静的学习角落">
      <meta itemprop="image" content="/images/avatar_zz.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始的BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">LeetCode算法题(Hard)
              
            
          </h1>
        

        <div class="post-meta">
	
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-03 08:54:54" itemprop="dateCreated datePublished" datetime="2018-10-03T08:54:54+08:00">2018-10-03</time>
            

            
          </span>

	  
  	    <span class="post-updated">
    		&nbsp; | &nbsp; 更新于
    		<time itemprop="dateUpdated" datetime="2019-07-07T20:30:35+08:00" content="2019-07-07">
      		  2019-07-07
    		</time>
  	  </span>
	  

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon"
            >
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">75k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1:08</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="004-Median-of-Two-Sorted-Arrays"><a href="#004-Median-of-Two-Sorted-Arrays" class="headerlink" title="004. Median of Two Sorted Arrays"></a>004. Median of Two Sorted Arrays</h1><h2 id="Description-寻找两个有序数组的中位数"><a href="#Description-寻找两个有序数组的中位数" class="headerlink" title="Description: 寻找两个有序数组的中位数"></a>Description: 寻找两个有序数组的中位数</h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume nums1 and nums2 cannot be both empty.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">The median is 2.0</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">The median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-根据中位数的特性"><a href="#解法一-根据中位数的特性" class="headerlink" title="解法一: 根据中位数的特性"></a>解法一: 根据中位数的特性</h2><p><strong>题目要求需要时间复杂度为 $O(log (m+n))$.</strong><br><strong>空间复杂度:</strong> $O(1)$, 未使用额外空间</p>
<p>首先我们思考中位数的作用: 中位数可以将一个数组分成两个长度相同的部分, 并且一部分中的数字总比另一部分中的小. 那么对于两个数组的情况, 我们需要做的就是找到一个数字, 可以使这两个数组分别分成两部分, <strong>这两部分长度相等(当个数为奇数时, 前一部分多一个元素), 同时前一部分的元素小于等于后一部分的元素</strong>. 首先,我们将数组 A 分成两部分, 由于 A 有 m 个数字,  所以它可以有 m 种不同的分法, 我们以下标 i 对应的数字为界限, 将A分成两部分, 前一部分的长度为 i (从0到 i-1 ), 后一部分的长度为 m-i (从 i 到 m-1): <code>A[1,2,...,i-1] | A[i, i+1, ..., m-1]</code>. 同理,数组 B 也可以做如下分割: <code>B[1,2,...,j-1] | B[j, j+1, ..., n-1]</code>.</p>
<p><strong>这里需要注意一个细节, 我们需要确保 A[i] 这个数字可以将两个数组等长的分割, 那么 A 数组的长度 <u>必须小于等于</u> B 数组的长度. 因为如果 A 数组的长度大于 B 数组的长度, 那么就会出现一种情况: A[i] 前的数字个数已经大于两数组总个数的一半, 此时无论如何也做不到等长分割, 因此, 我们需要先对数组长度判断, 令 A 数组代表的是较短的数组, 利用 <code>swap()</code> 方法可以在 $O(1)$ 时间复杂度内完成.</strong></p>
<p>当两个数组 A 和 B 都被分到了两部分以后, 将它们合起来, 第一部分的数字为 <code>A[1,2,...,i-1]</code> 和 <code>B[1,2,...,j-1]</code>, 第二部分的数字为 <code>A[i, i+1, ..., m-1]</code> 和 <code>B[j, j+1, ..., n-1]</code>, 我们并不关系两部分内部的顺序, 我们只关心一件事, 那就是: <strong>第一部分和第二部分的长度相等, 并且第一部分的数字都比第二部分小</strong>, 于是, i 和 j和取值就必须满足下列关系:</p>
<ul>
<li>i+j = m-i + n-j 或 m-i + n-j + 1   (加1的原因是因为有可能数组总长为奇数, 我们令前一部分比后一部分多1个元素)</li>
<li>i=0 或 A[i-1] &lt;= B[j] (前者说明 A 中元素全部被分配到后半段, 即前半段元素均由 B 中元素组成)</li>
<li>i=m 或 B[j-1] &lt;= A[i] (前者说明 A 中元素全部在前半段, 即后半段元素均由 B 中元素组成)</li>
<li>由于上式 i+j = m-i + n-j 或 m-i + n-j + 1 , 因此有 j = (m+n+1)/2 - i ;  (向下取整).  故而可以只对 i 进行判断 i 是否越界, 只要 i 满足条件,  j就不会等于0或n(前提条件是 A 数组长度小于等于 B 数组长度)</li>
</ul>
<p>根据上面的分析, 解题过程如下:</p>
<ul>
<li>根据两数组的长度, 将短的一方设为A数组 (j要对应较长的那个数组, 否则的话j有可能小于0 ), 令start=0, end=A.size</li>
<li>令 i=(start+end)/2</li>
<li>计算j = (m+n+1)/2 - i</li>
<li>判断当前 i 和 j 是否满足条件,有三种情况(对这三种情况不断重复, 直到i,j位置刚刚好):<ul>
<li>i &gt; 0 并且 A[i-1] &gt; B[j], 说明 i 的位置过大, 令 end = i-1.</li>
<li>i &lt; m 并且 B[j-1] &gt; A[i], 说明 i 的位置过小, 令 start = i+1;</li>
<li>其他情况(i==0 或 A[i-1] &lt;= B[j] 并且 i==m 或 B[j-1] &lt;= A[i]), 说明 i 和 j的位置刚刚好.</li>
</ul>
</li>
<li>当i,j位置刚好时, 根据数组整体长度的奇偶, 返回正确的中位数:<ul>
<li>奇数: 返回前半段的最大元素</li>
<li>偶数: 返回前半段最大元素和后半段最小元素的平均值</li>
</ul>
</li>
</ul>
<h3 id="非递归写法"><a href="#非递归写法" class="headerlink" title="非递归写法"></a>非递归写法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.size() &gt; nums2.size())</span><br><span class="line">            nums1.swap(nums2);</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end=m;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)&#123; <span class="comment">//当 start = end 时, 此时 i=start=end, 不能忽略</span></span><br><span class="line">            <span class="keyword">int</span> i = (start+end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = (n+m+<span class="number">1</span>)/<span class="number">2</span> - i;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums1[i<span class="number">-1</span>] &gt; nums2[j])  <span class="comment">//注意, i=0时说明位置恰好</span></span><br><span class="line">                end = i<span class="number">-1</span>; <span class="comment">//i太大</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i&lt;end &amp;&amp; nums2[j<span class="number">-1</span>] &gt; nums1[i])</span><br><span class="line">                start = i+<span class="number">1</span>; <span class="comment">// i太小</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> leftmax;<span class="comment">// 取左边最大的</span></span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) leftmax=nums2[j<span class="number">-1</span>];  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) leftmax=nums1[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> leftmax = max(nums1[i<span class="number">-1</span>], nums2[j<span class="number">-1</span>]) ;</span><br><span class="line">                <span class="keyword">if</span>( (n+m)%<span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> leftmax;  </span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> rightmin; <span class="comment">// 取右边最小的</span></span><br><span class="line">                <span class="keyword">if</span>(i==m) rightmin = nums2[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==n) rightmin = nums1[i];</span><br><span class="line">                <span class="keyword">else</span> rightmin = min(nums1[i] ,nums2[j]);</span><br><span class="line">                <span class="keyword">return</span> (leftmax+rightmin) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">       <span class="comment">// return 0.0;  //因为, 两数组不会同时为空, 所以这句话主要用于调试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h3><p><strong>写法一:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.size() &lt;= nums2.size())</span><br><span class="line">            <span class="keyword">return</span> helper(nums1, <span class="number">0</span> , nums1.size(),nums2);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> helper(nums2, <span class="number">0</span> , nums2.size(),nums1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = (start1+end1)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> j = (nums1.size()+nums2.size()+<span class="number">1</span>)/<span class="number">2</span> - i;</span><br><span class="line">        <span class="comment">// if(start1 &gt; end1) return 0.0; 因为数组一定是有效的, 因此不会出现这种情况</span></span><br><span class="line">        <span class="keyword">if</span>( (i==<span class="number">0</span> || nums1[i<span class="number">-1</span>]&lt;=nums2[j]) &amp;&amp; (i==nums1.size() || nums2[j<span class="number">-1</span>]&lt;=nums1[i]))&#123; <span class="comment">// 如果找到i</span></span><br><span class="line">            <span class="keyword">int</span> res11, res12;  </span><br><span class="line">            <span class="keyword">int</span> res21, res22;</span><br><span class="line">            <span class="comment">// 首先将左边部分的两个数组分别赋值, 如果i或j为0, 说明对应数组在左边</span></span><br><span class="line">            <span class="comment">//只有0个元素 , 将其赋值为INT_MIN(因为要取max(res11, res21))</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) res11= INT_MIN;          </span><br><span class="line">            <span class="keyword">else</span> res11=nums1[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>) res21= INT_MIN;</span><br><span class="line">            <span class="keyword">else</span> res21=nums2[j<span class="number">-1</span>];            </span><br><span class="line">            <span class="comment">//同理, 对右边进行处理, 取min(res12, res22)</span></span><br><span class="line">            <span class="keyword">if</span>(i==nums1.size()) res12= INT_MAX;</span><br><span class="line">            <span class="keyword">else</span> res12=nums1[i];</span><br><span class="line">            <span class="keyword">if</span>(j==nums2.size()) res22= INT_MAX;</span><br><span class="line">            <span class="keyword">else</span> res22=nums2[j];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据数组奇偶个数返回结果</span></span><br><span class="line">            <span class="keyword">if</span>((nums1.size() + nums2.size())%<span class="number">2</span> == <span class="number">1</span> )&#123;</span><br><span class="line">                <span class="keyword">return</span> max(res11, res21);</span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ( max(res11,res21)+min(res12,res22) ) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i<span class="number">-1</span>] &gt; nums2[j])&#123;</span><br><span class="line">            <span class="keyword">return</span> helper(nums1, start1, i<span class="number">-1</span>, nums2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> helper(nums1, i+<span class="number">1</span>, end1, nums2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>写法二:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.size() &gt; nums2.size())</span><br><span class="line">            <span class="keyword">return</span> helper(nums2, nums1, <span class="number">0</span>, nums2.size());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> helper(nums1, nums2, <span class="number">0</span>, nums1.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//if (start&gt;end) return 0.0; 因为数组一定是有效的, 因此不会出现这种情况</span></span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> i = (start+end)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> j = (m+n+<span class="number">1</span>)/<span class="number">2</span> - i;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums1[i<span class="number">-1</span>] &gt; nums2[j])</span><br><span class="line">            <span class="keyword">return</span> helper(nums1, nums2, start, i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i&lt;m &amp;&amp; nums2[j<span class="number">-1</span>] &gt; nums1[i])</span><br><span class="line">            <span class="keyword">return</span> helper(nums1, nums2, i+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> leftmax;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) leftmax = nums2[j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) leftmax = nums1[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> leftmax = max(nums1[i<span class="number">-1</span>], nums2[j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>((m+n)&amp;<span class="number">1</span> == <span class="number">1</span>) <span class="keyword">return</span> leftmax;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> rightmin;</span><br><span class="line">            <span class="keyword">if</span>(i==m) rightmin = nums2[j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==n) rightmin = nums1[i];</span><br><span class="line">            <span class="keyword">else</span> rightmin = min(nums1[i], nums2[j]);</span><br><span class="line">            <span class="keyword">return</span> (leftmax+rightmin)/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="010-Regular-Expression-Matching"><a href="#010-Regular-Expression-Matching" class="headerlink" title="010 Regular Expression Matching"></a>010 Regular Expression Matching</h1><h2 id="Description-正则表达式匹配"><a href="#Description-正则表达式匹配" class="headerlink" title="Description: 正则表达式匹配"></a>Description: 正则表达式匹配</h2><p>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’.</p>
<p>‘.’ Matches any single character.<br>‘*’ Matches zero or more of the preceding element.<br>The matching should cover the entire input string (not partial).</p>
<p><strong>Note:</strong><br>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like . or *.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &apos;*&apos; means zero or more of the precedeng element, &apos;a&apos;. Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-递归实现-速度很慢-只超过0-97-的提交"><a href="#解法一-递归实现-速度很慢-只超过0-97-的提交" class="headerlink" title="解法一: 递归实现( 速度很慢, 只超过0.97%的提交)"></a>解法一: 递归实现( 速度很慢, 只超过0.97%的提交)</h2><p>采用递归法, 首先判断当前字符串 p 是否已经走到尽头, 如果是, 则看 s 是否走到尽头, 返回 true 或者 false.<br>然后在第一个字符的匹配情况, 并记录之.<br>然后看是否存在 ‘<em>‘, 并根据情况进行递归调用.<br>若不存在 ‘</em>‘, 则按正常匹配处理.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> i, <span class="built_in">string</span> &amp;p, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(), m = p.size();</span><br><span class="line">        <span class="keyword">if</span> (j == m) <span class="keyword">return</span> (i == n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> firstMatch = (i != n <span class="keyword">and</span></span><br><span class="line">                            (s[i] == p[j] <span class="keyword">or</span> p[j] == <span class="string">'.'</span>));</span><br><span class="line">        <span class="keyword">if</span> (j &lt; m - <span class="number">1</span> <span class="keyword">and</span> p[j+<span class="number">1</span>] == <span class="string">'*'</span>) &#123; <span class="comment">//只有长度大于 2 的时候，才考虑 *</span></span><br><span class="line">            <span class="comment">//两种情况</span></span><br><span class="line">            <span class="comment">//pattern 直接跳过两个字符。表示 * 前边的字符出现 0 次</span></span><br><span class="line">            <span class="comment">//pattern 不变，例如 text = aa ，pattern = a*</span></span><br><span class="line">            <span class="keyword">return</span> helper(s, i, p, j+<span class="number">2</span>) <span class="keyword">or</span></span><br><span class="line">                    (firstMatch <span class="keyword">and</span> helper(s, i+<span class="number">1</span>, p, j));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//  </span></span><br><span class="line">            <span class="keyword">return</span> firstMatch <span class="keyword">and</span> helper(s, i+<span class="number">1</span>, p, j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-动态规划"><a href="#解法二-动态规划" class="headerlink" title="解法二: 动态规划"></a>解法二: 动态规划</h2><p>This problem has a typical solution using Dynamic Programming. We define the state P[i][j] to be true if s[0..i) matches p[0..j) and false otherwise. Then the state equations are:</p>
<ul>
<li>P[i][j] = P[i - 1][j - 1], if p[j - 1] != ‘*’ &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == ‘.’);</li>
<li>P[i][j] = P[i][j - 2], if p[j - 1] == ‘*’ and the pattern repeats for 0 times;</li>
<li>P[i][j] = P[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == ‘.’), if p[j - 1] == ‘*’ and the pattern repeats for at least 1 times.</li>
</ul>
<p>Putting these together, we will have the following code.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> dp[s.size()+<span class="number">1</span>][p.size()+<span class="number">1</span>]&#123;<span class="number">0</span>&#125;; <span class="comment">//!! 这里注意一定要初始化, 否则在下面的循环中, dp[2][0] 是循环不到的, 但是dp[2][2]会访问dp[2][0]的值, 如果不进行初始化, 就会发生 RuntimeError !!!</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;s.size()+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;p.size()+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j<span class="number">-1</span>] == <span class="string">'*'</span>) <span class="comment">//  注意这里是j-1</span></span><br><span class="line">                    dp[i][j] =  ( j &gt; <span class="number">1</span> &amp;&amp; dp[i][j<span class="number">-2</span>] )|| ( i&gt;<span class="number">0</span> &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] || p[j<span class="number">-2</span>] == <span class="string">'.'</span>) &amp;&amp; dp[i<span class="number">-1</span>][j]);  <span class="comment">// 注意这里是j-2, i-1, 一定要知道这些是为什</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = i&gt;<span class="number">0</span> &amp;&amp; dp[i<span class="number">-1</span>][j<span class="number">-1</span>] &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">'.'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size()][p.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="023-Merge-k-Sorted-Lists"><a href="#023-Merge-k-Sorted-Lists" class="headerlink" title="023. Merge k Sorted Lists"></a>023. Merge k Sorted Lists</h1><h2 id="Description-合并-k-个有序链表"><a href="#Description-合并-k-个有序链表" class="headerlink" title="Description: 合并 k 个有序链表"></a>Description: 合并 k 个有序链表</h2><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-基于比较的合并"><a href="#解法一-基于比较的合并" class="headerlink" title="解法一: 基于比较的合并"></a>解法一: 基于比较的合并</h2><p>时间复杂度: $O(k \times N)$  k为需要合并和链表个数, 在比较时需要遍历k个链表的头结点, 以便找出最小的. 每插入一个节点, 就要重新遍历一次, 故需要遍历 $N$ 次, $N$ 为所有链表的节点总数.<br>空间复杂度: $O(1)$</p>
<p>将该问题看做是两个有序链表的合并问题, 只不过每次选择最小的节点时, 需要从vector.size()个节点中选择, 同时还要注意及时移除vector中已经走到头的空链表, 并判断size当前的大小, 当vector中的size大小为1时, 说明其余链表都已经合并完成, 此时退出循环, 直接将该链表接入即可.</p>
<p>另外要注意vector为空, 以及vector中全是nullptr链表的特殊情况.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">//处理[]的情况</span></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur_node = dummy;</span><br><span class="line">        <span class="keyword">while</span>(lists.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> min_node_index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;lists.size() ;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lists[i] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    lists.erase(lists.begin()+i);</span><br><span class="line">                    i--; <span class="comment">//移除第i个元素后, 下一个元素会自动成为第i个元素,因此, 将当前i--</span></span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// continue后, i会++, 最终i指向了下一个元素</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(lists[min_node_index]-&gt;val &gt; lists[i]-&gt;val)&#123;</span><br><span class="line">                    min_node_index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(lists.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">//主要是应对 [[], []] 的情况, 本身vector的size大于0, 但是经过erase以后size就变成0了, 此时应返回nullptr</span></span><br><span class="line">            cur_node-&gt;next = lists[min_node_index];</span><br><span class="line">            cur_node = cur_node-&gt;next;</span><br><span class="line">            lists[min_node_index] = lists[min_node_index]-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(lists[min_node_index] == <span class="literal">nullptr</span>) lists.erase(lists.begin()+min_node_index);</span><br><span class="line">        &#125;</span><br><span class="line">        cur_node-&gt;next = lists[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-用小顶堆对解法一的比较操作进行优化"><a href="#解法二-用小顶堆对解法一的比较操作进行优化" class="headerlink" title="解法二: 用小顶堆对解法一的比较操作进行优化"></a>解法二: 用小顶堆对解法一的比较操作进行优化</h2><p>时间复杂度: $O(logk \times N)$, N 代表所有链表的节点总数.<br>空间复杂度: $O(k)$  由于要构造堆, 所以需要额外空间</p>
<p>由于我们只需要找到k个节点里面数值最小的那一个, 因此可以利用Priority Queue (实际上就是大顶堆和小顶堆)对上面的比较操作进行优化, 使得比较操作的复杂度从 $k$ 降到 $logk$. 由于每个节点都会进入小顶堆一次, 所有总共需要执行 $N$ 次入堆操作, 故最终的复杂度的 $logk\times N$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 用函数对象进行比较</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode *node1, ListNode *node2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node1-&gt;val &gt; node2-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;ListNode *, <span class="built_in">vector</span>&lt;ListNode *&gt;, cmp&gt; min_heap;</span><br><span class="line">        <span class="comment">// 用 lambda 表达式进行比较</span></span><br><span class="line">        <span class="comment">// auto cmp = [](ListNode* node1, ListNode* node2) &#123;</span></span><br><span class="line">        <span class="comment">//     return node1-&gt;val &gt; node2-&gt;val; // 小顶堆</span></span><br><span class="line">        <span class="comment">// &#125;;</span></span><br><span class="line">        <span class="comment">//priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, decltype(cmp)&gt; min_heap(cmp);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> node_head : lists)</span><br><span class="line">            <span class="keyword">if</span>(node_head!=<span class="literal">nullptr</span>) min_heap.push(node_head);</span><br><span class="line">        <span class="keyword">if</span>(min_heap.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(!min_heap.empty())&#123;</span><br><span class="line">            ListNode *tmp = min_heap.top(); min_heap.pop();</span><br><span class="line">            cur-&gt;next = tmp;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;next != <span class="literal">nullptr</span>) min_heap.push(tmp-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-转化成双列表合并问题"><a href="#解法三-转化成双列表合并问题" class="headerlink" title="解法三: 转化成双列表合并问题"></a>解法三: 转化成双列表合并问题</h2><p>时间复杂度: $O(k \times N)$<br>空间复杂度: $O(1)$</p>
<p>双列表合并问题的时间复杂度为 $O(m+n)$ , 可以将多链表合并问题看做是k次双列表合并.</p>
<h2 id="解法四-对解法三进行优化"><a href="#解法四-对解法三进行优化" class="headerlink" title="解法四: 对解法三进行优化"></a>解法四: 对解法三进行优化</h2><p>时间复杂度: $O(logk \times N)$<br>空间复杂度: $O(1)$</p>
<p>对列表合并时, 每次都是两两合并(不是解法三中的逐一合并), 这样, 只需要经过 $logk$ 次两两合并就可完成所有合并过程.</p>
<p><strong>迭代实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span></span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">nullptr</span>) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">else</span> cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> len = lists.size();</span><br><span class="line">        <span class="keyword">int</span> interval = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(interval &lt; len)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+interval&lt;len; i+= <span class="number">2</span>*interval)&#123;<span class="comment">//i应满足: 0,2,4... / 0,4,.. / 0</span></span><br><span class="line">                lists[i] = mergeTwoLists(lists[i], lists[i+interval]);<span class="comment">//i+interval必须&lt;len, 否则溢出</span></span><br><span class="line">            &#125;</span><br><span class="line">            interval *= <span class="number">2</span>; <span class="comment">//区间大小翻倍</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>递归实现:</strong> 递归实现需要额外的 $O(logk)$ 的栈空间(调用递归的次数)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span></span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">nullptr</span>) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">else</span> cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists[start];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">            ListNode* l1 = partition(lists, start, mid);</span><br><span class="line">            ListNode* l2 = partition(lists, mid+<span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(l1, l2);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> partition(lists, <span class="number">0</span>, lists.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>将双链表合并也写成递归形式:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l2==<span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists[start];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">            ListNode* l1 = partition(lists, start, mid);</span><br><span class="line">            ListNode* l2 = partition(lists, mid+<span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(l1, l2);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> partition(lists, <span class="number">0</span>, lists.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="041-First-Missing-Positive"><a href="#041-First-Missing-Positive" class="headerlink" title="041. First Missing Positive"></a>041. First Missing Positive</h1><p>寻找数组中缺失的最小的正数</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an unsorted integer array, find the smallest missing positive integer.</p>
<p>Example 1:</p>
<p>Input: [1,2,0]<br>Output: 3<br>Example 2:</p>
<p>Input: [3,4,-1,1]<br>Output: 2<br>Example 3:</p>
<p>Input: [7,8,9,11,12]<br>Output: 1<br>Note:</p>
<p>Your algorithm should run in O(n) time and uses constant extra space.</p>
<h2 id="解法一-下标与正数对应"><a href="#解法一-下标与正数对应" class="headerlink" title="解法一: 下标与正数对应"></a>解法一: 下标与正数对应</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$ (但是对改变了原始的数组, 这是一个小缺陷)</p>
<p>将下标与正数相应对, 例如对于正数5, 我们就将放置在nums[4]上, 这样一来, 再次遍历数组的时候, 当遇到第一个与下标不对应的数字时, 该下标对应的正数(i+1)就是缺少的正数.</p>
<p>放置正数到正确位置上时, 需要注意几点:</p>
<ul>
<li>swap之后需要继续将原来位置上(nums[4])的数放置到正确的位置上, 这里需要一个while循环</li>
<li>在检查数组时, 如果所有数组内所有数字都处在正确位置上, 那么就应该返回nums.size+1 (包括了数组为空的情况: 返回0+1=1)</li>
</ul>
<p><strong>写法一: for+while</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="comment">// 注意这些条件: 前两个是为了令交换下标合法, 后一个是防止相同的数交换, 造成死循环</span></span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i]&lt;nums.size() &amp;&amp; nums[i] != nums[nums[i]<span class="number">-1</span>])</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[i], nums[nums[i]<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size()+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>写法二: while</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;nums.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span> &amp;&amp;nums[i]&lt;nums.size() &amp;&amp; nums[i] != nums[nums[i]<span class="number">-1</span>])</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[i], nums[nums[i]<span class="number">-1</span>]); <span class="comment">// 如果进行了swap, 就不要i++</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size()+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-哈希"><a href="#解法二-哈希" class="headerlink" title="解法二: 哈希"></a>解法二: 哈希</h2><p><strong>时间复杂度:</strong> $O(n)$ (3次for循环, 毫无争议的 $O(n)$ )<br><strong>空间复杂度:</strong> $O(1)$ (但是对改变了原始的数组, 这是一个小缺陷)</p>
<p><strong>注意:</strong> 虽然这里的时间复杂度是毫无争议的 $O(n)$ , 但是不一定会上面的速度快, 因为上面只有两次循环, 内第一次内部的循环次数一般情况下都不会很大.</p>
<p><strong>从哈希的角度理解: 可以将数组下标看成是hash的key</strong></p>
<ol>
<li>for any array whose length is l, the first missing positive must be in range [1,…,l+1],<br> so we only have to care about those elements in this range and remove the rest.</li>
<li>we can use the array index as the hash to restore the frequency of each number within<br>  the range [1,…,l+1]</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 丢失的最小正数只可能在 [1,2,...,nums.size()+1] 之间</span></span><br><span class="line">        <span class="comment">// 这里的pushback是必须的, 因为下面会将不符合要求的元素都置为0,</span></span><br><span class="line">        <span class="comment">//因此nums[0]需要与0对应, 以代表所有的非法元素,</span></span><br><span class="line">        <span class="comment">//这点与上面基于swap的方法不同, 上面的swap是让nums[0] 与 1 对应.</span></span><br><span class="line">        nums.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt;length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span> || nums[i] &gt;= length)</span><br><span class="line">                nums[i] = <span class="number">0</span>; <span class="comment">// 将所有不符合丢失正数的数移除, 这一步必须单独用一个for循环做</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">            nums[nums[i]%length] += length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]/length == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="042-Trapping-Rain-Water"><a href="#042-Trapping-Rain-Water" class="headerlink" title="042 Trapping Rain Water"></a>042 Trapping Rain Water</h1><p>数组中每个值代表柱状体的高度, 每个柱状体的宽度都为1, 根据数组内的值组成的高低不同的块, 能够存储多少个bin (1×1)的水</p>
<h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p><img src="https://wx3.sinaimg.cn/large/d7b90c85ly1fwj4ej0utpj20d904mglk.jpg" alt=""></p>
<p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p>
<p>Example:</p>
<p>Input: [0,1,0,2,1,0,1,3,2,1,2,1]<br>Output: 6</p>
<h2 id="解法一-左右指针"><a href="#解法一-左右指针" class="headerlink" title="解法一: 左右指针"></a>解法一: 左右指针</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>分别用两个变量left和right指向左边和右边的柱子, 并再用两个变量maxleft和maxright维护左边最高的柱子和右边最高的柱子, 统计的时候, 先固定left和right当中柱子高度较高的那一个, 然后统计较低柱子上存储的水量. 利用, 如果当前left的高度小于right的高度, 则我们计算left上面能够存储的水量, 有两种情况, 当left柱子的高度大于等于maxleft时, 则left柱子上没法存储水, 因为谁会从左边全部流失(右边比左边高, 所以不会从右边流失).  如果left的高度小于maxleft时, 由于水无法从左边流失, 也不能从右边流失, 因此当前柱子上就会存储水, 存储的水量为<code>maxleft-height[left]</code> (不考虑maxright, 因为maxright大于maxleft).</p>
<p><strong>注意:</strong> 此题中的柱子是有 <strong>宽度</strong> 的, 这一点很重要, 如果柱子的宽度为0 , 那么就是另一种情况了.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = height.size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, maxleft = <span class="number">0</span>, maxright = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt;= height[right])&#123; <span class="comment">//固定较大的一个柱子</span></span><br><span class="line">                <span class="keyword">if</span>(height[left] &gt; maxleft) maxleft = height[left];<span class="comment">// 如果当前柱子的高度大于左边max柱子的高度, 那么该柱子所处位置一定存不下水</span></span><br><span class="line">                <span class="keyword">else</span> res = res + maxleft - height[left]; <span class="comment">// 反之, 该柱子位置上可以存储的水的量为 坐标max高度减去当前的高度</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(height[right] &gt; maxright) maxright = height[right];</span><br><span class="line">                <span class="keyword">else</span> res = res + maxright - height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>更简洁的写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.size() <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLH = height[left], maxRH = height[right];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            maxLH = <span class="built_in">std</span>::max(maxLH, height[left]);</span><br><span class="line">            maxRH = <span class="built_in">std</span>::max(maxRH, height[right]);</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                res += maxLH - height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += maxRH - height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="044-Wildcard-Matching"><a href="#044-Wildcard-Matching" class="headerlink" title="044. Wildcard Matching"></a>044. Wildcard Matching</h1><h2 id="Description-通配符匹配"><a href="#Description-通配符匹配" class="headerlink" title="Description: 通配符匹配"></a>Description: 通配符匹配</h2><p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*’.</p>
<p>‘?’ Matches any single character.<br>‘*’ Matches any sequence of characters (including the empty sequence).<br>The matching should cover the entire input string (not partial).</p>
<p>Note:</p>
<p>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like ? or *.<br>Example 1:</p>
<p>Input:<br>s = “aa”<br>p = “a”<br>Output: false<br>Explanation: “a” does not match the entire string “aa”.<br>Example 2:</p>
<p>Input:<br>s = “aa”<br>p = “<em>“<br>Output: true<br>Explanation: ‘</em>‘ matches any sequence.<br>Example 3:</p>
<p>Input:<br>s = “cb”<br>p = “?a”<br>Output: false<br>Explanation: ‘?’ matches ‘c’, but the second letter is ‘a’, which does not match ‘b’.<br>Example 4:</p>
<p>Input:<br>s = “adceb”<br>p = “<em>a</em>b”<br>Output: true<br>Explanation: The first ‘<em>‘ matches the empty sequence, while the second ‘</em>‘ matches the substring “dce”.<br>Example 5:</p>
<p>Input:<br>s = “acdcb”<br>p = “a*c?b”<br>Output: false</p>
<h2 id="解法一-迭代"><a href="#解法一-迭代" class="headerlink" title="解法一: 迭代"></a>解法一: 迭代</h2><p><strong>时间复杂度:</strong> $O(m+n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>对于每次循环迭代, <code>i</code>和<code>j</code>其中至少有一个前进一步, 所以时间复杂度为 $O(m+n)$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> m = p.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> star_index = <span class="number">-1</span>, match = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; m <span class="keyword">and</span> (s[i] == p[j] <span class="keyword">or</span> p[j] == <span class="string">'?'</span>)) &#123; <span class="comment">// 单个字符匹配, i, j继续匹配下一个</span></span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; m <span class="keyword">and</span> p[j] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                star_index = j; <span class="comment">// 如果当前字符为 *, 则有可能如0或若干个字符匹配, 首先假设至于0个字符匹配</span></span><br><span class="line">                match = i; <span class="comment">// 只与0个字符匹配时, 记录当前i的值, 然后将j++, i不变</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (star_index != <span class="number">-1</span>) &#123; <span class="comment">// 如果前面两个条件都不满足, 说明之间的匹配方法不正确, 此时重新从前一个 * 开始匹配</span></span><br><span class="line">                match++; <span class="comment">// 令 * 与之前标记的未匹配的i进行匹配, 然后将标记往后移一位</span></span><br><span class="line">                i = match; <span class="comment">// 令 i 和 j 都等于下一个字符, 继续匹配过程</span></span><br><span class="line">                j = star_index+<span class="number">1</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> jj = j ; jj &lt; m; jj++) &#123; <span class="comment">// 当 i==n 退出循环时, j 有可能还未达到m, 因为有可能是 ***** 的形式</span></span><br><span class="line">            <span class="keyword">if</span> (p[jj] != <span class="string">'*'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-DP"><a href="#解法二-DP" class="headerlink" title="解法二: DP"></a>解法二: DP</h2><p><strong>时间复杂度:</strong> $O(nm)$, $n$ 为<code>s</code>的长度, $m$ 为<code>p</code>的长度<br><strong>空间复杂度:</strong> $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pLen = p.size(), sLen = s.size(), i, j, k, cur, prev;</span><br><span class="line">        <span class="keyword">if</span>(!pLen) <span class="keyword">return</span> sLen == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> matched[<span class="number">2</span>][sLen+<span class="number">1</span>];</span><br><span class="line">        fill_n(&amp;matched[<span class="number">0</span>][<span class="number">0</span>], <span class="number">2</span>*(sLen+<span class="number">1</span>), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        matched[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=pLen; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = i%<span class="number">2</span>, prev= <span class="number">1</span>-cur;</span><br><span class="line">            matched[cur][<span class="number">0</span>]= matched[prev][<span class="number">0</span>] &amp;&amp; p[i<span class="number">-1</span>]==<span class="string">'*'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p[i<span class="number">-1</span>]==<span class="string">'*'</span>) <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=sLen; ++j) matched[cur][j] = matched[cur][j<span class="number">-1</span>] || matched[prev][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=sLen; ++j)            matched[cur][j] =  matched[prev][j<span class="number">-1</span>] &amp;&amp; (p[i<span class="number">-1</span>]==<span class="string">'?'</span> || p[i<span class="number">-1</span>]==s[j<span class="number">-1</span>]) ;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> matched[cur][sLen];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-DP"><a href="#解法三-DP" class="headerlink" title="解法三: DP"></a>解法三: DP</h2><p><strong>时间复杂度:</strong> $O(nm)$, $n$ 为<code>s</code>的长度, $m$ 为<code>p</code>的长度<br><strong>空间复杂度:</strong> $O(nm)$</p>
<p>采用和第 10 题相同的思路, 令<code>dp[i][j]</code>代表<code>s[0, i)</code>和<code>p[0,j)</code>是否匹配, 该解法的空间复杂度比解法二高.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> m = p.size();</span><br><span class="line">        <span class="keyword">bool</span> dp[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">std</span>::fill_n(&amp;dp[<span class="number">0</span>][<span class="number">0</span>], (n+<span class="number">1</span>)*(m+<span class="number">1</span>), <span class="literal">false</span>); <span class="comment">// 用 fill_n 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j<span class="number">-1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    dp[i][j] = (i &gt; <span class="number">0</span> <span class="keyword">and</span> dp[i<span class="number">-1</span>][j]) <span class="keyword">or</span> (dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = i &gt; <span class="number">0</span> <span class="keyword">and</span> dp[i<span class="number">-1</span>][j<span class="number">-1</span>] <span class="keyword">and</span> (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] <span class="keyword">or</span> p[j<span class="number">-1</span>] == <span class="string">'?'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="076-Minimum-Window-Substring"><a href="#076-Minimum-Window-Substring" class="headerlink" title="076. Minimum Window Substring"></a>076. Minimum Window Substring</h1><p>求包含子串字符的最小窗口</p>
<h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>
<p>Example:</p>
<p>Input: S = “ADOBECODEBANC”, T = “ABC”<br>Output: “BANC”<br>Note:</p>
<p>If there is no such window in S that covers all characters in T, return the empty string “”.<br>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</p>
<h2 id="解法-两个变量记录当前窗口大小"><a href="#解法-两个变量记录当前窗口大小" class="headerlink" title="解法: 两个变量记录当前窗口大小"></a>解法: 两个变量记录当前窗口大小</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hmap(<span class="number">256</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:t) hmap[<span class="keyword">int</span>(c)]++;</span><br><span class="line">        <span class="keyword">int</span> count = t.size(), begin=<span class="number">0</span>, end=<span class="number">0</span>, head=<span class="number">0</span>, cur_window=INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(end&lt;s.size())&#123;</span><br><span class="line">            <span class="comment">// 这里可以直接写成 if(hmap[int(s[end++])]-- &gt; 0) count--;  但是可读性很差,  不建议这样写.</span></span><br><span class="line">            <span class="keyword">if</span>(hmap[<span class="keyword">int</span>(s[end])] &gt; <span class="number">0</span>) count--;</span><br><span class="line">            hmap[<span class="keyword">int</span>(s[end])]--; end++;</span><br><span class="line">            <span class="keyword">while</span>(count==<span class="number">0</span>)&#123; <span class="comment">//end 超尾</span></span><br><span class="line">                <span class="keyword">if</span>( (end-begin) &lt; cur_window) cur_window = end - (head=begin);</span><br><span class="line">                <span class="comment">// 同样, 可以直接写成 if(hmap[int(s[begin++])]++ &gt; 0) count++;  但是可读性很差</span></span><br><span class="line">                <span class="keyword">if</span>(hmap[<span class="keyword">int</span>(s[begin])] == <span class="number">0</span>) count++;</span><br><span class="line">                hmap[<span class="keyword">int</span>(s[begin])]++; begin++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur_window==INT_MAX ? <span class="string">""</span> : s.substr(head, cur_window);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="子串相关题目的模板解法"><a href="#子串相关题目的模板解法" class="headerlink" title="子串相关题目的模板解法"></a>子串相关题目的模板解法</h2><p><a href="https://leetcode.com/problems/minimum-window-substring/discuss/26808/Here-is-a-10-line-template-that-can-solve-most-&#39;substring&#39;-problems" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-window-substring/discuss/26808/Here-is-a-10-line-template-that-can-solve-most-&#39;substring&#39;-problems</a></p>
<p>对于大多数的子串相关的问题, 通常可以描述为给定一个字符串, 要求找到满足某些限制条件的子串, 这类都可以用下面的基于哈希表和两个辅助指示变量的模板来求解:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hmap(<span class="number">128</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">// 用于检查子串是否合法</span></span><br><span class="line">    <span class="keyword">int</span> begin=<span class="number">0</span>, end=<span class="number">0</span>; <span class="comment">// 两个指示变量, 分别指向子串的头和尾(end会在++后退出循环, 因此最后end会变成超尾)</span></span><br><span class="line">    <span class="keyword">int</span> len_sub; <span class="comment">// 子串的长度</span></span><br><span class="line">    <span class="keyword">for</span>()&#123; &#125;<span class="comment">//对hasp map进行初始化</span></span><br><span class="line">    <span class="keyword">while</span>(end&lt;s.size())&#123;</span><br><span class="line">        <span class="comment">//if(hmap[s[end++]]-- ? ) &#123; &#125; //修改count</span></span><br><span class="line">        <span class="comment">//上面的语句可读性很差, 最后拆开来写, 后面也同理, 拆开写</span></span><br><span class="line">        <span class="keyword">if</span>(hmap[<span class="keyword">int</span>(s[end])] ? ) &#123; &#125; <span class="comment">//修改count</span></span><br><span class="line">        hmap[<span class="keyword">int</span>(s[end])]--; <span class="comment">//注意顺序</span></span><br><span class="line">        end++;</span><br><span class="line">        <span class="keyword">while</span>( count? )&#123; <span class="comment">// 检查count是否满足条件</span></span><br><span class="line">            <span class="comment">// update len_sub</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(hmap[<span class="keyword">int</span>(s[begin])] ?) &#123; &#125; <span class="comment">//修改count</span></span><br><span class="line">            hmap[<span class="keyword">int</span>(s[begin])]++;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如, 对于问题 <strong>Longest Substring At Two Distinct Characters</strong> 的模板解法如下:</p>
<p>对于问题 <strong>Longest Substring Without Repeating Characters</strong> 的模板解法如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>(<span class="number">256</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> begin=<span class="number">0</span>,end=<span class="number">0</span>,len_sub=<span class="number">0</span>,count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(end&lt;s.size())&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[<span class="keyword">int</span>(s[end])] &gt; <span class="number">0</span>) count++;</span><br><span class="line">        <span class="built_in">map</span>[<span class="keyword">int</span>(s[end])]++;</span><br><span class="line">        end++;</span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>) <span class="keyword">if</span>(<span class="built_in">map</span>[<span class="keyword">int</span>(s[begin])] &gt; <span class="number">1</span>) count;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="084-Largest-Rectangle-in-Histogram"><a href="#084-Largest-Rectangle-in-Histogram" class="headerlink" title="084. Largest Rectangle in Histogram"></a>084. Largest Rectangle in Histogram</h1><p>求最大面积的矩形</p>
<h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p>Example:<br>Input: [2,1,5,6,2,3]<br>Output: 10</p>
<p><img src="https://wx1.sinaimg.cn/large/d7b90c85ly1fx2pvbryaxj20if0l0js6.jpg" alt=""></p>
<h2 id="解法一-穷举"><a href="#解法一-穷举" class="headerlink" title="解法一: 穷举"></a>解法一: 穷举</h2><p><strong>时间复杂度:</strong> $O(n^2)$, 超时<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>列出以每一个i上的值为矩形高度的矩形面积, 然后取得最大值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;heights.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> low = i;</span><br><span class="line">            <span class="keyword">while</span>(low&gt;=<span class="number">0</span> &amp;&amp; heights[low] &gt;=heights[i]) low--;</span><br><span class="line">            low++;</span><br><span class="line">            <span class="keyword">int</span> high = i;</span><br><span class="line">            <span class="keyword">while</span>(high&lt;heights.size() &amp;&amp; heights[high] &gt;= heights[i]) high++;</span><br><span class="line">            high--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> cur_area = heights[i]* (high-low+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(max_area&lt;cur_area) max_area = cur_area;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-解法一的改进-空间换时间"><a href="#解法二-解法一的改进-空间换时间" class="headerlink" title="解法二: 解法一的改进-空间换时间"></a>解法二: 解法一的改进-空间换时间</h2><p><strong>时间复杂度:</strong> $O(n)$, 前面省略常数项(因为不好确定常数项的值)<br><strong>空间复杂度:</strong> $O(2n)$</p>
<p>从解法一中我们可以看出, 核心的要点就在于求取每一个i对应的矩形的左端和右端, 如下图所示:</p>
<p><img src="https://wx3.sinaimg.cn/large/d7b90c85ly1fx2qxg3740j20lf0j8t9r.jpg" alt=""></p>
<p>那么, 如果我们可以在 $O(1)$ 的时间内获取到左端和右端的值, 则时间复杂度就可以降低到 $O(n)$, 因此, 首先想到的是用数组将每个i对应的左端和右端的值保存起来. 于是, 我们需要先求取这两个数组(左端,右端)的值, <strong>在对左端和右端求值时, 我们要确保时间复杂度不能超过 $O(n)$</strong>, 因此, 我们不能每次都重新从i出发分别向左向右遍历(如解法一那样), 反之, 我们可以利用左端和右端中已经求好的值, 对于左端来说, 我们可以利用左端数组跳跃式的向左前进, 对于右端来说, 我们可以利用右端数组跳跃式的向右前进(这里不太好用语言描述, 具体请看程序代码).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> *left = <span class="keyword">new</span> <span class="keyword">int</span>[heights.size()];</span><br><span class="line">        <span class="keyword">int</span> *right = <span class="keyword">new</span> <span class="keyword">int</span>[heights.size()];</span><br><span class="line"></span><br><span class="line">        left[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;heights.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(p&gt;=<span class="number">0</span> &amp;&amp; heights[p] &gt;= heights[i])</span><br><span class="line">                p = left[p];</span><br><span class="line">            left[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        right[heights.size()<span class="number">-1</span>] = heights.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=heights.size()<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(p&lt;heights.size() &amp;&amp; heights[p] &gt;= heights[i])</span><br><span class="line">                p = right[p];</span><br><span class="line">            right[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;heights.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> low = left[i];</span><br><span class="line">            <span class="keyword">int</span> high = right[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> cur_area = heights[i]*(high-low<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(max_area&lt;cur_area) max_area = cur_area;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-最优-栈"><a href="#解法三-最优-栈" class="headerlink" title="解法三: 最优-栈"></a>解法三: 最优-栈</h2><p><strong>时间复杂度: $O(n)$</strong>, 无常数项<br><strong>空间复杂度: $O(n)$</strong>, 无常数项</p>
<p>上面的解法二, 虽然时间复杂度为 $O(n)$, 但实际上其时间复杂度是略微高于 $O(n)$, 因为在求取左端右端时, 每次跳跃的次数是大于等于1, 而不是仅为1次的.(只不过大O记法不考虑常数项). 而对于空间复杂度来说, 实际上是 $O(2n)$. 下面我们从另外一个角度出发: <strong>不再以当前i对应的高度为最低, 向左右两边探索, 改为以当前i对应的高度为最低, 仅仅向左边探索</strong>, 实现算法如下:</p>
<ul>
<li>首先, 构造一个空栈</li>
<li>从heights数组的第一个bar开始, 遍历所有的bar值(0~n-1), 并执行以下逻辑:<ul>
<li>如果当前栈为空, 或者当前数组bar值大于等于栈顶bar值, 则将bar值下标入栈</li>
<li>否则, 将栈顶出栈, 并以栈顶下标对应的bar值作为最低的高度, 求该高度对应的面积, 因为当前数组bar值小于栈顶下标对应的bar值, 因此可以将当前bar值下标作为right_index, 又因为栈顶bar值下标的前一个元素, 要么小于栈顶, 要么等于栈顶, 不论哪种情况, 都可以将其下标作为left_index(因为栈顶退出对, 次栈顶就会成为新的栈顶, 所以可以包括bar值相等的情况), 得到了高度, right_index, left_index, 即可计算当前栈顶对应的面积, 并与max_area判断, 更新max_area的值</li>
</ul>
</li>
<li>最后, 如果遍历完以后栈顶不为空(说明后面有几个连续的bar值相等, 或者bar只呈递增排序), 则依次强制弹出栈顶计算面积, 并更新max_area.</li>
</ul>
<p>复杂度分析: 由于入栈出栈的元素仅为heights数组元素, 可以栈的size就是heights数组的大小, 即空间复杂度为 $O(n)$, 时间复杂度从代码中可看出约为 $O(n)$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> height_index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;heights.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty() || heights[i] &gt;= heights[s.top()])</span><br><span class="line">                s.push(i++);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                height_index = s.top(); s.pop();</span><br><span class="line">                cur_area = heights[height_index] * ( s.empty()? i : i-s.top()<span class="number">-1</span> );  </span><br><span class="line">                <span class="comment">// 注意, 如果栈为空, 则说明当前i对应的bar值是前i个bar值中最小的, 所以宽为i, 否则宽为i-s.top()-1</span></span><br><span class="line">                <span class="keyword">if</span>(cur_area &gt; max_area) max_area = cur_area;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            height_index = s.top(); s.pop();</span><br><span class="line">            cur_area = heights[height_index] * ( s.empty()? i : i-s.top()<span class="number">-1</span> );  </span><br><span class="line">            <span class="comment">// 注意, 如果栈为空, 则说明当前i对应的bar值是前i个bar值中最小的, 所以宽为i, 否则宽为i-s.top()-1</span></span><br><span class="line">            <span class="keyword">if</span>(cur_area &gt; max_area) max_area = cur_area;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124. Binary Tree Maximum Path Sum"></a>124. Binary Tree Maximum Path Sum</h1><p>求二叉树中, 以任意节点为起始的路径和(这里是将二叉树看成无向图来计算路径的)的最大值, 例如对于下面的二叉树, 具有最大值的为:2-&gt;1-&gt;3 = 6<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br></pre></td></tr></table></figure></p>
<h2 id="Description-求最长路径加权和"><a href="#Description-求最长路径加权和" class="headerlink" title="Description: 求最长路径加权和"></a>Description: 求最长路径加权和</h2><p>Given a non-empty binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   3</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [-10,9,20,null,null,15,7]</span><br><span class="line">    -10</span><br><span class="line">    / \</span><br><span class="line">   9  20</span><br><span class="line">     /  \</span><br><span class="line">    15   7</span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-递归"><a href="#解法一-递归" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p>这道题的难点在于能否解读出题目的求值过程实际上是一个后序遍历的过程.</p>
<p>对于本题来说, 我们需要求得每个节点所在的路径的最大值, 以下面的例子来说:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  11 13</span><br><span class="line"> / \</span><br><span class="line">7   2</span><br></pre></td></tr></table></figure></p>
<p>我们需要求的最大和的路径为: 7-&gt;11-&gt;4-&gt;13. 而根据二叉树的遍历性质, 我们假设现在已经遍历到节点7, 此时, 左右子树均为空, 所以左右子树的最大和为0, 那么此时节点7所在的路径的最大和为: 左子树+右子树+当前节点值 = 7.  然后, 回溯到了节点11, 此时同理, 节点11所在的路径的最大和为: 左子树+右子树+当前节点值 = 11.(忽略节点2的遍历过程). 接下来对于节点4, 同理也应为: 左子树+右子树+当前节点值. 右子树返回的值很容易看出是13, 但是左子树应该返回多少呢? 由于我们希望求得当前的最大和, 因此, 左子树就应该返回它的最大和, 但是, 不能统计两条路径, 而应该选择以左节点为根节点的左右子树的较大者, 因此, 应该返回的是: max(左节点左子树, 左节点右子树)+左节点的值, 因此, 返回的是: 7+11 = 18. 于是, 节点4对应的最大和就为: 18+13+4. 可以看到, 这实际上就是一个后序遍历的过程.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=INT_MIN;</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* cur_node, <span class="keyword">int</span> &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur_node==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">std</span>::max(helper(cur_node-&gt;left, res), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">std</span>::max(helper(cur_node-&gt;right, res), <span class="number">0</span>);</span><br><span class="line">        res = <span class="built_in">std</span>::max(res, left+right+cur_node-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(left, right)+cur_node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代"><a href="#解法二-迭代" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p>后序遍历的迭代实现</p>
<h1 id="128-Longest-Consecutive-Sequence"><a href="#128-Longest-Consecutive-Sequence" class="headerlink" title="128. Longest Consecutive Sequence"></a>128. Longest Consecutive Sequence</h1><p>返回无序数组中, 可以组成的最长的连续子串的长度</p>
<h2 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h2><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>Your algorithm should run in O(n) complexity.</p>
<p>Example:</p>
<p>Input: [100, 4, 200, 1, 3, 2]<br>Output: 4<br>Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</p>
<h2 id="解法一-排序"><a href="#解法一-排序" class="headerlink" title="解法一: 排序"></a>解法一: 排序</h2><p><strong>时间复杂度:</strong> $O(nlogn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>先排序, 然后在从头往后遍历, 并用一个变量维护当前的最长连续序列的长度.</p>
<h2 id="解法二-利用哈希表"><a href="#解法二-利用哈希表" class="headerlink" title="解法二: 利用哈希表"></a>解法二: 利用哈希表</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>利用 <code>unordered_set</code> 将所有的数字存储起来, 然后遍历每一个数字 <code>num</code>, 查看这个数字是否为所在连续序列的开头(即查看 <code>num-1</code> 是否存在). 若 <code>num</code> 就是所在连续序列的开头, 则查看当前序列的长度, 并更新最大长度. 故而时间复杂度为 $O(n+n) = O(n)$. 同时, 因为使用了 <code>unordered_set</code>, 所以空间复杂度为 $O(n)$.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; sets(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : sets)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sets.find(num<span class="number">-1</span>) == sets.end())&#123;</span><br><span class="line">                <span class="keyword">int</span> cur_len = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(sets.find(num+<span class="number">1</span>) !=sets.end())&#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    cur_len++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(longest &lt; cur_len) longest = cur_len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法三-另一种哈希表用法"><a href="#解法三-另一种哈希表用法" class="headerlink" title="解法三: 另一种哈希表用法"></a>解法三: 另一种哈希表用法</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>主题思想与解法二相同, 不过是从另一角度来使用 <code>unordered_map</code>, 首先, 依然利用 <code>unordered_map</code> 将 <code>nums</code> 存储起来, 然后遍历 <code>nums</code>, 对于 <code>nums</code> 中的每一个 <code>num</code>, 查看其是否存在于 <code>unordered_map</code> 中, 如果存在, 则分别向左向右查找当前数字 <code>num</code> 所在序列的最左端和最右端的数字, 同时, 将在 <code>unordered_map</code> 中遍历过的数字都移除(因为每个数字只可能唯一的属于一个连续序列). 之后, 利用最左端和最右端来更新最长连续序列的长度.  这样, 遍历的时间复杂度也为 $O(n+n) = O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; sets(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sets.find(num)!=sets.end())&#123;</span><br><span class="line">                sets.erase(num);</span><br><span class="line">                <span class="keyword">int</span> pre = num<span class="number">-1</span>, next = num+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(sets.find(pre)!=sets.end())</span><br><span class="line">                    sets.erase(pre--);</span><br><span class="line">                <span class="keyword">while</span>(sets.find(next)!=sets.end())</span><br><span class="line">                    sets.erase(next++);</span><br><span class="line">                <span class="keyword">if</span>(longest &lt; next-pre) longest = next-pre<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="140-Word-Break-II"><a href="#140-Word-Break-II" class="headerlink" title="140. Word Break II"></a>140. Word Break II</h1><h2 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h2><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.</p>
<p>Note:</p>
<p>The same word in the dictionary may be reused multiple times in the segmentation.<br>You may assume the dictionary does not contain duplicate words.<br>Example 1:</p>
<p>Input:<br>s = “catsanddog”<br>wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]<br>Output:<br>[<br>  “cats and dog”,<br>  “cat sand dog”<br>]<br>Example 2:</p>
<p>Input:<br>s = “pineapplepenapple”<br>wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br>Output:<br>[<br>  “pine apple pen apple”,<br>  “pineapple pen apple”,<br>  “pine applepen apple”<br>]<br>Explanation: Note that you are allowed to reuse a dictionary word.<br>Example 3:</p>
<p>Input:<br>s = “catsandog”<br>wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>Output:<br>[]</p>
<h2 id="解法一-DP"><a href="#解法一-DP" class="headerlink" title="解法一: DP"></a>解法一: DP</h2><p>直接使用回溯法, 有大量重复计算, 导致时间超时, 无法通过 OJ, 因此考虑 DP 思想. 将中间的计算结果缓存起来, 再次遇到的时候无需重复计算, 只需直接使用即可.<br>利用一个哈希表将每个字符串与该字符串能拆分出的句子联系起来, 其中, key 为字符串, value 为字符串拆分后的句子. 假设我们已经求出一个字符串的解为 <code>res</code>, 并将其存入到哈希表中, 此时, 如果在该字符串的前面再加上一个单词(单词表的中任意一个), 那么新的解就应该为: <code>word+&quot; &quot;+res[i]</code>. 代码实现如下.</p>
<p><strong>注意</strong>, 这里我们要对 wordDict 进行遍历来查找可以拆分的情况, 如果是对字符串 s 查找可拆分情况, 那么哈希表中的键将会大幅增加, 例如对于<code>&quot;aaaaaaaaaaa&quot;</code>这种情况.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; wordBreak(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; hash_dict;</span><br><span class="line">        <span class="keyword">return</span> DP_helper(s, wordDict, hash_dict);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; DP_helper(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;wordDict, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;hash_dict)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash_dict.find(s)!=hash_dict.end()) <span class="keyword">return</span> hash_dict[s];</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">""</span>) <span class="keyword">return</span> &#123;<span class="string">""</span>&#125;; <span class="comment">//这里必须返回具有一个元素("")的vector, 否则下面的push_back语句不会执行</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : wordDict)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.substr(<span class="number">0</span>, word.size()) != word) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res_word = DP_helper(s.substr(word.size()), wordDict, hash_dict); <span class="comment">//s.substr(word.size()) 代表截取剩余的字符, 所以有可能出现空字符的情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> str : res_word)&#123; <span class="comment">// 如果返回的是空的vector, 则不会执行该语句, 因此, 不能返回空vector, 当遇到空字符串时, 因该返回 &#123;""&#125;, 即只有一个元素的vector, 该元素为"".</span></span><br><span class="line">                res.push_back(word + (str==<span class="string">""</span>? <span class="string">""</span>:<span class="string">" "</span>) + str); <span class="comment">//这里根据 str的值来决定是否加空格, 如果str为空, 说明是word是最后一个字符, 则其后不应该添加空格</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hash_dict[s] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>内存超限的写法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; wordBreak(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; hash;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; word : wordDict) &#123;</span><br><span class="line">                <span class="keyword">int</span> lenW = word.size();</span><br><span class="line">                <span class="keyword">if</span> (i+<span class="number">1</span> &gt;= lenW <span class="keyword">and</span> s.substr(i-lenW+<span class="number">1</span>, lenW) == word) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i+<span class="number">1</span> == lenW) &#123;</span><br><span class="line">                        res.push_back(word);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">string</span> tmp_s = s.substr(<span class="number">0</span>, i-lenW+<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span> (hash.find(tmp_s) != hash.end()) &#123;</span><br><span class="line">                            <span class="keyword">auto</span> tmp_words = hash[tmp_s];</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">auto</span> str : tmp_words) &#123;</span><br><span class="line">                                res.push_back(str + <span class="string">" "</span> + word);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[s.substr(<span class="number">0</span>, i+<span class="number">1</span>)] = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hash.find(s) != hash.end()) <span class="keyword">return</span> hash[s];</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">""</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="149-Max-Points-on-a-Line"><a href="#149-Max-Points-on-a-Line" class="headerlink" title="149. Max Points on a Line"></a>149. Max Points on a Line</h1><h2 id="Description-最大的共线点个数"><a href="#Description-最大的共线点个数" class="headerlink" title="Description 最大的共线点个数"></a>Description 最大的共线点个数</h2><p>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p>
<p>Example 1:</p>
<p>Input: [[1,1],[2,2],[3,3]]<br>Output: 3<br>Explanation:<br>^<br>|<br>|        o<br>|     o<br>|  o<br>+——————-&gt;<br>0  1  2  3  4<br>Example 2:</p>
<p>Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]<br>Output: 4<br>Explanation:<br>^<br>|<br>|  o<br>|     o        o<br>|        o<br>|  o        o<br>+—————————-&gt;<br>0  1  2  3  4  5  6</p>
<h2 id="解法一-哈希表"><a href="#解法一-哈希表" class="headerlink" title="解法一: 哈希表"></a>解法一: 哈希表</h2><p><strong>时间复杂度:</strong> $O(n^2)$, 求取任意两点间的斜率<br><strong>空间复杂度:</strong> $O(n)$, 哈希表, 存储斜率</p>
<p>由于要求共线点个数, 就必须获取任意两点间的斜率, 因此, 时间复杂度最少为 $O(n^2)$. 算法流程如下:</p>
<ul>
<li>对于每一个点来说, 构造一个哈希表, 表中的键为斜率, 表中的值为对应斜率的点的个数, 这里注意, 当我们求完第i个点与第j个点之间的斜率之后, 就不用再求第j个点与第i个点之间的斜率情况了(即令<code>int j = i+1</code>, 而不是<code>int j = 0</code>)</li>
<li>对于重点的情况, 需要单独设置一个变量来记录, 之后将该重复次数加入到该点所在的每条直线上(因为重点也算是共线)</li>
<li>对于斜率不存在的情况, 可以考虑利用<code>INT_MAX</code>来作为键值</li>
<li><strong>精度:</strong> 在求取斜率时, 会进行除法, 而在计算机内部, 除法在精度上始终会有一定误差, 会造成斜率相同的两对点在计算成浮点数以后斜率不同, 因此, 要 <strong>避免使用除法</strong>, 解决办法是利用 <strong>最大公约数</strong>, 求取<code>y2-y1</code>与<code>x2-x1</code>之间的最大公约数, 然后对进行约分, 用约分后的值作为键来存储, 就不会造成精度上的损失, 但是, 此时需要用<code>pair</code>作为键, 故不能用<code>unordered_map</code>(C++没有为pair类型提供对应的哈希函数), 而只能用<code>map</code>(键只有重载了<code>&lt;</code>和<code>&gt;</code>就可以使用<code>map</code>, 搜索的时间复杂度为 $O(logn)$), 另一种可选做法是利用<code>string</code>类型, 将两个<code>int</code>数值转换成<code>string</code>后再拼接, 此时就可以使用<code>unordered_map</code>了(搜索的时间复杂度为 $O(1)$, 但是<code>int</code>和<code>string</code>的类型转换也需要消耗时间).</li>
<li>当采用公约数以后, 因为没有了除法, 因此可以不用特殊处理斜率不存在的情况, 代码更加简洁.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">C<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a point.</span></span><br><span class="line"><span class="comment"> * struct Point &#123;</span></span><br><span class="line"><span class="comment"> *     int x;</span></span><br><span class="line"><span class="comment"> *     int y;</span></span><br><span class="line"><span class="comment"> *     Point() : x(0), y(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Point(int a, int b) : x(a), y(b) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt;&amp; points)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;points.size(); i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> duplicate = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; lines_hash; <span class="comment">//这里用map的原因是因为unordered_map的键的类型只能是基本类型, 不能是pair</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;points.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(points[i].x==points[j].x &amp;&amp; points[i].y==points[j].y)&#123;</span><br><span class="line">                    duplicate++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> a = points[j].y-points[i].y;</span><br><span class="line">                    <span class="keyword">int</span> b = points[j].x-points[i].x;</span><br><span class="line">                    <span class="keyword">int</span> d = gcd(a, b);</span><br><span class="line">                    lines_hash[&#123;a/d, b/d&#125;]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, duplicate); <span class="comment">// 如果points里面只有一个点, 则哈希表中不会有键值, 因此需要先处理只有一个点的情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> line : lines_hash)&#123;</span><br><span class="line">                res = max(res, duplicate+line.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="comment">// 求a与b的最大公约数</span></span><br><span class="line">        <span class="keyword">return</span> (b==<span class="number">0</span>) ? a : gcd(b, a%b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>用 string 做键, 使用哈希表而不是map:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a%b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; line_hash;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> duplicate = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (points[i].x == points[j].x <span class="keyword">and</span> points[i].y == points[j].y) &#123;</span><br><span class="line">                    duplicate++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> a = points[j].y - points[i].y;</span><br><span class="line">                <span class="keyword">int</span> b = points[j].x - points[i].x;</span><br><span class="line">                <span class="keyword">int</span> d = gcd(a, b);</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> slope = <span class="built_in">std</span>::to_string(a/d) + <span class="built_in">std</span>::to_string(b/d);</span><br><span class="line">                line_hash[slope]++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">std</span>::max(res, duplicate);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it : line_hash) &#123;</span><br><span class="line">                res = <span class="built_in">std</span>::max(res, duplicate + it.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="212-Word-Search-II"><a href="#212-Word-Search-II" class="headerlink" title="212. Word Search II"></a>212. Word Search II</h1><h2 id="Description-返回字符矩阵中含有的所有单词"><a href="#Description-返回字符矩阵中含有的所有单词" class="headerlink" title="Description: 返回字符矩阵中含有的所有单词"></a>Description: 返回字符矩阵中含有的所有单词</h2><p>Given a 2D board and a list of words from the dictionary, find all words in the board.</p>
<p>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>
<p>Example:</p>
<p>Input:<br>words = [“oath”,”pea”,”eat”,”rain”] and board =<br>[<br>  [‘o’,’a’,’a’,’n’],<br>  [‘e’,’t’,’a’,’e’],<br>  [‘i’,’h’,’k’,’r’],<br>  [‘i’,’f’,’l’,’v’]<br>]</p>
<p>Output: [“eat”,”oath”]</p>
<h2 id="解法一-穷举-1"><a href="#解法一-穷举-1" class="headerlink" title="解法一: 穷举"></a>解法一: 穷举</h2><p><strong>时间复杂度:</strong> $O(w mn 4^k)$, 暴力求解, $mn$ 为字符矩阵的宽和高, 也即 cell 数量, 对于 dfs 中的每个 cell, 有4个扩展方向, 一共需要扩展 $k$ 次($k$ 为单词的长度). 总共有 $w$ 个单词, 因此复杂度为$O(w mn 4^k)$<br><strong>空间复杂度:</strong> $O(mn)$ , 和79题相同, 回溯时, 用<code>#</code>来记录已经遍历过的点, 无需申请额外空间来记录. 但是递归程序需要占用 $O(mn)$ 的空间复杂度.</p>
<p>该题和79题类似, 只不过给定的是一个单词列表, 而不是一个单词, 因此, 可以对这个单词列表循环调用79题的解. 不过时间复杂度过高, 无法通过 OJ.</p>
<h2 id="解法二-字典树"><a href="#解法二-字典树" class="headerlink" title="解法二: 字典树"></a>解法二: 字典树</h2><p><strong>时间复杂度:</strong> $O(mn 4^k)$, 暴力求解, $mn$ 为字符矩阵的 cell 数量, 对于 dfs 中的每个 cell, 有4个扩展方向, 一共需要扩展 $k$ 次($k$ 为单词的长度).<br><strong>空间复杂度:</strong> $O(mn)$ , 和79题相同, 回溯时, 用<code>#</code>来记录已经遍历过的点, 无需申请额外空间来记录. 但是递归程序需要占用 $O(mn)$ 的空间复杂度. <strong>另外, 还有构建字典树所需的空间复杂度, 这部分复杂度与具体的字符串数组有关, 当字符串公共部分较多时, 复杂度较低, 反之, 复杂度较高, 最差情况下为 $O(wk)$, 即无公共前缀</strong></p>
<p>相对于第79题来说, 本题增加的复杂度主要体现在需要同时查看 $w$ 个单词的字符, 查询这些单词字符的复杂度约为 $O(wk)$, 其中, $k$ 为单词的最大长度, 那么, 我们能否将这里的复杂度降低成 $k$ 呢? 如果降低成 $k$ 的话, 就相当是在查找一个单词, 那么整体的复杂度就和79题相同, 变成了 $O(mn 4^k)$.<br>实际上, 字典树正是这种数据结构! 在由 $w$ 个字符串构成的字典树中查询某个字符串或者字符子串的复杂度为 $k$. 因此, 我们可以借助字典树来降低整体的时间复杂度. 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *child[<span class="number">26</span>];</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    TrieNode():str(<span class="string">""</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;node : child) node=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line"></span><br><span class="line">    Trie():root(<span class="keyword">new</span> TrieNode())&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = c - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;child[i] == <span class="literal">nullptr</span>) p-&gt;child[i] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            p = p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;str = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findWords(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(words.size()==<span class="number">0</span> || board.size()==<span class="number">0</span> || board[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visit(board.size(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(board[<span class="number">0</span>].size(), <span class="literal">false</span>));</span><br><span class="line">        Trie T;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : words) T.insert(word);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;board[i].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(T.root-&gt;child[board[i][j] - <span class="string">'a'</span>] != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    search(board, T.root-&gt;child[board[i][j]-<span class="string">'a'</span>], i, j, visit, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, TrieNode *node, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;visit, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;str.empty())&#123;</span><br><span class="line">            res.push_back(node-&gt;str);</span><br><span class="line">            node-&gt;str.clear(); <span class="comment">// 重新置为空 node-&gt;str = ""; 防止重复push_back</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> direct[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125; &#125;;</span><br><span class="line">        visit[i][j] = <span class="literal">true</span>; <span class="comment">// 将当前位置设置为已访问, 因为题目要求同一个位置只能在一个字符串中被访问一次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d : direct)&#123;</span><br><span class="line">            <span class="keyword">int</span> new_i = i + d[<span class="number">0</span>]; <span class="keyword">int</span> new_j = j + d[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(new_i&gt;=<span class="number">0</span> &amp;&amp; new_j&gt;=<span class="number">0</span> &amp;&amp; new_i&lt;board.size() &amp;&amp; new_j&lt;board[<span class="number">0</span>].size() &amp;&amp; visit[new_i][new_j]==<span class="literal">false</span> &amp;&amp; node-&gt;child[board[new_i][new_j] - <span class="string">'a'</span>] != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                search(board, node-&gt;child[board[new_i][new_j] - <span class="string">'a'</span>], new_i, new_j, visit, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[i][j] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="218-The-Skyline-Problem"><a href="#218-The-Skyline-Problem" class="headerlink" title="218. The Skyline Problem"></a>218. The Skyline Problem</h1><h2 id="Description-天际线问题"><a href="#Description-天际线问题" class="headerlink" title="Description: 天际线问题"></a>Description: 天际线问题</h2><p>A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).</p>
<p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fxr32nc4xoj215u0guq3p.jpg" alt=""></p>
<p>The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 &lt; Hi ≤ INT_MAX, and Ri - Li &gt; 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</p>
<p>For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .</p>
<p>The output is a list of “key points” (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], … ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.</p>
<p>For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].</p>
<h2 id="解法一-multiset"><a href="#解法一-multiset" class="headerlink" title="解法一: multiset"></a>解法一: multiset</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 拆分三元组到二元组为 $O(n)$, 排序为 $O(nlogn)$, 更新轮廓节点为 $O(nlogn)$ (插入高度为 $O(log)$, 总共有 $O(n)$ 组高度).<br><strong>空间复杂度:</strong> $O(n)$, 存储高度的二元组 vector, 以及维护当前建筑物高度顺序的 multiset.</p>
<p>首先我们将表示建筑物的所有三元组<code>(Li, Ri, Hi)</code>进行拆分, 将其分成<code>(Li, -Hi)</code>, <code>(Ri, Hi)</code>的两个二元组, 将这些二元组存放在一个数组 vector 中, 然后按照 x 轴的下标进行排序, 注意如果当一个建筑物的右侧和另一个建筑物的左侧重叠时, 我们为了不丢失当前建筑物的高度, 必须先考虑将另一个建筑物的左侧添加进 multiset 里, 然后获取最高高度. 接着在下一次循环时, 再将重合的右侧边界对应的建筑物剔除, 因此我们需要令二元组中的左侧为负, 使其在排序时可以排到前面.<br>得到有序的建筑物二元组序列以后, 我们遍历该序列, 如果遇到了某个建筑物的左侧边界, 则将该边界对应建筑物的高度加入到 multiset 中, 如果遇到了某个建筑物的右侧边界, 则将对应建筑物的高度剔除. 假设我们已经得到了前 i 个坐标的建筑物组成的轮廓坐标点, 现在来到第 i+1 个坐标, 只有可能对应下面几种情况:</p>
<ul>
<li>i+1 坐标上新来的建筑物(遇到该建筑物左侧就行)完全被之前的建筑物覆盖, 此时不更新 res 轮廓. 说明添加了该建筑物后, 并不改变当前建筑群的最高高度.</li>
<li>i+1 坐标上新来的建筑物比当前建筑群最高的高度还要高, 则需要记录当前的点.</li>
<li>i+1 坐标上没有新来建筑物, 但是有一个建筑物遇到了右侧边界, 此时建筑群的高度会变成第二高建筑物的高度, 同样需要记录当前的坐标点.</li>
<li>i+1 坐标上既没有新来建筑物, 也没有遇到建筑物右侧, 此时无需记录任何值, 可继续探测 i+2 坐标.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; getSkyline(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; buildings) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; heights, res; <span class="comment">// height 用于存放建筑物的高度, res存放结果</span></span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; m; <span class="comment">// 用 multiset 数据结构来维护当前x坐标之前的建筑物高度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;b : buildings)&#123;</span><br><span class="line">            <span class="comment">//用负高度代表当前的边是左侧的边. 因为后面有排序, 所以必须令左侧为负, 而不能令右侧为负.</span></span><br><span class="line">            <span class="comment">//因为当x坐标相同时, 当前的building的右侧还不能剔除,</span></span><br><span class="line">            <span class="comment">//否则, 有可能"低估" 轮廓高度所以要将左侧的排在前面</span></span><br><span class="line">            heights.push_back(&#123;b[<span class="number">0</span>], -b[<span class="number">2</span>]&#125;);</span><br><span class="line">            heights.push_back(&#123;b[<span class="number">1</span>], b[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(heights.begin(), heights.end()); <span class="comment">// 按照x坐标排序, 当x一样时, 按照高度排序</span></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>; <span class="comment">// pre代表之前的最高建筑物的高度, 初始为0</span></span><br><span class="line">        <span class="keyword">int</span> cur; <span class="comment">// cur 代表当前的最高建筑物的高度, 会在for循环中赋值.</span></span><br><span class="line">        m.insert(<span class="number">0</span>); <span class="comment">// 开始的时候, m中的最高高度为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;h : heights)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h.second &lt; <span class="number">0</span>) m.insert(-h.second); <span class="comment">// 如果是左侧边, 则加入当前建筑物高度集合, 并自动排序</span></span><br><span class="line">            <span class="keyword">else</span> m.erase(m.find(h.second)); <span class="comment">// 如果遇到了右侧边, 则将对应的建筑物从当前建筑物集合内剔除</span></span><br><span class="line">            <span class="comment">// 注意, 这里在使用erase时, 是先找到key值匹配的某一个元素的迭代器(多个存在多个匹配), 然后再删除</span></span><br><span class="line">            <span class="comment">// 如果直接使用 erase(key) 的话, 则会将满足key值的所有元素都擦除, 这样会导致程序出错.</span></span><br><span class="line">            cur = *m.rbegin(); <span class="comment">// 获取当前的最大高度</span></span><br><span class="line">            <span class="keyword">if</span>(cur != pre)&#123; <span class="comment">// 说明此时要么新加入了更高的高度, 要么被用于最高高度的建筑物被剔除, 需要更新轮廓点</span></span><br><span class="line">                res.push_back(&#123;h.first, cur&#125;); <span class="comment">//新更新的轮廓点的x坐标即为当前h的x坐标.</span></span><br><span class="line">                pre = cur; <span class="comment">// 更新pre</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-priority-queue-堆"><a href="#解法二-priority-queue-堆" class="headerlink" title="解法二: priority_queue(堆)"></a>解法二: priority_queue(堆)</h2><p>在解法一中, 用了 multiset, 之所以不用 priority_queue 的原因是因为, C++ 的 priority_queue 容器并没有提供<code>erase</code>或者<code>find</code>之类的方法, 因此, 在删除指定高度时, 比较麻烦. 而 multiset 不仅完成堆的功能(最后一个元素就是最大的), 同时还支持在对数复杂度时间内删除指定的高度.</p>
<p>因此, 如果想要使用 priority_queue 的话, 就需要调整算法的逻辑, 下面是使用 priority_queue 的解法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; getSkyline(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; buildings) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, cur_X, cur_H = <span class="number">-1</span>, len = buildings.size();</span><br><span class="line">        <span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; liveBlg;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; len <span class="keyword">or</span> !liveBlg.empty()) &#123;</span><br><span class="line">            cur_X = liveBlg.empty() ? buildings[cur][<span class="number">0</span>] : liveBlg.top().second;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur &gt;= len <span class="keyword">or</span> buildings[cur][<span class="number">0</span>] &gt; cur_X) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!liveBlg.empty() &amp;&amp; (liveBlg.top().second &lt;= cur_X)) &#123;</span><br><span class="line">                    liveBlg.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur_X = buildings[cur][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">while</span> (cur &lt; len &amp;&amp; buildings[cur][<span class="number">0</span>] == cur_X) &#123;</span><br><span class="line">                    liveBlg.push(&#123;buildings[cur][<span class="number">2</span>], buildings[cur][<span class="number">1</span>]&#125;);</span><br><span class="line">                    cur++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur_H = liveBlg.empty() ? <span class="number">0</span> : liveBlg.top().first;</span><br><span class="line">            <span class="keyword">if</span> (res.empty() <span class="keyword">or</span> (res.back().second != cur_H)) &#123;</span><br><span class="line">                res.push_back(&#123;cur_X, cur_H&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239. Sliding Window Maximum"></a>239. Sliding Window Maximum</h1><h2 id="Description-滑动窗口的最大值"><a href="#Description-滑动窗口的最大值" class="headerlink" title="Description: 滑动窗口的最大值"></a>Description: 滑动窗口的最大值</h2><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3</span><br><span class="line">Output: [3,3,5,5,6,7]</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ input array’s size for non-empty array.</p>
<p><strong>Follow up:</strong><br>Could you solve it in linear time?</p>
<h2 id="解法一-双端队列"><a href="#解法一-双端队列" class="headerlink" title="解法一: 双端队列"></a>解法一: 双端队列</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(k)$, 双端队列的 size 为 $k$.</p>
<p>使用双端队列deque, 从下标0开始, 一直到n-1, 每次进行如下步骤:</p>
<ul>
<li>当前元素是否比队列中最后一个元素大, 如果大, 说明队列元素以后也不可能再成为较大值, 直接pop, 如此循环, 直到队列为空或者遇到比当前值大的元素</li>
<li>判断队列中队首的元素是否过期(若队空则直接下一步, 无需判断), 若过期, 则pop, 否则, 不管( 只看队首, 队内的元素是否过期不影响算法, 因为就算过期后面也会将其淘汰)</li>
<li>将当前元素的下标存到队尾</li>
<li>将新的队首元素存到结果向量max_res中</li>
</ul>
<p><strong>注意:</strong> 队列里面存的是下标, 而不是元素本身的值, 后面在提到队列的元素值时, 均是指队列中存储的下标对应的元素值.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span> || k ==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dq.empty())</span><br><span class="line">                dq.push_back(i);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(dq.front() &lt; i-k+<span class="number">1</span>) dq.pop_front(); <span class="comment">//过期元素, 出队列</span></span><br><span class="line">                <span class="keyword">while</span>(!dq.empty() &amp;&amp; nums[dq.back()] &lt;= nums[i]) dq.pop_back(); <span class="comment">// 将队列中小于当前元素的都出队列(因为它们不可能成为max)</span></span><br><span class="line">                dq.push_back(i); <span class="comment">// 将当前元素入队列.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k<span class="number">-1</span>) res.push_back(nums[dq.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="295-Find-Median-from-Data-Stream"><a href="#295-Find-Median-from-Data-Stream" class="headerlink" title="295. Find Median from Data Stream"></a>295. Find Median from Data Stream</h1><h2 id="Description-返回数据流的中位数"><a href="#Description-返回数据流的中位数" class="headerlink" title="Description: 返回数据流的中位数"></a>Description: 返回数据流的中位数</h2><p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>
<p>For example,<br><code>[2,3,4]</code>, the median is <code>3</code><br><code>[2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code></p>
<p>Design a data structure that supports the following two operations:</p>
<ul>
<li>void addNum(int num) - Add a integer number from the data stream to the data structure.</li>
<li>double findMedian() - Return the median of all elements so far.</li>
</ul>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addNum(1)</span><br><span class="line">addNum(2)</span><br><span class="line">findMedian() -&gt; 1.5</span><br><span class="line">addNum(3)</span><br><span class="line">findMedian() -&gt; 2</span><br></pre></td></tr></table></figure></p>
<p><strong>Follow up:</strong></p>
<ol>
<li>If all integer numbers from the stream are between 0 and 100, how would you optimize it?</li>
<li>If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?</li>
</ol>
<h2 id="解法一-传统排序"><a href="#解法一-传统排序" class="headerlink" title="解法一: 传统排序"></a>解法一: 传统排序</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 添加数字时不排序, 返回中位数时排序<br><strong>空间复杂度:</strong> $O(n)$, 排序需要额外空间</p>
<p>添加数字时, 直接添加, 时间复杂度为 $O(1)$, 每次需要输出中位数时, 都对数组内当前所有元素排序, 时间复杂度为 $O(nlogn)$, <strong>该方法超时</strong>.</p>
<h2 id="解法二-插入排序"><a href="#解法二-插入排序" class="headerlink" title="解法二: 插入排序"></a>解法二: 插入排序</h2><p><strong>时间复杂度:</strong> $O(n)$, 二分搜索位置需要 $O(logn)$, 插入需要 $O(n)$.<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>每次新来一个数字时, 都执行插入排序, 先利用二分搜索(因为当前数组已经有序)找到应该插入的位置, 时间复杂度为 $O(logn)$, 然后将数字插入到该位置, 插入的时间复杂度是 $O(n)$, 由于已经排序好, 因此返回中位数的时间复杂度是 $O(1). 该解法 <strong>同样超时</strong>.</p>
<h2 id="解法三-大顶堆-小顶堆"><a href="#解法三-大顶堆-小顶堆" class="headerlink" title="解法三: 大顶堆+小顶堆"></a>解法三: 大顶堆+小顶堆</h2><p><strong>时间复杂度:</strong> $O(5\times logn) = O(logn)$<br><strong>空间复杂度:</strong> $O(n)$, 大顶堆和小顶堆的大小之和为 $n$.</p>
<p>元素首先加入大顶堆($O(logn)$), 得到前面数字的最大值, 然后将该最大值弹出($O(logn)$)并加入到小顶堆当中($O(logn)$), 以维护当前小顶堆的元素合法(例如, 新的大顶堆堆顶的元素大于当前小顶堆堆顶元素, 这就不合法了), 然后, 看看当前大顶堆和小顶堆的元素个数是否符合要求, 如果不符合的话, 就小顶堆的堆顶弹出($O(logn)$)并加入大顶堆($O(logn)$). 由此可知, 添加元素的时间复杂度为: $O(5\times logn)$. 返回中位数时可以直接获取堆顶, 而无需更改堆结构, 故而为 $O(1)$. 所以, 最终的时间复杂度就为 $O(5\times logn) = O(logn)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; max_heap; <span class="comment">// 大顶堆, 维护前 (n+1)/2 个元素</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;&gt; min_heap; <span class="comment">//小顶堆, 维护后n/2个元素</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        max_heap.push(num); <span class="comment">// 先将当前元素添加到大顶堆中, 找到前半段最大元素</span></span><br><span class="line">        min_heap.push(max_heap.top()); max_heap.pop(); <span class="comment">// 调节最小堆, 这一步是必须的, 是为了同时确保大顶堆和小顶堆的元素正确</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数字会随着元素size的变化而不断在大顶堆和小顶堆之间切换</span></span><br><span class="line">        <span class="keyword">if</span>(max_heap.size() &lt; min_heap.size())&#123; <span class="comment">//调节后, 平衡大顶堆和小顶堆的size</span></span><br><span class="line">            max_heap.push(min_heap.top());</span><br><span class="line">            min_heap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (max_heap.size() + min_heap.size())%<span class="number">2</span>==<span class="number">1</span> ? <span class="keyword">double</span>(max_heap.top()) : (max_heap.top() + min_heap.top())*<span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj.addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="解法四-multiset-指示器"><a href="#解法四-multiset-指示器" class="headerlink" title="解法四: multiset+指示器"></a>解法四: multiset+指示器</h2><p><strong>时间复杂度:</strong> $O(logn+1) = O(logn)$<br><strong>空间复杂度:</strong> $O(n)$, multiset 容器需要 $n$ 大小的空间.</p>
<p>用两个迭代指示器分别指向当前数组内的中位数(元素数目为奇数时, 二者指向同一点), 那么当新来一个元素时, 这个元素只可能有三种插入情况:</p>
<ul>
<li>插在两指示器的前面</li>
<li>插在两指示器的后面</li>
<li>插在两指示器的中间(只在未插入前元素数目为偶数时才可以)</li>
</ul>
<p>由于迭代指示器是随着元素移动而移动的(这点和下标就有区别了), 因此, 我们可以通过对指示器操作来使其指向新的中位数, 对应三种情况分别为:</p>
<ul>
<li>前面元素变多, 说明指示器应该后挪(最多一位)</li>
<li>后面元素变多, 说明指示器应该前挪(最多一位)</li>
<li>插在中间, 说明当前插入的元素正是中位数, 令指示器指向即可.</li>
</ul>
<p>当然, 上面只是核心思想, 具体的挪动算法还要分元素数目的奇偶性来分情况讨论, 代码如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator low_mid, high_mid; <span class="comment">// 迭代指示器会随着容器的变动而变动, 这个性质是该解法可行的重要因素之一</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MedianFinder():low_mid(data.end()), high_mid(data.end()) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> n = data.size();</span><br><span class="line">        data.insert(num);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            low_mid = data.begin();</span><br><span class="line">            high_mid = data.begin();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n &amp; <span class="number">1</span>==<span class="number">1</span>)&#123; <span class="comment">// 插入之前元素数量为奇数, low_mid=high_mid</span></span><br><span class="line">            <span class="keyword">if</span>(num &lt; *low_mid) <span class="comment">// 会插入到 low_mid/high_mid 之前, 因此, 前半段元素增加</span></span><br><span class="line">                low_mid--;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 如果 &gt;=, 则会插入到low_mid/high_mid 之后</span></span><br><span class="line">                high_mid++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 插入之前元素数量为偶数, low_mid+1 = high_mid</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(num &gt;= *low_mid &amp;&amp; num &lt; *high_mid)&#123; <span class="comment">//插入的元素刚好在中间, 注意前面要用 &gt;=, 后面用 &lt;, 因为相等时, 会插在后面</span></span><br><span class="line">                low_mid++;</span><br><span class="line">                high_mid--; <span class="comment">// 两个指针都想中间靠拢.</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &lt; *low_mid)&#123; <span class="comment">// 插入元素会插在前面, 则前面元素数量增加</span></span><br><span class="line">                high_mid--; <span class="comment">// 令high_mid=low_mid;</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 插在了后面</span></span><br><span class="line">                low_mid++; <span class="comment">// 令low_mid=high_mid;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (*low_mid + *high_mid) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的指示器实际上可以简化成一个(因为两个指示器只能互相挨着或者重叠), 因此, 我们可以只维护一个指示器, 简化代码如下(但是不太好理解):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator mid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MedianFinder()</span><br><span class="line">        : mid(data.end())</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = data.size();</span><br><span class="line">        data.insert(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!n)                                 <span class="comment">// first element inserted</span></span><br><span class="line">            mid = data.begin();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; *mid)                    <span class="comment">// median is decreased</span></span><br><span class="line">            mid = (n &amp; <span class="number">1</span> ? mid : prev(mid));</span><br><span class="line">        <span class="keyword">else</span>                                    <span class="comment">// median is increased</span></span><br><span class="line">            mid = (n &amp; <span class="number">1</span> ? next(mid) : mid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.size() &amp; <span class="number">1</span> == <span class="number">1</span> ? (*mid) : (*mid + *next(mid)) * <span class="number">0.5</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Follow-Up"><a href="#Follow-Up" class="headerlink" title="Follow Up"></a>Follow Up</h2><ol>
<li>If all integer numbers from the stream are between 0 and 100, how would you optimize it?</li>
</ol>
<p>用bucket?</p>
<ol>
<li>If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?</li>
</ol>
<h1 id="297-Serialize-and-Deserialize-Binary-Tree"><a href="#297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="297. Serialize and Deserialize Binary Tree"></a>297. Serialize and Deserialize Binary Tree</h1><h2 id="Description-序列化和反序列化二叉树"><a href="#Description-序列化和反序列化二叉树" class="headerlink" title="Description: 序列化和反序列化二叉树"></a>Description: 序列化和反序列化二叉树</h2><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">You may serialize the following tree:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">     / \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">as &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure></p>
<p><strong>Clarification:</strong> The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>
<p><strong>Note:</strong> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>
<h2 id="解法一-DFS"><a href="#解法一-DFS" class="headerlink" title="解法一: DFS"></a>解法一: DFS</h2><p><strong>时间复杂度:</strong> $O(n)$, 在序列化和反序列化递归中, 各遍历每个节点一次<br><strong>空间复杂度:</strong> $O(n\times v + n) = O(n)$, 其中, $n$ 为节点个数, $v$ 为节点上的值所占空间大小, 最后的一个 $n$ 代表递归调用所占的空间大小.</p>
<p>使用 <code>ostringstream</code> 和 <code>istringstream</code> 来缓存字符串, 中间用空格分隔, 利用流操作 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 可以方便的对字符串进行存入和读取, 而无需额外进行分词操作.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode *root, <span class="built_in">ostringstream</span> &amp;out)</span></span>&#123; <span class="comment">// 函数重载</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) out &lt;&lt; <span class="string">"# "</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            out &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            serialize(root-&gt;left, out);</span><br><span class="line">            serialize(root-&gt;right, out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">deserialize</span><span class="params">(<span class="built_in">istringstream</span> &amp;in)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> cur_val;</span><br><span class="line">        in &gt;&gt; cur_val;</span><br><span class="line">        <span class="keyword">if</span>(cur_val==<span class="string">"#"</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode *node = <span class="keyword">new</span> TreeNode(<span class="built_in">std</span>::stoi(cur_val));</span><br><span class="line">            node-&gt;left = deserialize(in);</span><br><span class="line">            node-&gt;right = deserialize(in);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ostringstream</span> out;</span><br><span class="line">        serialize(root, out);</span><br><span class="line">        <span class="keyword">return</span> out.str();        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> deserialize(in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>
<h2 id="解法二-BFS"><a href="#解法二-BFS" class="headerlink" title="解法二: BFS"></a>解法二: BFS</h2><p><strong>时间复杂度:</strong> $O(n)$, 在序列化和反序列化中, 每个节点都遍历一次<br><strong>空间复杂度:</strong></p>
<p>BFS 的会按照层次遍历的顺序将树的节点序列化, 序列化的代码比较好写, 只需对普通的层次遍历稍加改动即可. 反序列化的代码有一点麻烦, 需要控制树节点的左右子节点的值, 具体如下.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ostringstream</span> out;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode *node = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                out &lt;&lt; node-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                out &lt;&lt; <span class="string">"# "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.str();        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">        <span class="built_in">string</span> val;</span><br><span class="line">        in &gt;&gt; val;</span><br><span class="line">        TreeNode *res = <span class="keyword">new</span> TreeNode(<span class="built_in">std</span>::stoi(val));</span><br><span class="line">        TreeNode *cur = res;</span><br><span class="line">        q.push(cur);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode *node = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!(in&gt;&gt;val)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(val!=<span class="string">"#"</span>)&#123;</span><br><span class="line">                cur = <span class="keyword">new</span> TreeNode(<span class="built_in">std</span>::stoi(val));</span><br><span class="line">                node-&gt;left = cur;</span><br><span class="line">                q.push(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!(in&gt;&gt;val)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(val!=<span class="string">"#"</span>)&#123;</span><br><span class="line">                cur = <span class="keyword">new</span> TreeNode(<span class="built_in">std</span>::stoi(val));</span><br><span class="line">                node-&gt;right = cur;</span><br><span class="line">                q.push(cur);</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="315-Count-of-Smaller-Numbers-After-Self"><a href="#315-Count-of-Smaller-Numbers-After-Self" class="headerlink" title="315. Count of Smaller Numbers After Self"></a>315. Count of Smaller Numbers After Self</h1><h2 id="Description-统计右边比当前数字小的个数"><a href="#Description-统计右边比当前数字小的个数" class="headerlink" title="Description: 统计右边比当前数字小的个数"></a>Description: 统计右边比当前数字小的个数</h2><p>You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,2,6,1]</span><br><span class="line">Output: [2,1,1,0]</span><br><span class="line">Explanation:</span><br><span class="line">To the right of 5 there are 2 smaller elements (2 and 1).</span><br><span class="line">To the right of 2 there is only 1 smaller element (1).</span><br><span class="line">To the right of 6 there is 1 smaller element (1).</span><br><span class="line">To the right of 1 there is 0 smaller element.</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-multiset-1"><a href="#解法一-multiset-1" class="headerlink" title="解法一: multiset"></a>解法一: multiset</h2><p><strong>时间复杂度:</strong> $O(n\times(logn+n+logn)=O(n^2)$<br><strong>空间复杂度:</strong> $O(n+n) = O(n)$</p>
<p>先介绍一下利用 <code>multiset</code> 的解法, <code>multiset</code> 的底层实现使用了红黑树, 所以在插入和查找的时候复杂度都为 $O(logn)$, 但是求 <code>distance</code> 时, 由于 <code>multiset</code> 的迭代器不是随机访问的, 因此复杂度为 $O(n)$, 故而最后的时间复杂度为 $O(n^2)$. 该方法在 OJ 上超时, 此处仅用于记录.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countSmaller(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; nums_set;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(nums.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">auto</span> itlow = nums_set.lower_bound(nums[i]);</span><br><span class="line"></span><br><span class="line">            res[i] = <span class="built_in">std</span>::distance(nums_set.begin(), itlow);</span><br><span class="line">            <span class="comment">// multiset 求distance的复杂度为线性, 因此, 总复杂度为 O(n^2)</span></span><br><span class="line"></span><br><span class="line">            nums_set.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-有序数组"><a href="#解法二-有序数组" class="headerlink" title="解法二: 有序数组"></a>解法二: 有序数组</h2><p><strong>时间复杂度:</strong> $O(n\times (logn+n) = O(n^2)$, 在有序数组中找指定位置需要 $O(logn)$, 将当前元素插入到数组的指定位置需要 $O(n)$, 这个过程需要进行 $n$ 次.<br><strong>空间复杂度:</strong> $O(n+n) = O(n)$, 一个有序数组, 一个结果数组, 大小都为 $n$.</p>
<p>我们从后往前遍历, 将遍历过的数字维护成一个有序数组, 然后对于任意一个新来的数字, 我们可以在有序数组中查询小于该数字的元素个数, 查询的时间复杂度为 $O(logn)$, 然后我们需要将该数字也插入到有序数组中并保持有序, 插入操作需要的时间复杂度为 $O(n)$, 总共有 $n$ 个数字, 因此需要执行 $n$ 次, 故时间复杂度约为 $O(n^2)$, (虽然是 $O(n^2)$, 但是仍然没超时, 考虑是因为只有一个 $logn$, 而解法一具有两个 $logn$.) 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countSmaller(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order_nums;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//计算第一个不小于nums[i]的数字之前的数字个数</span></span><br><span class="line">            <span class="keyword">int</span> d = <span class="built_in">std</span>::lower_bound(order_nums.begin(), order_nums.end(), nums[i]) - order_nums.begin();</span><br><span class="line">            res[i] = d; <span class="comment">//将数字个数填进结果数字</span></span><br><span class="line">            order_nums.insert(order_nums.begin()+d, nums[i]); <span class="comment">// 当 nums[i] 插入到合适位置, 保持order_nums有序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-二叉搜索树-BST"><a href="#解法三-二叉搜索树-BST" class="headerlink" title="解法三: 二叉搜索树(BST)"></a>解法三: 二叉搜索树(BST)</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 内部只有一个 $logn$ 复杂度的插入操作, 没有其他操作, 但是由于不是平衡的, 所以在最坏情况下的复杂度为 $O(n^2)$, 最好情况即为平衡树, 复杂度为 $O(nlogn)$.<br><strong>空间复杂度:</strong> $O(n+n)$, <code>res</code> 数组和二叉树结构各占 $n$ 大小的空间. 如果采用递归实现插入, 则可能额外需要 $n$ 大小的递归空间.</p>
<p>在解法一中, 通过 <code>multiset</code> 红黑树的结构使得插入时的复杂度为 $logn$, 但是最终需要进行的操作过多, 导致时间超时, 为此, 我们可以自己实现一个二叉搜索树, 从后往前的遍历数组, 并且在插入元素的时候就统计出小于当前元素的节点的个数(为此我们需要在树的结构中额外添加一个变量 <code>smaller</code>, 只是小于当前节点的元素个数), 故而只需要一次 $logn$, 且没有其他多于操作, 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> smaller;</span><br><span class="line">        TreeNode *left;</span><br><span class="line">        TreeNode *right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> v, <span class="keyword">int</span> s):val(v), smaller(s), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(TreeNode *&amp;root, <span class="keyword">int</span> val)</span></span>&#123; <span class="comment">//  注意, 这要insert函数中, root的值要影响函数外的指针, 所以要用引用&amp;</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            root = <span class="keyword">new</span> TreeNode(val, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root-&gt;val)&#123;</span><br><span class="line">            root-&gt;smaller++; <span class="comment">// 如果新来的数比当前root的的值还小, 则smaller增1</span></span><br><span class="line">            <span class="keyword">return</span> insert(root-&gt;left, val); <span class="comment">// 递归插入到左子树中</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 递归插入到右子树中, 返回的小于元素的数量为: 根左侧的数量+右子树的数量+根(0:1)</span></span><br><span class="line">            <span class="keyword">return</span> root-&gt;smaller + insert(root-&gt;right, val) + (root-&gt;val==val ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 这里要千万注意三目运算符的优先级, 一定要用括号整个括起来才行!!!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countSmaller(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, <span class="number">0</span>);</span><br><span class="line">        TreeNode *root = <span class="literal">nullptr</span>;              </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123; <span class="comment">// 如果题目问的是左侧, 则i从0开始</span></span><br><span class="line">            res[i] = insert(root, nums[i]);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-归并排序"><a href="#解法四-归并排序" class="headerlink" title="解法四: 归并排序"></a>解法四: 归并排序</h2><p><strong>时间复杂度:</strong> $O(nlogn)$<br><strong>空间复杂度:</strong> $O(n+n) = O(n)$</p>
<p>由于解法三构造的二叉树并不是一个平衡的二叉树, 导致在树的极端情况下, 时间复杂度为 $O(n^2)$, 而要手动实现二叉树的平衡逻辑, 又有些复杂, 不适合解此题. 所以, 我们可以考虑此题的另一种解法, 即利用归并排序来解决.</p>
<p>【链接】Loading…<br><a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/76607/C%2B%2B-O(nlogn)-Time-O(n)-Space-MergeSort-Solution-with-Detail-Explanation" target="_blank" rel="noopener">https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/76607/C%2B%2B-O(nlogn)-Time-O(n)-Space-MergeSort-Solution-with-Detail-Explanation</a></p>
<h1 id="329-Longest-Increasing-Path-in-a-Matrix"><a href="#329-Longest-Increasing-Path-in-a-Matrix" class="headerlink" title="329. Longest Increasing Path in a Matrix"></a>329. Longest Increasing Path in a Matrix</h1><h2 id="Description-寻找矩阵中的最长递增序列"><a href="#Description-寻找矩阵中的最长递增序列" class="headerlink" title="Description: 寻找矩阵中的最长递增序列"></a>Description: 寻找矩阵中的最长递增序列</h2><p>Given an integer matrix, find the length of the longest increasing path.</p>
<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: nums =</span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest increasing path is [1, 2, 6, 9].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: nums =</span><br><span class="line">[</span><br><span class="line">  [3,4,5],</span><br><span class="line">  [3,2,6],</span><br><span class="line">  [2,2,1]</span><br><span class="line">]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-DP-dfs"><a href="#解法一-DP-dfs" class="headerlink" title="解法一: DP + dfs"></a>解法一: DP + dfs</h2><p><strong>时间复杂度:</strong> $O(mn)$, 每个节点都会遍历一次, 当遍历一次后, 下次再访问时可以直接通过 dp 数组得知答案.<br><strong>空间复杂度:</strong> $O(mn+mn=mn)$, $n$ 行 $m$ 列的 DP 数组所占用的空间大小, 另外还有递归所占用的空间($mn?$)</p>
<p>申请和矩阵相同大小的 DP 数组, 令 <code>dp[i][j]</code> 代表从 <code>(i,j)</code> 位置为起点的绝对递增数列的长度, 每遍历一个位置后, 下一次再访问该位置时就无需重复计算, 可以直接通过 dp 数组获取到相应长度. 在查找当前节点的最大长度时, 我们利用 dfs 算法, 依次从四个方向进行查找, 最终取最大值作为本位置的最长递增序列长度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;dp, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> &amp;n, <span class="keyword">int</span> &amp;m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j]!=<span class="number">0</span>) <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        dp[i][j] = <span class="number">1</span>; <span class="comment">//长度至少为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d : dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i+d[<span class="number">0</span>], y = j+d[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;m &amp;&amp; matrix[x][y] &gt; matrix[i][j])&#123; <span class="comment">// 绝对递增, 因此不能有 =</span></span><br><span class="line">                <span class="keyword">int</span> len =  <span class="number">1</span>+dfs(matrix, dp, x, y, n, m);</span><br><span class="line">                dp[i][j] = <span class="built_in">std</span>::max(dp[i][j], len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span> || matrix[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++)&#123;</span><br><span class="line">                res = <span class="built_in">std</span>::max(res, dfs(matrix, dp, i, j, n, m));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-DP-BFS"><a href="#解法二-DP-BFS" class="headerlink" title="解法二: DP + BFS"></a>解法二: DP + BFS</h2><p>TODO: <a href="http://www.cnblogs.com/grandyang/p/5148030.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/5148030.html</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size(), res = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs&#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q&#123;&#123;&#123;i, j&#125;&#125;&#125;;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                    <span class="keyword">int</span> len = q.size();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; ++k) &#123;</span><br><span class="line">                        <span class="keyword">auto</span> t = q.front(); q.pop();</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dirs) &#123;</span><br><span class="line">                            <span class="keyword">int</span> x = t.first + dir[<span class="number">0</span>], y = t.second + dir[<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || matrix[x][y] &lt;= matrix[t.first][t.second] || cnt &lt;= dp[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">                            dp[x][y] = cnt;</span><br><span class="line">                            res = max(res, cnt);</span><br><span class="line">                            q.push(&#123;x, y&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法刷题/" rel="tag"><i class="fa fa-tag"></i> 算法刷题</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/z_post/面试-视频教程-玩转算法面试/" rel="prev" title="《玩转算法面试LeetCode》视频教程笔记">
                <i class="fa fa-chevron-left"></i> 《玩转算法面试LeetCode》视频教程笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/z_post/面试-智力题/" rel="next" title="智力题">
                智力题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar_zz.png"
                alt="ZeroZone" />
            
              <p class="site-author-name" itemprop="name">ZeroZone</p>
              <p class="site-description motion-element" itemprop="description">并不是什么厉害的地方<br>只是一个安静的学习角落</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">263</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/hellozhaozheng" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:hellozhaozheng@foxmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/ksws0292756" title="零域CSDN博客" target="_blank">零域CSDN博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://xinghanzzy.github.io/" title="BoXiao的博客" target="_blank">BoXiao的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://oldpan.me/" title="Oldpan的博客" target="_blank">Oldpan的博客</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#004-Median-of-Two-Sorted-Arrays"><span class="nav-text">004. Median of Two Sorted Arrays</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-寻找两个有序数组的中位数"><span class="nav-text">Description: 寻找两个有序数组的中位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-根据中位数的特性"><span class="nav-text">解法一: 根据中位数的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#非递归写法"><span class="nav-text">非递归写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归写法"><span class="nav-text">递归写法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#010-Regular-Expression-Matching"><span class="nav-text">010 Regular Expression Matching</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-正则表达式匹配"><span class="nav-text">Description: 正则表达式匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归实现-速度很慢-只超过0-97-的提交"><span class="nav-text">解法一: 递归实现( 速度很慢, 只超过0.97%的提交)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-动态规划"><span class="nav-text">解法二: 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#023-Merge-k-Sorted-Lists"><span class="nav-text">023. Merge k Sorted Lists</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-合并-k-个有序链表"><span class="nav-text">Description: 合并 k 个有序链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-基于比较的合并"><span class="nav-text">解法一: 基于比较的合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-用小顶堆对解法一的比较操作进行优化"><span class="nav-text">解法二: 用小顶堆对解法一的比较操作进行优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-转化成双列表合并问题"><span class="nav-text">解法三: 转化成双列表合并问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-对解法三进行优化"><span class="nav-text">解法四: 对解法三进行优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#041-First-Missing-Positive"><span class="nav-text">041. First Missing Positive</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-下标与正数对应"><span class="nav-text">解法一: 下标与正数对应</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-哈希"><span class="nav-text">解法二: 哈希</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#042-Trapping-Rain-Water"><span class="nav-text">042 Trapping Rain Water</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-1"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-左右指针"><span class="nav-text">解法一: 左右指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#044-Wildcard-Matching"><span class="nav-text">044. Wildcard Matching</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-通配符匹配"><span class="nav-text">Description: 通配符匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-迭代"><span class="nav-text">解法一: 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-DP"><span class="nav-text">解法二: DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-DP"><span class="nav-text">解法三: DP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#076-Minimum-Window-Substring"><span class="nav-text">076. Minimum Window Substring</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-2"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-两个变量记录当前窗口大小"><span class="nav-text">解法: 两个变量记录当前窗口大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子串相关题目的模板解法"><span class="nav-text">子串相关题目的模板解法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#084-Largest-Rectangle-in-Histogram"><span class="nav-text">084. Largest Rectangle in Histogram</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-3"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-穷举"><span class="nav-text">解法一: 穷举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-解法一的改进-空间换时间"><span class="nav-text">解法二: 解法一的改进-空间换时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-最优-栈"><span class="nav-text">解法三: 最优-栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#124-Binary-Tree-Maximum-Path-Sum"><span class="nav-text">124. Binary Tree Maximum Path Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-求最长路径加权和"><span class="nav-text">Description: 求最长路径加权和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#128-Longest-Consecutive-Sequence"><span class="nav-text">128. Longest Consecutive Sequence</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-4"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-排序"><span class="nav-text">解法一: 排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-利用哈希表"><span class="nav-text">解法二: 利用哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-另一种哈希表用法"><span class="nav-text">解法三: 另一种哈希表用法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#140-Word-Break-II"><span class="nav-text">140. Word Break II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-5"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-DP"><span class="nav-text">解法一: DP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#149-Max-Points-on-a-Line"><span class="nav-text">149. Max Points on a Line</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-最大的共线点个数"><span class="nav-text">Description 最大的共线点个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希表"><span class="nav-text">解法一: 哈希表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#212-Word-Search-II"><span class="nav-text">212. Word Search II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-返回字符矩阵中含有的所有单词"><span class="nav-text">Description: 返回字符矩阵中含有的所有单词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-穷举-1"><span class="nav-text">解法一: 穷举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-字典树"><span class="nav-text">解法二: 字典树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#218-The-Skyline-Problem"><span class="nav-text">218. The Skyline Problem</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-天际线问题"><span class="nav-text">Description: 天际线问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-multiset"><span class="nav-text">解法一: multiset</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-priority-queue-堆"><span class="nav-text">解法二: priority_queue(堆)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#239-Sliding-Window-Maximum"><span class="nav-text">239. Sliding Window Maximum</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-滑动窗口的最大值"><span class="nav-text">Description: 滑动窗口的最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-双端队列"><span class="nav-text">解法一: 双端队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#295-Find-Median-from-Data-Stream"><span class="nav-text">295. Find Median from Data Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-返回数据流的中位数"><span class="nav-text">Description: 返回数据流的中位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-传统排序"><span class="nav-text">解法一: 传统排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-插入排序"><span class="nav-text">解法二: 插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-大顶堆-小顶堆"><span class="nav-text">解法三: 大顶堆+小顶堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-multiset-指示器"><span class="nav-text">解法四: multiset+指示器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Follow-Up"><span class="nav-text">Follow Up</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#297-Serialize-and-Deserialize-Binary-Tree"><span class="nav-text">297. Serialize and Deserialize Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-序列化和反序列化二叉树"><span class="nav-text">Description: 序列化和反序列化二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-DFS"><span class="nav-text">解法一: DFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-BFS"><span class="nav-text">解法二: BFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#315-Count-of-Smaller-Numbers-After-Self"><span class="nav-text">315. Count of Smaller Numbers After Self</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-统计右边比当前数字小的个数"><span class="nav-text">Description: 统计右边比当前数字小的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-multiset-1"><span class="nav-text">解法一: multiset</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-有序数组"><span class="nav-text">解法二: 有序数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-二叉搜索树-BST"><span class="nav-text">解法三: 二叉搜索树(BST)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-归并排序"><span class="nav-text">解法四: 归并排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#329-Longest-Increasing-Path-in-a-Matrix"><span class="nav-text">329. Longest Increasing Path in a Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-寻找矩阵中的最长递增序列"><span class="nav-text">Description: 寻找矩阵中的最长递增序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-DP-dfs"><span class="nav-text">解法一: DP + dfs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-DP-BFS"><span class="nav-text">解法二: DP + BFS</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZeroZone</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">2.5m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">37:45</span>
  
</div>










  <div class="footer-custom">勤练带来力量</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  





  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


</body>
</html>
