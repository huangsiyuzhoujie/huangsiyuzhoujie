<!DOCTYPE html>













<html class="theme-next gemini" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">

<meta name="google-site-verification" content="jgw73iXouBAJcOuff0yi9vdSNDecBSOUXacsHJszpmo" />
<meta name="baidu-site-verification" content="xyf9WD2vvl" />











<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/apple-icon-57x57.png?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_body":"slideDownIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="001. Two SumDescription: 求出能组合出目标数的两个元素Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one s">
<meta name="keywords" content="算法刷题">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode 算法题全解">
<meta property="og:url" content="https://hellozhaozheng.github.io/z_post/面试-算法刷题-LeetCode-题目全解/index.html">
<meta property="og:site_name" content="从零开始的BLOG">
<meta property="og:description" content="001. Two SumDescription: 求出能组合出目标数的两个元素Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one s">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://wx4.sinaimg.cn/large/d7b90c85ly1fvxf2u0hrfj20h004iglr.jpg">
<meta property="og:image" content="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1ft6j20hd08kzki.jpg">
<meta property="og:image" content="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1afaj20ge08dwep.jpg">
<meta property="og:image" content="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1khnj20ie06b3yh.jpg">
<meta property="og:image" content="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fw0kh84zz9j20gh085dg5.jpg">
<meta property="og:image" content="https://wx3.sinaimg.cn/large/d7b90c85ly1fwj4ej0utpj20d904mglk.jpg">
<meta property="og:image" content="https://wx1.sinaimg.cn/large/d7b90c85ly1fx2pvbryaxj20if0l0js6.jpg">
<meta property="og:image" content="https://wx3.sinaimg.cn/large/d7b90c85ly1fx2qxg3740j20lf0j8t9r.jpg">
<meta property="og:image" content="https://wx1.sinaimg.cn/large/d7b90c85ly1fxlbg7qyk9j21cs0nwq4u.jpg">
<meta property="og:image" content="http://wx3.sinaimg.cn/large/d7b90c85ly1fxngsjxjyag20cd0a9q6x.gif">
<meta property="og:image" content="https://wx4.sinaimg.cn/large/d7b90c85ly1fxnm0ibh7vj20jc0ggadn.jpg">
<meta property="og:image" content="https://wx4.sinaimg.cn/large/d7b90c85ly1fxr32nc4xoj215u0guq3p.jpg">
<meta property="og:updated_time" content="2019-07-18T05:31:16.804Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode 算法题全解">
<meta name="twitter:description" content="001. Two SumDescription: 求出能组合出目标数的两个元素Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one s">
<meta name="twitter:image" content="https://wx4.sinaimg.cn/large/d7b90c85ly1fvxf2u0hrfj20h004iglr.jpg">






  <link rel="canonical" href="https://hellozhaozheng.github.io/z_post/面试-算法刷题-LeetCode-题目全解/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>LeetCode 算法题全解 | 从零开始的BLOG</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?21a4899cc63d3c11a3d90ac58074a19c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">从零开始的BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">与其感慨路难行，不如马上出发</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档<span class="badge">263</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-计算机视觉">
    <a href="/categories/计算机视觉/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tripadvisor"></i> <br />计算机视觉</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-深度学习">
    <a href="/categories/深度学习/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-drupal"></i> <br />深度学习</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-caffe2">
    <a href="/categories/Caffe2/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-coffee"></i> <br />Caffe2</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-pytorch">
    <a href="/categories/PyTorch/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-free-code-camp"></i> <br />PyTorch</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-c++">
    <a href="/categories/Cpp/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-codiepie"></i> <br />C++</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-python">
    <a href="/categories/Python/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-product-hunt"></i> <br />Python</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-项目">
    <a href="/categories/项目/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-connectdevelop"></i> <br />项目</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-cuda">
    <a href="/categories/CUDA/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-braille"></i> <br />CUDA</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-其他">
    <a href="/categories/其他/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />其他</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签<span class="badge">40</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于我</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />站内搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="站内搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  
  
    
      
    
    <a href="https://github.com/hellozhaozheng" class="github-corner" target="_blank" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg>
    
      </a>
    



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hellozhaozheng.github.io/z_post/面试-算法刷题-LeetCode-题目全解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZeroZone">
      <meta itemprop="description" content="并不是什么厉害的地方<br>只是一个安静的学习角落">
      <meta itemprop="image" content="/images/avatar_zz.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始的BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">LeetCode 算法题全解
              
            
          </h1>
        

        <div class="post-meta">
	
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-02 08:54:58" itemprop="dateCreated datePublished" datetime="2018-11-02T08:54:58+08:00">2018-11-02</time>
            

            
          </span>

	  
  	    <span class="post-updated">
    		&nbsp; | &nbsp; 更新于
    		<time itemprop="dateUpdated" datetime="2019-07-18T13:31:16+08:00" content="2019-07-18">
      		  2019-07-18
    		</time>
  	  </span>
	  

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon"
            >
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">493k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">7:28</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="001-Two-Sum"><a href="#001-Two-Sum" class="headerlink" title="001. Two Sum"></a>001. Two Sum</h1><h2 id="Description-求出能组合出目标数的两个元素"><a href="#Description-求出能组合出目标数的两个元素" class="headerlink" title="Description: 求出能组合出目标数的两个元素"></a>Description: 求出能组合出目标数的两个元素</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong>exactly one solution</strong>, and you may not use the same element twice.</p>
<p>Example:</p>
<p>Given nums = [2, 7, 11, 15], target = 9,</p>
<p>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>
<h2 id="解法一-穷举"><a href="#解法一-穷举" class="headerlink" title="解法一: 穷举"></a>解法一: 穷举</h2><p>时间复杂度: $O(n^2)$<br>空间复杂度: $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;nums.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res =&#123;i,j&#125;;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-哈希表-两次遍历"><a href="#解法二-哈希表-两次遍历" class="headerlink" title="解法二 : 哈希表, 两次遍历"></a>解法二 : 哈希表, 两次遍历</h2><p><strong>注意, 题目中说数组的解恰好只有一个, 这是一种很强的假设, 解法二在面对有多个解时, 也只会输出一个</strong><br>这里要特别注意: 同一个元素不能使用两次, 但是数组中的元素是可以重复的, 重复的元素看作是两个元素. hash表中最终存储的将会是重复元素的最后一个下标, 因此, 在进行比较时, 使用 <code>i!= nums_map[target-nums[i]]</code> 来判断它们是否为同一个元素, 而不能使用<code>nums_map[nums[i]] != nums_map[target-nums[i]]</code></p>
<p>时间复杂度: $O(n)$  遍历两次<br>空间复杂度: $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; nums_map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;nums.size(); i++)&#123;</span><br><span class="line">            nums_map.insert(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span> ; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums_map.count(target-nums[i]) == <span class="number">1</span> &amp;&amp; i!= nums_map[target-nums[i]])&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = &#123;i, nums_map[target-nums[i]]&#125;; <span class="comment">//这里一定要用i,而不能用nums_map[nums[i]] , 上面也同理</span></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-哈希表-一次遍历"><a href="#解法三-哈希表-一次遍历" class="headerlink" title="解法三: 哈希表 一次遍历"></a>解法三: 哈希表 一次遍历</h2><p>事实上, 可以将hash表的插入和查找对应元素的操作放在 一个循环里, 这样就只需要进行一次遍历</p>
<p>时间复杂度: $O(n)$  遍历一次<br>空间复杂度: $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; nums_map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums_map.count(target-nums[i]) == <span class="number">1</span> &amp;&amp; i!= nums_map[target-nums[i]])&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = &#123;i, nums_map[target-nums[i]]&#125;;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            nums_map.insert(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h2><p>How would you approach the problem if the input array is very large (but limited range) and cannot fit in the memory ? This is a follow-up question for this problem.</p>
<h1 id="002-Add-Two-Numbers"><a href="#002-Add-Two-Numbers" class="headerlink" title="002. Add Two Numbers"></a>002. Add Two Numbers</h1><h2 id="Description-链表数之和"><a href="#Description-链表数之和" class="headerlink" title="Description: 链表数之和"></a>Description: 链表数之和</h2><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Example:</p>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.</p>
<h2 id="解法一-顺序相加-注意进位"><a href="#解法一-顺序相加-注意进位" class="headerlink" title="解法一: 顺序相加, 注意进位"></a>解法一: 顺序相加, 注意进位</h2><p>从链表的第一个节点开始, 将两个节点的值和进位位想加, 如果大于10, 则当前结果节点的值对10取余, 同时将进位位置1, 如果小于10, 则直接赋值给当前结果节点, 同时将进位位置0.</p>
<p>特别注意 <code>l1</code> 和 <code>l2</code> 的长度问题, 当二者节点遇到 <code>nullptr</code> 时, 将较长的剩余部分重新赋给l1, 并继续判断</p>
<p>最后, 需要注意是否有进位位, 如果有, 则要申请一个新节点, 并将其置为1</p>
<p><strong>时间复杂度</strong>: $O(\max(m,n))$<br><strong>空间复杂度</strong>: $O(1)$  (这种做法会破坏原有链的结构)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//创建指向最终结果的头指针</span></span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="literal">nullptr</span>)  head-&gt;next = l1; <span class="comment">// 虽然题目指明为非空链表, 但是最好还是做一下判断</span></span><br><span class="line">        <span class="keyword">else</span> head-&gt;next = l2;</span><br><span class="line">        ListNode* pre=head; <span class="comment">// pre用于保存l1的上一个指针</span></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            l1-&gt;val = l1-&gt;val + l2-&gt;val + carry;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &gt; <span class="number">9</span>)&#123;</span><br><span class="line">                l1-&gt;val %= <span class="number">10</span>;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = l1;</span><br><span class="line">            l1 = l1-&gt;next; l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l2!=<span class="literal">nullptr</span>)&#123; <span class="comment">// 此时说明l2比l1长, 用l1的上一个指针指向当前l2剩余的部分,</span></span><br><span class="line">            l1 = pre;</span><br><span class="line">            l1-&gt;next =  l2;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span>)&#123;  <span class="comment">// 此时l1为剩余(l1或l2) 的部分,  只需要考虑是否有进位即可</span></span><br><span class="line">            l1-&gt;val = l1-&gt;val + carry;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &gt; <span class="number">9</span>)&#123;</span><br><span class="line">                l1-&gt;val %= <span class="number">10</span>;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                carry = <span class="number">0</span>;  <span class="comment">// 如果没有进位, 一定要将此处置0, 否则会引起错误</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;  <span class="comment">// 对应 999 + 001 的特殊情况,  此时进位会不断传递, 最终数字位数加1, 最高位为1</span></span><br><span class="line">            ListNode* newnode = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">            l1 = pre;</span><br><span class="line">            l1-&gt;next = newnode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-顺序相加-维持原链表"><a href="#解法二-顺序相加-维持原链表" class="headerlink" title="解法二: 顺序相加, 维持原链表"></a>解法二: 顺序相加, 维持原链表</h2><p><strong>时间复杂度</strong>: $O(\max(m,n))$<br><strong>空间复杂度</strong>: $O(\max(m,n))$  (这种做法需要额外申请空间, 但不会破坏原有链的结构)</p>
<p>该解法思路与解法一一致, 只不过每次都申请一个新的节点, 确保不会改变原有链表的结构.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *pre = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> || l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode *cur = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> a = l1==<span class="literal">nullptr</span> ? <span class="number">0</span> : l1-&gt;val;</span><br><span class="line">            <span class="keyword">int</span> b = l2==<span class="literal">nullptr</span> ? <span class="number">0</span> : l2-&gt;val;</span><br><span class="line">            cur-&gt;val = a + b + carry;</span><br><span class="line">            carry = cur-&gt;val / <span class="number">10</span>;</span><br><span class="line">            cur-&gt;val = cur-&gt;val % <span class="number">10</span>;</span><br><span class="line">            pre-&gt;next = cur;</span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">nullptr</span>) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="literal">nullptr</span>) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            pre-&gt;next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展问题-1"><a href="#扩展问题-1" class="headerlink" title="扩展问题"></a>扩展问题</h2><p>What if the the digits in the linked list are stored in non-reversed order? For example:</p>
<p>$(3 \to 4 \to 2) + (4 \to 6 \to 5) = 8 \to 0 \to 7 (3→4→2)+(4→6→5)=8→0→7$</p>
<p>思路:</p>
<p>先将链表转置 , 再用上面的方法求解</p>
<p><strong>转置时间复杂度</strong>: $O(n)$<br><strong>转置空间复杂度</strong>: $O(1)$</p>
<h1 id="003-Longest-Substring-Without-Repeating-Characters"><a href="#003-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="003. Longest Substring Without Repeating Characters"></a>003. Longest Substring Without Repeating Characters</h1><h2 id="Description-寻找无重复字符的最长子串"><a href="#Description-寻找无重复字符的最长子串" class="headerlink" title="Description: 寻找无重复字符的最长子串"></a>Description: 寻找无重复字符的最长子串</h2><p>Given a string, find the length of the longest substring without repeating characters.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3.</span><br></pre></td></tr></table></figure></p>
<p>Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p>
<h2 id="解法一-暴力"><a href="#解法一-暴力" class="headerlink" title="解法一:暴力"></a>解法一:暴力</h2><p><strong>时间复杂度</strong>: $O(n^3)$ 对于每一个字符, 子串的添加以及查重过程时间复杂度为 $O(n^2)$ , 总共n个字符, 所以为 $O(n^3)$<br><strong>空间复杂度</strong>: $O(min(n,m))$ 需要将当前子串存在起来以便查询是否相等, n为字符串length, m为字符集size</p>
<h2 id="解法二-前后两个指示变量"><a href="#解法二-前后两个指示变量" class="headerlink" title="解法二: 前后两个指示变量"></a>解法二: 前后两个指示变量</h2><p><strong>时间复杂度</strong>: $O(2n) = O(n)$<br><strong>空间复杂度</strong>: $O(min(n,m))$</p>
<p>思路: 首先构造一个哈希表, 用来存储当前子串中出现的字符, 这样, 新来的字符可以直接查询哈希表来判断字符是否存在, 构建哈希表空间复杂度为 <script type="math/tex">O(min(n,m))</script> ( $m$ 为字符集合的大小,一般为26(字母), 128(ASCII), 256(ASCII), $n$ 为字符串的长度)</p>
<p>然后, 使用两个指示变量, 分别指向当前未重复子串的首字符, 和超尾字符, 进行如下几个判断:</p>
<ul>
<li>如果超尾字符与当前子串中的字符不重复, 那么将超尾字符加入到当前子串中,并将length加1</li>
<li>如果超尾字符与当前子串中的字符重复, 利用哈希表查的重复字符的所在位置, 将当前子串的首字符直接跳向该重复字符的下一个位置( <strong>这样可以保证只遍历一遍</strong> ), 并将包括重复字符在内的之前所有字符都从哈希表中删除(之前的字符不再可能组成更长的子串了), 同时将超尾字符加入, length赋予新值: 超尾位置-重复位置-1;</li>
<li>判断首字符与超尾字符是否相等, 如果相等, 将超尾字符加1, 并将length置为1</li>
<li>看当前length是否比maxlength大, 并重复以上过程,直到超尾字符超出size</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>, r=<span class="number">0</span>; r&lt;s.size(); )&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[s[r]] == <span class="number">0</span>)&#123;</span><br><span class="line">                hash[s[r]] = <span class="number">1</span>;</span><br><span class="line">                max_len = <span class="built_in">std</span>::max(max_len, r-l+<span class="number">1</span>);</span><br><span class="line">                r++;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hash[s[l]] = <span class="number">0</span>;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-只需一次遍历"><a href="#解法三-只需一次遍历" class="headerlink" title="解法三: 只需一次遍历"></a>解法三: 只需一次遍历</h2><p><strong>时间复杂度</strong>: $O(n)$, 只需一次遍历<br><strong>空间复杂度</strong>: $O(min(m,n)$, 与解法二相同</p>
<p>当我们在 <code>[i,j)</code> 之间发现了一个重复的下标为 <code>j&#39;</code> 的字符时, 我们不用一点点的增加 <code>i</code> 的值, 而是可以直接将 <code>i</code> 的值跳到 <code>j&#39;+1</code> 处. 故, 我们可以只利用一次遍历就找到最长的不重复子串.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; s_hash;      </span><br><span class="line">        <span class="keyword">int</span> max_length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ,j=<span class="number">0</span> ; j&lt; s.size() ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s_hash.count(s[j]))&#123; <span class="comment">// 这里未删除 i 之前的, 所以即使这里的哈希可以查到, 也不一定就是重复.</span></span><br><span class="line">                i = max(i,s_hash[s[j]]+<span class="number">1</span>); <span class="comment">//如果遇到重复的, 就将当前的i指向重复的下一个</span></span><br><span class="line">                <span class="comment">// (这里用max的原因是, 没有删除当前i到重复字符之间的其他字符, 这些字符</span></span><br><span class="line">                <span class="comment">//  后续还可能被检测到,  所以这里只取max的, 也就是i不会倒退)</span></span><br><span class="line">                <span class="comment">//s_hash.erase(s[j]); // 该语句是多余的</span></span><br><span class="line">            &#125;</span><br><span class="line">            s_hash[s[j]] = j;</span><br><span class="line">            max_length = max_length &gt; (j-i+<span class="number">1</span>) ? max_length : (j-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_length;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>用数组做哈希表:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">256</span>];<span class="comment">// 哈希表中存在的值代表下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;item : hash) item = <span class="number">-1</span>; <span class="comment">// 赋初值</span></span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; j &lt; s.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[s[j]] != <span class="number">-1</span>)&#123; <span class="comment">// 当哈希表中值不为-1时, 说明存在重复</span></span><br><span class="line">                i = <span class="built_in">std</span>::max(hash[s[j]] + <span class="number">1</span>, i); <span class="comment">// 注意这里必须保证 i 不会倒退, 因此要使用 max</span></span><br><span class="line">            &#125;</span><br><span class="line">            max_len = <span class="built_in">std</span>::max(max_len, j-i+<span class="number">1</span>);</span><br><span class="line">            hash[s[j]] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>哈希表, 键为字符, 值为字符在字符串中的位置, 如果键不为空, 说明之前出现过重复字符, 此时, 令起始下标<code>i</code>更新, 注意, 如果, <code>i</code>大于之前键的值, 说明已经包在外面了, i 则不变, 核心思路就是 i 不会回退.</p>
<p>时间复杂度 $O(n)$, 空间复杂度 $O(n)$</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        h_dict = &#123;&#125;</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> h_dict:</span><br><span class="line">                i = max(i, h_dict[c] + <span class="number">1</span>)</span><br><span class="line">            max_len = max(max_len, j - i + <span class="number">1</span>)</span><br><span class="line">            h_dict[c] = j</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
<h1 id="004-Median-of-Two-Sorted-Arrays"><a href="#004-Median-of-Two-Sorted-Arrays" class="headerlink" title="004. Median of Two Sorted Arrays"></a>004. Median of Two Sorted Arrays</h1><h2 id="Description-寻找两个有序数组的中位数"><a href="#Description-寻找两个有序数组的中位数" class="headerlink" title="Description: 寻找两个有序数组的中位数"></a>Description: 寻找两个有序数组的中位数</h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume nums1 and nums2 cannot be both empty.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">The median is 2.0</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">The median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-根据中位数的特性"><a href="#解法一-根据中位数的特性" class="headerlink" title="解法一: 根据中位数的特性"></a>解法一: 根据中位数的特性</h2><p><strong>题目要求需要时间复杂度为 $O(log (m+n))$.</strong><br><strong>空间复杂度:</strong> $O(1)$, 未使用额外空间</p>
<p>首先我们思考中位数的作用: 中位数可以将一个数组分成两个长度相同的部分, 并且一部分中的数字总比另一部分中的小. 那么对于两个数组的情况, 我们需要做的就是找到一个数字, 可以使这两个数组分别分成两部分, <strong>这两部分长度相等(当个数为奇数时, 前一部分多一个元素), 同时前一部分的元素小于等于后一部分的元素</strong>. 首先,我们将数组 A 分成两部分, 由于 A 有 m 个数字,  所以它可以有 m 种不同的分法, 我们以下标 i 对应的数字为界限, 将A分成两部分, 前一部分的长度为 i (从0到 i-1 ), 后一部分的长度为 m-i (从 i 到 m-1): <code>A[1,2,...,i-1] | A[i, i+1, ..., m-1]</code>. 同理,数组 B 也可以做如下分割: <code>B[1,2,...,j-1] | B[j, j+1, ..., n-1]</code>.</p>
<p><strong>这里需要注意一个细节, 我们需要确保 A[i] 这个数字可以将两个数组等长的分割, 那么 A 数组的长度 <u>必须小于等于</u> B 数组的长度. 因为如果 A 数组的长度大于 B 数组的长度, 那么就会出现一种情况: A[i] 前的数字个数已经大于两数组总个数的一半, 此时无论如何也做不到等长分割, 因此, 我们需要先对数组长度判断, 令 A 数组代表的是较短的数组, 利用 <code>swap()</code> 方法可以在 $O(1)$ 时间复杂度内完成.</strong></p>
<p>当两个数组 A 和 B 都被分到了两部分以后, 将它们合起来, 第一部分的数字为 <code>A[1,2,...,i-1]</code> 和 <code>B[1,2,...,j-1]</code>, 第二部分的数字为 <code>A[i, i+1, ..., m-1]</code> 和 <code>B[j, j+1, ..., n-1]</code>, 我们并不关系两部分内部的顺序, 我们只关心一件事, 那就是: <strong>第一部分和第二部分的长度相等, 并且第一部分的数字都比第二部分小</strong>, 于是, i 和 j和取值就必须满足下列关系:</p>
<ul>
<li>i+j = m-i + n-j 或 m-i + n-j + 1   (加1的原因是因为有可能数组总长为奇数, 我们令前一部分比后一部分多1个元素)</li>
<li>i=0 或 A[i-1] &lt;= B[j] (前者说明 A 中元素全部被分配到后半段, 即前半段元素均由 B 中元素组成)</li>
<li>i=m 或 B[j-1] &lt;= A[i] (前者说明 A 中元素全部在前半段, 即后半段元素均由 B 中元素组成)</li>
<li>由于上式 i+j = m-i + n-j 或 m-i + n-j + 1 , 因此有 j = (m+n+1)/2 - i ;  (向下取整).  故而可以只对 i 进行判断 i 是否越界, 只要 i 满足条件,  j就不会等于0或n(前提条件是 A 数组长度小于等于 B 数组长度)</li>
</ul>
<p>根据上面的分析, 解题过程如下:</p>
<ul>
<li>根据两数组的长度, 将短的一方设为A数组 (j要对应较长的那个数组, 否则的话j有可能小于0 ), 令start=0, end=A.size</li>
<li>令 i=(start+end)/2</li>
<li>计算j = (m+n+1)/2 - i</li>
<li>判断当前 i 和 j 是否满足条件,有三种情况(对这三种情况不断重复, 直到i,j位置刚刚好):<ul>
<li>i &gt; 0 并且 A[i-1] &gt; B[j], 说明 i 的位置过大, 令 end = i-1.</li>
<li>i &lt; m 并且 B[j-1] &gt; A[i], 说明 i 的位置过小, 令 start = i+1;</li>
<li>其他情况(i==0 或 A[i-1] &lt;= B[j] 并且 i==m 或 B[j-1] &lt;= A[i]), 说明 i 和 j的位置刚刚好.</li>
</ul>
</li>
<li>当i,j位置刚好时, 根据数组整体长度的奇偶, 返回正确的中位数:<ul>
<li>奇数: 返回前半段的最大元素</li>
<li>偶数: 返回前半段最大元素和后半段最小元素的平均值</li>
</ul>
</li>
</ul>
<h3 id="非递归写法"><a href="#非递归写法" class="headerlink" title="非递归写法"></a>非递归写法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.size() &gt; nums2.size())</span><br><span class="line">            nums1.swap(nums2);</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end=m;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)&#123; <span class="comment">//当 start = end 时, 此时 i=start=end, 不能忽略</span></span><br><span class="line">            <span class="keyword">int</span> i = (start+end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = (n+m+<span class="number">1</span>)/<span class="number">2</span> - i;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums1[i<span class="number">-1</span>] &gt; nums2[j])  <span class="comment">//注意, i=0时说明位置恰好</span></span><br><span class="line">                end = i<span class="number">-1</span>; <span class="comment">//i太大</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i&lt;end &amp;&amp; nums2[j<span class="number">-1</span>] &gt; nums1[i])</span><br><span class="line">                start = i+<span class="number">1</span>; <span class="comment">// i太小</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> leftmax;<span class="comment">// 取左边最大的</span></span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) leftmax=nums2[j<span class="number">-1</span>];  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) leftmax=nums1[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> leftmax = max(nums1[i<span class="number">-1</span>], nums2[j<span class="number">-1</span>]) ;</span><br><span class="line">                <span class="keyword">if</span>( (n+m)%<span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> leftmax;  </span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> rightmin; <span class="comment">// 取右边最小的</span></span><br><span class="line">                <span class="keyword">if</span>(i==m) rightmin = nums2[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==n) rightmin = nums1[i];</span><br><span class="line">                <span class="keyword">else</span> rightmin = min(nums1[i] ,nums2[j]);</span><br><span class="line">                <span class="keyword">return</span> (leftmax+rightmin) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">       <span class="comment">// return 0.0;  //因为, 两数组不会同时为空, 所以这句话主要用于调试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h3><p><strong>写法一:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.size() &lt;= nums2.size())</span><br><span class="line">            <span class="keyword">return</span> helper(nums1, <span class="number">0</span> , nums1.size(),nums2);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> helper(nums2, <span class="number">0</span> , nums2.size(),nums1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = (start1+end1)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> j = (nums1.size()+nums2.size()+<span class="number">1</span>)/<span class="number">2</span> - i;</span><br><span class="line">        <span class="comment">// if(start1 &gt; end1) return 0.0; 因为数组一定是有效的, 因此不会出现这种情况</span></span><br><span class="line">        <span class="keyword">if</span>( (i==<span class="number">0</span> || nums1[i<span class="number">-1</span>]&lt;=nums2[j]) &amp;&amp; (i==nums1.size() || nums2[j<span class="number">-1</span>]&lt;=nums1[i]))&#123; <span class="comment">// 如果找到i</span></span><br><span class="line">            <span class="keyword">int</span> res11, res12;  </span><br><span class="line">            <span class="keyword">int</span> res21, res22;</span><br><span class="line">            <span class="comment">// 首先将左边部分的两个数组分别赋值, 如果i或j为0, 说明对应数组在左边</span></span><br><span class="line">            <span class="comment">//只有0个元素 , 将其赋值为INT_MIN(因为要取max(res11, res21))</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) res11= INT_MIN;          </span><br><span class="line">            <span class="keyword">else</span> res11=nums1[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>) res21= INT_MIN;</span><br><span class="line">            <span class="keyword">else</span> res21=nums2[j<span class="number">-1</span>];            </span><br><span class="line">            <span class="comment">//同理, 对右边进行处理, 取min(res12, res22)</span></span><br><span class="line">            <span class="keyword">if</span>(i==nums1.size()) res12= INT_MAX;</span><br><span class="line">            <span class="keyword">else</span> res12=nums1[i];</span><br><span class="line">            <span class="keyword">if</span>(j==nums2.size()) res22= INT_MAX;</span><br><span class="line">            <span class="keyword">else</span> res22=nums2[j];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据数组奇偶个数返回结果</span></span><br><span class="line">            <span class="keyword">if</span>((nums1.size() + nums2.size())%<span class="number">2</span> == <span class="number">1</span> )&#123;</span><br><span class="line">                <span class="keyword">return</span> max(res11, res21);</span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ( max(res11,res21)+min(res12,res22) ) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i<span class="number">-1</span>] &gt; nums2[j])&#123;</span><br><span class="line">            <span class="keyword">return</span> helper(nums1, start1, i<span class="number">-1</span>, nums2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> helper(nums1, i+<span class="number">1</span>, end1, nums2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>写法二:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.size() &gt; nums2.size())</span><br><span class="line">            <span class="keyword">return</span> helper(nums2, nums1, <span class="number">0</span>, nums2.size());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> helper(nums1, nums2, <span class="number">0</span>, nums1.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//if (start&gt;end) return 0.0; 因为数组一定是有效的, 因此不会出现这种情况</span></span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> i = (start+end)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> j = (m+n+<span class="number">1</span>)/<span class="number">2</span> - i;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums1[i<span class="number">-1</span>] &gt; nums2[j])</span><br><span class="line">            <span class="keyword">return</span> helper(nums1, nums2, start, i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i&lt;m &amp;&amp; nums2[j<span class="number">-1</span>] &gt; nums1[i])</span><br><span class="line">            <span class="keyword">return</span> helper(nums1, nums2, i+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> leftmax;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) leftmax = nums2[j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) leftmax = nums1[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> leftmax = max(nums1[i<span class="number">-1</span>], nums2[j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>((m+n)&amp;<span class="number">1</span> == <span class="number">1</span>) <span class="keyword">return</span> leftmax;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> rightmin;</span><br><span class="line">            <span class="keyword">if</span>(i==m) rightmin = nums2[j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==n) rightmin = nums1[i];</span><br><span class="line">            <span class="keyword">else</span> rightmin = min(nums1[i], nums2[j]);</span><br><span class="line">            <span class="keyword">return</span> (leftmax+rightmin)/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="005-最长回文子串"><a href="#005-最长回文子串" class="headerlink" title="005. 最长回文子串"></a>005. 最长回文子串</h1><h2 id="Description-最长回文子串"><a href="#Description-最长回文子串" class="headerlink" title="Description: 最长回文子串"></a>Description: 最长回文子串</h2><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p>
<p>Example 1:</p>
<p>Input: “babad”<br>Output: “bab”<br>Note: “aba” is also a valid answer.<br>Example 2:</p>
<p>Input: “cbbd”<br>Output: “bb”</p>
<h2 id="解法一：最长公共子串"><a href="#解法一：最长公共子串" class="headerlink" title="解法一：最长公共子串"></a>解法一：最长公共子串</h2><p><strong>时间复杂度:</strong> $O(n^2)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>先将字符串 <code>s</code> 利用 <code>reverse</code> 逆置成 <code>s&#39;</code>, 然后查找 <code>s</code> 和 <code>s&#39;</code> 的最长公共子串, 即为最长的回文子串.</p>
<h2 id="解法二：-穷举"><a href="#解法二：-穷举" class="headerlink" title="解法二： 穷举"></a>解法二： 穷举</h2><p><strong>时间复杂度:</strong> $O(n^3)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>对于字符串中的每一个字符, 共有 $\frac{n(n-1)}{2}$ 种包含该字符的子串, 所以如果对所有可能的子串判断, 需要 $O(n^3)$ 的时间复杂度</p>
<h2 id="解法三：-动态规划"><a href="#解法三：-动态规划" class="headerlink" title="解法三： 动态规划"></a>解法三： 动态规划</h2><p><strong>时间复杂度:</strong> $O(n^2)$<br><strong>空间复杂度:</strong> $O(n^2)$</p>
<p>我们令 DP 数组为一个 $n\times n$ 的矩阵, $dp(i,j)$ 代表从 <code>s[i]</code> 开始, 到 <code>s[j]</code> 结束的子串是否为回文串, 如果是, 则为 <code>true</code>. 那么, $dp(i,j)$ 为真的条件就是必须满足 $dp(i+1, j-1)=true$ 并且 $s[i]=s[j]$. dp 数组的初始值为: $dp(i,i)=true$, $dp(i,i+1)= s[i]==s[i+1]$. 由于需要遍历 dp 矩阵中每一个位置的值, 因此时间复杂度为 $O(n^2)$, 空间复杂度很明显为 $O(n^2)$.</p>
<h2 id="解法三：-扩展中心法"><a href="#解法三：-扩展中心法" class="headerlink" title="解法三： 扩展中心法"></a>解法三： 扩展中心法</h2><p><strong>时间复杂度:</strong> $O(n^2)$<br><strong>空间复杂度:</strong> $O(1)$ 或者 $O(n)$</p>
<p>以每一个字符为中心,  向两边扩展,  将当前能够扩展的长度 len 和最大扩展长度 max_len 作比较, 记录较大者, 同时记录较大者的所对应的中心字符的下标 max_index. 最后, 根据最大扩展的长度max_len 和中心字符的下标 max_index 计算最大回文子串的开始位置和总长度</p>
<p>此处注意, 回文子串有奇偶两种情况, 可采用以下举措之一解决:</p>
<ul>
<li>分别检查奇数和偶数的情况, 这样多检查一次(虽然多检查一次, 但和下面的检查总次数差不多, 因为下面虽然只检查一次, 但次数较多)</li>
<li>向字符内插入特殊符号 ‘#’, 这样不管偶数奇数, 都可以当做奇数处理, 缺点是占用了额外的 $O(n)$ 空间.</li>
</ul>
<p>注意: 既然已经使用了空间复杂度为 $O(n)$ 的方法, 实际上更应该将其该写成马拉车算法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空间复杂度 $O(1)$</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len1=<span class="number">0</span>,len2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> left=i, right = i;  <span class="comment">//通过left和right , 是的对奇偶的分别处理更方便</span></span><br><span class="line">            <span class="keyword">while</span>( left &gt;=<span class="number">0</span> &amp;&amp; right&lt;s.size() &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">                left--; right++;</span><br><span class="line">            &#125;</span><br><span class="line">            len1 = right-left<span class="number">-1</span>; <span class="comment">// 注意, 这里一定是-1, 而不是+1</span></span><br><span class="line"></span><br><span class="line">            left=i;</span><br><span class="line">            right=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>( left&gt;=<span class="number">0</span> &amp;&amp; right&lt;s.size() &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">                left--; right++;</span><br><span class="line">            &#125;</span><br><span class="line">            len2 = right-left<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> len = max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span>(len&gt;max_len)&#123;</span><br><span class="line">                max_len = len;</span><br><span class="line">                start = i- (len<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, max_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>另一种写法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空间复杂度 $O(1)$</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left, right;</span><br><span class="line">            left = i, right = i;</span><br><span class="line">            <span class="keyword">while</span>(s[left] == s[right])&#123; <span class="comment">// 奇数情况</span></span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">if</span>(left &lt; <span class="number">0</span> || right == s.size())&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max_len &lt; right-left<span class="number">-1</span>)&#123;</span><br><span class="line">                max_len = right-left<span class="number">-1</span>;</span><br><span class="line">                max_i = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            left = i, right = i+<span class="number">1</span>; <span class="comment">// 下面要对 right 判断, 防止越界</span></span><br><span class="line">            <span class="keyword">while</span>(right !=s.size() &amp;&amp; s[left] == s[right])&#123;<span class="comment">// 偶数</span></span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">if</span>(left &lt; <span class="number">0</span> || right == s.size())&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max_len &lt; right-left<span class="number">-1</span>)&#123;</span><br><span class="line">                max_len = right-left<span class="number">-1</span>;</span><br><span class="line">                max_i = i+<span class="number">1</span>;<span class="comment">//偶数时令max_i指向偏右的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(max_i-max_len/<span class="number">2</span>, max_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空间复杂度 $O(n)$</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>*  cs = <span class="keyword">new</span> <span class="keyword">char</span>[s.size() * <span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">        cs[<span class="number">0</span>]=<span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size() ; i++)&#123; <span class="comment">//插入 '#'</span></span><br><span class="line">            cs[i*<span class="number">2</span>+<span class="number">1</span>] = s[i];</span><br><span class="line">            cs[i*<span class="number">2</span>+<span class="number">2</span>] = <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;s.size()*<span class="number">2</span>+<span class="number">1</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len=<span class="number">0</span>; <span class="comment">//记录当前扩展长度len</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; i-j&gt;=<span class="number">0</span> &amp;&amp; i+j&lt;s.size()*<span class="number">2</span>+<span class="number">1</span> ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cs[i-j] == cs[i+j])&#123; <span class="comment">//两边字符若相等, 则len长度增1</span></span><br><span class="line">                    len++;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(len &gt; max_len)&#123;</span><br><span class="line">                max_len = len;</span><br><span class="line">                max_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = (max_index - max_len)/<span class="number">2</span>;  <span class="comment">//根据maxlen和index 计算回文子串开始坐标</span></span><br><span class="line">        <span class="keyword">int</span> len = max_len;</span><br><span class="line">        <span class="keyword">delete</span> cs;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, len);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法五-马拉车-Manacher-算法"><a href="#解法五-马拉车-Manacher-算法" class="headerlink" title="解法五: 马拉车(Manacher) 算法"></a>解法五: 马拉车(Manacher) 算法</h2><p>时间复杂度: $O(n)$<br>空间复杂度: $O(n)$</p>
<p>There is even an O(n), O(n) algorithm called Manacher’s algorithm, explained here in detail. However, it is a non-trivial algorithm, and no one expects you to come up with this algorithm in a 45 minutes coding session. But, please go ahead and understand it, I promise it will be a lot of fun.</p>
<p>马拉车算法的核心思想还是从中心扩展发出发, 不过他必须使用 ‘#’ 字符先对原始字符串插入, 如下所示:</p>
<p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fvxf2u0hrfj20h004iglr.jpg" alt=""></p>
<p>接下来, 在每一次 <code>for</code> 循环当中, 都需要保存这么几个值(命名是个人习惯, 可以用其他名字代替):</p>
<ul>
<li>P: P 为最大右边界下标值, 对应的是所有已检测的回文子串中, 右边界下标最大的那个</li>
<li>P_center: 该值是P对应的回文子串的中心下标</li>
<li>max_len: 对应当前最大回文子串的半径(aba的半径为1, a的半径为0)</li>
<li>max_index: 对应当前最大回文子串的中心下标</li>
</ul>
<p>然后, 还需要构建一个和插入’#’后的字符串长度相关的数组 <code>p_len</code>, 里面存放着对应位置的回文串半径, 用以后续的计算, 这一步是关键, 有了这个数组 ,才能实现利用之前计算结果</p>
<p>接下来, 遍历 “新字符串”(即插入’#’之后的字符串) 的每一个字符, 设当前下标为 i, 则有如下情况, 分别处理:</p>
<ul>
<li>P&gt;i, 说明 i 在 P 的范围内, 可以利用前面的计算结果</li>
<li>P&lt;=i, 说明 i 不在 P 的范围内, 无法利用前面的计算结果, 只能逐个判断</li>
</ul>
<p>对上面两种情况具体分析如下:</p>
<p>第一种情况: P&gt;i</p>
<p>找到i相对于 P_center 的对称位置, 设为j, 那么如果Len[j]&lt;P-i, 如下图所示:</p>
<p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1ft6j20hd08kzki.jpg" alt=""></p>
<p> 则以i为中心的回文串的长度至少和以j为中心的回文串一样 , 即Len [i]&gt;=Len[j] , 因此可以直接从Len[j]+1开始判断回文</p>
<p>如果Len[j]&gt;=P-i, 如下图所示:</p>
<p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1afaj20ge08dwep.jpg" alt=""></p>
<p>由对称性, 说明以i为中心的回文串可能会延伸到P之外, 而大于P的部分我们还没有进行匹配, 所以要从P+1位置开始一个一个进行匹配, 直到发生失配</p>
<p>第二种情况: P&lt;=i</p>
<p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1khnj20ie06b3yh.jpg" alt=""></p>
<p>如果i比P还要大, 说明对于中点为i的回文串还一点都没有匹配, 这个时候, 就只能老老实实地一个一个匹配了</p>
<p>在这一次循环完成之前, 更新上面提及的四个变量</p>
<p>循环结束后, 根据 max_index 和 max_len 的值返回最长回文子串</p>
<p>时间复杂度分析:</p>
<p>对于每一个字符, 由于如果直接比较过, 那么就可以利用之前比较的结果直接判断, 所以每个字符都只进行了一次比较, 故而时间复杂度为 $O(n)$</p>
<h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cs_size = s.size()*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>* cs = <span class="keyword">new</span> <span class="keyword">char</span>[cs_size];</span><br><span class="line">        cs[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.size(); i++)&#123;</span><br><span class="line">            cs[i*<span class="number">2</span> + <span class="number">1</span>] = s[i];</span><br><span class="line">            cs[i*<span class="number">2</span> + <span class="number">2</span>] = <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> P = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> P_center = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>* p_len = <span class="keyword">new</span> <span class="keyword">int</span>[cs_size];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;cs_size; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i &lt; P)&#123; <span class="comment">// 如果i&lt;P, 说明可以复用前面的计算结果</span></span><br><span class="line">                <span class="keyword">int</span> j = P_center*<span class="number">2</span> - i; <span class="comment">// j对i关于P_center的对称点</span></span><br><span class="line">                <span class="keyword">if</span>(P-i &gt; p_len[j])&#123; <span class="comment">// 如果i与P之间的距离比 j 的回文串长度还大,</span></span><br><span class="line">                    <span class="comment">//说明可以直接从p_len[j] + 1开始比较, 之前的子串一定是回文串</span></span><br><span class="line">                    <span class="keyword">int</span> k = p_len[j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(i-k&gt;=<span class="number">0</span> &amp;&amp; i+k&lt;cs_size &amp;&amp; cs[i-k] == cs[i+k])&#123;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p_len[i] = k<span class="number">-1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">// 如果距离没有p_len[j] + 1大, 则从超出P的部分开始比较</span></span><br><span class="line">                    <span class="keyword">int</span> k = P - i;</span><br><span class="line">                    <span class="keyword">while</span>(i-k&gt;=<span class="number">0</span> &amp;&amp; i+k&lt;cs_size &amp;&amp; cs[i-k] == cs[i+k])&#123;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p_len[i] = k<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果i不在P范围内, 则必须从1开始逐个比较, 无法利用之前的计算结果</span></span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(i-k&gt;=<span class="number">0</span> &amp;&amp; i+k&lt;cs_size &amp;&amp; cs[i-k] == cs[i+k])&#123;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p_len[i] = k<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(p_len[i] &gt; max_len)&#123;</span><br><span class="line">                max_len = p_len[i];</span><br><span class="line">                max_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i+p_len[i] &gt; P)&#123;</span><br><span class="line">                P = i+p_len[i];</span><br><span class="line">                P_center = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> cs;</span><br><span class="line">        <span class="keyword">delete</span> p_len;</span><br><span class="line">        <span class="keyword">int</span> start = (max_index - max_len)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> len = max_len;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h3><p>解法一: 扩展中心法, 需要额外注意奇数和偶数的情况, 可以通过插入字符将所有的回文串变成奇数情况, 时间复杂度 $O(n^2)$, 空间复杂度 $O(1)$ 或 $O(n)$, 取决于是否插入字符</p>
<p>解法二: Manacher, 基于扩展中心法, 在符合条件的情况下, 可以利用之前的结果来加速判断流程, 时间复杂度接近于 $O(n)$, 空间复杂度 $O(n)$.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Manacher 算法实现(python)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        T = <span class="string">'#'</span>.join(<span class="string">'$&#123;&#125;^'</span>.format(s))</span><br><span class="line">        palin_len = [<span class="number">0</span>] * len(T)</span><br><span class="line">        max_P = <span class="number">0</span></span><br><span class="line">        max_center = <span class="number">0</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(T) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; max_P: <span class="comment"># 当 i 处于最长回文的范围内, 则可利用之前的信息</span></span><br><span class="line">                j = max_center - (i-max_center)</span><br><span class="line">                p_len = min(palin_len[j], max_P - i)</span><br><span class="line">                l = i - p_len - <span class="number">1</span></span><br><span class="line">                r = i + p_len + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 否则, 只能老老实实逐个匹配</span></span><br><span class="line">                l = i - <span class="number">1</span></span><br><span class="line">                r = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; len(T) <span class="keyword">and</span> T[l] == T[r]):</span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            palin_len[i] = r - i - <span class="number">1</span> <span class="comment"># 记录当前字符的回文串长度(半边的长度)</span></span><br><span class="line">            <span class="keyword">if</span> (max_P &lt; r): <span class="comment"># 更新 max_P 和 max_center</span></span><br><span class="line">                max_P = r - <span class="number">1</span></span><br><span class="line">                max_center = i</span><br><span class="line">            <span class="keyword">if</span> (max_len &lt; r - i): <span class="comment"># 更新最长的回文串信息(超头, 超尾)</span></span><br><span class="line">                max_len = r - i</span><br><span class="line">                res_start = l</span><br><span class="line">                res_end = r</span><br><span class="line">        <span class="keyword">return</span> T[res_start+<span class="number">1</span>:res_end].replace(<span class="string">'#'</span>, <span class="string">''</span>) <span class="comment"># 返回时注意去除 '#' 符号</span></span><br></pre></td></tr></table></figure>
<h1 id="006-Z-字形变换-中等"><a href="#006-Z-字形变换-中等" class="headerlink" title="006. Z 字形变换-中等"></a>006. Z 字形变换-中等</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zigzag-conversion/</a></p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>找到字符串下标的对应关系如下:</p>
<ul>
<li>第一行和最后一行: 字符之间的下标间隔刚好是 <code>2 * numRows - 2</code></li>
<li>其他行: 字符之间的下标间隔分两种情况交替出现:<ul>
<li>1: 字符距离最后一行字符的下标距离的 2 倍</li>
<li>2: 字符距离第一行字符的下标距离的 2 倍</li>
</ul>
</li>
</ul>
<p>注意一种特殊情况, 就是当<code>numRows</code>为 1 时, 此时<code>2 * numRows - 2</code>的值为0, 会陷入死循环, 实际上, <code>numRows</code>的值为 1 时, 最终的结果就是原字符串, 直接返回即可</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s: str, numRows: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">1</span>: <span class="keyword">return</span> s</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numRows):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> i == numRows<span class="number">-1</span>:</span><br><span class="line">                index = i</span><br><span class="line">                <span class="keyword">while</span> (index &lt; len(s)):</span><br><span class="line">                    res += s[index]</span><br><span class="line">                    index += <span class="number">2</span> * numRows - <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index = i</span><br><span class="line">                step1 = (numRows - <span class="number">1</span> - i ) * <span class="number">2</span></span><br><span class="line">                step2 = (i) * <span class="number">2</span></span><br><span class="line">                <span class="keyword">while</span> (index &lt; len(s)):</span><br><span class="line">                    res += s[index]</span><br><span class="line">                    index += step1</span><br><span class="line">                    step1, step2 = step2, step1</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="007-Reverse-Integer"><a href="#007-Reverse-Integer" class="headerlink" title="007. Reverse Integer"></a>007. Reverse Integer</h1><h2 id="Description-将数字逆置"><a href="#Description-将数字逆置" class="headerlink" title="Description: 将数字逆置"></a>Description: 将数字逆置</h2><p>Given a 32-bit signed integer, reverse digits of an integer.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-取余数"><a href="#解法一-取余数" class="headerlink" title="解法一: 取余数"></a>解法一: 取余数</h2><p>这道题本身不难, 只要不断对x的绝对值取余数, 就可以得到反转的整数, 但是, 该题的核心考察点在于边界条件的判断, 稍不注意, 很容易漏解(如果不进行边界判断, 即使写出了解决方法, 面试官也很不满意)</p>
<ul>
<li>x为0</li>
<li>x反转后的值,超过了int型数据的表示范围, 检查方法是先用long存储, 然后看情况决定返回值正负.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">int</span> abs_x = <span class="built_in">abs</span>(x);</span><br><span class="line">        <span class="keyword">int</span> sign_x = x&gt;<span class="number">0</span>? <span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>; <span class="comment">// 为了看int是否越界,特意将res声明为long型</span></span><br><span class="line">        <span class="keyword">while</span>( abs_x!=<span class="number">0</span> )&#123;</span><br><span class="line">            res = res*<span class="number">10</span> + abs_x%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(res &gt; INT_MAX || res &lt; INT_MIN) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//这一句就是最主要的考察点,看int是否越界</span></span><br><span class="line">            abs_x = abs_x/<span class="number">10</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sign_x ==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>-res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="008-String-to-Integer-atoi"><a href="#008-String-to-Integer-atoi" class="headerlink" title="008. String to Integer (atoi)"></a>008. String to Integer (atoi)</h1><h2 id="Description-将字符串转换成整数"><a href="#Description-将字符串转换成整数" class="headerlink" title="Description: 将字符串转换成整数"></a>Description: 将字符串转换成整数</h2><h2 id="解法一-考虑多种情况"><a href="#解法一-考虑多种情况" class="headerlink" title="解法一: 考虑多种情况"></a>解法一: 考虑多种情况</h2><p>此题时间复杂度为 $O(n)$ , 重点考察是否考虑的全面, 主要有以下几种情况, 缺一不可:</p>
<ul>
<li>+123 dd   // 返回123</li>
<li>+123d   // 返回123</li>
<li>d-123  // 返回0</li>
<li>-123+ //返回-123</li>
<li>-123+4 // 返回-123</li>
<li>323123423423423 // 返回INT_MAX</li>
<li>-1231238923894234 // 返回INT_MIN</li>
<li>1234-5 // 返回1234</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sign =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> is_first = <span class="literal">true</span>; <span class="comment">//记录当前非数字字符是否是第一个非空格字符, 如果是, 返回0</span></span><br><span class="line">        <span class="keyword">bool</span> has_sign = <span class="literal">false</span>; <span class="comment">// 记录正负号的出现次数, 出现多于1次的, 返回0</span></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;  <span class="comment">//记录当前的int值, 要出现int范围, 返回对应的INT</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt;str.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span> &amp;&amp; is_first) <span class="keyword">continue</span>; <span class="comment">// 空格, 且没有出现任何非空格字符(如出现了, 则空格也会跟着变成循环停止的标志)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( !has_sign &amp;&amp; (str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>) )&#123; <span class="comment">// 判断符号</span></span><br><span class="line">                has_sign = <span class="literal">true</span>;</span><br><span class="line">                is_first = <span class="literal">false</span>;</span><br><span class="line">                sign = str[i]==<span class="string">'+'</span> ? <span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] &lt;= <span class="string">'9'</span> &amp;&amp; str[i] &gt;= <span class="string">'0'</span>)&#123;</span><br><span class="line">                has_sign = <span class="literal">true</span>;</span><br><span class="line">                is_first = <span class="literal">false</span>;</span><br><span class="line">                res = res*<span class="number">10</span> + <span class="keyword">int</span>(str[i] - <span class="string">'0'</span>) * sign; <span class="comment">// 数字累加, 注意这里使用了sign, 因此无需在后面判断正负, 直接加就可以</span></span><br><span class="line">                <span class="keyword">if</span> (res &gt; INT_MAX) <span class="keyword">return</span> INT_MAX; <span class="comment">// 超限</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(res &lt; INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(is_first)&#123;  <span class="comment">//首字符为非法字符, 返回0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="009-回文数-简单"><a href="#009-回文数-简单" class="headerlink" title="009. 回文数-简单"></a>009. 回文数-简单</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-number/</a></p>
<h2 id="解法一-转换成字符串进行标准的中心扩展法进行判断"><a href="#解法一-转换成字符串进行标准的中心扩展法进行判断" class="headerlink" title="解法一: 转换成字符串进行标准的中心扩展法进行判断"></a>解法一: 转换成字符串进行标准的中心扩展法进行判断</h2><p>需要两次遍历, 一次转换, 一次判断</p>
<p>略</p>
<h2 id="解法二-利用数学计算"><a href="#解法二-利用数学计算" class="headerlink" title="解法二: 利用数学计算"></a>解法二: 利用数学计算</h2><p>利用数学计算得到新的回文值, 然后将二者进行比较, 这样进需要一次遍历</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>): <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        new_x = <span class="number">0</span></span><br><span class="line">        ori_x = x</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>):</span><br><span class="line">            new_x = new_x * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x = x // <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> new_x == ori_x <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h1 id="010-Regular-Expression-Matching"><a href="#010-Regular-Expression-Matching" class="headerlink" title="010 Regular Expression Matching"></a>010 Regular Expression Matching</h1><h2 id="Description-正则表达式匹配"><a href="#Description-正则表达式匹配" class="headerlink" title="Description: 正则表达式匹配"></a>Description: 正则表达式匹配</h2><p>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’.</p>
<p>‘.’ Matches any single character.<br>‘*’ Matches zero or more of the preceding element.<br>The matching should cover the entire input string (not partial).</p>
<p><strong>Note:</strong><br>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like . or *.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &apos;*&apos; means zero or more of the precedeng element, &apos;a&apos;. Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-递归实现-速度很慢-只超过0-97-的提交"><a href="#解法一-递归实现-速度很慢-只超过0-97-的提交" class="headerlink" title="解法一: 递归实现( 速度很慢, 只超过0.97%的提交)"></a>解法一: 递归实现( 速度很慢, 只超过0.97%的提交)</h2><p>采用递归法, 首先判断当前字符串 p 是否已经走到尽头, 如果是, 则看 s 是否走到尽头, 返回 true 或者 false.<br>然后在第一个字符的匹配情况, 并记录之.<br>然后看是否存在 ‘<em>‘, 并根据情况进行递归调用.<br>若不存在 ‘</em>‘, 则按正常匹配处理.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> i, <span class="built_in">string</span> &amp;p, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(), m = p.size();</span><br><span class="line">        <span class="keyword">if</span> (j == m) <span class="keyword">return</span> (i == n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> firstMatch = (i != n <span class="keyword">and</span></span><br><span class="line">                            (s[i] == p[j] <span class="keyword">or</span> p[j] == <span class="string">'.'</span>));</span><br><span class="line">        <span class="keyword">if</span> (j &lt; m - <span class="number">1</span> <span class="keyword">and</span> p[j+<span class="number">1</span>] == <span class="string">'*'</span>) &#123; <span class="comment">//只有长度大于 2 的时候, 才考虑 *</span></span><br><span class="line">            <span class="comment">//两种情况</span></span><br><span class="line">            <span class="comment">//pattern 直接跳过两个字符. 表示 * 前边的字符出现 0 次</span></span><br><span class="line">            <span class="comment">//pattern 不变, 例如 text = aa , pattern = a*</span></span><br><span class="line">            <span class="keyword">return</span> helper(s, i, p, j+<span class="number">2</span>) <span class="keyword">or</span></span><br><span class="line">                    (firstMatch <span class="keyword">and</span> helper(s, i+<span class="number">1</span>, p, j));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//  </span></span><br><span class="line">            <span class="keyword">return</span> firstMatch <span class="keyword">and</span> helper(s, i+<span class="number">1</span>, p, j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-动态规划"><a href="#解法二-动态规划" class="headerlink" title="解法二: 动态规划"></a>解法二: 动态规划</h2><p>This problem has a typical solution using Dynamic Programming. We define the state P[i][j] to be true if s[0..i) matches p[0..j) and false otherwise. Then the state equations are:</p>
<ul>
<li>P[i][j] = P[i - 1][j - 1], if p[j - 1] != ‘*’ &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == ‘.’);</li>
<li>P[i][j] = P[i][j - 2], if p[j - 1] == ‘*’ and the pattern repeats for 0 times;</li>
<li>P[i][j] = P[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == ‘.’), if p[j - 1] == ‘*’ and the pattern repeats for at least 1 times.</li>
</ul>
<p>Putting these together, we will have the following code.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> dp[s.size()+<span class="number">1</span>][p.size()+<span class="number">1</span>]&#123;<span class="number">0</span>&#125;; <span class="comment">//!! 这里注意一定要初始化, 否则在下面的循环中, dp[2][0] 是循环不到的, 但是dp[2][2]会访问dp[2][0]的值, 如果不进行初始化, 就会发生 RuntimeError !!!</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;s.size()+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;p.size()+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j<span class="number">-1</span>] == <span class="string">'*'</span>) <span class="comment">//  注意这里是j-1</span></span><br><span class="line">                    dp[i][j] =  ( j &gt; <span class="number">1</span> &amp;&amp; dp[i][j<span class="number">-2</span>] )|| ( i&gt;<span class="number">0</span> &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] || p[j<span class="number">-2</span>] == <span class="string">'.'</span>) &amp;&amp; dp[i<span class="number">-1</span>][j]);  <span class="comment">// 注意这里是j-2, i-1, 一定要知道这些是为什</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = i&gt;<span class="number">0</span> &amp;&amp; dp[i<span class="number">-1</span>][j<span class="number">-1</span>] &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">'.'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size()][p.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="011-Container-With-Most-Water"><a href="#011-Container-With-Most-Water" class="headerlink" title="011. Container With Most Water"></a>011. Container With Most Water</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container and n is at least 2.</p>
<p>The below vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fw0kh84zz9j20gh085dg5.jpg" alt=""></p>
<h2 id="解法一-暴力-1"><a href="#解法一-暴力-1" class="headerlink" title="解法一: 暴力"></a>解法一: 暴力</h2><p>时间复杂度: $O(n^2)$</p>
<p>用max_area标记当前最大容器的取值, 然后两个for循环遍历所有容器的可能取值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;height.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; height.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(max_area &lt; min( height[i],height[j] ) * (j-i))&#123;</span><br><span class="line">                    max_area = min( height[i],height[j] ) * (j-i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-用两个指针"><a href="#解法二-用两个指针" class="headerlink" title="解法二: 用两个指针"></a>解法二: 用两个指针</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>分别用两个指针指向数组的第一个元素和最后一个元素, 并计算当前的area, 然后移动指针元素值较小的一方, 移动过程中更新max_area的值</p>
<p>原理:</p>
<p>首先假设容器可以具有最大长度的宽, 也就是分别指向首尾元素,  这时候 , 我们想查看是否还有比当前最大容积更大的容器,  那么, 我们必须维持较高的垂直边不动, 而将较低的垂直边移动, 因为只有这样, 我们才 <strong>有可能</strong> (注意不是一定)获得比当前容积更大的容器, 这个时候虽然宽变小了, 但是高度却可能增加(因为新增的边有可能大于当前较低边的高).  如果移动较高的边, 那么新增的边由于受到当前较低边的作用, 只有可能减小容器的面积</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = height.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">int</span> area = min( height[low], height[high] ) * (high-low);</span><br><span class="line">            <span class="keyword">if</span>(max_area &lt; area)&#123;</span><br><span class="line">                max_area = area;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(height[low] &lt; height[high])</span><br><span class="line">                low++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="012-整数转罗马数字-中等"><a href="#012-整数转罗马数字-中等" class="headerlink" title="012. 整数转罗马数字-中等"></a>012. 整数转罗马数字-中等</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/integer-to-roman/</a></p>
<h2 id="解法-字典映射-哈希"><a href="#解法-字典映射-哈希" class="headerlink" title="解法: 字典映射(哈希)"></a>解法: 字典映射(哈希)</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        i2r_dict = &#123;<span class="number">1000</span>: <span class="string">'M'</span>, <span class="number">900</span>: <span class="string">'CM'</span>, <span class="number">500</span>: <span class="string">'D'</span>, <span class="number">400</span>: <span class="string">'CD'</span>, <span class="number">100</span>: <span class="string">'C'</span>, <span class="number">90</span>:<span class="string">'XC'</span>,</span><br><span class="line">                    <span class="number">50</span>:<span class="string">'L'</span>, <span class="number">40</span>:<span class="string">'XL'</span>, <span class="number">10</span>:<span class="string">'X'</span>, <span class="number">9</span>:<span class="string">'IX'</span>, <span class="number">5</span>:<span class="string">'V'</span>, <span class="number">4</span>:<span class="string">'IV'</span>, <span class="number">1</span>:<span class="string">'I'</span>&#125;</span><br><span class="line">        i2r = [<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(i2r)):</span><br><span class="line">            <span class="keyword">while</span>(i2r[i] &lt;= num):</span><br><span class="line">                res += i2r_dict[i2r[i]]</span><br><span class="line">                num -= i2r[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="013-Roman-to-Integer"><a href="#013-Roman-to-Integer" class="headerlink" title="013. Roman to Integer"></a>013. Roman to Integer</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p>
<p>Symbol       Value<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>
<p>I can be placed before V (5) and X (10) to make 4 and 9.<br>X can be placed before L (50) and C (100) to make 40 and 90.<br>C can be placed before D (500) and M (1000) to make 400 and 900.<br>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>
<p>Example 1:</p>
<p>Input: “III”<br>Output: 3<br>Example 2:</p>
<p>Input: “IV”<br>Output: 4<br>Example 3:</p>
<p>Input: “IX”<br>Output: 9<br>Example 4:</p>
<p>Input: “LVIII”<br>Output: 58<br>Explanation: L = 50, V= 5, III = 3.<br>Example 5:</p>
<p>Input: “MCMXCIV”<br>Output: 1994<br>Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</p>
<h2 id="解法一-顺序扫描"><a href="#解法一-顺序扫描" class="headerlink" title="解法一: 顺序扫描"></a>解法一: 顺序扫描</h2><p>时间复杂度: $O(n)$</p>
<p>顺序扫描, 如果当前字符比下一个字符小, 说明是 ‘4’ 或 ‘9’ 的情况, 用下一个字符的值减去当前字符的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; roman_char;</span><br><span class="line">        roman_char[<span class="string">'I'</span>] = <span class="number">1</span>;</span><br><span class="line">        roman_char[<span class="string">'V'</span>] = <span class="number">5</span>;</span><br><span class="line">        roman_char[<span class="string">'X'</span>] = <span class="number">10</span>;</span><br><span class="line">        roman_char[<span class="string">'L'</span>] = <span class="number">50</span>;</span><br><span class="line">        roman_char[<span class="string">'C'</span>] = <span class="number">100</span>;</span><br><span class="line">        roman_char[<span class="string">'D'</span>] = <span class="number">500</span>;</span><br><span class="line">        roman_char[<span class="string">'M'</span>] = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;s.size() ; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( i&lt;s.size()<span class="number">-1</span> &amp;&amp; roman_char[s[i]] &lt; roman_char[s[i+<span class="number">1</span>]])&#123;</span><br><span class="line">                res += roman_char[s[i+<span class="number">1</span>]]-roman_char[s[i]];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res += roman_char[s[i]];       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展问题-异常检测"><a href="#扩展问题-异常检测" class="headerlink" title="扩展问题: 异常检测"></a>扩展问题: 异常检测</h2><p>上面的解法虽然可以通过OJ, 但是此题还需要进行特别的异常诊断, 即要能够判断出当前输入的罗马输出是否合法! 如 “IVIV” 就是典型的不合法输入, 对于此输入, 上面的程序会输出 , 这显然不正确</p>
<h1 id="014-Longest-Common-Prefix"><a href="#014-Longest-Common-Prefix" class="headerlink" title="014. Longest Common Prefix"></a>014. Longest Common Prefix</h1><h2 id="Description-最长公共前缀"><a href="#Description-最长公共前缀" class="headerlink" title="Description: 最长公共前缀"></a>Description: 最长公共前缀</h2><p>Write a function to find the longest common prefix string amongst an array of strings.<br>If there is no common prefix, return an empty string “”.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>All given inputs are in lowercase letters a-z.</p>
<h2 id="解法一-顺序比较"><a href="#解法一-顺序比较" class="headerlink" title="解法一: 顺序比较"></a>解法一: 顺序比较</h2><p><strong>时间复杂度:</strong> $O(S)$, $S$ 为所有字符串中的字符总数<br><strong>空间复杂度:</strong> $O(1)$, 没有使用额外的空间</p>
<p>暴力求解, 先求第一个字符串与第二个字符串最长公共前缀, 然后利用该前缀与第三个字符串比较, 知道公共前缀为空或者比较完所有字符串.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.size()==<span class="number">0</span> || strs[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;strs.size() &amp;&amp; !prefix.empty(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;prefix.size()&amp;&amp;j&lt;strs[i].size()</span><br><span class="line">                 &amp;&amp;prefix[j] == strs[i][j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            prefix = prefix.substr(<span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-垂直比较"><a href="#解法二-垂直比较" class="headerlink" title="解法二: 垂直比较"></a>解法二: 垂直比较</h2><p><strong>时间复杂度:</strong> $O(S)$, $S$ 为所有字符串中的字符总数, 最好情况下复杂度为 $O(n\min(s)$, $\min(s)$ 为字符串数组中的最短字符串长度.<br><strong>空间复杂度:</strong> $O(1)$, 没有使用额外的空间</p>
<p>顺序比较所有字符串的值, 直到遇到第一次不相等的位置, 然后输出前面的公共前缀, 需要额外注意处理以下几种特殊情况:<br>输入</p>
<ul>
<li>输入为: [] 或 [“”]  应该直接返回””</li>
<li>输入为: [“abc”]   应该直接返回”abc”</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() ==<span class="number">0</span> || strs[<span class="number">0</span>]==<span class="string">""</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() ==<span class="number">1</span> ) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k&lt;strs.size(); k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[<span class="number">0</span>][i] != strs[k][i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span>) <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>,i);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="015-3Sum"><a href="#015-3Sum" class="headerlink" title="015. 3Sum"></a>015. 3Sum</h1><h2 id="Description-三数和为零"><a href="#Description-三数和为零" class="headerlink" title="Description: 三数和为零"></a>Description: 三数和为零</h2><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong><br>The solution set must <strong>not</strong> contain duplicate triplets.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-固定一个数-剩余两个数用双指针法求"><a href="#解法一-固定一个数-剩余两个数用双指针法求" class="headerlink" title="解法一: 固定一个数, 剩余两个数用双指针法求"></a>解法一: 固定一个数, 剩余两个数用双指针法求</h2><p><strong>时间复杂度:</strong> $O(n^2+nlogn)=O(n^2)$<br><strong>空间复杂度:</strong> $O(1)$, 无需额外空间</p>
<p><strong>解题步骤:</strong></p>
<ol>
<li>对整个数组排序, $O(nlogn)$;</li>
<li>固定下标 <code>i</code>, 令下标<code>j=i+1</code>, 令 <code>k=nums.size()-1</code>.</li>
<li>如果 <code>nums[i]</code> 为正数, 说明不可能组成和为零的三元组, 直接返回当前结果;</li>
<li>为了消除重复, 对于相同的相邻元素, 我们只选其中的一个参与组合. <strong>注意: 这里的重复是指三元组的值的重复, 而不是下标重复, 也就是说, 对于下标不同但值相同的元素, 也算作重复.</strong></li>
<li>重复(2)(3)(4)过程直到循环终止.</li>
</ol>
<p><strong>排序的必要性:</strong> 这里我们排序的主要目的是为了消除重复, 如果题目允许重复, 那么可以不进行排序, 而采用基于哈希表的 TwoSum 来求解.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[low] != nums[(low+high)/<span class="number">2</span>])&#123; <span class="comment">// 注意这里用异或交换的陷阱</span></span><br><span class="line">            nums[low] = nums[low] + nums[(low+high)/<span class="number">2</span>];</span><br><span class="line">            nums[(low+high)/<span class="number">2</span>] = nums[low] - nums[(low+high)/<span class="number">2</span>];</span><br><span class="line">            nums[low] = nums[low] - nums[(low+high)/<span class="number">2</span>];      </span><br><span class="line">        &#125; <span class="comment">// 主要是将中将的数字和首位交换, 个人觉得可有可无, 因为时间复杂度是一样的</span></span><br><span class="line">        <span class="keyword">int</span> P = nums[low];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P&lt;=nums[high]) high--;</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P&gt;=nums[low]) low++;</span><br><span class="line">            nums[high] = nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = P;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = partition(nums, low, high);</span><br><span class="line">        <span class="keyword">if</span>(low&lt;mid ) quickSort(nums, low, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;high) quickSort(nums, mid+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;<span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//剪枝, 如果当前数字为正, 那么后面就不可能再有符合条件的三元组, 可以提前退出</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] ) <span class="keyword">continue</span>; <span class="comment">//去除重复, 遇到除第一个外相同的三元组最小的数字, 则跳过</span></span><br><span class="line">            <span class="keyword">int</span> low = i+<span class="number">1</span>, high = nums.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">                <span class="keyword">if</span>(low&gt;i+<span class="number">1</span> &amp;&amp; nums[low] == nums[low<span class="number">-1</span>])&#123; <span class="comment">// 仍然是去除重复,</span></span><br><span class="line">                    low++; <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[low] + nums[i] + nums[high];</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;<span class="number">0</span>) high--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) low++;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp&#123;nums[low], nums[i], nums[high]&#125;;</span><br><span class="line">                    res.push_back(tmp);</span><br><span class="line">                    low++;  <span class="comment">// 这一点千万别漏了, 要继续判断, 因为以当前数字开始的三元组可能不止一个</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更好的写法:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;=<span class="number">2</span>)<span class="keyword">return</span> result;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(a &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; a == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;<span class="comment">// 这里不能用nums[i]==nums[i+1], 因为会丢掉类似于 -1,-1,2 的解.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> j = i + <span class="number">1</span>, k = nums.size() - <span class="number">1</span>; j &lt; k;) &#123;</span><br><span class="line">                <span class="keyword">int</span> b = nums[j];</span><br><span class="line">                <span class="keyword">int</span> c = nums[k];</span><br><span class="line">                <span class="keyword">int</span> value = a + b + c;</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</span><br><span class="line">                    result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;a, b, c&#125;));</span><br><span class="line">                    <span class="keyword">while</span> (j &lt; k &amp;&amp; b == nums[++j]); <span class="comment">// 主要是这里的写法很优雅, 其他地方和上面差不多</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; k &amp;&amp;c == nums[--k]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-python写法"><a href="#解法二-python写法" class="headerlink" title="解法二: python写法"></a>解法二: python写法</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        target = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> p1 <span class="keyword">in</span> range (len(nums) - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> (nums[p1] &gt; <span class="number">0</span>): <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">if</span> (p1 &gt; <span class="number">0</span> <span class="keyword">and</span> nums[p1] == nums[p1<span class="number">-1</span>]): <span class="keyword">continue</span></span><br><span class="line">            p2 = p1 + <span class="number">1</span></span><br><span class="line">            p3 = len(nums) <span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> (p2 &lt; p3):</span><br><span class="line">                <span class="keyword">if</span> (p2<span class="number">-1</span> != p1 <span class="keyword">and</span> nums[p2] == nums[p2<span class="number">-1</span>]):</span><br><span class="line">                    p2 += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                tmp = nums[p1] + nums[p2] + nums[p3]</span><br><span class="line">                <span class="keyword">if</span> (tmp &gt; <span class="number">0</span>): p3 -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> (tmp &lt; <span class="number">0</span>): p2 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[p1], nums[p2], nums[p3]])</span><br><span class="line">                    p2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="016-3Sum-Closest"><a href="#016-3Sum-Closest" class="headerlink" title="016. 3Sum Closest"></a>016. 3Sum Closest</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.com/problems/3sum-closest/" target="_blank" rel="noopener">题目链接</a></p>
<p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p>Example:<br>Given array nums = [-1, 2, 1, -4], and target = 1.<br>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p>
<h2 id="解法一-排序-双指针"><a href="#解法一-排序-双指针" class="headerlink" title="解法一: 排序+双指针"></a>解法一: 排序+双指针</h2><p><strong>时间复杂度:</strong> $O(n^2)$</p>
<p>先排序, 然后固定中间位, 移动两边</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        sum3 = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> center <span class="keyword">in</span> range(<span class="number">1</span>, len(nums) - <span class="number">1</span>):</span><br><span class="line">            p1 = <span class="number">0</span></span><br><span class="line">            p2 = len(nums) <span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> (p1 != center <span class="keyword">and</span> p2 != center):</span><br><span class="line">                tmp3sum = nums[p1] + nums[center] + nums[p2]</span><br><span class="line">                <span class="keyword">if</span> (abs(tmp3sum - target) &lt; abs(sum3 - target)):</span><br><span class="line">                    sum3 = tmp3sum</span><br><span class="line">                <span class="keyword">if</span> (tmp3sum &lt; target):</span><br><span class="line">                    p1 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> (tmp3sum &gt; target):</span><br><span class="line">                    p2 -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> sum3</span><br></pre></td></tr></table></figure>
<h1 id="017-Letter-Combinations-of-a-Phone-Number"><a href="#017-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="017. Letter Combinations of a Phone Number"></a>017. Letter Combinations of a Phone Number</h1><h2 id="Description-九键字母组合"><a href="#Description-九键字母组合" class="headerlink" title="Description: 九键字母组合"></a>Description: 九键字母组合</h2><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.<br>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="解法一-递归"><a href="#解法一-递归" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h3><p><strong>时间复杂度:</strong> $O(n<em>4^n)$, $n$ 为数字的长度<br><em>*空间复杂度:</em></em> $O(4^n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back_tracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; digit_letters, <span class="built_in">string</span>&amp; tmp,<span class="built_in">string</span> digits, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == digits.size())&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;digit_letters[digits[index]-<span class="string">'0'</span>].size(); i++)&#123;</span><br><span class="line">                tmp.push_back(digit_letters[digits[index]-<span class="string">'0'</span>][i]);</span><br><span class="line">                back_tracking(res, digit_letters, tmp, digits, index+<span class="number">1</span>);</span><br><span class="line">                tmp.pop_back();<span class="comment">// 移除当前末尾元素, 以便可以加下一个</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(digits.size() &lt;=<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//res.push_back(""); //在递归解法中, 不需要改语句.</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; digit_letters&#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,</span><br><span class="line">                      <span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> tmp=<span class="string">""</span>;</span><br><span class="line">        back_tracking(res, digit_letters, tmp, digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解法二-非递归"><a href="#解法二-非递归" class="headerlink" title="解法二: 非递归"></a>解法二: 非递归</h3><p><strong>时间复杂度:</strong> $O(n<em>4^n)$, $n$ 为数字数组的长度<br><em>*空间复杂度:</em></em> $O(4^n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(digits.size() &lt;=<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        res.push_back(<span class="string">""</span>); <span class="comment">//对res向量初始化,以便开始, 如果不初始化, 则size为0,后面的循环无法进行</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; digit_letters&#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,</span><br><span class="line">                                          <span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;digits.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = digits[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(digit_letters[num] == <span class="string">""</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp; <span class="comment">// 申请一个临时vector, 用于存放加上当前数字字符的string集合</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; digit_letters[num].size(); k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l =<span class="number">0</span>; l &lt; res.size(); l++)&#123;</span><br><span class="line">                    tmp.push_back(res[l]+digit_letters[num][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.swap(tmp); <span class="comment">// 将res于tmp交换, swap仅仅是改变指针, 比'='更快, 因为'='包含了复制</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="解法一-利用reduce实现"><a href="#解法一-利用reduce实现" class="headerlink" title="解法一: 利用reduce实现"></a>解法一: 利用reduce实现</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> digits==<span class="string">""</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        digit_letters = &#123;<span class="string">'0'</span>:<span class="string">""</span>, <span class="string">'1'</span>:<span class="string">""</span>, <span class="string">'2'</span>:<span class="string">"abc"</span>,</span><br><span class="line">                        <span class="string">'3'</span>:<span class="string">"def"</span>, <span class="string">'4'</span>:<span class="string">"ghi"</span>, <span class="string">'5'</span>:<span class="string">"jkl"</span>,</span><br><span class="line">                        <span class="string">'6'</span>:<span class="string">"mno"</span>, <span class="string">'7'</span>:<span class="string">"pqrs"</span>, <span class="string">'8'</span>:<span class="string">"tuv"</span>, <span class="string">'9'</span>:<span class="string">"wxyz"</span>&#125;</span><br><span class="line">        <span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">        <span class="comment"># 在python3中, reduce()函数已经从全局命名空间移除, 现在存在于functools模块中,使用时需要导入</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> res,digit:[x+y <span class="keyword">for</span> x <span class="keyword">in</span> res <span class="keyword">for</span> y <span class="keyword">in</span> digit_letters[digit]], digits, [<span class="string">""</span>])</span><br></pre></td></tr></table></figure>
<p><span id="018"></span></p>
<h1 id="018-四数之和"><a href="#018-四数之和" class="headerlink" title="018. 四数之和"></a>018. 四数之和</h1><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法:"></a>解法:</h2><p>转换成两数之和<br><strong>时间复杂度</strong> $O(n^3)$</p>
<p>先排序<br>从前往后, 固定一个数字, 这样, 该数字后的剩余数列变成了一个 3sum 问题<br>然后再固定一个数字, 这样, 剩余数列就变成了一个 2sum 问题</p>
<p><strong>注意1:</strong> 要注意重复四元组的判断, 判断方式是当 <code>i &gt; 0 and nums[i] == nums[i-1]</code> 时, 跳过该数字.<br><strong>注意2:</strong> 一定要使用早停, 否则程序的运行时间回大大升高</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(nums, target, k, res, tmp_res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span>(len(nums) &lt; k <span class="keyword">or</span> nums[<span class="number">0</span>] * k &gt; target <span class="keyword">or</span> nums[<span class="number">-1</span>] * k &lt; target):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">2</span>):</span><br><span class="line">                i = <span class="number">0</span></span><br><span class="line">                j = len(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; j):</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i<span class="number">-1</span>] == nums[i]):</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    tmp = nums[i] + nums[j]</span><br><span class="line">                    <span class="keyword">if</span> (tmp &lt; target): i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> (tmp &gt; target): j -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res.append(tmp_res + [nums[i], nums[j]])</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i<span class="number">-1</span>] == nums[i]):</span><br><span class="line">                        <span class="comment">#i += 1 这里不论加不加 i 效果都一样, 为什么?</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    twoSum(nums[i+<span class="number">1</span>:], target-nums[i], k<span class="number">-1</span>, res, tmp_res+[nums[i]])</span><br><span class="line">        res = []</span><br><span class="line">        twoSum(sorted(nums), target, <span class="number">4</span>, res, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="019-Remove-Nth-Node-From-End-of-List"><a href="#019-Remove-Nth-Node-From-End-of-List" class="headerlink" title="019. Remove Nth Node From End of List"></a>019. Remove Nth Node From End of List</h1><h2 id="Description-移除链表的倒数第-N-个字符"><a href="#Description-移除链表的倒数第-N-个字符" class="headerlink" title="Description: 移除链表的倒数第 N 个字符"></a>Description: 移除链表的倒数第 N 个字符</h2><p>Given a linked list, remove the n-th node from the end of list and return its head.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>Given n will always be valid.</p>
<p><strong>Follow up:</strong><br>Could you do this in one pass?</p>
<h2 id="解法一-遍历两次"><a href="#解法一-遍历两次" class="headerlink" title="解法一: 遍历两次"></a>解法一: 遍历两次</h2><p>第一次遍历求出链表长度, 第二次遍历在对应位置删除节点</p>
<h2 id="解法二-双指针-只遍历一次"><a href="#解法二-双指针-只遍历一次" class="headerlink" title="解法二: 双指针, 只遍历一次"></a>解法二: 双指针, 只遍历一次</h2><p>时间复杂度: $O(n)$ 且只遍历一次</p>
<p>空间复杂度: $O(1)$</p>
<p>维护两个指针, 两指针之间的距离刚好相差n, 当第二个指针到达链表尾部时, 第一个指针刚好指向倒数第n个节点, 直接删除该节点即可.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* first = head;</span><br><span class="line">        ListNode* second = head;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">nullptr</span>) <span class="keyword">return</span> head-&gt;next; <span class="comment">// 链表长度为n, 删除倒数第n个节点</span></span><br><span class="line">        <span class="keyword">while</span> (first-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是有一种写法, 新申请了一个节点空间, 用于指向head节点, 可以使代码看起来更容易理解, 对边界条件的判断也更加方便</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> head; <span class="comment">//链表为空, 或者n&lt;=0时, 直接返回head</span></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* first = dummy;</span><br><span class="line">        ListNode* second = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(second == <span class="literal">nullptr</span>) <span class="keyword">return</span> dummy-&gt;next;<span class="comment">// n超出了链表的长度</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(second-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        first-&gt;next = first-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="020-Valid-Parentheses"><a href="#020-Valid-Parentheses" class="headerlink" title="020. Valid Parentheses"></a>020. Valid Parentheses</h1><h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><p>Given a string containing just the characters <code>&#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;</code>, determine if the input string is valid.<br>An input string is valid if:<br>Open brackets must be closed by the same type of brackets.<br>Open brackets must be closed in the correct order.<br>Note that an empty string is also considered valid.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;([)]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-栈"><a href="#解法一-栈" class="headerlink" title="解法一: 栈"></a>解法一: 栈</h2><p>时间复杂度: $O(n)$<br>空间复杂度: $O(n)$</p>
<p><strong>写法一:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s_brack;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c=<span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>) c=<span class="string">'('</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">']'</span>) c=<span class="string">'['</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">'&#125;'</span>) c=<span class="string">'&#123;'</span>;</span><br><span class="line">            <span class="keyword">if</span>(!s_brack.empty() &amp;&amp; c ==  s_brack.top()) s_brack.pop();</span><br><span class="line">            <span class="keyword">else</span> s_brack.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s_brack.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>写法二:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; parent;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'('</span> || c==<span class="string">'&#123;'</span> || c==<span class="string">'['</span>)</span><br><span class="line">                parent.push(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(parent.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((c==<span class="string">')'</span> &amp;&amp; parent.top()==<span class="string">'('</span>) ||</span><br><span class="line">                    (c==<span class="string">'&#125;'</span> &amp;&amp; parent.top()==<span class="string">'&#123;'</span>) ||</span><br><span class="line">                    (c==<span class="string">']'</span> &amp;&amp; parent.top()==<span class="string">'['</span>))&#123;</span><br><span class="line">                parent.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent.empty() ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="021-Merge-Two-Sorted-Lists"><a href="#021-Merge-Two-Sorted-Lists" class="headerlink" title="021. Merge Two Sorted Lists"></a>021. Merge Two Sorted Lists</h1><h2 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p>Example:</p>
<p>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<h2 id="解法一-遍历融合"><a href="#解法一-遍历融合" class="headerlink" title="解法一: 遍历融合"></a>解法一: 遍历融合</h2><p>时间复杂度: $O(min(m,n))$</p>
<p>空间复杂度: $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* head=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur= cur-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="literal">nullptr</span>) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面开关头结点的过程过于复杂, 可以用<code>dummy</code>指针简化这个过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="literal">nullptr</span>) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="022-Generate-Parentheses"><a href="#022-Generate-Parentheses" class="headerlink" title="022. Generate Parentheses"></a>022. Generate Parentheses</h1><h2 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-暴力-2"><a href="#解法一-暴力-2" class="headerlink" title="解法一: 暴力"></a>解法一: 暴力</h2><p>先求出所有可能性, 然后验证每一种可能性是否正确</p>
<h2 id="解法二-回溯"><a href="#解法二-回溯" class="headerlink" title="解法二: 回溯"></a>解法二: 回溯</h2><p>有关递归的时间空间复杂度分析起来都不太容易, 这里只上答案(//TODO 具体怎么来没搞懂)</p>
<p><strong>时间复杂度:</strong> $O(\frac{4^n}{\sqrt n})$<br><strong>空间复杂度:</strong> $O(\frac{4^n}{\sqrt n})$ 以及 $O(n)$ 的空间来存储组合序列</p>
<p>考虑合法括号组合的规律: 必须首先出现左括号, 然后才能出现右括号, 如果当前的string里面的右括号数量大于左括号数量, 那么就一定会出现<code>)(</code>这种不匹配的情况.</p>
<p>核心思路: 从头开始构建组合, 每次接入一个字符, 接入的字符只有两种可能性, 即左括号或者右括号, 而一旦接入的字符使得当前字符中右括号数量大于左括号, 就会变得不合法组合,其它均为合法. 根据此性质, 进行如下递归:</p>
<p>维护两个变量left_rest, right_rest分别代表 <strong>剩余</strong> 可以添加的括号的 <strong>数量</strong>. 采用递归算法, 每次添加一个 ‘(‘ 或者一个 ‘)’, 添加时需要考虑下面几种情况:</p>
<ul>
<li>为了保证当前string内左括号数量多于右括号数量, left_rest一定要小于right_rest</li>
<li>如果<code>left_rest = right_rest = 0</code>, 则说明此时没有可以添加的括号了.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        helper(res, <span class="string">""</span>, n, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res, <span class="built_in">string</span> out, <span class="keyword">int</span> left_rest, <span class="keyword">int</span> right_rest)</span></span>&#123; <span class="comment">//注意这里的 out 不能生命成引用形式</span></span><br><span class="line">        <span class="comment">//if(left_rest &gt; right_rest) return;</span></span><br><span class="line">        <span class="keyword">if</span>(left_rest == <span class="number">0</span> &amp;&amp; right_rest ==<span class="number">0</span>) res.push_back(out);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(left_rest&gt;<span class="number">0</span>) helper(res, out+<span class="string">'('</span>, left_rest<span class="number">-1</span>, right_rest);</span><br><span class="line">            <span class="keyword">if</span>(right_rest&gt;<span class="number">0</span> &amp;&amp; right_rest &gt; left_rest) helper(res, out+<span class="string">')'</span>, left_rest, right_rest<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-Closure-Number"><a href="#解法三-Closure-Number" class="headerlink" title="解法三: Closure Number"></a>解法三: Closure Number</h2><p><strong>时间复杂度:</strong> $O(\frac{4^n}{\sqrt n})$, 同解法4<br><strong>空间复杂度:</strong> $O(\frac{4^n}{\sqrt n})$, 同解法4</p>
<p>该方法可以看做是一种插入法, 选定一组括号 <code>()</code>, 由此便消耗了一组括号的数量, 此时还剩下 <code>n-1</code> 组括号, 我们将这 <code>n-1</code> 组括号插入到选定的括号中, 即 <code>(left)right</code>, 其中, <code>left</code> 和 <code>right</code> 都是有效的括号组合, 它们的括号组数加起来刚好为 <code>n-1</code>, 因此, <code>left</code> 的括号组数的情况共有 <code>n</code> 种情况: [0, …, n-1], 对应的 <code>right</code> 的组数有 <code>n-1-left</code> 组. 具体代码实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            res.push_back(<span class="string">""</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;n; c++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">string</span> left : generateParenthesis(c))</span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">string</span> right : generateParenthesis(n<span class="number">-1</span>-c))</span><br><span class="line">                        res.push_back(<span class="string">"("</span>+left+<span class="string">")"</span>+right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-用栈来模拟递归"><a href="#解法四-用栈来模拟递归" class="headerlink" title="解法四: 用栈来模拟递归"></a>解法四: 用栈来模拟递归</h2><p>首先是最厚的括号包裹状态, 即一开始左边是连续的左括号, 右边是连续的右括号, 然后执行以下逻辑：</p>
<ol>
<li>右括号不能比左括号多;</li>
<li>弹出右括号, 直到遇到第一个左括号, 如果左括号改成右括号仍然合法, 则把它改成右括号; 否则, 左括号继续弹出;</li>
<li>改完之后一个劲加左括号, 直到所有可以用的左括号都加完为止; 然后再一个劲的加右括号, 直到加完位置;</li>
<li>循环一直执行到不能弹出括号为止, 即直到栈为空.</li>
</ol>
<p><strong>这里刚好凸显了一件事情, 那就是要注意尽可能不要将自增或自减操作写在 <code>while()</code> 条件句里面, 否则会造成一些很难发现的错误, 下面代码中的注释会说明</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = n;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="comment">// 注意, 将left写在while里面的问题时, 当left为0时才会结束while</span></span><br><span class="line">        <span class="comment">// 但是此时会使得 left 变成 -1, 因此, 需要再left++, 或者讲left--写在 while 里面</span></span><br><span class="line">        <span class="keyword">while</span> (left--) &#123;</span><br><span class="line">            s += <span class="string">'('</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">        <span class="keyword">while</span> (right--) &#123;</span><br><span class="line">            s += <span class="string">')'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">        res.push_back(s);</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.back() == <span class="string">')'</span>) &#123;</span><br><span class="line">                s.pop_back();</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left+<span class="number">1</span> &lt; right) &#123;</span><br><span class="line">                left++; right--;</span><br><span class="line">                s.back() = <span class="string">')'</span>;</span><br><span class="line">                <span class="keyword">while</span> (left--) s.push_back(<span class="string">'('</span>);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">while</span> (right--) s.push_back(<span class="string">')'</span>);</span><br><span class="line">                right++;</span><br><span class="line">                res.push_back(s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.pop_back();</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="023-Merge-k-Sorted-Lists"><a href="#023-Merge-k-Sorted-Lists" class="headerlink" title="023. Merge k Sorted Lists"></a>023. Merge k Sorted Lists</h1><h2 id="Description-合并-k-个有序链表"><a href="#Description-合并-k-个有序链表" class="headerlink" title="Description: 合并 k 个有序链表"></a>Description: 合并 k 个有序链表</h2><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-基于比较的合并"><a href="#解法一-基于比较的合并" class="headerlink" title="解法一: 基于比较的合并"></a>解法一: 基于比较的合并</h2><p>时间复杂度: $O(k \times N)$  k为需要合并和链表个数, 在比较时需要遍历k个链表的头结点, 以便找出最小的. 每插入一个节点, 就要重新遍历一次, 故需要遍历 $N$ 次, $N$ 为所有链表的节点总数.<br>空间复杂度: $O(1)$</p>
<p>将该问题看做是两个有序链表的合并问题, 只不过每次选择最小的节点时, 需要从vector.size()个节点中选择, 同时还要注意及时移除vector中已经走到头的空链表, 并判断size当前的大小, 当vector中的size大小为1时, 说明其余链表都已经合并完成, 此时退出循环, 直接将该链表接入即可.</p>
<p>另外要注意vector为空, 以及vector中全是nullptr链表的特殊情况.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">//处理[]的情况</span></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur_node = dummy;</span><br><span class="line">        <span class="keyword">while</span>(lists.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> min_node_index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;lists.size() ;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lists[i] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    lists.erase(lists.begin()+i);</span><br><span class="line">                    i--; <span class="comment">//移除第i个元素后, 下一个元素会自动成为第i个元素,因此, 将当前i--</span></span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// continue后, i会++, 最终i指向了下一个元素</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(lists[min_node_index]-&gt;val &gt; lists[i]-&gt;val)&#123;</span><br><span class="line">                    min_node_index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(lists.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">//主要是应对 [[], []] 的情况, 本身vector的size大于0, 但是经过erase以后size就变成0了, 此时应返回nullptr</span></span><br><span class="line">            cur_node-&gt;next = lists[min_node_index];</span><br><span class="line">            cur_node = cur_node-&gt;next;</span><br><span class="line">            lists[min_node_index] = lists[min_node_index]-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(lists[min_node_index] == <span class="literal">nullptr</span>) lists.erase(lists.begin()+min_node_index);</span><br><span class="line">        &#125;</span><br><span class="line">        cur_node-&gt;next = lists[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-用小顶堆对解法一的比较操作进行优化"><a href="#解法二-用小顶堆对解法一的比较操作进行优化" class="headerlink" title="解法二: 用小顶堆对解法一的比较操作进行优化"></a>解法二: 用小顶堆对解法一的比较操作进行优化</h2><p>时间复杂度: $O(logk \times N)$, N 代表所有链表的节点总数.<br>空间复杂度: $O(k)$  由于要构造堆, 所以需要额外空间</p>
<p>由于我们只需要找到k个节点里面数值最小的那一个, 因此可以利用Priority Queue (实际上就是大顶堆和小顶堆)对上面的比较操作进行优化, 使得比较操作的复杂度从 $k$ 降到 $logk$. 由于每个节点都会进入小顶堆一次, 所有总共需要执行 $N$ 次入堆操作, 故最终的复杂度的 $logk\times N$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 用函数对象进行比较</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode *node1, ListNode *node2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node1-&gt;val &gt; node2-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;ListNode *, <span class="built_in">vector</span>&lt;ListNode *&gt;, cmp&gt; min_heap;</span><br><span class="line">        <span class="comment">// 用 lambda 表达式进行比较</span></span><br><span class="line">        <span class="comment">// auto cmp = [](ListNode* node1, ListNode* node2) &#123;</span></span><br><span class="line">        <span class="comment">//     return node1-&gt;val &gt; node2-&gt;val; // 小顶堆</span></span><br><span class="line">        <span class="comment">// &#125;;</span></span><br><span class="line">        <span class="comment">//priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, decltype(cmp)&gt; min_heap(cmp);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> node_head : lists)</span><br><span class="line">            <span class="keyword">if</span>(node_head!=<span class="literal">nullptr</span>) min_heap.push(node_head);</span><br><span class="line">        <span class="keyword">if</span>(min_heap.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(!min_heap.empty())&#123;</span><br><span class="line">            ListNode *tmp = min_heap.top(); min_heap.pop();</span><br><span class="line">            cur-&gt;next = tmp;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;next != <span class="literal">nullptr</span>) min_heap.push(tmp-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-转化成双列表合并问题"><a href="#解法三-转化成双列表合并问题" class="headerlink" title="解法三: 转化成双列表合并问题"></a>解法三: 转化成双列表合并问题</h2><p>时间复杂度: $O(k \times N)$<br>空间复杂度: $O(1)$</p>
<p>双列表合并问题的时间复杂度为 $O(m+n)$ , 可以将多链表合并问题看做是k次双列表合并.</p>
<h2 id="解法四-对解法三进行优化"><a href="#解法四-对解法三进行优化" class="headerlink" title="解法四: 对解法三进行优化"></a>解法四: 对解法三进行优化</h2><p>时间复杂度: $O(logk \times N)$<br>空间复杂度: $O(1)$</p>
<p>对列表合并时, 每次都是两两合并(不是解法三中的逐一合并), 这样, 只需要经过 $logk$ 次两两合并就可完成所有合并过程.</p>
<p><strong>迭代实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span></span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">nullptr</span>) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">else</span> cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> len = lists.size();</span><br><span class="line">        <span class="keyword">int</span> interval = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(interval &lt; len)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+interval&lt;len; i+= <span class="number">2</span>*interval)&#123;<span class="comment">//i应满足: 0,2,4... / 0,4,.. / 0</span></span><br><span class="line">                lists[i] = mergeTwoLists(lists[i], lists[i+interval]);<span class="comment">//i+interval必须&lt;len, 否则溢出</span></span><br><span class="line">            &#125;</span><br><span class="line">            interval *= <span class="number">2</span>; <span class="comment">//区间大小翻倍</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>递归实现:</strong> 递归实现需要额外的 $O(logk)$ 的栈空间(调用递归的次数)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span></span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">nullptr</span>) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">else</span> cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists[start];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">            ListNode* l1 = partition(lists, start, mid);</span><br><span class="line">            ListNode* l2 = partition(lists, mid+<span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(l1, l2);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> partition(lists, <span class="number">0</span>, lists.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>将双链表合并也写成递归形式:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l2==<span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            <span class="keyword">return</span> lists[start];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">            ListNode* l1 = partition(lists, start, mid);</span><br><span class="line">            ListNode* l2 = partition(lists, mid+<span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(l1, l2);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> partition(lists, <span class="number">0</span>, lists.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="024-两两交换链表中的节点-中等"><a href="#024-两两交换链表中的节点-中等" class="headerlink" title="024. 两两交换链表中的节点-中等"></a>024. 两两交换链表中的节点-中等</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs/</a></p>
<h2 id="解法-按照题目要求逻辑进行交换"><a href="#解法-按照题目要求逻辑进行交换" class="headerlink" title="解法: 按照题目要求逻辑进行交换"></a>解法: 按照题目要求逻辑进行交换</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="keyword">None</span> <span class="keyword">or</span> head.next == <span class="keyword">None</span>: <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        first = dummy.next</span><br><span class="line">        second = dummy.next.next</span><br><span class="line">        pre = dummy</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">True</span>):</span><br><span class="line">            pre.next = second</span><br><span class="line">            first.next = second.next</span><br><span class="line">            second.next = first</span><br><span class="line">            pre = first</span><br><span class="line">            <span class="keyword">if</span> (first.next != <span class="keyword">None</span> <span class="keyword">and</span> first.next.next != <span class="keyword">None</span>):</span><br><span class="line">                second = first.next.next</span><br><span class="line">                first = first.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<h1 id="025-K-个一组翻转链表"><a href="#025-K-个一组翻转链表" class="headerlink" title="025. K 个一组翻转链表"></a>025. K 个一组翻转链表</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-nodes-in-k-group/</a></p>
<h2 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h2><p>一组一组逆置, 难点在于要将前一组逆置后的尾节点记录, 同时将该尾节点指向当前组逆置后的头结点, 另外, 当最后一组不足 $k$ 个元素时, 需要复原最后一组.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = head</span><br><span class="line">        first = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">None</span>):</span><br><span class="line">            pre = <span class="keyword">None</span></span><br><span class="line">            tmp_rail = cur</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">                <span class="keyword">if</span> cur == <span class="keyword">None</span>: <span class="comment"># 最后一组不足k个时, 要将逆置的链表复原</span></span><br><span class="line">                    h = pre</span><br><span class="line">                    r = tmp_rail</span><br><span class="line">                    c = pre</span><br><span class="line">                    p = <span class="keyword">None</span></span><br><span class="line">                    <span class="keyword">while</span>(c <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>):</span><br><span class="line">                        post = c.next</span><br><span class="line">                        c.next = p</span><br><span class="line">                        p = c</span><br><span class="line">                        c = post</span><br><span class="line">                    pre = p</span><br><span class="line">                    tmp_rail = h</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                post = cur.next <span class="comment"># 逆置链表</span></span><br><span class="line">                cur.next = pre</span><br><span class="line">                pre =  cur</span><br><span class="line">                cur = post</span><br><span class="line">            <span class="keyword">if</span> (first): <span class="comment"># 如果是第一次, 需要用 dummy 标记头部</span></span><br><span class="line">                dummy.next = pre</span><br><span class="line">                key_head = tmp_rail</span><br><span class="line">                first = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 如果是后面的组, 那么需要将前一组的尾部指向改组的头部, 同时将该组的尾部标记</span></span><br><span class="line">                key_head.next = pre</span><br><span class="line">                key_head = tmp_rail</span><br><span class="line"></span><br><span class="line">        tmp_rail.next = <span class="keyword">None</span> <span class="comment"># 末尾指向 None, 不然会陷入训练</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<h1 id="026-Remove-Duplicates-from-Sorted-Array"><a href="#026-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="026. Remove Duplicates from Sorted Array"></a>026. Remove Duplicates from Sorted Array</h1><h2 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h2><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一:"></a>解法一:</h2><p>遍历,  两种写法, 后者相当精简</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> same = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == same)&#123;</span><br><span class="line">                nums.erase(nums.begin()+i);</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                same = nums[i];</span><br><span class="line">                length++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&gt;nums[length<span class="number">-1</span>])</span><br><span class="line">                nums[length++]=n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="027-移除元素"><a href="#027-移除元素" class="headerlink" title="027. 移除元素"></a>027. 移除元素</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-element/</a></p>
<h2 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h2><p>一次遍历, 双指针法, 当 “快” 指针不等于目标值时, 将其赋值给 “慢” 指针, 最终直接返回 “慢” 指针的位置即可</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != val:</span><br><span class="line">                nums[index] = nums[i]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> index</span><br></pre></td></tr></table></figure>
<h1 id="028-Implement-strStr"><a href="#028-Implement-strStr" class="headerlink" title="028. Implement strStr()"></a>028. Implement strStr()</h1><p>字符串匹配算法, 更详细的解析请看<a href="../面试-算法刷题-算法题集合/#字符串匹配算法">字符串匹配算法解析</a></p>
<h2 id="description-KMP-判断是否为子串"><a href="#description-KMP-判断是否为子串" class="headerlink" title="description: KMP, 判断是否为子串"></a>description: KMP, 判断是否为子串</h2><p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
<p>Example 1:</p>
<p>Input: haystack = “hello”, needle = “ll”<br>Output: 2<br>Example 2:</p>
<p>Input: haystack = “aaaaa”, needle = “bba”<br>Output: -1<br>Clarification:</p>
<p>What should we return when needle is an empty string? This is a great question to ask during an interview.</p>
<p>For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf().</p>
<h2 id="解法一-暴力-3"><a href="#解法一-暴力-3" class="headerlink" title="解法一: 暴力"></a>解法一: 暴力</h2><h2 id="解法二-KMP"><a href="#解法二-KMP" class="headerlink" title="解法二: KMP"></a>解法二: KMP</h2><p>求解next数组: 求解某个位置 $k$ 的next数组值是一个循环的过程, 需要不断检查以 <strong>位置 $k-1$ 的next值</strong> 为下标的元素的 <strong>下一位元素</strong> 与 <strong>当前位置 $k$ 元素</strong> 是否相等, 如果相等, 则 <strong>next[k] = next[k-1]+1</strong>, 如果不相等, 则</p>
<h1 id="029-Divide-Two-Integers"><a href="#029-Divide-Two-Integers" class="headerlink" title="029. Divide Two Integers"></a>029. Divide Two Integers</h1><h2 id="Description-实现除法"><a href="#Description-实现除法" class="headerlink" title="Description: 实现除法"></a>Description: 实现除法</h2><p>Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.<br>Return the quotient after dividing dividend by divisor.<br>The integer division should truncate toward zero.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: dividend = 10, divisor = 3</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: dividend = 7, divisor = -3</span><br><span class="line">Output: -2</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>Both dividend and divisor will be 32-bit signed integers.<br>The divisor will never be 0.<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: $[−2^{31},  2^{31 − 1}]$. For the purpose of this problem, assume that your function returns 2^{31 − 1} when the division result overflows.</p>
<h2 id="解法一-循环加法"><a href="#解法一-循环加法" class="headerlink" title="解法一: 循环加法"></a>解法一: 循环加法</h2><p><strong>时间复杂度:</strong> $O(dividend)$</p>
<p>这种方法很容易时间超限: 当被除数很大(INT_MAX), 除数很小(1), 则需要循环INT_MAX次才能完成计算.</p>
<h2 id="解法二-左移法"><a href="#解法二-左移法" class="headerlink" title="解法二: 左移法"></a>解法二: 左移法</h2><p><strong>时间复杂度:</strong> $O(log(dividend))$, dividend 为被除数的大小.</p>
<p>对除数进行左移, 相当于每次乘以2, 直到左移后大于被除数, 用被除数减去左移后的数字, 记录左移对应除数的倍数, 然后再次将从除数开始左移, 直到被除数小于除数.</p>
<p>以上是除法的基本实现思路, 但是在具体实现时, 还需要特别考虑下面的情况</p>
<ul>
<li>当被除数为 INT_MIN, 除数为 -1 时, 此时的返回值为 INT_MAX+1. (根据题目要求, 溢出时刻直接返回 INT_MAX)</li>
<li>当除数为 0 时, 也应该看做是溢出情况.</li>
<li>处理上面情况最方便的方法使用 <code>long</code> 长整型, 而不是 <code>unsigned int</code> 无符号类型. 因为 <code>unsigned int</code> 类型在进行乘以 2 的操作时, 很容易也溢出, 最终造成程序的死循环, 为了防止溢出, 最好使用 <code>long</code>, 具体请看代码.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(divisor==<span class="number">0</span> || (dividend==INT_MIN&amp;&amp;divisor==<span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign = ((dividend&lt;<span class="number">0</span>) ^ (divisor&lt;<span class="number">0</span>)) ? <span class="number">-1</span>:<span class="number">1</span>;<span class="comment">// 用异或来获取符号</span></span><br><span class="line">        <span class="keyword">long</span> did = <span class="built_in">labs</span>(dividend); <span class="comment">// long与int在有些环境中字节中一样, 此时最好用long long</span></span><br><span class="line">        <span class="keyword">long</span> dis = <span class="built_in">labs</span>(divisor);</span><br><span class="line">        <span class="keyword">while</span>(did &gt;= dis)&#123;</span><br><span class="line">            <span class="keyword">long</span> temp = dis, multiple = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>( did &gt;= temp&lt;&lt;<span class="number">1</span> )&#123;</span><br><span class="line">                temp = temp&lt;&lt;<span class="number">1</span>;</span><br><span class="line">                multiple = multiple&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            did -= temp;</span><br><span class="line">            res+= multiple;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res*sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展-这道题如果不允许使用-long-或者long-long-怎么解"><a href="#扩展-这道题如果不允许使用-long-或者long-long-怎么解" class="headerlink" title="扩展: 这道题如果不允许使用 long 或者long long 怎么解?"></a>扩展: 这道题如果不允许使用 long 或者long long 怎么解?</h2><h1 id="031-Next-Permutation"><a href="#031-Next-Permutation" class="headerlink" title="031. Next Permutation"></a>031. Next Permutation</h1><h2 id="Description-实现-next-permutation-函数逻辑"><a href="#Description-实现-next-permutation-函数逻辑" class="headerlink" title="Description: 实现 next_permutation 函数逻辑"></a>Description: 实现 next_permutation 函数逻辑</h2><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.<br>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).<br>The replacement must be in-place and use only constant extra memory.<br>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-next-permutation-实现"><a href="#解法一-next-permutation-实现" class="headerlink" title="解法一: next_permutation 实现"></a>解法一: next_permutation 实现</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>STL中的 <code>next_permutation</code> 函数和  <code>prev_permutation</code> 两个函数提供了对于一个特定排列P, 求出其后一个排列P+1和前一个排列P-1的功能.</p>
<p><code>next_permutation</code> 的实现方法如下:</p>
<ul>
<li>先 <strong>从后往前</strong> 找第一个小于后一个数的元素 <code>nums[i]</code>: <code>nums[i]&lt;nums[i+1]</code></li>
<li>再 <strong>从后往前</strong> 找第一个大于 <code>nums[i]</code> 的数 <code>nums[j]</code>: <code>nums[j]&gt;nums[i]</code></li>
<li>交换 <code>nums[i]</code> 和 <code>nums[j]</code></li>
<li>将 <code>i</code> 之后的元素逆置(<code>reverse</code>)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = n<span class="number">-2</span>, j = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;=nums[i+<span class="number">1</span>]) i--;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;=nums[j]) j--;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums.begin()+i+<span class="number">1</span>, nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="033-Search-in-Rotated-Sorted-Array"><a href="#033-Search-in-Rotated-Sorted-Array" class="headerlink" title="033. Search in Rotated Sorted Array"></a>033. Search in Rotated Sorted Array</h1><h2 id="Description-在循环有序数组中查找元素"><a href="#Description-在循环有序数组中查找元素" class="headerlink" title="Description: 在循环有序数组中查找元素"></a>Description: 在循环有序数组中查找元素</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Your algorithm’s runtime complexity must be in the order of $O(log n)$.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-二分查找"><a href="#解法一-二分查找" class="headerlink" title="解法一: 二分查找"></a>解法一: 二分查找</h2><p><strong>时间复杂度:</strong> $O(logn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>对于数组[4,5,6,7,0,1,2], 可以将其看成是两段: [4,5,6,7] 和 [0,1,2], 可以看出, 前一段中的任意一个数字都大于后一段中的数字, 于是, 令low=0, high=size()-1, 进行二分查找, 其中 mid 对应的数字要么落在前半段(<code>nums[low] &lt;= nums[mid]</code>), 要么落在后半段.</p>
<p>如果落在的前半段, 则看 target 的值是否在 low与mid之间. 是则 <code>high = mid-1</code>, 否则 <code>low = mid+1</code></p>
<p>反之, 如果落在后半段, 则看 <code>target</code> 的值是否在 <code>mid</code> 与 <code>high</code> 之间, 是则 <code>low=mid+1</code> , 否则<code>high = mid-1</code></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int low = <span class="number">0</span>;</span><br><span class="line">        int high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        //数组前半段的数字永远大于后半段的数字</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123; //当low==high时, mid=low=high, 如果不等于target, 则之后会退出循环</span><br><span class="line">            int mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == nums[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[low] &lt;= nums[mid])&#123; //说明当前mid落在数组的前半段(), 这里等于号必须带, 否则会漏解</span><br><span class="line">                //判断target是否在low与mid之间, 这里low需要带等于号,</span><br><span class="line">                //因为target有可能=nums[low], mid无需带等于号</span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[low] &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    high = mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    low = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; // 只有当nums[low]完全小于nums[mid]时, mid才落在后半段</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[high])</span><br><span class="line">                    low = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    high = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-二分查找"><a href="#解法二-二分查找" class="headerlink" title="解法二: 二分查找"></a>解法二: 二分查找</h2><p><strong>时间复杂度:</strong> $O(logn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>该方法同样是二分查找, 只不过与上面有一点不同, 对于数组<code>nums</code>=[4,5,6,7,0,1,2]来说, 如果 <code>target &lt; nums[0]</code>, 说明 <code>target</code> 位于数组的后半段, 那么可以将数组看做是<code>nums</code>=[INT_MIN,INT_MIN,INT_MIN,INT_MIN,0,1,2] , 这样一来, 就变成了最常规的有序数组, 反之, 如果 <code>target</code> 位于数组的前半段, 那么可以将数组看做是<code>nums</code>=[4,5,6,7,INT_MAX,INT_MAX,INT_MAX].</p>
<p>注意, 这里并不会改变数组内部的值, 我们只是利用一个临时变量<code>num</code>来代替当前的nums[mid]的值, 然后利用 <code>num</code> 与 <code>target</code> 比较进行二分查找.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int low = <span class="number">0</span>;</span><br><span class="line">        int high = nums.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            int mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            int num;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[<span class="number">0</span>])&#123; //target在后半段, 所以将前半段都看做INT_MIN</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="number">0</span>])  num = nums[mid]; // nums[mid]在后半段</span><br><span class="line">                <span class="keyword">else</span> num = INT_MIN; // nums[mid]在前半段,</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; //target在前半段, 所以将后半段都看作是INT_MAX</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="number">0</span>]) num = INT_MAX;  // nums[mid]在后半段</span><br><span class="line">                <span class="keyword">else</span> num = nums[mid]; // nums[mid]在前半段</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; num) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>更精简的写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>, high=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> num;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;nums[<span class="number">0</span>])</span><br><span class="line">                num = nums[mid]&lt;nums[<span class="number">0</span>] ? nums[mid] : INT_MIN;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num = nums[mid]&lt;nums[<span class="number">0</span>] ? INT_MAX : nums[mid];</span><br><span class="line">            <span class="keyword">if</span>(target &gt; num) low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; num) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="034-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#034-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="034. Find First and Last Position of Element in Sorted Array"></a>034. Find First and Last Position of Element in Sorted Array</h1><h2 id="Description-在有序数组中查找目标的开始位置和结束位置"><a href="#Description-在有序数组中查找目标的开始位置和结束位置" class="headerlink" title="Description: 在有序数组中查找目标的开始位置和结束位置"></a>Description: 在有序数组中查找目标的开始位置和结束位置</h2><p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>If the target is not found in the array, return [-1, -1].</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-二分查找-1"><a href="#解法一-二分查找-1" class="headerlink" title="解法一: 二分查找"></a>解法一: 二分查找</h2><p>时间复杂度: $O(logn)$<br>空间复杂度: $O(1)$</p>
<p>先用常规的二分查找找到target, 然后分别用二分查找找到最左边的target和最右边的target下标.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int low = <span class="number">0</span>;</span><br><span class="line">        int high = nums.size() - <span class="number">1</span>;</span><br><span class="line">        vector&lt;int&gt; res&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        int mid=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123; //正常的二分查找, 先找到target</span><br><span class="line">            mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid==<span class="number">-1</span> || nums[mid] != target) <span class="keyword">return</span> res; // 数组为空或者数组内没有target</span><br><span class="line">        //以mid为中心, 分别查找下标最小的target和下标最大的target</span><br><span class="line">        int llow=low, lhigh=mid; // 左边的二分查找low,high初始化</span><br><span class="line">        int rlow=mid, rhigh=high; // 右边的二分查找low,high初始化</span><br><span class="line">        <span class="keyword">while</span>(llow&lt;=lhigh)&#123;</span><br><span class="line">            int mid = (llow+lhigh)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mid==llow || nums[mid<span class="number">-1</span>] != target)&#123; //关键: 只有当等于target并且左边没有元素或者左边元素不等于target时, 当前mid才是最左边的target</span><br><span class="line">                    res[<span class="number">0</span>] = mid; <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    lhigh = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                llow = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lhigh = mid<span class="number">-1</span>;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(rlow&lt;=rhigh)&#123;</span><br><span class="line">            int mid = (rlow+rhigh)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mid==rhigh || nums[mid+<span class="number">1</span>] != target)&#123; //同理, 找最右边的target</span><br><span class="line">                    res[<span class="number">1</span>] = mid; <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    rlow = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                rlow = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rhigh = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-二分查找-1"><a href="#解法二-二分查找-1" class="headerlink" title="解法二: 二分查找"></a>解法二: 二分查找</h2><p>同样是二分查找, 更加精炼, 先找到最左边的target, 然后以最左边为low, 开始找最右边的target, 需要注意的是不能在<code>nums[mid] == target</code>时就退出循环.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int low = <span class="number">0</span>;</span><br><span class="line">        int high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        vector&lt;int&gt; res&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123; //找起始位置, 注意这里不能是 &lt;=, 而必须是=, 否则会死循环</span><br><span class="line">            int mid = (low+high)/<span class="number">2</span>; //偏向左边, 很重要, 否则会死循环</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid; //注意, 这里不是mid<span class="number">-1</span>, 因为现在是在找最左边的target, 故不能在=target时退出, 因此也不能直接令high=mid<span class="number">-1</span>, 否则会丢失mid=target的情况</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span> || nums[low] != target) <span class="keyword">return</span> res;</span><br><span class="line">        res[<span class="number">0</span>]=low;</span><br><span class="line"></span><br><span class="line">        high = nums.size()<span class="number">-1</span>;// low 已经指向起始位置, 这里只需重置high</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123; // 找终止位置</span><br><span class="line">            int mid = (low+high+<span class="number">1</span>)/<span class="number">2</span>; //使mid偏向右边, 这很重要</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">1</span>]=high;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-STL-函数"><a href="#解法三-STL-函数" class="headerlink" title="解法三: STL 函数"></a>解法三: STL 函数</h2><p><strong>时间复杂度:</strong> $O(logn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>直接利用 STL 的 <code>lower_bound()</code> 和 <code>upper_bound()</code> 函数分别找到其实位置和终止位置即可, 在使用这两个函数时, 需要注意以下几点:</p>
<ul>
<li><code>lower_bound()</code> 函数返回首个 <strong>不小于</strong> target 的迭代器, 如果数组中所有元素 <strong>都小于</strong> target, 则会返回超尾迭代器.</li>
<li><code>upper_bound()</code> 函数返回首个 <strong>大于</strong> target 的迭代器, 如果数组中所有元素 <strong>都小于等于</strong> target, 则会返回超尾迭代器.</li>
<li>注意 <code>upper_bound()</code> 返回的迭代器是首个 <strong>大于</strong> 目标值的迭代器, 因此需要将其减一才是我们要找的 target 的终止位置.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> lower = <span class="built_in">std</span>::lower_bound(nums.begin(), nums.end(), target);</span><br><span class="line">        <span class="keyword">if</span>(lower==nums.end() || *lower != target) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> upper = <span class="built_in">std</span>::upper_bound(nums.begin(), nums.end(), target);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;lower-nums.begin(), upper-nums.begin()<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="036-Valid-Sudoku"><a href="#036-Valid-Sudoku" class="headerlink" title="036. Valid Sudoku"></a>036. Valid Sudoku</h1><h2 id="Description-验证一个矩阵是否是数独数据"><a href="#Description-验证一个矩阵是否是数独数据" class="headerlink" title="Description: 验证一个矩阵是否是数独数据"></a>Description: 验证一个矩阵是否是数独数据</h2><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</p>
<p>Each row must contain the digits 1-9 without repetition.<br>Each column must contain the digits 1-9 without repetition.<br>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</p>
<h2 id="解法一-利用flag数组存储判断矩阵"><a href="#解法一-利用flag数组存储判断矩阵" class="headerlink" title="解法一: 利用flag数组存储判断矩阵"></a>解法一: 利用flag数组存储判断矩阵</h2><p><strong>时间复杂度:</strong> $O(9^2)$<br><strong>空间复杂度:</strong> $O(3\times 9^2)$  虽然要申请三个二维数组, 但都是常数级.</p>
<p>用三个 9×9 大小的矩阵, 分别储存每一行上, 每一列上, 每一个子块上1-9数字是否出现.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        // 下面三个矩阵分别存储了 行上<span class="number">1</span><span class="number">-9</span>是否出现, 列上<span class="number">1</span><span class="number">-9</span>是否出现, sub-box上<span class="number">1</span><span class="number">-9</span>是否出现的bool值</span><br><span class="line">        // 如果row_flag[<span class="number">1</span>][<span class="number">3</span>] 为真, 则说明第<span class="number">1</span>行(从第<span class="number">0</span>行算起)上已经具有数字<span class="number">4</span>(数字比下标大<span class="number">1</span>)了</span><br><span class="line">        bool row_flag[<span class="number">9</span>][<span class="number">9</span>] &#123;<span class="number">0</span>&#125;, col_flag[<span class="number">9</span>][<span class="number">9</span>] &#123;<span class="number">0</span>&#125;, sub_flag[<span class="number">9</span>][<span class="number">9</span>] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span> ; i&lt;board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j&lt;board[i].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>) <span class="keyword">continue</span>; // 如果为 <span class="string">'.'</span> 则可以直接跳过此次判断</span><br><span class="line">                int num = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>; //这里<span class="number">-1</span>主要是为了能够直接将num作为下标使用</span><br><span class="line">                int k = i/<span class="number">3</span>*<span class="number">3</span> + j/<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span>(row_flag[i][num] || col_flag[j][num] || sub_flag[k][num])</span><br><span class="line">                    <span class="keyword">return</span> false;</span><br><span class="line">                row_flag[i][num]=col_flag[j][num]=sub_flag[k][num]=true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-位操作"><a href="#解法二-位操作" class="headerlink" title="解法二: 位操作"></a>解法二: 位操作</h2><p><strong>时间复杂度:</strong> $O(n^2)=O(9^2)$<br><strong>空间复杂度:</strong> $O(3\times 9)$</p>
<p>这是目前看到的最好的方法, 核心思想就是用一个  <code>short</code> 类型变量的某一位来作为 flag, 这样, 我们可以进一步节省空间的使用, 将空间复杂度从 $O(n^2)$ 降低到 $O(n)$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; row(<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; col(<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; block(<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> idx = <span class="number">1</span> &lt;&lt; (board[i][j]-<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span>(row[i]&amp;idx || col[j]&amp;idx || block[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>]&amp;idx)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                row[i] |= idx;<span class="comment">//将对应位置为1, 标记已经出现过</span></span><br><span class="line">                col[j] |= idx;</span><br><span class="line">                block[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>] |= idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="038-Count-and-Say"><a href="#038-Count-and-Say" class="headerlink" title="038. Count and Say"></a>038. Count and Say</h1><h2 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h2><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p>
<ol>
<li>1</li>
<li>11</li>
<li>21</li>
<li>1211</li>
<li>111221<br>1 is read off as “one 1” or 11.<br>11 is read off as “two 1s” or 21.<br>21 is read off as “one 2, then one 1” or 1211.</li>
</ol>
<p>Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.</p>
<p>Note: Each term of the sequence of integers will be represented as a string.</p>
<h2 id="解法一-依次查看上一次的数字"><a href="#解法一-依次查看上一次的数字" class="headerlink" title="解法一: 依次查看上一次的数字"></a>解法一: 依次查看上一次的数字</h2><p><strong>时间复杂度:</strong> $O(nm)$  m为数字字符串的长度<br><strong>空间复杂度:</strong> $O(m)$</p>
<p>每次根据上一次的数字更新当前的数字字符串, 如此迭代直到达到指定次数</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string countAndSay(int n) &#123;</span><br><span class="line">        string res=<span class="string">"1"</span>;</span><br><span class="line">        int i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">            string tmp;</span><br><span class="line">            <span class="keyword">for</span>(int u=<span class="number">0</span>; u&lt;res.size(); u++)&#123;</span><br><span class="line">                char c=res[u];</span><br><span class="line">                int count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(u+<span class="number">1</span>&lt;res.size() &amp;&amp; res[u+<span class="number">1</span>]==c)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    u++;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp += to_string(count)+c;   </span><br><span class="line">            &#125;</span><br><span class="line">            res.swap(tmp);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="041-First-Missing-Positive"><a href="#041-First-Missing-Positive" class="headerlink" title="041. First Missing Positive"></a>041. First Missing Positive</h1><p>寻找数组中缺失的最小的正数</p>
<h2 id="Description-8"><a href="#Description-8" class="headerlink" title="Description"></a>Description</h2><p>Given an unsorted integer array, find the smallest missing positive integer.</p>
<p>Example 1:</p>
<p>Input: [1,2,0]<br>Output: 3<br>Example 2:</p>
<p>Input: [3,4,-1,1]<br>Output: 2<br>Example 3:</p>
<p>Input: [7,8,9,11,12]<br>Output: 1<br>Note:</p>
<p>Your algorithm should run in O(n) time and uses constant extra space.</p>
<h2 id="解法一-下标与正数对应"><a href="#解法一-下标与正数对应" class="headerlink" title="解法一: 下标与正数对应"></a>解法一: 下标与正数对应</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$ (但是对改变了原始的数组, 这是一个小缺陷)</p>
<p>将下标与正数相应对, 例如对于正数5, 我们就将放置在nums[4]上, 这样一来, 再次遍历数组的时候, 当遇到第一个与下标不对应的数字时, 该下标对应的正数(i+1)就是缺少的正数.</p>
<p>放置正数到正确位置上时, 需要注意几点:</p>
<ul>
<li>swap之后需要继续将原来位置上(nums[4])的数放置到正确的位置上, 这里需要一个while循环</li>
<li>在检查数组时, 如果所有数组内所有数字都处在正确位置上, 那么就应该返回nums.size+1 (包括了数组为空的情况: 返回0+1=1)</li>
</ul>
<p><strong>写法一: for+while</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="comment">// 注意这些条件: 前两个是为了令交换下标合法, 后一个是防止相同的数交换, 造成死循环</span></span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i]&lt;nums.size() &amp;&amp; nums[i] != nums[nums[i]<span class="number">-1</span>])</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[i], nums[nums[i]<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size()+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>写法二: while</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;nums.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span> &amp;&amp;nums[i]&lt;nums.size() &amp;&amp; nums[i] != nums[nums[i]<span class="number">-1</span>])</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[i], nums[nums[i]<span class="number">-1</span>]); <span class="comment">// 如果进行了swap, 就不要i++</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size()+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-哈希"><a href="#解法二-哈希" class="headerlink" title="解法二: 哈希"></a>解法二: 哈希</h2><p><strong>时间复杂度:</strong> $O(n)$ (3次for循环, 毫无争议的 $O(n)$ )<br><strong>空间复杂度:</strong> $O(1)$ (但是对改变了原始的数组, 这是一个小缺陷)</p>
<p><strong>注意:</strong> 虽然这里的时间复杂度是毫无争议的 $O(n)$ , 但是不一定会上面的速度快, 因为上面只有两次循环, 内第一次内部的循环次数一般情况下都不会很大.</p>
<p><strong>从哈希的角度理解: 可以将数组下标看成是hash的key</strong></p>
<ol>
<li>for any array whose length is l, the first missing positive must be in range [1,…,l+1],<br> so we only have to care about those elements in this range and remove the rest.</li>
<li>we can use the array index as the hash to restore the frequency of each number within<br>  the range [1,…,l+1]</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 丢失的最小正数只可能在 [1,2,...,nums.size()+1] 之间</span></span><br><span class="line">        <span class="comment">// 这里的pushback是必须的, 因为下面会将不符合要求的元素都置为0,</span></span><br><span class="line">        <span class="comment">//因此nums[0]需要与0对应, 以代表所有的非法元素,</span></span><br><span class="line">        <span class="comment">//这点与上面基于swap的方法不同, 上面的swap是让nums[0] 与 1 对应.</span></span><br><span class="line">        nums.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt;length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span> || nums[i] &gt;= length)</span><br><span class="line">                nums[i] = <span class="number">0</span>; <span class="comment">// 将所有不符合丢失正数的数移除, 这一步必须单独用一个for循环做</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">            nums[nums[i]%length] += length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]/length == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="042-Trapping-Rain-Water"><a href="#042-Trapping-Rain-Water" class="headerlink" title="042 Trapping Rain Water"></a>042 Trapping Rain Water</h1><p>数组中每个值代表柱状体的高度, 每个柱状体的宽度都为1, 根据数组内的值组成的高低不同的块, 能够存储多少个bin (1×1)的水</p>
<h2 id="Description-9"><a href="#Description-9" class="headerlink" title="Description"></a>Description</h2><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p><img src="https://wx3.sinaimg.cn/large/d7b90c85ly1fwj4ej0utpj20d904mglk.jpg" alt=""></p>
<p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p>
<p>Example:</p>
<p>Input: [0,1,0,2,1,0,1,3,2,1,2,1]<br>Output: 6</p>
<h2 id="解法一-左右指针"><a href="#解法一-左右指针" class="headerlink" title="解法一: 左右指针"></a>解法一: 左右指针</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>分别用两个变量left和right指向左边和右边的柱子, 并再用两个变量maxleft和maxright维护左边最高的柱子和右边最高的柱子, 统计的时候, 先固定left和right当中柱子高度较高的那一个, 然后统计较低柱子上存储的水量. 利用, 如果当前left的高度小于right的高度, 则我们计算left上面能够存储的水量, 有两种情况, 当left柱子的高度大于等于maxleft时, 则left柱子上没法存储水, 因为谁会从左边全部流失(右边比左边高, 所以不会从右边流失).  如果left的高度小于maxleft时, 由于水无法从左边流失, 也不能从右边流失, 因此当前柱子上就会存储水, 存储的水量为<code>maxleft-height[left]</code> (不考虑maxright, 因为maxright大于maxleft).</p>
<p><strong>注意:</strong> 此题中的柱子是有 <strong>宽度</strong> 的, 这一点很重要, 如果柱子的宽度为0 , 那么就是另一种情况了.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = height.size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, maxleft = <span class="number">0</span>, maxright = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt;= height[right])&#123; <span class="comment">//固定较大的一个柱子</span></span><br><span class="line">                <span class="keyword">if</span>(height[left] &gt; maxleft) maxleft = height[left];<span class="comment">// 如果当前柱子的高度大于左边max柱子的高度, 那么该柱子所处位置一定存不下水</span></span><br><span class="line">                <span class="keyword">else</span> res = res + maxleft - height[left]; <span class="comment">// 反之, 该柱子位置上可以存储的水的量为 坐标max高度减去当前的高度</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(height[right] &gt; maxright) maxright = height[right];</span><br><span class="line">                <span class="keyword">else</span> res = res + maxright - height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>更简洁的写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.size() <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLH = height[left], maxRH = height[right];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            maxLH = <span class="built_in">std</span>::max(maxLH, height[left]);</span><br><span class="line">            maxRH = <span class="built_in">std</span>::max(maxRH, height[right]);</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                res += maxLH - height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += maxRH - height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="044-Wildcard-Matching"><a href="#044-Wildcard-Matching" class="headerlink" title="044. Wildcard Matching"></a>044. Wildcard Matching</h1><h2 id="Description-通配符匹配"><a href="#Description-通配符匹配" class="headerlink" title="Description: 通配符匹配"></a>Description: 通配符匹配</h2><p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*’.</p>
<p>‘?’ Matches any single character.<br>‘*’ Matches any sequence of characters (including the empty sequence).<br>The matching should cover the entire input string (not partial).</p>
<p>Note:</p>
<p>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like ? or *.<br>Example 1:</p>
<p>Input:<br>s = “aa”<br>p = “a”<br>Output: false<br>Explanation: “a” does not match the entire string “aa”.<br>Example 2:</p>
<p>Input:<br>s = “aa”<br>p = “<em>“<br>Output: true<br>Explanation: ‘</em>‘ matches any sequence.<br>Example 3:</p>
<p>Input:<br>s = “cb”<br>p = “?a”<br>Output: false<br>Explanation: ‘?’ matches ‘c’, but the second letter is ‘a’, which does not match ‘b’.<br>Example 4:</p>
<p>Input:<br>s = “adceb”<br>p = “<em>a</em>b”<br>Output: true<br>Explanation: The first ‘<em>‘ matches the empty sequence, while the second ‘</em>‘ matches the substring “dce”.<br>Example 5:</p>
<p>Input:<br>s = “acdcb”<br>p = “a*c?b”<br>Output: false</p>
<h2 id="解法一-迭代"><a href="#解法一-迭代" class="headerlink" title="解法一: 迭代"></a>解法一: 迭代</h2><p><strong>时间复杂度:</strong> $O(m+n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>对于每次循环迭代, <code>i</code>和<code>j</code>其中至少有一个前进一步, 所以时间复杂度为 $O(m+n)$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> m = p.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> star_index = <span class="number">-1</span>, match = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; m <span class="keyword">and</span> (s[i] == p[j] <span class="keyword">or</span> p[j] == <span class="string">'?'</span>)) &#123; <span class="comment">// 单个字符匹配, i, j继续匹配下一个</span></span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; m <span class="keyword">and</span> p[j] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                star_index = j; <span class="comment">// 如果当前字符为 *, 则有可能如0或若干个字符匹配, 首先假设至于0个字符匹配</span></span><br><span class="line">                match = i; <span class="comment">// 只与0个字符匹配时, 记录当前i的值, 然后将j++, i不变</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (star_index != <span class="number">-1</span>) &#123; <span class="comment">// 如果前面两个条件都不满足, 说明之间的匹配方法不正确, 此时重新从前一个 * 开始匹配</span></span><br><span class="line">                match++; <span class="comment">// 令 * 与之前标记的未匹配的i进行匹配, 然后将标记往后移一位</span></span><br><span class="line">                i = match; <span class="comment">// 令 i 和 j 都等于下一个字符, 继续匹配过程</span></span><br><span class="line">                j = star_index+<span class="number">1</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> jj = j ; jj &lt; m; jj++) &#123; <span class="comment">// 当 i==n 退出循环时, j 有可能还未达到m, 因为有可能是 ***** 的形式</span></span><br><span class="line">            <span class="keyword">if</span> (p[jj] != <span class="string">'*'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-DP"><a href="#解法二-DP" class="headerlink" title="解法二: DP"></a>解法二: DP</h2><p><strong>时间复杂度:</strong> $O(nm)$, $n$ 为<code>s</code>的长度, $m$ 为<code>p</code>的长度<br><strong>空间复杂度:</strong> $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pLen = p.size(), sLen = s.size(), i, j, k, cur, prev;</span><br><span class="line">        <span class="keyword">if</span>(!pLen) <span class="keyword">return</span> sLen == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> matched[<span class="number">2</span>][sLen+<span class="number">1</span>];</span><br><span class="line">        fill_n(&amp;matched[<span class="number">0</span>][<span class="number">0</span>], <span class="number">2</span>*(sLen+<span class="number">1</span>), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        matched[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=pLen; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = i%<span class="number">2</span>, prev= <span class="number">1</span>-cur;</span><br><span class="line">            matched[cur][<span class="number">0</span>]= matched[prev][<span class="number">0</span>] &amp;&amp; p[i<span class="number">-1</span>]==<span class="string">'*'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p[i<span class="number">-1</span>]==<span class="string">'*'</span>) <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=sLen; ++j) matched[cur][j] = matched[cur][j<span class="number">-1</span>] || matched[prev][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=sLen; ++j)            matched[cur][j] =  matched[prev][j<span class="number">-1</span>] &amp;&amp; (p[i<span class="number">-1</span>]==<span class="string">'?'</span> || p[i<span class="number">-1</span>]==s[j<span class="number">-1</span>]) ;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> matched[cur][sLen];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-DP"><a href="#解法三-DP" class="headerlink" title="解法三: DP"></a>解法三: DP</h2><p><strong>时间复杂度:</strong> $O(nm)$, $n$ 为<code>s</code>的长度, $m$ 为<code>p</code>的长度<br><strong>空间复杂度:</strong> $O(nm)$</p>
<p>采用和第 10 题相同的思路, 令<code>dp[i][j]</code>代表<code>s[0, i)</code>和<code>p[0,j)</code>是否匹配, 该解法的空间复杂度比解法二高.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> m = p.size();</span><br><span class="line">        <span class="keyword">bool</span> dp[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">std</span>::fill_n(&amp;dp[<span class="number">0</span>][<span class="number">0</span>], (n+<span class="number">1</span>)*(m+<span class="number">1</span>), <span class="literal">false</span>); <span class="comment">// 用 fill_n 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j<span class="number">-1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    dp[i][j] = (i &gt; <span class="number">0</span> <span class="keyword">and</span> dp[i<span class="number">-1</span>][j]) <span class="keyword">or</span> (dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = i &gt; <span class="number">0</span> <span class="keyword">and</span> dp[i<span class="number">-1</span>][j<span class="number">-1</span>] <span class="keyword">and</span> (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] <span class="keyword">or</span> p[j<span class="number">-1</span>] == <span class="string">'?'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><span id="Permutations"></span></p>
<h1 id="046-Permutations"><a href="#046-Permutations" class="headerlink" title="046. Permutations"></a>046. Permutations</h1><p>全排列, 注意是distict的数字, 故而不需要进行重复检查</p>
<h2 id="Description-不含重复数字的全排列"><a href="#Description-不含重复数字的全排列" class="headerlink" title="Description: 不含重复数字的全排列"></a>Description: 不含重复数字的全排列</h2><p>Given a collection of distinct integers, return all possible permutations.</p>
<p>Example:</p>
<p>Input: [1,2,3]<br>Output:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>
<h2 id="解法一-递归-1"><a href="#解法一-递归-1" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(A^n_n)$ , 每一种情况都是 $O(1)$ , 共有 $O(A^n_n)$ 种情况. (对吗?)</p>
<p>用一个变量pos指向nums的第一个位置, 然后将pos与后面所有位置上的数字交换(包括自己), 最终会得到n种可能性, 这n种可能性就是出现在第一位置上的所有可能字符的情况集合, 然后将第一位固定, 并将pos指向下一位, 此时问题转换成了n-1个字符的全排列, 按照这种想法一致递归下去, 就可以找到所有位置上的所有组合情况(用pos==nums.size()判断)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        permute_helper(res, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permute_helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;res, <span class="keyword">int</span> pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == nums.size())</span><br><span class="line">            res.push_back(nums);  <span class="comment">// 当pos走到最后时, 说明一种情况诞生, 将其添加到res中</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i&lt;nums.size(); i++)&#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[pos], nums[i]);</span><br><span class="line">                permute_helper(res, pos+<span class="number">1</span>, nums);</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[pos], nums[i]); <span class="comment">// 能够去掉这句话的前提是对res内的字符串进行重复检查, 具体可看牛客分析</span></span><br><span class="line">                <span class="comment">//在面对含有重复字符的情况时, 最好加上这句话</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代"><a href="#解法二-迭代" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p><strong>时间复杂度:</strong> $O(n^3)$<br><strong>空间复杂度:</strong> $O(A_n^n)$ 全排列的size</p>
<p>对于n个数的全排列问题, 可以想象成已经获得了n-1个数的全排列, 然后将第n个数插入到n-1个数的n个空位上( 如将3插入到12的空位上分别为: 312,132,123).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num.size(); i++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; tmp_res(<span class="built_in">std</span>::move(res)); <span class="comment">// move之后, res内部会自动被清空, 而且move的效率较高</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;tmp_res.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;=tmp_res[<span class="number">0</span>].size(); k++)&#123; <span class="comment">// 注意这里是&lt;=, 因为还要往尾部插</span></span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(tmp_res[j]);</span><br><span class="line">                    tmp.insert(tmp.begin()+k, num[i]);</span><br><span class="line">                    res.push_back(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-利用C-的内置函数-next-permutation"><a href="#解法三-利用C-的内置函数-next-permutation" class="headerlink" title="解法三: 利用C++的内置函数 next_permutation"></a>解法三: 利用C++的内置函数 next_permutation</h2><p>关于 <code>next_permutation()</code> 的详细解析请看<a href="../面试-算法刷题-算法题集合/#permutation">这里</a></p>
<p>STL中的 <code>next_permutation</code> 函数和  <code>prev_permutation</code> 两个函数提供了对于一个特定排列P, 求出其后一个排列P+1和前一个排列P-1的功能.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(next_permutation(nums.begin(), nums.end()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这道题利用 <code>prev_permutation</code> 也可以解决, 但是这里就多了一步 <code>reverse</code> 的操作, 这里贴出来只是帮助理解 STL 函数的内部实现, 对于 Permutation2 题也是同理:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 倒序排序</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(prev_permutation(nums.begin(), nums.end()));<span class="comment">//使用 prev</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法四-自己实现-next-permutation"><a href="#解法四-自己实现-next-permutation" class="headerlink" title="解法四: 自己实现 next_permutation"></a>解法四: 自己实现 next_permutation</h2><p><strong>用迭代器作为参数:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">nextPermutation</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> i = last - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> j = last - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= first &amp;&amp; *i &gt;= *(i+<span class="number">1</span>)) i--;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= first) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= first &amp;&amp; *i &gt;= *j) j--;</span><br><span class="line">            <span class="built_in">std</span>::iter_swap(i, j);</span><br><span class="line">            <span class="built_in">std</span>::reverse(i+<span class="number">1</span>, last);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i&gt;=first ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125; <span class="keyword">while</span> (nextPermutation(nums.begin(), nums.end()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>用数组作为参数:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = n<span class="number">-2</span>, j = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;=nums[i+<span class="number">1</span>]) i--;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;=nums[j]) j--;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums.begin()+i+<span class="number">1</span>, nums.end());</span><br><span class="line">        <span class="keyword">return</span> i&gt;=<span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(nextPermutation(nums));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>prev_permutation 实现:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">prevPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = n<span class="number">-2</span>, j = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; nums[i]&lt;=nums[i+<span class="number">1</span>]) i--;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; nums[i]&lt;=nums[j]) j--;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums.begin()+i+<span class="number">1</span>, nums.end());</span><br><span class="line">        <span class="keyword">return</span> i&gt;=<span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(prevPermutation(nums));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>next_permutation</code> python 实现:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        i = n - <span class="number">2</span></span><br><span class="line">        j = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i] &gt;= nums[i+<span class="number">1</span>]): i -= <span class="number">1</span> <span class="comment"># 找到i</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">while</span> (j &gt; i <span class="keyword">and</span> nums[i] &gt;= nums[j]): j -= <span class="number">1</span> <span class="comment"># 找到 j</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i] <span class="comment"># 交换, 并将 i 之后的进行逆置</span></span><br><span class="line">        nums[i+<span class="number">1</span>:] = nums[i+<span class="number">1</span>:][::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> i != <span class="number">-1</span> <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        res.append(nums.copy()) <span class="comment"># 注意这里一定要用copy, 否则后续的更改会影响前面的nums的值</span></span><br><span class="line">        <span class="keyword">while</span>(self.nextPermutation(nums)):</span><br><span class="line">            res.append(nums.copy())</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p><code>prev_permutation</code> python 实现<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prevPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        i = n - <span class="number">2</span></span><br><span class="line">        j = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i] &lt;= nums[i+<span class="number">1</span>]): i -= <span class="number">1</span> <span class="comment"># 找到i</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">while</span> (j &gt; i <span class="keyword">and</span> nums[i] &lt;= nums[j]): j -= <span class="number">1</span> <span class="comment"># 找到 j</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i] <span class="comment"># 交换, 并将 i 之后的进行逆置</span></span><br><span class="line">        nums[i+<span class="number">1</span>:] = nums[i+<span class="number">1</span>:][::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> i != <span class="number">-1</span> <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        res = []</span><br><span class="line">        res.append(nums.copy()) <span class="comment"># 注意这里一定要用copy, 否则后续的更改会影响前面的nums的值</span></span><br><span class="line">        <span class="keyword">while</span>(self.prevPermutation(nums)):</span><br><span class="line">            res.append(nums.copy())</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h1 id="047-Permutations-II"><a href="#047-Permutations-II" class="headerlink" title="047. Permutations II"></a>047. Permutations II</h1><h2 id="Description-带有重复元素的全排列"><a href="#Description-带有重复元素的全排列" class="headerlink" title="Description: 带有重复元素的全排列"></a>Description: 带有重复元素的全排列</h2><h2 id="解法一-递归-set"><a href="#解法一-递归-set" class="headerlink" title="解法一: 递归+set"></a>解法一: 递归+set</h2><p><strong>时间复杂度:</strong><br><strong>空间复杂度:</strong></p>
<p><code>set</code> 插入元素的时间复杂度为 $O(logn)$, $n$ 为当前 <code>set</code> 的大小.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res, <span class="keyword">int</span> pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(pos==len)</span><br><span class="line">            res.insert(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=pos; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=pos &amp;&amp; nums[i]==nums[pos]) <span class="keyword">continue</span>;</span><br><span class="line">            swap(nums[pos], nums[i]);</span><br><span class="line">            helper(res, pos+<span class="number">1</span>, nums);</span><br><span class="line">            swap(nums[pos], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">set</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        helper(res, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(res.begin(), res.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-STL-的-next-permutation-函数"><a href="#解法二-STL-的-next-permutation-函数" class="headerlink" title="解法二: STL 的 next_permutation 函数"></a>解法二: STL 的 next_permutation 函数</h2><p>关于 <code>next_permutation()</code> 的详细解析请看<a href="../面试-算法刷题-算法题集合/#permutation">这里</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(next_permutation(nums.begin(), nums.end()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用 <code>prev_permutation()</code> 也可解决, 不过需要记得要倒序排序.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 倒序排序</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(prev_permutation(nums.begin(), nums.end())); <span class="comment">// prev</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法三-自己实现-next-permutation"><a href="#解法三-自己实现-next-permutation" class="headerlink" title="解法三: 自己实现 next_permutation()"></a>解法三: 自己实现 next_permutation()</h2><p>python 实现:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(nums)</span>:</span></span><br><span class="line">            n = len(nums)</span><br><span class="line">            i = n - <span class="number">2</span></span><br><span class="line">            j = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i] &gt;= nums[i+<span class="number">1</span>]): i -=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;=<span class="number">0</span>):</span><br><span class="line">                <span class="keyword">while</span> (j &gt; i <span class="keyword">and</span> nums[i] &gt;= nums[j]): j -=<span class="number">1</span></span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">            nums[i+<span class="number">1</span>:] = nums[i+<span class="number">1</span>:][::<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> i != <span class="number">-1</span> <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        res.append(nums.copy())</span><br><span class="line">        <span class="keyword">while</span> (nextPermutation(nums)):</span><br><span class="line">            res.append(nums.copy())</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p><strong>用迭代器做参数:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">nextPermutation</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> i = last - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> j = last - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= first &amp;&amp; *i &gt;= *(i+<span class="number">1</span>)) i--;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= first) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= first &amp;&amp; *i &gt;= *j) j--;</span><br><span class="line">            <span class="built_in">std</span>::iter_swap(i, j);</span><br><span class="line">            <span class="built_in">std</span>::reverse(i+<span class="number">1</span>, last);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i&gt;=first ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125; <span class="keyword">while</span>(nextPermutation(nums.begin(), nums.end()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>用数组做参数:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = n<span class="number">-2</span>, j = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;=nums[i+<span class="number">1</span>]) i--;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;=nums[j]) j--;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums.begin()+i+<span class="number">1</span>, nums.end());</span><br><span class="line">        <span class="keyword">return</span> i&gt;=<span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(nextPermutation(nums));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="048-Rotate-Image"><a href="#048-Rotate-Image" class="headerlink" title="048. Rotate Image"></a>048. Rotate Image</h1><h2 id="Description-图片旋转-90-度"><a href="#Description-图片旋转-90-度" class="headerlink" title="Description: 图片旋转 90 度"></a>Description: 图片旋转 90 度</h2><p>You are given an n x n 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise).</p>
<p>Note:</p>
<p>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p>
<p>Example 1:</p>
<p>Given input matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p>
<p>rotate the input matrix in-place such that it becomes:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]<br>Example 2:</p>
<p>Given input matrix =<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>],</p>
<p>rotate the input matrix in-place such that it becomes:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p>
<h2 id="解法一-逆置-转置"><a href="#解法一-逆置-转置" class="headerlink" title="解法一: 逆置+转置"></a>解法一: 逆置+转置</h2><p><strong>时间复杂度:</strong> $O(n^2)$, 因为转置的复杂度为 $O(n^2)$</p>
<p>将图像矩阵看做是线性代数中的行列式, 首先将所有的行逆置(行与行交换), 然后对整个矩阵转置.</p>
<p>原理: 利用线性代数行列式的运算法则可证明(数学归纳法)</p>
<p>clockwise rotate<br>first reverse up to down, then swap the symmetry<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3     7 8 9     7 4 1</span><br><span class="line">4 5 6  =&gt; 4 5 6  =&gt; 8 5 2</span><br><span class="line">7 8 9     1 2 3     9 6 3</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::reverse(matrix.begin(), matrix.end()); <span class="comment">//逆置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;matrix[i].size();j++) <span class="comment">// 转置, 注意j=i+1</span></span><br><span class="line">                <span class="built_in">std</span>::swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-转置-列逆置"><a href="#解法二-转置-列逆置" class="headerlink" title="解法二: 转置+列逆置"></a>解法二: 转置+列逆置</h2><p>先求转置, 再对列逆置(列与列交换):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;matrix[i].size();j++)</span><br><span class="line">                <span class="built_in">std</span>::swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;vec_i : matrix) <span class="built_in">std</span>::reverse(vec_i.begin(), vec_i.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="补充-逆时针旋转90度"><a href="#补充-逆时针旋转90度" class="headerlink" title="补充: 逆时针旋转90度"></a>补充: 逆时针旋转90度</h2><p>先使用列逆置(列与列交换), 然后对矩阵使用转置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3     3 2 1     3 6 9</span><br><span class="line">4 5 6  =&gt; 6 5 4  =&gt; 2 5 8</span><br><span class="line">7 8 9     9 8 7     1 4 7</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anti_rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> vi : matrix) reverse(vi.begin(), vi.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; matrix[i].size(); ++j)</span><br><span class="line">            swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="补充-图片旋转-180-度-上下翻转"><a href="#补充-图片旋转-180-度-上下翻转" class="headerlink" title="补充: 图片旋转 180 度(上下翻转)"></a>补充: 图片旋转 180 度(上下翻转)</h2><p>将所有的行逆置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3     7 8 9</span><br><span class="line">4 5 6  =&gt; 4 5 6</span><br><span class="line">7 8 9     1 2 3</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reverse(matrix.begin(), matrix.end())</span><br></pre></td></tr></table></figure>
<h2 id="补充-图片左右翻转"><a href="#补充-图片左右翻转" class="headerlink" title="补充: 图片左右翻转"></a>补充: 图片左右翻转</h2><p>将所有的列逆置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3     3 2 1</span><br><span class="line">4 5 6  =&gt; 6 5 4</span><br><span class="line">7 8 9     9 8 7</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> vi : matrix) reverse(vi.begin(), vi.end());</span><br></pre></td></tr></table></figure>
<h1 id="049-Group-Anagrams"><a href="#049-Group-Anagrams" class="headerlink" title="049. Group Anagrams"></a>049. Group Anagrams</h1><h2 id="Description-找出同字母的异序词-并按字母分组输出"><a href="#Description-找出同字母的异序词-并按字母分组输出" class="headerlink" title="Description: 找出同字母的异序词, 并按字母分组输出"></a>Description: 找出同字母的异序词, 并按字母分组输出</h2><p>Given an array of strings, group anagrams together.</p>
<p>Example:</p>
<p>Input: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Output:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]<br>Note:</p>
<p>All inputs will be in lowercase.<br>The order of your output does not matter.</p>
<h2 id="解法一-哈希表-sort"><a href="#解法一-哈希表-sort" class="headerlink" title="解法一: 哈希表+sort"></a>解法一: 哈希表+sort</h2><p>用哈希表来存, 键为有序的字符序列, 值为string数组, 里面存着各个与有序字符序列包含字符相同的其他序列</p>
<p><strong>时间复杂度:</strong> $O(nmlogm)$ , 其中, n为输入字符串数组的长度, m为每个字符串的长度, 对于n个字符串, 要进行n次哈希表的插入, 同时每次插入时, 需要对字符串进行排序, 排序复杂度为 $O(mlogm)$.</p>
<p><strong>空间复杂度:</strong> $O(mn)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res_map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str: strs)&#123;</span><br><span class="line">            <span class="built_in">string</span> str_value = str;</span><br><span class="line">            <span class="built_in">std</span>::sort(str.begin(), str.end());</span><br><span class="line">            res_map[str].push_back(str_value); <span class="comment">//key 为字母有序string, value为含有这些字母的序列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res_vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str : res_map)</span><br><span class="line">            res_vec.push_back(str.second); <span class="comment">//将map中的所有的string转移到vec返回结果中</span></span><br><span class="line">        <span class="keyword">return</span> res_vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-哈希表-不使用sort"><a href="#解法二-哈希表-不使用sort" class="headerlink" title="解法二: 哈希表(不使用sort)"></a>解法二: 哈希表(不使用sort)</h2><p><strong>时间复杂度:</strong> $O(nm)$ , 其中, n为string个数, m为每个string的字母数.<br><strong>空间复杂度:</strong> $O(nm)$</p>
<p>由于上面的解法二需要使用排序, 故而时间上不够优化, 因此, 这里我们可以设计新的键来代替sort, 基本思想是对26个字母, 分别赋予一个素数值, 然后, 计算键的时候, 将对应字母的素数 <strong>相乘</strong> 即可, 这样一来, 每一种字符串的key都是唯一的( <strong>因为最终的乘积可以唯一的表示成素数相乘的序列</strong> ).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该解法是错误的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> primer[<span class="number">26</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span> ,<span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_sum_id</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : str)&#123;</span><br><span class="line">            sum * = primer[(<span class="keyword">int</span>)(c-<span class="string">'a'</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res_map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str: strs)&#123;</span><br><span class="line">            res_map[get_sum_id(str)].push_back(str); <span class="comment">//key 为字母有序string, value为含有这些字母的序列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res_vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str : res_map)</span><br><span class="line">            res_vec.push_back(str.second); <span class="comment">//将map中的所有的string转移到vec返回结果中</span></span><br><span class="line">        <span class="keyword">return</span> res_vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-另一种生成-key-的解法-不用sort"><a href="#解法三-另一种生成-key-的解法-不用sort" class="headerlink" title="解法三: 另一种生成 key 的解法(不用sort)"></a>解法三: 另一种生成 key 的解法(不用sort)</h2><p>应该将字符count作为键, 所谓字符count就是统计每个字符出现的次数, 然后根据该信息就可以生成唯一的一个字符串, 例如, 对于 “abbb”, 来说, ‘a’ 出现了一次, ‘b’ 出现了三次, 因此, 其字符count就应该为: (1,3,0,…0), 总共有 26 个元素, 为了将其转换成字符串, 需要用一个特殊符号来做分隔符, 因此可以生成如下的字符串: <code>&quot;#1#3#0#0...#0&quot;</code>(这也是通常的内置 hash 的键的实现方法之一).<br>该解法的时间复杂度为 $O(mn)$, 其中, $n$ 为遍历字符串数组的时间, $m$ 为获取 key 的时间, 无需进行排序.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">get_key</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> str_count[<span class="number">26</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : str)</span><br><span class="line">            str_count[c-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="built_in">string</span> str_key;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : str_count)</span><br><span class="line">            str_key += <span class="string">"#"</span> + to_string(i);</span><br><span class="line">        <span class="keyword">return</span> str_key;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res_hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str : strs)&#123;</span><br><span class="line">            <span class="built_in">string</span> s = get_key(str);</span><br><span class="line">            res_hash[s].push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s : res_hash)</span><br><span class="line">            res.push_back(s.second);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="050-Pow-x-n"><a href="#050-Pow-x-n" class="headerlink" title="050. Pow(x, n)"></a>050. Pow(x, n)</h1><p>实现幂乘操作</p>
<h2 id="Descriptin"><a href="#Descriptin" class="headerlink" title="Descriptin"></a>Descriptin</h2><p>Implement pow(x, n), which calculates x raised to the power n (x^n).</p>
<p>Example 1:</p>
<p>Input: 2.00000, 10<br>Output: 1024.00000<br>Example 2:</p>
<p>Input: 2.10000, 3<br>Output: 9.26100<br>Example 3:</p>
<p>Input: 2.00000, -2<br>Output: 0.25000<br>Explanation: 2-2 = 1/22 = 1/4 = 0.25<br>Note:</p>
<p>-100.0 &lt; x &lt; 100.0<br>n is a 32-bit signed integer, within the range $[−2^{31}, 2^{31} − 1]$</p>
<h2 id="解法一-递归-2"><a href="#解法一-递归-2" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(logn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>当n为偶数时: $x^n = x^{n/2} \times x^{n/2}$<br>当n为奇数时: $x^n = x\times x^{n/2} \times x^{n/2}$</p>
<p><strong>这里需要注意一点: abs(INT_MIN) 的值仍然是负值, 因为 <code>int</code> 只有 32 位, abs(INT_MIN) 时, 仍然是 32 位, 因此不会变成正值, 解决方法是先把该值赋给 <code>long</code> 型变量, 然后对 <code>long</code> 型变量调用 <code>abs()</code> 函数, 另一种解决方法是利用 <code>unsigned int</code></strong>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> min = INT_MIN; <span class="comment">// -2147483648</span></span><br><span class="line"><span class="keyword">long</span> min_abs1 = <span class="built_in">abs</span>(min); <span class="comment">// 2147483648, 这里 min_abs1 的值仍然是 INT_MIN, 因为调用 abs 的时候, 仍然是32位</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> min_abs2 = min;</span><br><span class="line">min_abs2 = <span class="built_in">abs</span>(min_abs2); <span class="comment">// 2147483648, 这里是对64位调用 abs, 所以成功转化成正数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法二是利用 unsigned int</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> abs_min = <span class="built_in">abs</span>(min) <span class="comment">//2147483648</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> un = <span class="built_in">abs</span>(n);  <span class="comment">//注意这里必须是 unsigned类型, 就算是long , 也必须带unsigned, 主要是因为abs(INT_MIN)仍为负数INT_MIN!</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">        <span class="keyword">return</span> (un%<span class="number">2</span>==<span class="number">0</span>) ? myPow(x*x, un/<span class="number">2</span>) : x*myPow(x*x, un/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-非递归-1"><a href="#解法二-非递归-1" class="headerlink" title="解法二: 非递归"></a>解法二: 非递归</h2><p><strong>时间复杂度:</strong> $O(logn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>n 要么为偶数, 要么为奇数, 我们每一次都将 n 的值减半, 并且将 x 与自身相乘, 每次当 n 为奇数时, 我们都将 res 与 x 相乘, 最终, res 的值就是我们要求的幂乘. 举例来说,<br>对于 x=2, n=10 , 每次将x和自身相乘, 同时将 n 减半, n 和 x 的值分别为:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n: <span class="number">10</span>, <span class="number">5</span>,  <span class="number">2</span>,   <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">x: <span class="number">2</span>,  <span class="number">4</span>, <span class="number">16</span>, <span class="number">256</span>, <span class="number">65536</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到, 我们将 n 为奇数时的 x 相乘, 就是最终的幂乘: $4\times 256 = 2^{10} = 1024$. 当 n 为奇数时也是同理, 如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n: <span class="number">11</span>, <span class="number">5</span>,  <span class="number">2</span>,   <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">x: <span class="number">2</span>,  <span class="number">4</span>, <span class="number">16</span>, <span class="number">256</span>, <span class="number">65536</span></span><br></pre></td></tr></table></figure>
<p>最终幂乘: $2\times 4\times \times 256 = 2^{11} = 2048$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>) x = <span class="number">1</span>/x;</span><br><span class="line">        <span class="keyword">long</span> ln = n;</span><br><span class="line">        ln = <span class="built_in">abs</span>(ln);</span><br><span class="line">        <span class="keyword">double</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(ln&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ln%<span class="number">2</span>==<span class="number">1</span>) res = res * x;</span><br><span class="line">            x = x * x;</span><br><span class="line">            ln = ln/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="053-Maximum-Subarray"><a href="#053-Maximum-Subarray" class="headerlink" title="053. Maximum Subarray"></a>053. Maximum Subarray</h1><p>连续子数组的最大和</p>
<h2 id="Description-10"><a href="#Description-10" class="headerlink" title="Description"></a>Description</h2><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p>Example:</p>
<p>Input: [-2,1,-3,4,-1,2,1,-5,4],<br>Output: 6<br>Explanation: [4,-1,2,1] has the largest sum = 6.<br>Follow up:</p>
<p>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<h2 id="解法-记录当前最大值"><a href="#解法-记录当前最大值" class="headerlink" title="解法: 记录当前最大值"></a>解法: 记录当前最大值</h2><p><strong>时间复杂度:</strong> $O(n)$<br>根据数组性质, 设置两个变量, 一个记录当前的最大值, 一个记录当前的子序列之和. 首先, 如果当前子序列之和为负, 那么就是说, 从当前位置开始的子序列, 比从之前位置开始的子序列大, 那么就可以不考虑从之前位置开始的子序列, 之前累计的和也被抛弃</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_sum = INT_MIN;  <span class="comment">//数组有可能全负, 所以不能赋值为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; max_sum) max_sum = num; <span class="comment">//主要是为了预防数组中全是负数的情况</span></span><br><span class="line">            sum += num;</span><br><span class="line">            <span class="keyword">if</span>(sum!=<span class="number">0</span> &amp;&amp; sum&gt;max_sum) max_sum = sum; <span class="comment">// sum!=0 , 为了预防数组全负时, 0一定大于sum, 造成的错解</span></span><br><span class="line">            <span class="keyword">if</span>(sum &lt;<span class="number">0</span>) sum =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>更简洁的写法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmpRes = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmpRes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                tmpRes = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmpRes += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">std</span>::max(res, tmpRes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="054-Spiral-Matrix"><a href="#054-Spiral-Matrix" class="headerlink" title="054. Spiral Matrix"></a>054. Spiral Matrix</h1><p>以顺时针螺旋顺序返回矩阵元素, 顺时针打印矩阵</p>
<h2 id="Description-11"><a href="#Description-11" class="headerlink" title="Description"></a>Description</h2><p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
<p>Example 1:</p>
<p>Input:<br>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]<br>Output: [1,2,3,6,9,8,7,4,5]<br>Example 2:</p>
<p>Input:<br>[<br>  [1, 2, 3, 4],<br>  [5, 6, 7, 8],<br>  [9,10,11,12]<br>]<br>Output: [1,2,3,4,8,12,11,10,9,5,6,7]</p>
<h2 id="解法-按层次输出-由外而内"><a href="#解法-按层次输出-由外而内" class="headerlink" title="解法: 按层次输出(由外而内)"></a>解法: 按层次输出(由外而内)</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>输出形式如下(按层次编码, 以4×6的矩阵为例), 需要注意边界控制条件:</p>
<script type="math/tex; mode=display">\begin{matrix} 1_{top}&1_{top}&1_{top}&1_{top}&1_{top}&1_{top} \\ 1_{left}&2_{top}&2_{top}&2_{top}&2_{top}&1_{right} \\ 1_{left}&2_{bottom}&2_{bottom}&2_{bottom}&2_{bottom}&1_{right} \\ 1_{bottom}&1_{bottom}&1_{bottom}&1_{bottom}&1_{bottom}&1_{bottom}  \end{matrix}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span> || matrix[<span class="number">0</span>].size() ==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> row_layer = (matrix.size()+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> col_layer = (matrix[<span class="number">0</span>].size()+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> layer = min( row_layer, col_layer); <span class="comment">// 计算总共的层数</span></span><br><span class="line">        <span class="keyword">int</span> cur_layer =<span class="number">0</span>; <span class="comment">// 用于记录当前所处哪一层</span></span><br><span class="line">        <span class="keyword">int</span> len_row = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> len_col = matrix[<span class="number">0</span>].size(); <span class="comment">//分别为行和列的size</span></span><br><span class="line">        <span class="keyword">while</span>(cur_layer &lt; layer)&#123;</span><br><span class="line">            <span class="comment">//top 输出上边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =cur_layer; j&lt;len_col-cur_layer; j++)</span><br><span class="line">                res.push_back(matrix[cur_layer][j]);</span><br><span class="line">            <span class="comment">//right 输出右边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = cur_layer+<span class="number">1</span>; i&lt;len_row<span class="number">-1</span>-cur_layer; i++)</span><br><span class="line">                res.push_back(matrix[i][len_col - <span class="number">1</span> - cur_layer]);</span><br><span class="line">            <span class="comment">//bottom  输出下边, 这里注意为了防止重复输出, 需要确保上边和下边的行数不同,即:</span></span><br><span class="line">            <span class="comment">// cur_layer!=len_row-1-cur_layer</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= len_col - <span class="number">1</span> -cur_layer; cur_layer!=len_row<span class="number">-1</span>-cur_layer &amp;&amp; j &gt;=cur_layer  ;j--)</span><br><span class="line">                res.push_back(matrix[len_row - <span class="number">1</span> -cur_layer][j]);</span><br><span class="line">            <span class="comment">//left 输出左边, 同样, 要确保左边和右边的列数不同, 即: cur_layer!=len_col-1-cur_layer</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = len_row<span class="number">-2</span>-cur_layer; cur_layer!=len_col<span class="number">-1</span>-cur_layer &amp;&amp; i&gt;cur_layer; i--)</span><br><span class="line">                res.push_back(matrix[i][cur_layer]);</span><br><span class="line">            cur_layer++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>另一种写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() <span class="keyword">or</span> matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> rowUp = <span class="number">-1</span>; <span class="comment">// 记录上边界</span></span><br><span class="line">        <span class="keyword">int</span> rowDown = n; <span class="comment">// 下边界</span></span><br><span class="line">        <span class="keyword">int</span> colLeft = <span class="number">-1</span>; <span class="comment">// 左边界</span></span><br><span class="line">        <span class="keyword">int</span> colRight = m; <span class="comment">// 右边界</span></span><br><span class="line">        <span class="keyword">while</span> (rowUp &lt; rowDown <span class="keyword">and</span> colLeft &lt; colRight) &#123;</span><br><span class="line">            rowUp++;</span><br><span class="line">            rowDown--;</span><br><span class="line">            <span class="keyword">if</span> (rowUp &gt; rowDown) <span class="keyword">break</span>; <span class="comment">// 如果越界, 则直接退出</span></span><br><span class="line">            colLeft++;</span><br><span class="line">            colRight--;</span><br><span class="line">            <span class="keyword">if</span> (colLeft &gt; colRight) <span class="keyword">break</span>; <span class="comment">// 越界则退出</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = colLeft; j &lt;= colRight; j++) &#123;</span><br><span class="line">                res.emplace_back(matrix[rowUp][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rowUp+<span class="number">1</span>; i &lt;= rowDown<span class="number">-1</span>; i++) &#123;</span><br><span class="line">                res.emplace_back(matrix[i][colRight]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = colRight; rowUp != rowDown <span class="keyword">and</span> j &gt;= colLeft; j--) &#123;</span><br><span class="line">                res.emplace_back(matrix[rowDown][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rowDown<span class="number">-1</span>; colLeft != colRight <span class="keyword">and</span> i &gt;= rowUp+<span class="number">1</span>; i--) &#123;</span><br><span class="line">                res.emplace_back(matrix[i][colLeft]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="055-Jump-Game"><a href="#055-Jump-Game" class="headerlink" title="055. Jump Game"></a>055. Jump Game</h1><p>数组的数字为最大的跳跃步数, 根据数组判断是否能跳到最后一位上</p>
<h2 id="Description-12"><a href="#Description-12" class="headerlink" title="Description"></a>Description</h2><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>Example 1:</p>
<p>Input: [2,3,1,1,4]<br>Output: true<br>Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.<br>Example 2:</p>
<p>Input: [3,2,1,0,4]<br>Output: false<br>Explanation: You will always arrive at index 3 no matter what. Its maximum<br>             jump length is 0, which makes it impossible to reach the last index.</p>
<h2 id="解法一-回溯"><a href="#解法一-回溯" class="headerlink" title="解法一: 回溯"></a>解法一: 回溯</h2><p><strong>时间复杂度:</strong> $O(2^n)$  总共有 $2^n$ 种跳法来跳到最后一个位置上(对于任意一个位置, 有经过和不经过两个种可能性)<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>试遍所有的可能性, 正常来说会超时, 并且也肯定不是最佳答案</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> final_position = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(position == final_position) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> furthest = <span class="built_in">std</span>::min(position+nums[position], final_position);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = position+<span class="number">1</span>; i&lt;=furthest; i++)&#123;</span><br><span class="line">            <span class="comment">//这里有个小小的优化, 就是令i从最大步长开始, i--, 这种优化虽然最坏情况时一样的</span></span><br><span class="line">            <span class="comment">//但在实际使用中, 会比从position+1开始要快一点(但是依然超时)</span></span><br><span class="line">            <span class="keyword">if</span>(helper(nums, i)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-top-down-动态规划-递归"><a href="#解法二-top-down-动态规划-递归" class="headerlink" title="解法二: top-down 动态规划(递归)"></a>解法二: top-down 动态规划(递归)</h2><p><strong>时间复杂度:</strong> $O(n^2)$ , 对于每个点来说, 都是要找到下一个<code>good_position</code>, 则需要进行 $(O)$ 的查找, 又因为总共有 $O(n)$个元素, 所以复杂度为 $O(n^2)$.<br><strong>空间复杂度:</strong> $O(2n)$, 递归需要 $O(n)$ , <code>memo</code>需要 $O(n)$.</p>
<p>设计一个数组, 用来记录当前下标对应位置是否可又达到终点, 如果能, 则该位置为<code>good position</code>, 如果不能, 则为<code>bad position</code>, 刚开始的时候都是<code>unknown position</code>(除了最后一个位置为<code>good</code>).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span>&#123;</span>GOOD, BAD, UNKNOWN&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Status&gt; memo;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-1</span>; i++)</span><br><span class="line">            memo.push_back(Status::UNKNOWN);</span><br><span class="line">        memo.push_back(Status::GOOD);</span><br><span class="line">        <span class="keyword">return</span> helper(nums, memo, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="built_in">vector</span>&lt;Status&gt; &amp;memo, <span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> final_position = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo[position] != Status::UNKNOWN) <span class="keyword">return</span> memo[position]==Status::GOOD ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> furthest = <span class="built_in">std</span>::min(position+nums[position], final_position);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = furthest; i&gt;position; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(helper(nums, memo, i))&#123;</span><br><span class="line">                memo[position] = Status::GOOD; <span class="comment">//注意是position, 不是i</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[position] = Status::BAD;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-down-top-动态规划-非递归"><a href="#解法三-down-top-动态规划-非递归" class="headerlink" title="解法三: down-top 动态规划(非递归)"></a>解法三: down-top 动态规划(非递归)</h2><p><strong>时间复杂度:</strong> $O(n^2)$ , 对于每个点来说, 都是要找到下一个<code>good_position</code>, 则需要进行 $(O)$ 的查找, 又因为总共有 $O(n)$个元素, 所以复杂度为 $O(n^2)$.<br><strong>空间复杂度:</strong> $O(n)$, 无需递归 , 只需要<code>memo</code>, $O(n)$.</p>
<p>动态规划的非递归版本.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span>&#123;</span>GOOD, BAD, UNKNOWN&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if(nums.size() ==0) return false;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;Status&gt; memo;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-1</span>; i++)</span><br><span class="line">            memo.push_back(Status::UNKNOWN);</span><br><span class="line">        memo.push_back(Status::GOOD);</span><br><span class="line">        <span class="keyword">int</span> final_position = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.size()<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> furthest = <span class="built_in">std</span>::min(i+nums[i], final_position);</span><br><span class="line">            <span class="comment">//for(int j = i+1; j&lt;=furthest; j++)&#123;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = furthest; j&gt;i;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(memo[j] == Status::GOOD)&#123; <span class="comment">// 只要有一个GOOD, 当前i位置就为GOOD, 而无需考虑BAD的情况</span></span><br><span class="line">                    memo[i] = memo[j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[<span class="number">0</span>] == Status::GOOD ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-贪心"><a href="#解法四-贪心" class="headerlink" title="解法四: 贪心"></a>解法四: 贪心</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>由上面的down-top递归可以看出, 当前下标位置的点是否为good点, 实际上只取决于当前点是否能够达到右边坐标中(从右往左走)最左边的good(可以看上面的break语句), 如果能够达到, 则当前点一定为good点, 因此, 我们只需要用一个变量<code>left_most_good</code>来维护当前点右边的最左good点下标即可, 无需任何其他空间和操作.(速度极快)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left_most_good = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size()<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+nums[i] &gt;= left_most_good)&#123;</span><br><span class="line">                left_most_good = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left_most_good==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>另一种贪心的形式:</strong> 记录当前能够达到的最大位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> reach=<span class="number">0</span>; i&lt;nums.size() &amp;&amp; i&lt;=reach; i++ )</span><br><span class="line">            reach = max(i+nums[i], reach);</span><br><span class="line">        <span class="keyword">return</span> i==nums.size(); <span class="comment">// 或者用 reach &gt;= nums.size()-1 判断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="056-Merge-Intervals"><a href="#056-Merge-Intervals" class="headerlink" title="056. Merge Intervals"></a>056. Merge Intervals</h1><p>融合区间</p>
<h2 id="Description-13"><a href="#Description-13" class="headerlink" title="Description"></a>Description</h2><p>Given a collection of intervals, merge all overlapping intervals.</p>
<p>Example 1:</p>
<p>Input: [[1,3],[2,6],[8,10],[15,18]]<br>Output: [[1,6],[8,10],[15,18]]<br>Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].<br>Example 2:</p>
<p>Input: [[1,4],[4,5]]<br>Output: [[1,5]]<br>Explanation: Intervals [1,4] and [4,5] are considerred overlapping.</p>
<h2 id="解法一-sort-O-n"><a href="#解法一-sort-O-n" class="headerlink" title="解法一: sort+O(n)"></a>解法一: sort+O(n)</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 主要是排序<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>最简单的实现方法, 先按照interval.start用sort排序, 排好序以后, 能够融合的interval都会聚到一起, 这个时候, 因为start是呈递增的, 只需要看end的大小关系就可以.</p>
<p>最简单的实现方法就是sort之后, 通过额外申请空间来存储融合后的interval, 最后返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;Interval&gt;&#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; res;</span><br><span class="line">        <span class="built_in">std</span>::sort(intervals.begin(), intervals.end(), [](Interval a, Interval b)&#123;<span class="keyword">return</span> a.start &lt; b.start;&#125;);</span><br><span class="line">        res.push_back(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iv : intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.back().end &lt; iv.start) res.push_back(iv);</span><br><span class="line">            <span class="keyword">else</span> res.back().end = <span class="built_in">std</span>::max(res.back().end, iv.end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-sort-O-1"><a href="#解法二-sort-O-1" class="headerlink" title="解法二: sort+O(1)"></a>解法二: sort+O(1)</h2><p><strong>时间复杂度:</strong> $O(nlogn)$ , 主要是排序<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>上面的方法在逻辑上不够好, 因为既然已经申请了额外的内存来存储放回结果, 说明我们不希望改变原vector内部的数据, 但是sort之后, 数据顺序已经被破坏了, 既然已经破坏了, 那最好就是直接使用原地融合的办法, 来减少内存的开销<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;Interval&gt;&#123;&#125;;</span><br><span class="line">        <span class="comment">//vector&lt;Interval&gt; res; 既然决定使用sort, 就说明已经改变了intervals, 此时不应该在额外申请空间, 而应该进行原地融合.</span></span><br><span class="line">        <span class="built_in">std</span>::sort(intervals.begin(), intervals.end(), [](Interval a, Interval b)&#123;<span class="keyword">return</span> a.start &lt; b.start;&#125;);</span><br><span class="line">        <span class="keyword">auto</span> cur_iv = intervals.begin();</span><br><span class="line">        <span class="keyword">auto</span> next_iv = intervals.begin()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; next_iv!=intervals.end(); next_iv++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (*cur_iv).end &lt; (*next_iv).start )&#123;</span><br><span class="line">                cur_iv++;</span><br><span class="line">                (*cur_iv) = (*next_iv);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                (*cur_iv).end = <span class="built_in">std</span>::max( (*cur_iv).end, (*next_iv).end );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        intervals.erase(cur_iv+<span class="number">1</span>, intervals.end());</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法三-不使用sort"><a href="#解法三-不使用sort" class="headerlink" title="解法三: 不使用sort"></a>解法三: 不使用sort</h2><p>有时, 我们要求不能改变原向量intervals的内容, 此时, 就不能使用sort (除非牺牲大量空间留副本,但单肯定不推荐).</p>
<p>//TODO, 未细看, 但时间复杂度应该会高于 O(nlogn)<br><a href="https://leetcode.com/problems/merge-intervals/discuss/153979/Elegant-c++-solutions.-One-without-modifying-intervals-and-one-inplace" target="_blank" rel="noopener">https://leetcode.com/problems/merge-intervals/discuss/153979/Elegant-c++-solutions.-One-without-modifying-intervals-and-one-inplace</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Without modifying intervals</span><br><span class="line">Since we can't sort interval, we want to instead ensure our destination <span class="built_in">vector</span> is sorted. A insertion sort is required then. Insertion should be done as follows;</span><br><span class="line"></span><br><span class="line">Find first destination interval that ends after the incoming interval starts. Called it</span><br><span class="line">If no such interval is found <span class="keyword">or</span> the incoming interval end is less than found intervals start then we can just insert <span class="keyword">and</span> be done.</span><br><span class="line">Otherwise there must be an overlap, but it could be more than one. Do another search, <span class="keyword">this</span> time <span class="keyword">for</span> the first interval whose start is greater than incoming interval end. Called last</span><br><span class="line">Everything from [it, last) can be merged together with incoming interval into a single interval</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Interval&gt; ret;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; interval : intervals) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">std</span>::lower_bound(ret.begin(), ret.end(), interval.start, [](<span class="keyword">const</span> Interval&amp; l, <span class="keyword">int</span> r) &#123; <span class="keyword">return</span> l.end &lt; r; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (it == ret.end() || interval.end &lt; it-&gt;start)</span><br><span class="line">          <span class="comment">// No overlap, insert as is</span></span><br><span class="line">          ret.insert(it, interval);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// There is an overlap, there might be more, so find the upper bound too</span></span><br><span class="line">          it-&gt;start = <span class="built_in">std</span>::min(it-&gt;start, interval.start);</span><br><span class="line">          <span class="keyword">auto</span> last = <span class="built_in">std</span>::upper_bound(it, ret.end(), interval.end, [](<span class="keyword">int</span> l, <span class="keyword">const</span> Interval&amp; r) &#123; <span class="keyword">return</span> l &lt; r.start; &#125;);</span><br><span class="line">          it-&gt;end = <span class="built_in">std</span>::max((last - <span class="number">1</span>)-&gt;end, interval.end);</span><br><span class="line">          ret.erase(it + <span class="number">1</span>, last);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="062-不同路径"><a href="#062-不同路径" class="headerlink" title="062. 不同路径"></a>062. 不同路径</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths/</a></p>
<h2 id="Description-14"><a href="#Description-14" class="headerlink" title="Description"></a>Description</h2><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<h2 id="解法一-DP"><a href="#解法一-DP" class="headerlink" title="解法一: DP"></a>解法一: DP</h2><p><strong>时间复杂度:</strong> $O(mn)$<br><strong>空间复杂度:</strong> $O(mn)$</p>
<p>这是一道经典的DP问题, 当机器人处于某一点时, 它只能从上面或者左边到达该点, 因此很容易得出<code>path[i][j] = path[i-1][j] + path[i][j-1];</code>, 其中 <code>path[i][j]</code>指到达 $(i,j)$ 点的可能路径数量.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; path(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ;i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span> ; j&lt;n; j++)&#123;</span><br><span class="line">                path[i][j] = path[i<span class="number">-1</span>][j] + path[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-优化的DP"><a href="#解法二-优化的DP" class="headerlink" title="解法二: 优化的DP"></a>解法二: 优化的DP</h2><p><strong>时间复杂度:</strong> $O(mn)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>通过分析知道, 当前点的可能路径数量只与上面点和左边点的值有关, 在上面的方法中, 我们用一个 $m\times n$ 的数组来存储当前点上面和左边的值, 实际上, 我们 <strong>只需要用一行数组</strong> 就可以完成这个功能, 首先, 求出第一行的所有点的值, 这里只会用每个点左边的值,  然后, 对于第二行的第一个点来说, 它只会用到上面的值, 也就是第一行的第一个值, 因此可以通过行数组直接得到, 然后, 对于第二行的第二个值, 它可以从第二行的第一个值, 以及第二行的第二个值得到, 这些值都是已知的, 所以可以直接求的, 由于在求得以后, 我们就再也不需要第一行的第二个值了, 所以我们可以用这个存储空间来存储第二行的第二个值, 如此递归执行, 我们只需要 $O(n)$ 的空间即可.</p>
<p>Python 实现:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                dp[j] = dp[j] + dp[j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path(n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                path[j] = path[j] + path[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-排列组合-最优"><a href="#解法三-排列组合-最优" class="headerlink" title="解法三: 排列组合(最优)"></a>解法三: 排列组合(最优)</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>实际上, 仔细分析该问题, 可以把该问题看成是一个典型的排列组合问题. 首先, 将机器人向右走记为 1, 将机器人向下走记为 0. 题目问有多少种不同的走法, 实际上就是在问1/0序列的不同排列有多少种, 并且, 1/0 的长度必须为 $(m -1 + n - 1)$. 因此, 这个问题可以看做是从 $(m-1+n-1)$ 个空槽位上选择 $(m-1)$ 个槽位, 将其置为1, 并将剩余的 $n-1$ 个槽位置为0, 故而就是组合问题: $C_{m-1+n-1}^{m-1}$ . 又因为 $C_{m-1+n-1}^{m-1} = C_{m-1+n-1}^{n-1}$ , 所以为了防止溢出, 我们可以选择小的进行计算</p>
<p><strong>注意, 在排列如何时, 因为涉及到除法, 所以一定要注意计算法则的先后顺序, 具体请看代码</strong></p>
<p>C++ 实现<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        long res = <span class="number">1</span>; //需要注意的是, 由于下面的计算操作是会有先乘一个数, 再初以一个数的操作, 因此很有可能乘完后超过int上限, 所以需要声明为long整型</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i&lt; std::min(m,n); i++)&#123;</span><br><span class="line">            res = res * (m<span class="number">-1</span>+n<span class="number">-1</span> - i+<span class="number">1</span>) / i;</span><br><span class="line">            // 这里如果写成 res *= (m<span class="number">-1</span>+n<span class="number">-1</span>+i+<span class="number">1</span>) / i, 则会报错, 因为这样会先计算除法, 这样有可能会出现浮点数, 但是排列组合是不会出现浮点数的, 切记!</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Python 实现<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, min(m, n)):</span><br><span class="line">            res = res * (m<span class="number">-1</span>+n<span class="number">-1</span> - i+<span class="number">1</span>) / (i)</span><br><span class="line">        <span class="keyword">return</span> int(res)</span><br></pre></td></tr></table></figure></p>
<p>直接调用 scipy 计算包:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.special <span class="keyword">import</span> comb, perm <span class="comment"># comb 组合, perm 排序</span></span><br><span class="line"><span class="keyword">return</span> comb(m<span class="number">-1</span>+n<span class="number">-1</span>, min(m, n) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>迭代器(超时):<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line">        data = range(m<span class="number">-1</span>+n<span class="number">-1</span>)</span><br><span class="line">        combs = (combinations(data, min(m, n)<span class="number">-1</span>)) <span class="comment"># 返回一个迭代器</span></span><br><span class="line">        <span class="keyword">return</span> sum(<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> combs) <span class="comment"># 注意, 迭代器迭代一轮就停止了, 不会重新回到头部, 即不能重复使用</span></span><br></pre></td></tr></table></figure></p>
<h1 id="063-不同路径-II"><a href="#063-不同路径-II" class="headerlink" title="063. 不同路径 II"></a>063. 不同路径 II</h1><h2 id="解法-动态规划"><a href="#解法-动态规划" class="headerlink" title="解法: 动态规划"></a>解法: 动态规划</h2><p>设置 dp 数组, 由于只需要上方和左方的元素, 因此 dp 数组可以只设为 2 x n 的大小, dp 数组中的值代表走到当前点总共的路径数.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(obstacleGrid) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        length = len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>] * (length+<span class="number">1</span>), [<span class="number">0</span>] * (length+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] != <span class="number">1</span>:</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(obstacleGrid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(obstacleGrid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    dp[<span class="number">1</span>][j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dp[<span class="number">1</span>][j] = dp[<span class="number">1</span>][j<span class="number">-1</span>] + dp[<span class="number">0</span>][j]</span><br><span class="line">            dp = dp[::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">-2</span>] <span class="comment"># 注意, 这里由于上面替换了 dp 的 0 和 1, 所以结果存在 dp[0] 中, 而不是 dp[1] 中</span></span><br></pre></td></tr></table></figure>
<h2 id="解法二-空间优化的动态规划"><a href="#解法二-空间优化的动态规划" class="headerlink" title="解法二: 空间优化的动态规划"></a>解法二: 空间优化的动态规划</h2><p>实际上, 并不需要 2xn 大小的数组, <strong>只需要一个 n 长度的一维数组就够了</strong>, 思路和 62 题一直, 具体实现如下所示:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(obstacleGrid) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = len(obstacleGrid)</span><br><span class="line">        n = len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>: dp[j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>: dp[j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>: dp[j] = dp[j]</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">0</span>: dp[j] = dp[j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>: dp[j] = dp[j] + dp[j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<h1 id="064-最小路径和"><a href="#064-最小路径和" class="headerlink" title="064. 最小路径和"></a>064. 最小路径和</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-path-sum/</a></p>
<h2 id="解法-动态规划-1"><a href="#解法-动态规划-1" class="headerlink" title="解法: 动态规划"></a>解法: 动态规划</h2><p>申请<code>dp[2][n]</code>数组, <code>dp[1][j]</code>代表走到<code>grid[i][j]</code>所需的最小步数.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sys.maxint</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> (len(grid) == <span class="number">0</span>): <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>] * n, [<span class="number">0</span>] * n]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[<span class="number">1</span>][j] = dp[<span class="number">0</span>][j] + grid[i][j]</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">                    dp[<span class="number">1</span>][j] = dp[<span class="number">1</span>][j<span class="number">-1</span>] + grid[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[<span class="number">1</span>][j] = min(dp[<span class="number">0</span>][j], dp[<span class="number">1</span>][j<span class="number">-1</span>]) + grid[i][j]</span><br><span class="line">            dp = dp[::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>] <span class="comment"># 由于上面dp[::-1]交换了顺序, 所以最终的结果存在dp[0]当中</span></span><br></pre></td></tr></table></figure>
<h2 id="解法-动态规划空间复杂度优化"><a href="#解法-动态规划空间复杂度优化" class="headerlink" title="解法: 动态规划空间复杂度优化"></a>解法: 动态规划空间复杂度优化</h2><p>实际上, 当前点只依赖与前一个点和上一个点的值, 因此, 我们可以通过一个以为数组就能够存储足够的信息, 故而可以将空间占用量减半</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> (len(grid) == <span class="number">0</span>): <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[j] = dp[j] + grid[i][j]</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">                    dp[j] = dp[j<span class="number">-1</span>] + grid[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = min(dp[j], dp[j<span class="number">-1</span>]) + grid[i][j]</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>] <span class="comment"># 由于上面dp[::-1]交换了顺序, 所以最终的结果存在dp[0]当中</span></span><br></pre></td></tr></table></figure>
<h1 id="066-Plus-One"><a href="#066-Plus-One" class="headerlink" title="066. Plus One"></a>066. Plus One</h1><p>数组代表一个整数, 模拟整数的加法</p>
<h2 id="Description-15"><a href="#Description-15" class="headerlink" title="Description"></a>Description</h2><p>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
<p>Example 1:</p>
<p>Input: [1,2,3]<br>Output: [1,2,4]<br>Explanation: The array represents the integer 123.<br>Example 2:</p>
<p>Input: [4,3,2,1]<br>Output: [4,3,2,2]<br>Explanation: The array represents the integer 4321.</p>
<h2 id="解法一-直接模拟"><a href="#解法一-直接模拟" class="headerlink" title="解法一: 直接模拟"></a>解法一: 直接模拟</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>, last_i = digits.size()<span class="number">-1</span>;</span><br><span class="line">        digits[last_i] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(digits[last_i] &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            digits[last_i] = <span class="number">0</span>;</span><br><span class="line">            carry=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = last_i<span class="number">-1</span>; i&gt;=<span class="number">0</span> &amp;&amp; carry ; i--)&#123;</span><br><span class="line">            digits[i] += carry;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] &gt; <span class="number">9</span>)</span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>) digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>另一种写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = digits.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cur=digits.size()<span class="number">-1</span>; cur&gt;=<span class="number">0</span>; cur--)&#123;</span><br><span class="line">            digits[cur] += one + carry;</span><br><span class="line">            one = <span class="number">0</span>;</span><br><span class="line">            carry = digits[cur] / <span class="number">10</span>;</span><br><span class="line">            digits[cur] = digits[cur] % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry) digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-不使用加法-更快更简单-击败100"><a href="#解法二-不使用加法-更快更简单-击败100" class="headerlink" title="解法二: 不使用加法(更快更简单, 击败100%)"></a>解法二: 不使用加法(更快更简单, 击败100%)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;digits) &#123;   <span class="comment">//未考虑前缀0的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = digits.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)   </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] != <span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                digits[i] ++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(digits[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="069-Sqrt-x"><a href="#069-Sqrt-x" class="headerlink" title="069. Sqrt(x)"></a>069. Sqrt(x)</h1><p>实现开方算法</p>
<h2 id="Description-16"><a href="#Description-16" class="headerlink" title="Description"></a>Description</h2><p>Implement int sqrt(int x).</p>
<p>Compute and return the square root of x, where x is guaranteed to be a non-negative integer.</p>
<p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-二分法"><a href="#解法一-二分法" class="headerlink" title="解法一: 二分法"></a>解法一: 二分法</h2><p><strong>时间复杂度:</strong> $O(logn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> low=<span class="number">0</span>, high=x;</span><br><span class="line">        <span class="keyword">double</span> res = high;</span><br><span class="line">        <span class="keyword">while</span>( <span class="built_in">std</span>::<span class="built_in">abs</span>(res*res - x) &gt; <span class="number">0.00001</span> )&#123;</span><br><span class="line">            <span class="keyword">if</span>(res*res &gt; x)&#123;</span><br><span class="line">                high = res;</span><br><span class="line">                res = (low+high)/<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = res;</span><br><span class="line">                res = (low+high)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ceil</span>(res)*<span class="built_in">ceil</span>(res)==x) <span class="keyword">return</span> <span class="built_in">ceil</span>(res); <span class="comment">// 为了能够正确截断, 必须加上此句</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-牛顿迭代法"><a href="#解法二-牛顿迭代法" class="headerlink" title="解法二: 牛顿迭代法"></a>解法二: 牛顿迭代法</h2><p><strong>时间复杂度:</strong> $O(logn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>相当于求解 $f(res)=res^2 - x = 0$ 中 $res$ 的解. 则对于任意一点 $(res, f(res))$, 都有切线方程:</p>
<script type="math/tex; mode=display">f(res) - 0 = f'(res)(res-res')</script><p>其中, $res’$ 是该直线与 $x$ 轴的交点. 令新的 $res$ 为该值, 就可以不断逼近 $f(res)$ 的零点, $res’$ 的值为:</p>
<script type="math/tex; mode=display">res' = res- \frac{f(res)}{f'(res)} = res- \frac{res^2-x}{2\times res} = \frac{res^2 + x}{2\times res}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = x;</span><br><span class="line">        <span class="keyword">while</span>( <span class="built_in">std</span>::<span class="built_in">abs</span>(res*res - x) &gt; <span class="number">0.00001</span> )&#123;</span><br><span class="line">            res = (res*res+x) / (<span class="number">2</span>*res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ceil</span>(res)*<span class="built_in">ceil</span>(res)==x) <span class="keyword">return</span> <span class="built_in">ceil</span>(res); <span class="comment">// 为了能够正确截断, 必须加上此句</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-按位检索"><a href="#解法三-按位检索" class="headerlink" title="解法三: 按位检索"></a>解法三: 按位检索</h2><p><strong>时间复杂度:</strong> $O(logn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>由于本题要返回的是整数, 而上面的两种方法都是针对double类型的精确开根方法, 时间复杂度为 $O(logn)$, 实际上, 当只需要返回整数时, 我们可以按整数的位进行检索, 而整数总共只有32位(传入的x位int型, 所以开根后不可能超过int), 因此时间复杂度只有 $O(32)$ , 也就是 $O(1)$.</p>
<p><strong>注意:</strong> 由于该方法是首先找到比 x 大的那一位, 因此有可能超过int上限, 所以要换成long整型</p>
<p>找到后依然需要进行二分查找来找到最终的返回值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( <span class="keyword">long</span>(<span class="number">1</span>&lt;&lt;h) * <span class="keyword">long</span>(<span class="number">1</span>&lt;&lt;h) &lt;= x) h++;</span><br><span class="line">        <span class="keyword">long</span> b = <span class="number">1</span>&lt;&lt;(h<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>( b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (res+b) * (res+b) &lt;= x)</span><br><span class="line">                res += b;</span><br><span class="line">            b = b/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="070-Climbing-Stairs"><a href="#070-Climbing-Stairs" class="headerlink" title="070. Climbing Stairs"></a>070. Climbing Stairs</h1><p>实际上就是斐波那契数列, 更具体分析可看牛客的跳台阶</p>
<h2 id="Description-17"><a href="#Description-17" class="headerlink" title="Description"></a>Description</h2><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>Note: Given n will be a positive integer.</p>
<p>Example 1:</p>
<p>Input: 2<br>Output: 2<br>Explanation: There are two ways to climb to the top.</p>
<ol>
<li>1 step + 1 step</li>
<li>2 steps<br>Example 2:</li>
</ol>
<p>Input: 3<br>Output: 3<br>Explanation: There are three ways to climb to the top.</p>
<ol>
<li>1 step + 1 step + 1 step</li>
<li>1 step + 2 steps</li>
<li>2 steps + 1 step</li>
</ol>
<h2 id="解法一-递归-3"><a href="#解法一-递归-3" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><h2 id="解法二-迭代-1"><a href="#解法二-迭代-1" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n2;</span><br><span class="line">            n2 = n1+n2;</span><br><span class="line">            n1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="073-Set-Matrix-Zeroes"><a href="#073-Set-Matrix-Zeroes" class="headerlink" title="073. Set Matrix Zeroes"></a>073. Set Matrix Zeroes</h1><h2 id="Description-18"><a href="#Description-18" class="headerlink" title="Description"></a>Description</h2><p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.</p>
<p>Example 1:</p>
<p>Input:<br>[<br>  [1,1,1],<br>  [1,0,1],<br>  [1,1,1]<br>]<br>Output:<br>[<br>  [1,0,1],<br>  [0,0,0],<br>  [1,0,1]<br>]<br>Example 2:</p>
<p>Input:<br>[<br>  [0,1,2,0],<br>  [3,4,5,2],<br>  [1,3,1,5]<br>]<br>Output:<br>[<br>  [0,0,0,0],<br>  [0,4,5,0],<br>  [0,3,1,0]<br>]<br>Follow up:</p>
<p>A straight forward solution using O(mn) space is probably a bad idea.<br>A simple improvement uses O(m + n) space, but still not the best solution.<br>Could you devise a constant space solution?</p>
<h2 id="解法一-穷举-1"><a href="#解法一-穷举-1" class="headerlink" title="解法一: 穷举"></a>解法一: 穷举</h2><p><strong>时间复杂度:</strong> $O(nm)$<br><strong>空间复杂度:</strong> $O(nm)$</p>
<p>记录所有出现0的位置, 然后根据这些位置坐标将对应的行和列上的值置为0.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rows;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    rows.push_back(i);</span><br><span class="line">                    cols.push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:rows)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:cols)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-穷举-减少空间复杂度"><a href="#解法二-穷举-减少空间复杂度" class="headerlink" title="解法二: 穷举(减少空间复杂度)"></a>解法二: 穷举(减少空间复杂度)</h2><p><strong>时间复杂度:</strong> $O(nm)$<br><strong>空间复杂度:</strong> $O(n+m)$</p>
<p>上面在记录位置坐标时没有进行重复检查, 实际上, 对于已经记录过的行或列, 可以不用再记录, 此时, 空间复杂度可以降为 $O(m+n)$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rows;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 记录行或列坐标之前先进行重复检查</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">std</span>::count(rows.begin(), rows.end(), i)==<span class="number">0</span>) rows.push_back(i);</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">std</span>::count(cols.begin(), cols.end(), j)==<span class="number">0</span>) cols.push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:rows)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:cols)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-穷举-无空间复杂度"><a href="#解法三-穷举-无空间复杂度" class="headerlink" title="解法三: 穷举(无空间复杂度)"></a>解法三: 穷举(无空间复杂度)</h2><p><strong>时间复杂度:</strong> $O(nm\times (m+n))$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>遍历矩阵时, 如果遇到 $(i,j)$ 上的值为0, 那么就将对应的行和列上的所有非0值全部置为一个矩阵范围外的值NAN(解答里面用的是-100000, <strong>实际上这种解法存在问题, 因为理论上矩阵中的元素可以是表示范围内的任何值</strong> ).</p>
<p>之后将所有的NAN值置为0, 就可以完成置0任务, 并且没有使用额外的空间. 由于每次找到一个0时, 都要遍历这个位置上的行和列, 因此时间复杂度较高</p>
<h2 id="解法四-用第一行和第一列记录"><a href="#解法四-用第一行和第一列记录" class="headerlink" title="解法四: 用第一行和第一列记录"></a>解法四: 用第一行和第一列记录</h2><p><strong>时间复杂度:</strong> $O(nm)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>用第一行和第一列的值记录是否应该将对应的行和列置为0, 此时由于第一行和第一列被用作了标记数组, 因此第一行和第一列的0不能用来判断是否应该置为全0, 所以需要额外设置两个变量记录.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> is_row=<span class="literal">false</span>, is_col = <span class="literal">false</span>; <span class="comment">// 用第一行和第一列的值来做标记, 因此需要额外的记录第一行和第一列本身是有应该全0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>) is_row=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">0</span>) is_col=<span class="literal">true</span>;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][j]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is_row)&#123; <span class="comment">//需要特别判断第一行和第一列是否应该置为0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt;matrix[<span class="number">0</span>].size();j++)  matrix[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is_col)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; matrix.size(); i++) matrix[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="075-Sort-Colors"><a href="#075-Sort-Colors" class="headerlink" title="075. Sort Colors"></a>075. Sort Colors</h1><p>对0,1,2 (颜色: RGB) 进行排序</p>
<h2 id="Description-19"><a href="#Description-19" class="headerlink" title="Description"></a>Description</h2><p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p>Note: You are not suppose to use the library’s sort function for this problem.</p>
<p>Example:</p>
<p>Input: [2,0,2,1,1,0]<br>Output: [0,0,1,1,2,2]<br>Follow up:</p>
<p>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.<br>Could you come up with a one-pass algorithm using only constant space?</p>
<h2 id="解法一-两次遍历"><a href="#解法一-两次遍历" class="headerlink" title="解法一: 两次遍历"></a>解法一: 两次遍历</h2><p><strong>时间复杂度: $O(n)$</strong><br><strong>空间复杂度: $O(1)$</strong></p>
<p>第一次遍历统计0,1,2的个数, 第二次遍历根据0,1,2的个数覆盖数组原有值</p>
<h2 id="解法二-一次遍历"><a href="#解法二-一次遍历" class="headerlink" title="解法二: 一次遍历"></a>解法二: 一次遍历</h2><p><strong>时间复杂度:</strong> 大于 $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>设置mid, low, high三个指示变量, 如果mid==0, 则将其与low交换, 如果mid==2, 则将其与high交换, 直到mid&gt;high为止.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>, mid=<span class="number">0</span>, high=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(mid&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[mid], nums[high--]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]==<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[mid++], nums[low++]);</span><br><span class="line">                <span class="comment">//这里 mid 可以直接++ 的原因是因为mid已经将0和2的情况进行处理,</span></span><br><span class="line">                <span class="comment">// 所以现在 low 指向的值只可能是 1, 因此交换后无需再对nums[mid]判断, 直接++即可</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mid++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="076-Minimum-Window-Substring"><a href="#076-Minimum-Window-Substring" class="headerlink" title="076. Minimum Window Substring"></a>076. Minimum Window Substring</h1><p>求包含子串字符的最小窗口</p>
<h2 id="Description-20"><a href="#Description-20" class="headerlink" title="Description"></a>Description</h2><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>
<p>Example:</p>
<p>Input: S = “ADOBECODEBANC”, T = “ABC”<br>Output: “BANC”<br>Note:</p>
<p>If there is no such window in S that covers all characters in T, return the empty string “”.<br>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</p>
<h2 id="解法-两个变量记录当前窗口大小"><a href="#解法-两个变量记录当前窗口大小" class="headerlink" title="解法: 两个变量记录当前窗口大小"></a>解法: 两个变量记录当前窗口大小</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hmap(<span class="number">256</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:t) hmap[<span class="keyword">int</span>(c)]++;</span><br><span class="line">        <span class="keyword">int</span> count = t.size(), begin=<span class="number">0</span>, end=<span class="number">0</span>, head=<span class="number">0</span>, cur_window=INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(end&lt;s.size())&#123;</span><br><span class="line">            <span class="comment">// 这里可以直接写成 if(hmap[int(s[end++])]-- &gt; 0) count--;  但是可读性很差,  不建议这样写.</span></span><br><span class="line">            <span class="keyword">if</span>(hmap[<span class="keyword">int</span>(s[end])] &gt; <span class="number">0</span>) count--;</span><br><span class="line">            hmap[<span class="keyword">int</span>(s[end])]--; end++;</span><br><span class="line">            <span class="keyword">while</span>(count==<span class="number">0</span>)&#123; <span class="comment">//end 超尾</span></span><br><span class="line">                <span class="keyword">if</span>( (end-begin) &lt; cur_window) cur_window = end - (head=begin);</span><br><span class="line">                <span class="comment">// 同样, 可以直接写成 if(hmap[int(s[begin++])]++ &gt; 0) count++;  但是可读性很差</span></span><br><span class="line">                <span class="keyword">if</span>(hmap[<span class="keyword">int</span>(s[begin])] == <span class="number">0</span>) count++;</span><br><span class="line">                hmap[<span class="keyword">int</span>(s[begin])]++; begin++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur_window==INT_MAX ? <span class="string">""</span> : s.substr(head, cur_window);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="子串相关题目的模板解法"><a href="#子串相关题目的模板解法" class="headerlink" title="子串相关题目的模板解法"></a>子串相关题目的模板解法</h2><p><a href="https://leetcode.com/problems/minimum-window-substring/discuss/26808/Here-is-a-10-line-template-that-can-solve-most-&#39;substring&#39;-problems" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-window-substring/discuss/26808/Here-is-a-10-line-template-that-can-solve-most-&#39;substring&#39;-problems</a></p>
<p>对于大多数的子串相关的问题, 通常可以描述为给定一个字符串, 要求找到满足某些限制条件的子串, 这类都可以用下面的基于哈希表和两个辅助指示变量的模板来求解:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hmap(<span class="number">128</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">// 用于检查子串是否合法</span></span><br><span class="line">    <span class="keyword">int</span> begin=<span class="number">0</span>, end=<span class="number">0</span>; <span class="comment">// 两个指示变量, 分别指向子串的头和尾(end会在++后退出循环, 因此最后end会变成超尾)</span></span><br><span class="line">    <span class="keyword">int</span> len_sub; <span class="comment">// 子串的长度</span></span><br><span class="line">    <span class="keyword">for</span>()&#123; &#125;<span class="comment">//对hasp map进行初始化</span></span><br><span class="line">    <span class="keyword">while</span>(end&lt;s.size())&#123;</span><br><span class="line">        <span class="comment">//if(hmap[s[end++]]-- ? ) &#123; &#125; //修改count</span></span><br><span class="line">        <span class="comment">//上面的语句可读性很差, 最后拆开来写, 后面也同理, 拆开写</span></span><br><span class="line">        <span class="keyword">if</span>(hmap[<span class="keyword">int</span>(s[end])] ? ) &#123; &#125; <span class="comment">//修改count</span></span><br><span class="line">        hmap[<span class="keyword">int</span>(s[end])]--; <span class="comment">//注意顺序</span></span><br><span class="line">        end++;</span><br><span class="line">        <span class="keyword">while</span>( count? )&#123; <span class="comment">// 检查count是否满足条件</span></span><br><span class="line">            <span class="comment">// update len_sub</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(hmap[<span class="keyword">int</span>(s[begin])] ?) &#123; &#125; <span class="comment">//修改count</span></span><br><span class="line">            hmap[<span class="keyword">int</span>(s[begin])]++;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如, 对于问题 <strong>Longest Substring At Two Distinct Characters</strong> 的模板解法如下:</p>
<p>对于问题 <strong>Longest Substring Without Repeating Characters</strong> 的模板解法如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>(<span class="number">256</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> begin=<span class="number">0</span>,end=<span class="number">0</span>,len_sub=<span class="number">0</span>,count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(end&lt;s.size())&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[<span class="keyword">int</span>(s[end])] &gt; <span class="number">0</span>) count++;</span><br><span class="line">        <span class="built_in">map</span>[<span class="keyword">int</span>(s[end])]++;</span><br><span class="line">        end++;</span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>) <span class="keyword">if</span>(<span class="built_in">map</span>[<span class="keyword">int</span>(s[begin])] &gt; <span class="number">1</span>) count;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="077-Combinations"><a href="#077-Combinations" class="headerlink" title="077. Combinations"></a>077. Combinations</h1><h2 id="Description-输出所有的组合"><a href="#Description-输出所有的组合" class="headerlink" title="Description: 输出所有的组合"></a>Description: 输出所有的组合</h2><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4, k = 2</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-回溯-1"><a href="#解法一-回溯-1" class="headerlink" title="解法一: 回溯"></a>解法一: 回溯</h2><p><strong>时间复杂度:</strong><br><strong>空间复杂度:</strong></p>
<p>标准的回溯(深度游戏遍历)解法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;out, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = out.size();</span><br><span class="line">        <span class="keyword">if</span>(count==k)&#123;</span><br><span class="line">            res.push_back(out);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=level; i&lt;n; i++)&#123;</span><br><span class="line">            out.push_back(i+<span class="number">1</span>);</span><br><span class="line">            dfs_helper(res, out, n, k, i+<span class="number">1</span>);</span><br><span class="line">            out.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">        dfs_helper(res, out, n, k, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代-2"><a href="#解法二-迭代-2" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p>TODO: 未看懂</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out(k, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            out[i]++;</span><br><span class="line">            <span class="keyword">if</span> (out[i] &gt; n) i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == k - <span class="number">1</span>) res.push_back(out);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">                out[i] = out[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="078-Subsets"><a href="#078-Subsets" class="headerlink" title="078. Subsets"></a>078. Subsets</h1><p>返回给定数字序列的子集, 序列中每个元素都不同(这是一个很重要的条件!!)</p>
<h2 id="Description-21"><a href="#Description-21" class="headerlink" title="Description"></a>Description</h2><p>Given a set of distinct integers, nums, return all possible subsets (the power set).</p>
<p>Note: The solution set must not contain duplicate subsets.</p>
<p>Example:</p>
<p>Input: nums = [1,2,3]<br>Output:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p>
<h2 id="解法一-迭代直接求出子集"><a href="#解法一-迭代直接求出子集" class="headerlink" title="解法一: 迭代直接求出子集"></a>解法一: 迭代直接求出子集</h2><p><strong>时间复杂度:</strong> $O(2^n)$ , 对于任意一个元素, 有包含和不包含两种情况<br><strong>空间复杂度:</strong> $O(2^n)$</p>
<p><strong>由于序列中的每个元素都不同</strong>, 因此, 对于任意一个元素, 只需要将其添加都前面序列所组成的子集的每一个子序列的末尾即可, 无需考虑是否包含重复元素的情况.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res &#123;vector&lt;int&gt;&#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(auto n : nums)&#123;</span><br><span class="line">            int len = res.size();</span><br><span class="line">            <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                vector&lt;int&gt; sub_item = res[i]; // c++中, =为复制赋值, move函数为移动赋值</span><br><span class="line">                sub_item.push_back(n);</span><br><span class="line">                res.push_back(sub_item);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-回溯-1"><a href="#解法二-回溯-1" class="headerlink" title="解法二: 回溯"></a>解法二: 回溯</h2><p><a href="https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning" target="_blank" rel="noopener">https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning</a>)<br>回溯法可以解决一系列相关问题, 先看Subsets的求解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sub_item;</span><br><span class="line">        back_track(res, sub_item, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back_track</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sub_item, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">        res.push_back(sub_item);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            sub_item.push_back(nums[i]);</span><br><span class="line">            back_track(res, sub_item, i+<span class="number">1</span>, nums);</span><br><span class="line">            sub_item.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>其他问题:</strong></p>
<p>Subsets II (contains duplicates) : <a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/subsets-ii/</a><br>悠悠  11:05:53<br>Permutations : <a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations/</a><br>悠悠  11:06:01<br>Permutations II (contains duplicates) : <a href="https://leetcode.com/problems/permutations-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations-ii/</a><br>悠悠  11:06:09<br>Combination Sum : <a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum/</a><br>悠悠  11:06:16<br>Combination Sum II (can’t reuse same element) : <a href="https://leetcode.com/problems/combination-sum-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum-ii/</a><br>悠悠  11:06:23<br>Palindrome Partitioning : <a href="https://leetcode.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-partitioning/</a></p>
<h2 id="解法三-bit控制"><a href="#解法三-bit控制" class="headerlink" title="解法三: bit控制"></a>解法三: bit控制</h2><p><strong>时间复杂度:</strong> $O(n\times 2^n)$ , 最慢的方法.<br><strong>空间复杂度:</strong> $O(2^n)$<br>因为对于任意一个数只有两种可能性, 出现在子序列中, 或者不出现在子序列中, 因此对于长度为 n 的(无相同元素的)序列来说, 共有 $2^n$ 个子序列, 我们先为这些子序列申请空间, 然后根据位操作(刚好有0,1两种情况)来决定对应位置上的字符出现还是不出现.</p>
<p>在实现时, 观察到, 第一个元素每隔两个子序列出现一次, 第二个元素每隔四个子序列出现两次, 第三个元素每隔八个子序列出现四次…</p>
<p>依次类推, 我们可以根据当前元素的位置来决定当前元素是否出现(间隔的前一半出现, 后一半不出现)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len_subsets = <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">2</span>,nums.size());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(len_subsets, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len_subsets; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;&gt;i &amp; <span class="number">1</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                    res[j].push_back(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="079-Word-Search"><a href="#079-Word-Search" class="headerlink" title="079. Word Search"></a>079. Word Search</h1><p>判断指定单词是否存在于字符矩阵中(可以通过上下左右邻接字符相连的才算是一个单词)</p>
<h2 id="Description-判断指定单词是否存在于字符矩阵中"><a href="#Description-判断指定单词是否存在于字符矩阵中" class="headerlink" title="Description: 判断指定单词是否存在于字符矩阵中"></a>Description: 判断指定单词是否存在于字符矩阵中</h2><p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>Example:</p>
<p>board =<br>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]</p>
<p>Given word = “ABCCED”, return true.<br>Given word = “SEE”, return true.<br>Given word = “ABCB”, return false.</p>
<h2 id="解法一-dfs-回溯"><a href="#解法一-dfs-回溯" class="headerlink" title="解法一: dfs+回溯"></a>解法一: dfs+回溯</h2><p><strong>时间复杂度:</strong> $O(mn 4^k)$, 暴力求解, $mn$ 为字符矩阵的宽和高, 也即 cell 数量, 对于 dfs 中的每个 cell, 有4个扩展方向, 一共需要扩展 $k$ 次($k$ 为单词的长度).<br><strong>空间复杂度:</strong> $O(mn)$ , 回溯时, 用<code>#</code>来记录已经遍历过的点, 无需申请额外空间来记录. 但是递归程序需要占用 $O(mn)$ 的空间复杂度.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size()==<span class="number">0</span> || board[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;board[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, word, <span class="number">0</span>, i, j)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">string</span> word, <span class="keyword">int</span> start, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> cur_c = board[x][y];</span><br><span class="line">        <span class="keyword">if</span>(cur_c != word[start]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(start == word.size()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        board[x][y]=<span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">bool</span> res=<span class="literal">false</span>, b_down=<span class="literal">false</span>, b_left=<span class="literal">false</span>, b_right=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">0</span>) res = dfs(board, word, start+<span class="number">1</span>, x<span class="number">-1</span>, y);</span><br><span class="line">        <span class="keyword">if</span>(!res &amp;&amp; x&lt;board.size()<span class="number">-1</span>) res = dfs(board, word, start+<span class="number">1</span>, x+<span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">if</span>(!res &amp;&amp; y&gt;<span class="number">0</span>) res = dfs(board, word, start+<span class="number">1</span>, x, y<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!res &amp;&amp; y&lt;board[<span class="number">0</span>].size()<span class="number">-1</span>) res = dfs(board, word, start+<span class="number">1</span>, x, y+<span class="number">1</span>);</span><br><span class="line">        board[x][y]=cur_c;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>另一种写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">string</span> &amp;word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[i][j] != word[pos]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos == word.size()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 注意是size-1</span></span><br><span class="line">        <span class="keyword">int</span> direct[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = board.size();</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">'#'</span>; <span class="comment">// 标记成已访问</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d : direct)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=i+d[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y=j+d[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt;m &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;n &amp;&amp; board[x][y]!=<span class="string">'#'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, word, x, y, pos+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = c; <span class="comment">// 退出前重置访问状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.empty() || board[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(word.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.size();</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, word, i, j, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="084-柱状图中最大的矩形-困难"><a href="#084-柱状图中最大的矩形-困难" class="headerlink" title="084. 柱状图中最大的矩形-困难"></a>084. 柱状图中最大的矩形-困难</h1><p>求最大面积的矩形</p>
<h2 id="Description-22"><a href="#Description-22" class="headerlink" title="Description"></a>Description</h2><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p>Example:<br>Input: [2,1,5,6,2,3]<br>Output: 10</p>
<p><img src="https://wx1.sinaimg.cn/large/d7b90c85ly1fx2pvbryaxj20if0l0js6.jpg" alt=""></p>
<h2 id="解法一-穷举-2"><a href="#解法一-穷举-2" class="headerlink" title="解法一: 穷举"></a>解法一: 穷举</h2><p><strong>时间复杂度:</strong> $O(n^2)$, 超时<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>列出以每一个i上的值为矩形高度的矩形面积, 然后取得最大值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;heights.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> low = i;</span><br><span class="line">            <span class="keyword">while</span>(low&gt;=<span class="number">0</span> &amp;&amp; heights[low] &gt;=heights[i]) low--;</span><br><span class="line">            low++;</span><br><span class="line">            <span class="keyword">int</span> high = i;</span><br><span class="line">            <span class="keyword">while</span>(high&lt;heights.size() &amp;&amp; heights[high] &gt;= heights[i]) high++;</span><br><span class="line">            high--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> cur_area = heights[i]* (high-low+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(max_area&lt;cur_area) max_area = cur_area;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-解法一的改进-空间换时间"><a href="#解法二-解法一的改进-空间换时间" class="headerlink" title="解法二: 解法一的改进-空间换时间"></a>解法二: 解法一的改进-空间换时间</h2><p><strong>时间复杂度:</strong> $O(n)$, 前面省略常数项(因为不好确定常数项的值)<br><strong>空间复杂度:</strong> $O(2n)$</p>
<p>从解法一中我们可以看出, 核心的要点就在于求取每一个i对应的矩形的左端和右端, 如下图所示:</p>
<p><img src="https://wx3.sinaimg.cn/large/d7b90c85ly1fx2qxg3740j20lf0j8t9r.jpg" alt=""></p>
<p>那么, 如果我们可以在 $O(1)$ 的时间内获取到左端和右端的值, 则时间复杂度就可以降低到 $O(n)$, 因此, 首先想到的是用数组将每个i对应的左端和右端的值保存起来. 于是, 我们需要先求取这两个数组(左端,右端)的值, <strong>在对左端和右端求值时, 我们要确保时间复杂度不能超过 $O(n)$</strong>, 因此, 我们不能每次都重新从i出发分别向左向右遍历(如解法一那样), 反之, 我们可以利用左端和右端中已经求好的值, 对于左端来说, 我们可以利用左端数组跳跃式的向左前进, 对于右端来说, 我们可以利用右端数组跳跃式的向右前进(这里不太好用语言描述, 具体请看程序代码).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> *left = <span class="keyword">new</span> <span class="keyword">int</span>[heights.size()];</span><br><span class="line">        <span class="keyword">int</span> *right = <span class="keyword">new</span> <span class="keyword">int</span>[heights.size()];</span><br><span class="line"></span><br><span class="line">        left[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;heights.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(p&gt;=<span class="number">0</span> &amp;&amp; heights[p] &gt;= heights[i])</span><br><span class="line">                p = left[p];</span><br><span class="line">            left[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        right[heights.size()<span class="number">-1</span>] = heights.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=heights.size()<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(p&lt;heights.size() &amp;&amp; heights[p] &gt;= heights[i])</span><br><span class="line">                p = right[p];</span><br><span class="line">            right[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;heights.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> low = left[i];</span><br><span class="line">            <span class="keyword">int</span> high = right[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> cur_area = heights[i]*(high-low<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(max_area&lt;cur_area) max_area = cur_area;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-最优-栈"><a href="#解法三-最优-栈" class="headerlink" title="解法三: 最优-栈"></a>解法三: 最优-栈</h2><p><strong>时间复杂度: $O(n)$</strong>, 无常数项<br><strong>空间复杂度: $O(n)$</strong>, 无常数项</p>
<p>上面的解法二, 虽然时间复杂度为 $O(n)$, 但实际上其时间复杂度是略微高于 $O(n)$, 因为在求取左端右端时, 每次跳跃的次数是大于等于1, 而不是仅为1次的.(只不过大O记法不考虑常数项). 而对于空间复杂度来说, 实际上是 $O(2n)$. 下面我们从另外一个角度出发: <strong>不再以当前i对应的高度为最低, 向左右两边探索, 改为以当前i对应的高度为最低, 仅仅向左边探索</strong>, 实现算法如下:</p>
<ul>
<li>首先, 构造一个空栈</li>
<li>从heights数组的第一个bar开始, 遍历所有的bar值(0~n-1), 并执行以下逻辑:<ul>
<li>如果当前栈为空, 或者当前数组bar值大于等于栈顶bar值, 则将bar值下标入栈</li>
<li>否则, 将栈顶出栈, 并以栈顶下标对应的bar值作为最低的高度, 求该高度对应的面积, 因为当前数组bar值小于栈顶下标对应的bar值, 因此可以将当前bar值下标作为right_index, 又因为栈顶bar值下标的前一个元素, 要么小于栈顶, 要么等于栈顶, 不论哪种情况, 都可以将其下标作为left_index(因为栈顶退出对, 次栈顶就会成为新的栈顶, 所以可以包括bar值相等的情况), 得到了高度, right_index, left_index, 即可计算当前栈顶对应的面积, 并与max_area判断, 更新max_area的值</li>
</ul>
</li>
<li>最后, 如果遍历完以后栈顶不为空(说明后面有几个连续的bar值相等, 或者bar只呈递增排序), 则依次强制弹出栈顶计算面积, 并更新max_area.</li>
</ul>
<p>复杂度分析: 由于入栈出栈的元素仅为heights数组元素, 可以栈的size就是heights数组的大小, 即空间复杂度为 $O(n)$, 时间复杂度从代码中可看出约为 $O(n)$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> height_index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;heights.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty() || heights[i] &gt;= heights[s.top()])</span><br><span class="line">                s.push(i++);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                height_index = s.top(); s.pop();</span><br><span class="line">                cur_area = heights[height_index] * ( s.empty()? i : i-s.top()<span class="number">-1</span> );  </span><br><span class="line">                <span class="comment">// 注意, 如果栈为空, 则说明当前i对应的bar值是前i个bar值中最小的, 所以宽为i, 否则宽为i-s.top()-1</span></span><br><span class="line">                <span class="keyword">if</span>(cur_area &gt; max_area) max_area = cur_area;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            height_index = s.top(); s.pop();</span><br><span class="line">            cur_area = heights[height_index] * ( s.empty()? i : i-s.top()<span class="number">-1</span> );  </span><br><span class="line">            <span class="comment">// 注意, 如果栈为空, 则说明当前i对应的bar值是前i个bar值中最小的, 所以宽为i, 否则宽为i-s.top()-1</span></span><br><span class="line">            <span class="keyword">if</span>(cur_area &gt; max_area) max_area = cur_area;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="085-最大矩形-困难-待完善"><a href="#085-最大矩形-困难-待完善" class="headerlink" title="085. 最大矩形-困难-待完善"></a>085. 最大矩形-困难-待完善</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximal-rectangle/</a></p>
<h2 id="解法一-动态规划"><a href="#解法一-动态规划" class="headerlink" title="解法一: 动态规划"></a>解法一: 动态规划</h2><p>时间复杂度: $O(mn)$<br>空间复杂度: $O(1)$</p>
<p>该思路来自于题目 “最大正方形”, 不同的地方在于, 横向和纵向分别可以形成高为 1 和宽为 1 的长条矩形, 这种情况也要考虑在内. 其余的和最大正方形相同, 使用右上角作为<code>dp</code>, 同时沿着对角线进行更新, 可以只使用常数量的空间复杂度.</p>
<p>更新: 该解法存在问题, 因为 dp 原本是有三种可能的, 但是每次只保留了当前最大面积的可能, 故而会漏解, 通过 OJ 是因为 OJ 的样例不全, 对于下面的例子就无法输出正确答案:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;],[&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;],[&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; m <span class="keyword">or</span> j &lt; n:</span><br><span class="line">            <span class="keyword">if</span> i &lt; m:</span><br><span class="line">                ii = i</span><br><span class="line">                jj = <span class="number">0</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> j &lt; n:</span><br><span class="line">                ii = <span class="number">0</span></span><br><span class="line">                jj = j</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            dp = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">            <span class="keyword">while</span> ii &lt; m <span class="keyword">and</span> jj &lt; n:</span><br><span class="line">                <span class="keyword">if</span> matrix[ii][jj] == <span class="string">'0'</span>:</span><br><span class="line">                    dp = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    w, h = dp</span><br><span class="line">                    kw, kh = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> (kw &lt;= w <span class="keyword">and</span> matrix[ii][jj-kw] == <span class="string">'1'</span>): <span class="comment"># 求宽</span></span><br><span class="line">                        kw += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> (kh &lt;= h <span class="keyword">and</span> matrix[ii-kh][jj] == <span class="string">'1'</span>): <span class="comment"># 求高</span></span><br><span class="line">                        kh += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    row = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> (row &lt;= ii <span class="keyword">and</span> matrix[ii-row][jj] == <span class="string">'1'</span>): <span class="comment"># 纵向的矩形</span></span><br><span class="line">                        row += <span class="number">1</span></span><br><span class="line">                    col = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> (col &lt;= jj <span class="keyword">and</span> matrix[ii][jj-col] == <span class="string">'1'</span>): <span class="comment"># 横向的矩形</span></span><br><span class="line">                        col += <span class="number">1</span></span><br><span class="line">                    index = max(zip([col, row, kw*kh], range(<span class="number">3</span>)))[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                    dp = [[col, <span class="number">1</span>], [<span class="number">1</span>, row], [kw, kh]][index]</span><br><span class="line">                    <span class="comment">#print(ii, jj, dp, kw, kh)</span></span><br><span class="line">                ii += <span class="number">1</span></span><br><span class="line">                jj += <span class="number">1</span></span><br><span class="line">                res = max(res, dp[<span class="number">0</span>]*dp[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="088-Merge-Sorted-Array"><a href="#088-Merge-Sorted-Array" class="headerlink" title="088. Merge Sorted Array"></a>088. Merge Sorted Array</h1><p>融合两个有序数组, 其中第一个数组的元素长度为n, 第二个为m, 题目假设第一个数组的空间为n+m.</p>
<h2 id="Description-23"><a href="#Description-23" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-后移-插入融合"><a href="#解法一-后移-插入融合" class="headerlink" title="解法一: 后移+插入融合"></a>解法一: 后移+插入融合</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =n+m<span class="number">-1</span>; i&gt;=n; i--)</span><br><span class="line">            nums1[i]=nums1[i-n];</span><br><span class="line">        <span class="comment">//for(int i =n; i&lt;n+m; i++) 注意, 这样写是有问题的, 例如对于 [1,2,3,4,0], 这种情况, 从前往后的复制方法会造成元素覆盖</span></span><br><span class="line">          <span class="comment">//  nums1[i]=nums1[i-n];</span></span><br><span class="line">        <span class="keyword">int</span> i =n, j=<span class="number">0</span>, k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n+m &amp;&amp; j&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                nums1[k] = nums1[i];</span><br><span class="line">                k++; i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[k] = nums2[j];</span><br><span class="line">                k++; j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n+m)</span><br><span class="line">            nums1[k++] = nums1[i++];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n)</span><br><span class="line">            nums1[k++] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="090-Subsets-II"><a href="#090-Subsets-II" class="headerlink" title="090. Subsets II"></a>090. Subsets II</h1><h2 id="Description-含重复元素的数组的子集"><a href="#Description-含重复元素的数组的子集" class="headerlink" title="Description: 含重复元素的数组的子集"></a>Description: 含重复元素的数组的子集</h2><p>Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).</p>
<p>Note: The solution set must not contain duplicate subsets.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-迭代-1"><a href="#解法一-迭代-1" class="headerlink" title="解法一: 迭代"></a>解法一: 迭代</h2><p><strong>时间复杂度:</strong> $O(2^n)$, 时间复杂度为子集的个数<br><strong>时间复杂度:</strong> $O(n)$, 空间复杂度为最长子集的长度</p>
<p>先排序, 然后对于一个元素, 如果这个元素与前一个元素相等, 那么在插入的时候, 就不能从第一个子集插入, 因为这样会重复, 因此要从不会造成重复的元素开始插入, 具体可看代码.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res &#123;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> pre_start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = (i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]) ? pre_start : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 从不会重复的元素开始 或者 从头开始</span></span><br><span class="line">            <span class="keyword">int</span> len = res.size();</span><br><span class="line">            <span class="keyword">for</span> ( ; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> sub_item = res[j];</span><br><span class="line">                sub_item.emplace_back(nums[i]);</span><br><span class="line">                res.emplace_back(sub_item);</span><br><span class="line">            &#125;</span><br><span class="line">            pre_start = len; <span class="comment">// 更新该值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-回溯-2"><a href="#解法二-回溯-2" class="headerlink" title="解法二: 回溯"></a>解法二: 回溯</h2><p><strong>时间复杂度:</strong> $O(2^n)$, 时间复杂度为子集的个数<br><strong>时间复杂度:</strong> $O(n)$, 空间复杂度为递归的深度</p>
<p>先排序, 然后同样, 如果遇到相等元素, 则跳过, 以避免重复</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sub_item;</span><br><span class="line">        back_trace(res, sub_item, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back_trace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; sub_item,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        res.push_back(sub_item);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; start <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            sub_item.emplace_back(nums[i]);</span><br><span class="line">            back_trace(res, sub_item, i+<span class="number">1</span>, nums);</span><br><span class="line">            sub_item.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="091-Decode-Ways"><a href="#091-Decode-Ways" class="headerlink" title="091. Decode Ways"></a>091. Decode Ways</h1><h2 id="Description-24"><a href="#Description-24" class="headerlink" title="Description"></a>Description</h2><p>A message containing letters from A-Z is being encoded to numbers using the following mapping:</p>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>Given a non-empty string containing only digits, determine the total number of ways to decode it.</p>
<p>Example 1:</p>
<p>Input: “12”<br>Output: 2<br>Explanation: It could be decoded as “AB” (1 2) or “L” (12).<br>Example 2:</p>
<p>Input: “226”<br>Output: 3<br>Explanation: It could be decoded as “BZ” (2 26), “VF” (22 6), or “BBF” (2 2 6).</p>
<h2 id="解法一-最优-DP-constant-space"><a href="#解法一-最优-DP-constant-space" class="headerlink" title="解法一(最优): DP constant space"></a>解法一(最优): DP constant space</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p><strong>存在问题:</strong> 下面的程序在面对测例:230001或230时, 输出的不是0. 但是仍然能通过OJ, <strong>但实际上下面的解法在面对上面的样例时会返回错误答案, 因为没有对 0 进行特殊处理</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span> || s.front()==<span class="string">"0"</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 注意, 不能用s.front() == "0"</span></span><br><span class="line">        <span class="keyword">int</span> f1=<span class="number">1</span>, f2=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'0'</span>) f1=<span class="number">0</span>; <span class="comment">//注意, 不能用s[i] == "0"</span></span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'1'</span> || (s[i<span class="number">-1</span>]==<span class="string">'2'</span> &amp;&amp; s[i]&lt;=<span class="string">'6'</span>))&#123;</span><br><span class="line">                f1 = f1+f2; <span class="comment">// 令f1为前i-1字符的可能组合+前i-2字符的可能组合</span></span><br><span class="line">                f2 = f1-f2; <span class="comment">// 令f2为前i-1字符的可能组合, 也就是对于下一个i来说的前i-2的可能组合</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                f2 = f1; <span class="comment">// 如果当前字符不能与前一个字符组合, 则当前字符f1不变, 而f2有变为下一个i的前i-2的可能组合, 即让新f2等于旧的f1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>修复了上述的问题, 现在遇到 0 时会进行额外的判断, 0 不能单独编码, 必须与前面的字符组合, 如果无法组合, 则应该返回0, 如 230001, 就应该返回 0, 代码如下:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || s[<span class="number">0</span>] == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//if(n==1) return 1;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'0'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] ==<span class="string">'2'</span> || s[i<span class="number">-1</span>] == <span class="string">'1'</span>) <span class="comment">// 0 不能单独编码, 必须与前面的数字组合, 因此这里是 dp[i-2]</span></span><br><span class="line">                    dp[i] = i&gt;<span class="number">1</span> ? dp[i<span class="number">-2</span>] : <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 如果 0 前面的值大于 2, 则无法组成编码, 应返回 0</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'1'</span> ||(s[i<span class="number">-1</span>]==<span class="string">'2'</span> &amp;&amp; s[i] &lt;= <span class="string">'6'</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> prev_two = i&gt;<span class="number">1</span> ? dp[i<span class="number">-2</span>] : <span class="number">1</span>;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + prev_two;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>上面的代码使用了 DP 数组, 空间复杂度为 $O(n)$, 实际上我们并不需要这么多空间, 只需要常数空间就可以完成数组, 即只需要当前 dp 值的前两个 dp 值即可. 代码如下:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || s[<span class="number">0</span>] == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//if(n==1) return 1;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> f1 = <span class="number">1</span>; <span class="comment">// 代表当前dp值之前一位的dp值</span></span><br><span class="line">        <span class="keyword">int</span> f2 = <span class="number">1</span>; <span class="comment">// 代表当前dp值之前两位的dp值</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'0'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] ==<span class="string">'2'</span> || s[i<span class="number">-1</span>] == <span class="string">'1'</span>)&#123; <span class="comment">// 0 不能单独编码, 必须与前面的数字组合, 因此这里是 dp[i-2]</span></span><br><span class="line">                    <span class="keyword">int</span> tmp = f1;</span><br><span class="line">                    f1 = f2; <span class="comment">// 令当前dp值为f2 (当前的dp值会成为下一个f1值)</span></span><br><span class="line">                    f2 = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 如果 0 前面的值大于 2, 则无法组成编码, 应返回 0</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'1'</span> ||(s[i<span class="number">-1</span>]==<span class="string">'2'</span> &amp;&amp; s[i] &lt;= <span class="string">'6'</span>))&#123;</span><br><span class="line">                f1 = f1 + f2;</span><br><span class="line">                f2 = f1 - f2;</span><br><span class="line">                <span class="comment">// 上面两个式子相当于:</span></span><br><span class="line">                <span class="comment">// int tmp = f1; f1 = f1+f2; f2 = tmp;</span></span><br><span class="line">                <span class="comment">//int prev_two = i&gt;1 ? dp[i-2] : 1;</span></span><br><span class="line">                <span class="comment">//dp[i] = dp[i-1] + prev_two;</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                f2 = f1; <span class="comment">// 当前dp值不变, 所以只需要更新 f2 即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>另一种写法, 更好理解:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty() || s[<span class="number">0</span>] == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp1 = <span class="number">1</span>; <span class="comment">// 记录当前字符前一位的可能组合数</span></span><br><span class="line">        <span class="keyword">int</span> dp2 = <span class="number">1</span>; <span class="comment">// 记录当前字符前两位的可能组合数</span></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>; <span class="comment">// 记录当前字符的可能组合数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i<span class="number">-1</span>] == <span class="string">'1'</span> <span class="keyword">or</span> s[i<span class="number">-1</span>] == <span class="string">'2'</span>) &#123; <span class="comment">// d</span></span><br><span class="line">                    res = dp2;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;d</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i<span class="number">-1</span>] == <span class="string">'1'</span></span><br><span class="line">                <span class="keyword">or</span> (s[i<span class="number">-1</span>] == <span class="string">'2'</span> <span class="keyword">and</span> s[i] &lt; <span class="string">'7'</span> <span class="keyword">and</span> s[i] &gt; <span class="string">'0'</span>)) &#123;</span><br><span class="line">                res = dp1 + dp2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = dp1;</span><br><span class="line">            &#125;</span><br><span class="line">            dp2 = dp1;</span><br><span class="line">            dp1 = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-递归"><a href="#解法二-递归" class="headerlink" title="解法二: 递归"></a>解法二: 递归</h2><p><strong>时间复杂度:</strong> $O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> recurve(<span class="number">0</span>,s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">recurve</span><span class="params">(<span class="keyword">int</span> pos, <span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos==s.size()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[pos]==<span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tmp_res = recurve(pos+<span class="number">1</span>, s);</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;s.size()<span class="number">-1</span> &amp;&amp; (s[pos]==<span class="string">'1'</span> || (s[pos]==<span class="string">'2'</span>&amp;&amp;s[pos+<span class="number">1</span>]&lt;=<span class="string">'6'</span>))) tmp_res += recurve(pos+<span class="number">2</span>, s);</span><br><span class="line">        <span class="keyword">return</span> tmp_res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="094-Binary-Tree-Inorder-Traversal"><a href="#094-Binary-Tree-Inorder-Traversal" class="headerlink" title="094. Binary Tree Inorder Traversal"></a>094. Binary Tree Inorder Traversal</h1><p>中序遍历二叉树</p>
<h2 id="Description-25"><a href="#Description-25" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure></p>
<p><strong>Follow up</strong>: Recursive solution is trivial, could you do it iteratively?</p>
<h2 id="解法一-递归-4"><a href="#解法一-递归-4" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>) inorder(root-&gt;left, res);</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>) inorder(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-非递归-2"><a href="#解法二-非递归-2" class="headerlink" title="解法二: 非递归"></a>解法二: 非递归</h2><p>标准的中序非递归遍历算法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s_tree;</span><br><span class="line">        <span class="keyword">while</span>(!s_tree.empty() || root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s_tree.push(root);</span><br><span class="line">                root= root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s_tree.empty())&#123;</span><br><span class="line">                root = s_tree.top(); s_tree.pop();</span><br><span class="line">                res.push_back(root-&gt;val);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="095-不同的二叉搜索树-II"><a href="#095-不同的二叉搜索树-II" class="headerlink" title="095. 不同的二叉搜索树 II"></a>095. 不同的二叉搜索树 II</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees-ii/</a></p>
<h2 id="解法一-递归-5"><a href="#解法一-递归-5" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p>思想与95题类似, 只不过此时我们需要将左右子树的可能情况都列举出来</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generate_trees</span><span class="params">(start, end)</span>:</span> <span class="comment"># 递归函数</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                <span class="keyword">return</span> [<span class="keyword">None</span>]</span><br><span class="line">            all_trees = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end+<span class="number">1</span>): <span class="comment"># 以每个节点作为根节点</span></span><br><span class="line">                left = generate_trees(start, i<span class="number">-1</span>) <span class="comment"># 获取所有可能的左子树</span></span><br><span class="line">                right = generate_trees(i+<span class="number">1</span>, end) <span class="comment"># 获取所有可能的右子树</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> left: <span class="comment"># 将左右子树逐个连接起来</span></span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> right:</span><br><span class="line">                        root = TreeNode(i)</span><br><span class="line">                        root.left = l</span><br><span class="line">                        root.right = r</span><br><span class="line">                        all_trees.append(root)</span><br><span class="line">            <span class="keyword">return</span> all_trees</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> generate_trees(<span class="number">1</span>, n) <span class="keyword">if</span> n <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure>
<h2 id="解法二-动态规划-1"><a href="#解法二-动态规划-1" class="headerlink" title="解法二: 动态规划"></a>解法二: 动态规划</h2><p>首先我们每次新增加的数字大于之前的所有数字, 所以新增加的数字出现的位置只可能是根节点或者是根节点的右孩子, 右孩子的右孩子, 右孩子的右孩子的右孩子等等, 总之一定是右边. 其次, 新数字所在位置原来的子树, 改为当前插入数字的左孩子即可, 因为插入数字是最大的.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">tree_copy</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            new_root = TreeNode(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.left: new_root.left = tree_copy(root.left)</span><br><span class="line">            <span class="keyword">if</span> root.right: new_root.right = tree_copy(root.right)</span><br><span class="line">            <span class="keyword">return</span> new_root</span><br><span class="line"></span><br><span class="line">        all_trees = [<span class="keyword">None</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            tmp_trees = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> all_trees:</span><br><span class="line">                <span class="comment"># 新插入的节点作为新的根</span></span><br><span class="line">                r1 = tree_copy(root)</span><br><span class="line">                new_root = TreeNode(i)</span><br><span class="line">                new_root.left = r1</span><br><span class="line">                tmp_trees.append(new_root)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n): <span class="comment"># 逐个找到可以插入新节点的节点</span></span><br><span class="line">                    j_root = tree_copy(root)</span><br><span class="line">                    jr_root = j_root</span><br><span class="line">                    k = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">if</span> jr_root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(j): <span class="comment">#</span></span><br><span class="line">                        pre = jr_root</span><br><span class="line">                        jr_root = jr_root.right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    new_node = TreeNode(i)</span><br><span class="line">                    pre.right = new_node</span><br><span class="line">                    new_node.left = jr_root</span><br><span class="line">                    tmp_trees.append(j_root)</span><br><span class="line">                    <span class="keyword">if</span> jr_root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            all_trees = tmp_trees</span><br><span class="line">        <span class="keyword">return</span> all_trees <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure>
<h1 id="096-不同的二叉搜索树"><a href="#096-不同的二叉搜索树" class="headerlink" title="096. 不同的二叉搜索树"></a>096. 不同的二叉搜索树</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees/</a></p>
<h2 id="解法一-递归-6"><a href="#解法一-递归-6" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p>模拟每个节点作为根节点时的状态, 将左子树的可能性与右子树的可能性相乘, 最后将所有节点的可能性相加</p>
<h2 id="解法二-动态规划-2"><a href="#解法二-动态规划-2" class="headerlink" title="解法二: 动态规划"></a>解法二: 动态规划</h2><p>思路和解法一一致, 将所有节点为根的情况一一计算并相加</p>
<p>时间复杂度 : 上述算法的主要计算开销在于包含 <code>dp[i]</code> 的语句. 因此, 时间复杂度为这些语句的执行次数, 也就是 $\sum_{i=2}^{n} i = \frac{(2+n)(n-1)}{2}$. 因此, 时间复杂度为 $O(N^2)$<br>空间复杂度 : 上述算法的空间复杂度主要是存储所有的中间结果, 因此为 $O(N)$</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i+<span class="number">1</span>):</span><br><span class="line">                dp[i] += dp[j<span class="number">-1</span>] * dp[i-j]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="解法三-卡特兰数"><a href="#解法三-卡特兰数" class="headerlink" title="解法三: 卡特兰数"></a>解法三: 卡特兰数</h2><p>根据解法二分析的递推公式, 完全符合卡特兰数的定义, 关于卡特兰数的介绍请看<a href="../面试-算法刷题-算法经典题型整理">算法经典题型整理</a></p>
<p>时间复杂度: $O(n)$<br>空间复杂度: $O(1)$</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            res *= (<span class="number">4</span>*i + <span class="number">2</span>) / (i+<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> int(res)</span><br></pre></td></tr></table></figure>
<h1 id="098-Validate-Binary-Search-Tree"><a href="#098-Validate-Binary-Search-Tree" class="headerlink" title="098. Validate Binary Search Tree"></a>098. Validate Binary Search Tree</h1><h2 id="Description-26"><a href="#Description-26" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>Example 1:</p>
<p>Input:<br>    2<br>   / \<br>  1   3<br>Output: true<br>Example 2:</p>
<pre><code>5
</code></pre><p>   / \<br>  1   4<br>     / \<br>    3   6<br>Output: false<br>Explanation: The input is: [5,1,4,null,null,3,6]. The root node’s value<br>             is 5 but its right child’s value is 4.</p>
<h2 id="解法一-递归-7"><a href="#解法一-递归-7" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p>用一个指针来指向当前节点在顺序上的前一个节点, 判断是否为BST</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* pre_node = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> isBST(root, pre_node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBST</span><span class="params">(TreeNode* root, TreeNode * &amp;pre_node)</span></span>&#123; <span class="comment">// 注意!!! 要维持递归时的pred_node, 因此必须使用 * &amp;, 否则每次的pre_node = root;实际上只是改变了pred_node的副本</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(isBST(root-&gt;left, pre_node) == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pre_node!=<span class="literal">nullptr</span> &amp;&amp; pre_node-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre_node = root;</span><br><span class="line">        <span class="keyword">if</span>(isBST(root-&gt;right, pre_node)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>下面的代码是典型错误解法:</strong> 因为, 我们不知只要考虑左子树节点值要小于当前节点值, 还要满足的另外一个条件是左子树本身也是一个二叉搜索树, 下面的代码没有进行该判断.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Input</span></span><br><span class="line"><span class="comment">[10,5,15,null,null,6,20]</span></span><br><span class="line"><span class="comment">Output</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">Expected</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> b=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            b = isValidBST(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="literal">false</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right-&gt;val &lt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            b = isValidBST(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代-中序"><a href="#解法二-迭代-中序" class="headerlink" title="解法二: 迭代(中序)"></a>解法二: 迭代(中序)</h2><p>中序遍历二叉搜索树时, 返回的是一个有序的数组, 因此, 我们可以在遍历时, 一旦发现不有序, 就返回 false, 需要注意一点的是, 本题中二叉搜索树中的节点值是唯一的.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">nullptr</span> || !s.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">                root = s.top(); s.pop();</span><br><span class="line">                <span class="keyword">if</span>(prev!=<span class="literal">nullptr</span> &amp;&amp; prev-&gt;val &gt;= root-&gt;val)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                prev = root;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a>101. Symmetric Tree</h1><p>判断一个二叉树是否为对称的.(与自身镜像相等)</p>
<h2 id="Description-27"><a href="#Description-27" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree [1,2,2,3,4,4,3] is symmetric:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure></p>
<p>But the following [1,2,2,null,3,null,3] is not:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>Bonus points if you could solve it both recursively and iteratively.</p>
<h2 id="解法一-递归-8"><a href="#解法一-递归-8" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(n)$ , 遍历了整个树中的每个节点一次<br><strong>空间复杂度:</strong> $O(n)$ , 调用递归的次数与树的高度有关, 在最差的情况下, 树的高度为n.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymHelper(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymHelper</span><span class="params">(TreeNode* subRoot1, TreeNode* subRoot2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subRoot1 == <span class="literal">nullptr</span> &amp;&amp; subRoot2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(subRoot1 == <span class="literal">nullptr</span> || subRoot2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(subRoot1-&gt;val != subRoot2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> b1 = isSymHelper(subRoot1-&gt;left, subRoot2-&gt;right);</span><br><span class="line">        <span class="keyword">bool</span> b2 = isSymHelper(subRoot1-&gt;right, subRoot2-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> b1&amp;&amp;b2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>更整洁的写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_sym</span><span class="params">(TreeNode* t1, TreeNode* t2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="literal">nullptr</span> &amp;&amp; t2==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="literal">nullptr</span> || t2==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1-&gt;val == t2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> is_sym(t1-&gt;left, t2-&gt;right) &amp;&amp; is_sym(t2-&gt;left, t1-&gt;right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> is_sym(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-迭代-3"><a href="#解法二-迭代-3" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p><strong>时间复杂度:</strong> $O(n)$ , 遍历了整个树中的每个节点一次<br><strong>空间复杂度:</strong> $O(n)$ , 层次遍历创建了两个队列, 其大小总和刚好为n. (有一种说法是: 层次遍历我们最多只会同时保存两层的节点数, 而最后一层的节点数最多为 $logn$, 所以空间复杂度实际上是 $O(logn)$ (常数项被约掉), 这种说法对吗??)</p>
<p>层次遍历, 注意不应该左子树和右子树做非空检查, 因此判断是否对称时, 需要包含节点为空的情况.(因为不需要知道当前的深度, 所以也不用维护深度信息)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q1;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q2;</span><br><span class="line">        q1.push(root-&gt;left);</span><br><span class="line">        q2.push(root-&gt;right);</span><br><span class="line">        TreeNode * cur1, * cur2;</span><br><span class="line">        <span class="keyword">while</span>(!q1.empty() &amp;&amp; !q2.empty())&#123;</span><br><span class="line">            cur1 = q1.front(); q1.pop();</span><br><span class="line">            cur2 = q2.front(); q2.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur1==<span class="literal">nullptr</span> &amp;&amp; cur2 ==<span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur1==<span class="literal">nullptr</span> || cur2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur1-&gt;val != cur2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            q1.push(cur1-&gt;left); q1.push(cur1-&gt;right);</span><br><span class="line">            q2.push(cur2-&gt;right); q2.push(cur2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-迭代"><a href="#解法三-迭代" class="headerlink" title="解法三: 迭代"></a>解法三: 迭代</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>只是用一个队列, 对每一层都进行回文检查<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode*&gt; queueTree;</span><br><span class="line">        queueTree.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!queueTree.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = queueTree.size();</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = queueTree.front();</span><br><span class="line">                queueTree.pop();</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    vec.push_back(<span class="number">0.5</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    vec.push_back(node-&gt;val);</span><br><span class="line">                    queueTree.push(node-&gt;left);</span><br><span class="line">                    queueTree.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> n = vec.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vec[i] != vec[n - i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a>102. Binary Tree Level Order Traversal</h1><p>按层次输出二叉树节点的值(每层的值要分开)</p>
<h2 id="Description-28"><a href="#Description-28" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-层次遍历"><a href="#解法一-层次遍历" class="headerlink" title="解法一: 层次遍历"></a>解法一: 层次遍历</h2><p><strong>时间复杂度:</strong> $O(n)$ , 每个节点遍历一次<br><strong>空间复杂度:</strong> $O(n)$ , 存储了n个节点的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode * cur_node;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; layer;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                cur_node = q.front(); q.pop();</span><br><span class="line">                layer.push_back(cur_node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;left != <span class="literal">nullptr</span>) q.push(cur_node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;right != <span class="literal">nullptr</span>) q.push(cur_node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(layer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal"></a>103. Binary Tree Zigzag Level Order Traversal</h1><p>按之字形打印二叉树</p>
<h2 id="Description-29"><a href="#Description-29" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its zigzag level order traversal as:<br>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p>
<h2 id="解法一：利用reverse"><a href="#解法一：利用reverse" class="headerlink" title="解法一：利用reverse"></a>解法一：利用reverse</h2><p>时间复杂度为 $O(n^2)$  空间复杂度为 $O(n)$</p>
<p>然后每次访问节点时, 都判断当前节点的层数, 如果为奇数层, 则将该层直接push back到结果向量中, 如果为偶数, 则将该层数据进行reverse后再push back到结果向量中. 通过while里面内置for循环, 来保证每次for循环都会将一整层的节点放进队列中, 无需额外的数组来存储depth信息<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(pRoot);</span><br><span class="line">        <span class="keyword">bool</span> even = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">//将vec声明在内部, 省去每次的clear操作, clear操作需要对vector进行遍历, 并将每个元素置为null？</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> size = que.size(); <span class="comment">//当前存的节点数目就是这一层所有的节点, 之前层的到已经被取出, 并且这一层的子节点还没有开始入队列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i)&#123; <span class="comment">//将该层所有节点的子节点入队列, 同时当到达该层最后一个节点时终止</span></span><br><span class="line">                TreeNode* tmp = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                vec.push_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                    que.push(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                    que.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(even) <span class="comment">//根据奇偶标识判断是否需要reverse</span></span><br><span class="line">                <span class="built_in">std</span>::reverse(vec.begin(), vec.end());</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            even = !even;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-最优-不用reverse"><a href="#解法二-最优-不用reverse" class="headerlink" title="解法二: 最优(不用reverse)"></a>解法二: 最优(不用reverse)</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>在解法二中, 复杂度高的原因是因每次遇到偶数层的时候都要进行 reverse, 实际上, 当我们知道了该层的节点个数以后, 我们可以直接开辟一个指定大小的 vector, 然后根据下标随机访问来填入该层的节点值, 这样一来就不用进行 reverse, 并且空间复杂度与解法二相同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">bool</span> is_odd = <span class="literal">true</span>;</span><br><span class="line">        TreeNode* cur_node;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> layer_len = q.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur_layer(layer_len);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;layer_len; i++)&#123;</span><br><span class="line">                cur_node = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span>(is_odd==<span class="literal">true</span>)</span><br><span class="line">                    cur_layer[i] = cur_node-&gt;val;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cur_layer[layer_len<span class="number">-1</span>-i ] = cur_node-&gt;val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;left!=<span class="literal">nullptr</span>) q.push(cur_node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;right!=<span class="literal">nullptr</span>) q.push(cur_node-&gt;right);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(cur_layer);</span><br><span class="line">            is_odd = !is_odd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-利用双端队列"><a href="#解法三-利用双端队列" class="headerlink" title="解法三: 利用双端队列"></a>解法三: 利用双端队列</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;TreeNode*&gt; dqTree;</span><br><span class="line">        dqTree.push_back(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!dqTree.empty()) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">int</span> len = dqTree.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmpRes;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (depth &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> node = dqTree.front();</span><br><span class="line">                    dqTree.pop_front();</span><br><span class="line">                    tmpRes.push_back(node-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) dqTree.push_back(node-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) dqTree.push_back(node-&gt;right);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">auto</span> node = dqTree.back();</span><br><span class="line">                    dqTree.pop_back();</span><br><span class="line">                    tmpRes.push_back(node-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) dqTree.push_front(node-&gt;right);</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) dqTree.push_front(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmpRes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a>104. Maximum Depth of Binary Tree</h1><p>求二叉树的最大深度(树的深度)</p>
<h2 id="Description-30"><a href="#Description-30" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p>Example:</p>
<p>Given binary tree [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p>
<p>return its depth = 3.</p>
<h2 id="解法一-层次遍历-1"><a href="#解法一-层次遍历-1" class="headerlink" title="解法一: 层次遍历"></a>解法一: 层次遍历</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        TreeNode* cur_node;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> layer_len = q.size();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;layer_len; i++)&#123;</span><br><span class="line">                cur_node = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;left!=<span class="literal">nullptr</span>) q.push(cur_node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;right!=<span class="literal">nullptr</span>) q.push(cur_node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-递归-1"><a href="#解法二-递归-1" class="headerlink" title="解法二: 递归"></a>解法二: 递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left_height = height(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right_height = height(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+max(left_height, right_height);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h1><h2 id="Description-根据先序和中序遍历构造二叉树"><a href="#Description-根据先序和中序遍历构造二叉树" class="headerlink" title="Description: 根据先序和中序遍历构造二叉树"></a>Description: 根据先序和中序遍历构造二叉树</h2><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong><br>You may assume that duplicates do not exist in the tree.(如果没有该条件则通常无法还原唯一的二叉树)</p>
<p>For example, given</p>
<p>preorder = [3,9,20,15,7]<br>inorder = [9,3,15,20,7]<br>Return the following binary tree:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-递归-9"><a href="#解法一-递归-9" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(n^2)$, 在中序遍历中查找根节点的复杂度为 $O(n)$, 先序序列中总共有 $n$ 个根节点, 所以需要查找 $n$ 次<br><strong>空间复杂度:</strong> 根据树的结构, 最坏情况下的递归深度为 $O(n)$.</p>
<p>先取先序遍历中的第一个节点为根节点, 然后在中序遍历冲查找该节点, 以该节点为界限将数组分成两边, 分别为左子树和右子树, 根据左子树和右子树的长度在先序遍历中也划分对应长度的两个数组, 然后将两个数组分别作为左子树的先序和中序, 以及右子树的先序和中序进行递归构建.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;preorder, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inorder, <span class="keyword">int</span> k, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">        <span class="comment">// tree        8 4 5 3 7 3</span></span><br><span class="line">        <span class="comment">// preorder    8 [4 3 3 7] [5]</span></span><br><span class="line">        <span class="comment">// inorder     [3 3 4 7] 8 [5]</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j || k &gt;= l)&#123;<span class="comment">// 注意, 这里的 j 和 l 均为超尾下标</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root_val = preorder[i];</span><br><span class="line">        <span class="keyword">auto</span> in_index = find(inorder.begin()+k, inorder.begin()+l, root_val);</span><br><span class="line">        <span class="keyword">int</span> dis = in_index - inorder.begin() - k;</span><br><span class="line"></span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line">        root-&gt;left = helper(preorder, i+<span class="number">1</span>, i+<span class="number">1</span>+dis, inorder, k, k+dis);</span><br><span class="line">        root-&gt;right = helper(preorder, i+<span class="number">1</span>+dis, j, inorder, k+dis+<span class="number">1</span>, l);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder, <span class="number">0</span>, preorder.size(), inorder, <span class="number">0</span>, inorder.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代-4"><a href="#解法二-迭代-4" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<ol>
<li>先将 <code>preorder[i]</code> 压入栈中, 如果当前 preorder 的元素与 inorder 中的元素不匹配, 则将 preorder 中的值构造成节点压入栈中, 并且新构造的节点一定是栈顶的左孩子. 重复该过程直到元素值匹配为止: <code>preorder[i] = inorder[index]</code></li>
<li>当先序和中序的值匹配时, 则将节点出栈, 直到不再匹配为止.</li>
<li>TODO: 该解法还没彻底搞清, 暂时搁置</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt;  s;</span><br><span class="line">        <span class="keyword">if</span>(preorder.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; preorder.size(); i++)&#123;</span><br><span class="line">            TreeNode* cur = s.top();</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val != inorder[index])&#123;</span><br><span class="line">                cur-&gt;left = <span class="keyword">new</span> TreeNode(preorder[i]);</span><br><span class="line">                s.push(cur-&gt;left);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top()-&gt;val == inorder[index])&#123;</span><br><span class="line">                    cur = s.top(); s.pop(); index++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(index &lt; inorder.size())&#123;</span><br><span class="line">                    cur-&gt;right = <span class="keyword">new</span> TreeNode(preorder[i]);</span><br><span class="line">                    s.push(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree"></a>108. Convert Sorted Array to Binary Search Tree</h1><p>根据 <strong>有序数组</strong> 构造平衡二叉搜索树(不唯一, 只要符合规则即可)</p>
<h2 id="Description-31"><a href="#Description-31" class="headerlink" title="Description"></a>Description</h2><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given the sorted array: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-递归构造"><a href="#解法一-递归构造" class="headerlink" title="解法一: 递归构造"></a>解法一: 递归构造</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$, 递归了n次(每个节点都被访问了一次)</p>
<p>由于题目给的条件是 <strong>有序数组</strong> , 因此大大降低了了构造难度, 可以每次将数组的中间位置作为根节点, 然后分别将两边的数组作为一个新的子数组进行构造, 无需考虑插入新节点引起的二叉搜索树不平衡的问题.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> construct_BST(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">construct_BST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low&gt;high) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root-&gt;left = construct_BST(nums, low, mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = construct_BST(nums, mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-迭代-5"><a href="#解法二-迭代-5" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p><strong>时间复杂度:</strong> $O(n)$, 只不过需要遍历两次树的size<br><strong>空间复杂度:</strong> $O(n)$, 层次遍历的队列和中根遍历的栈</p>
<p>先用层次遍历构造一个完全二叉树(以却确保树是平衡的), 然后在利用中根遍历对树中的每个元素进行赋值.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tree_len = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(tree_len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        q.push(root); tree_len--;</span><br><span class="line">        TreeNode* cur_node;</span><br><span class="line">        <span class="keyword">int</span> layer_len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(tree_len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            layer_len *= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;layer_len &amp;&amp; tree_len&gt;<span class="number">0</span>; i++)&#123;</span><br><span class="line">                cur_node = q.front(); q.pop();</span><br><span class="line">                TreeNode* left = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                cur_node-&gt;left = left;</span><br><span class="line">                q.push(cur_node-&gt;left); tree_len--;</span><br><span class="line">                <span class="keyword">if</span>(tree_len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    TreeNode *right = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                    cur_node-&gt;right = right;</span><br><span class="line">                    q.push(cur_node-&gt;right); tree_len--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        cur_node = root;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty() || cur_node!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur_node!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s.push(cur_node);</span><br><span class="line">                cur_node = cur_node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">                cur_node = s.top(); s.pop();</span><br><span class="line">                cur_node-&gt;val =nums[i++];</span><br><span class="line">                cur_node = cur_node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-迭代-只中根遍历一次"><a href="#解法三-迭代-只中根遍历一次" class="headerlink" title="解法三: 迭代(只中根遍历一次)"></a>解法三: 迭代(只中根遍历一次)</h2><p>【链接】Loading…<br><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/discuss/35218/Java-Iterative-Solution" target="_blank" rel="noopener">https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/discuss/35218/Java-Iterative-Solution</a></p>
<h1 id="111-minimum-depth-of-binary-tree"><a href="#111-minimum-depth-of-binary-tree" class="headerlink" title="111. minimum depth of binary tree"></a>111. minimum depth of binary tree</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一:"></a>解法一:</h2><p>层次优先遍历,遇到的首个叶子结点(左右子树为空)即为最短的深度</p>
<p>注意:</p>
<p>利用while内嵌for循环的方式, 可以省去对每个结点depth的维护, 只需要每次进入for循环之前, depth++即可(因为一个for循环会将当前层所有的结点都入队列, for循环结束后, 意味着进入了下一层, 所以depth++即可)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int run(TreeNode *root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q_node;</span><br><span class="line">        if(root==nullptr) return 0;</span><br><span class="line">        q_node.push(root);</span><br><span class="line">        int depth = 0;</span><br><span class="line">        while(!q_node.empty())&#123;</span><br><span class="line">            const int size = q_node.size();</span><br><span class="line">            depth++;</span><br><span class="line">            for(int i = 0; i&lt; size; i++)&#123;</span><br><span class="line">                TreeNode* node = q_node.front(); q_node.pop();</span><br><span class="line">                if(node-&gt;left!=nullptr) q_node.push(node-&gt;left);</span><br><span class="line">                if(node-&gt;right!=nullptr) q_node.push(node-&gt;right);</span><br><span class="line">                if(node-&gt;left==nullptr &amp;&amp; node-&gt;right == nullptr) return depth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-递归-2"><a href="#解法二-递归-2" class="headerlink" title="解法二(递归):"></a>解法二(递归):</h2><p>让当前结点为空, 则当前结点深度为0, 若当前结点左子树为空, 则当前结点深度等于左子树深度, 反之 ,等于右子树深度. 若当前结点左右子树均不为空, 则当前结点的 <strong>最小深度</strong> 等于左右子树深度 <strong>较小者</strong> 加1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root== <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> run(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right ==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> run(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> depth1=run(root-&gt;left);</span><br><span class="line">            <span class="keyword">int</span> depth2=run(root-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> depth1&lt;depth2 ? depth1+<span class="number">1</span> : depth2+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="114-二叉树展开为链表-中等"><a href="#114-二叉树展开为链表-中等" class="headerlink" title="114. 二叉树展开为链表-中等"></a>114. 二叉树展开为链表-中等</h1><p>给定一个二叉树，<strong>原地</strong> 将它展开为链表。<br>题目链接: <a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/</a></p>
<h2 id="解法一-先序遍历"><a href="#解法一-先序遍历" class="headerlink" title="解法一: 先序遍历"></a>解法一: 先序遍历</h2><p>先序遍历需要申请一个全局变量来维护最后访问的节点, 同时注意将右子树做一个备份, 因为在遍历左子树的时候, 有可能会改变根节点的右节点, 这样会导致访问错误的地址.</p>
<p><strong>该解法貌似存在一些问题, 下面的两种实现均不能通过 OJ</strong></p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root, last)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="keyword">None</span>: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> last != <span class="keyword">None</span>:</span><br><span class="line">                last.right = root</span><br><span class="line">                last.left = <span class="keyword">None</span></span><br><span class="line">            last = root</span><br><span class="line">            copy_right = root.right</span><br><span class="line">            helper(root.left, last)</span><br><span class="line">            helper(copy_right, last)</span><br><span class="line">        last = <span class="keyword">None</span></span><br><span class="line">        helper(root, last)</span><br></pre></td></tr></table></figure></p>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">TreeNode* last = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (last != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            last-&gt;right = root;</span><br><span class="line">            last-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last = root;</span><br><span class="line">        <span class="keyword">auto</span> right_copy = root-&gt;right;</span><br><span class="line">        flatten(root-&gt;left);</span><br><span class="line">        flatten(right_copy);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-后序遍历-递归"><a href="#解法二-后序遍历-递归" class="headerlink" title="解法二: 后序遍历, 递归"></a>解法二: 后序遍历, 递归</h2><p>依据二叉树展开为链表的特点, 使用后序遍历完成展开.<br><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="keyword">None</span>: <span class="keyword">return</span></span><br><span class="line">            helper(root.left)</span><br><span class="line">            helper(root.right)</span><br><span class="line">            <span class="keyword">if</span> root.left != <span class="keyword">None</span>: <span class="comment"># 后序遍历</span></span><br><span class="line">                pre = root.left <span class="comment"># 令 pre 指向左子树</span></span><br><span class="line">                <span class="keyword">while</span> pre.right: pre = pre.right <span class="comment"># 找到左子树中的最右节点</span></span><br><span class="line">                pre.right = root.right <span class="comment"># 令左子树中的最右节点的右子树 指向 根节点的右子树</span></span><br><span class="line">                root.right = root.left <span class="comment"># 令根节点的右子树指向根节点的左子树</span></span><br><span class="line">                root.left = <span class="keyword">None</span> <span class="comment"># 置空根节点的左子树</span></span><br><span class="line">            root = root.right <span class="comment"># 令当前节点指向下一个节点</span></span><br><span class="line">        helper(root)</span><br></pre></td></tr></table></figure></p>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">TreeNode* last = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        flatten(root-&gt;left);</span><br><span class="line">        flatten(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> pre = root-&gt;left;</span><br><span class="line">            <span class="keyword">while</span> (pre-&gt;right != <span class="literal">nullptr</span>) pre = pre-&gt;right;</span><br><span class="line">            pre-&gt;right = root-&gt;right;</span><br><span class="line">            root-&gt;right = root-&gt;left;</span><br><span class="line">            root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法三-非递归-不使用辅助空间及全局变量"><a href="#解法三-非递归-不使用辅助空间及全局变量" class="headerlink" title="解法三: 非递归, 不使用辅助空间及全局变量"></a>解法三: 非递归, 不使用辅助空间及全局变量</h2><p>前面的递归解法实际上也使用了额外的空间, 因为递归需要占用额外空间. 下面的解法无需申请栈, 也不用全局变量, 是真正的 In-Place 解法.</p>
<p><strong>C++ 解法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> most_right = root-&gt;left; <span class="comment">// 如果左子树不为空, 那么就先找到左子树的最右节点</span></span><br><span class="line">                <span class="keyword">while</span> (most_right-&gt;right != <span class="literal">nullptr</span>) most_right = most_right-&gt;right; <span class="comment">// 找最右节点</span></span><br><span class="line">                most_right-&gt;right = root-&gt;right; <span class="comment">// 然后将跟的右孩子放到最右节点的右子树上</span></span><br><span class="line">                root-&gt;right = root-&gt;left; <span class="comment">// 这时候跟的右孩子可以释放, 因此我令左孩子放到右孩子上</span></span><br><span class="line">                root-&gt;left = <span class="literal">nullptr</span>; <span class="comment">// 将左孩子置为空</span></span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;right; <span class="comment">// 继续下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>Python 解法:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">None</span>):</span><br><span class="line">            <span class="keyword">if</span> root.left != <span class="keyword">None</span>:</span><br><span class="line">                most_right = root.left</span><br><span class="line">                <span class="keyword">while</span> most_right.right != <span class="keyword">None</span>: most_right = most_right.right</span><br><span class="line">                most_right.right = root.right</span><br><span class="line">                root.right = root.left</span><br><span class="line">                root.left = <span class="keyword">None</span></span><br><span class="line">            root = root.right</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p>
<h1 id="116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="116. Populating Next Right Pointers in Each Node"></a>116. Populating Next Right Pointers in Each Node</h1><p>令每个节点中的 <code>next</code> 指针指向它的右兄弟, 如果没有右兄弟, 那么就置为 <code>nullptr</code>, <strong>注意, 题目给定的树是满二叉树</strong></p>
<h2 id="Description-32"><a href="#Description-32" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree</p>
<p>struct TreeLinkNode {<br>  TreeLinkNode <em> left;<br>  TreeLinkNode </em> right;<br>  TreeLinkNode * next;<br>}<br>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<p>Note:</p>
<p>You may only use constant extra space.<br>Recursive approach is fine, implicit stack space does not count as extra space for this problem.<br>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).<br>Example:</p>
<p>Given the following perfect binary tree,</p>
<pre><code> 1
</code></pre><p>   /  \<br>  2    3<br> / \  / \<br>4  5  6  7<br>After calling your function, the tree should look like:</p>
<pre><code> 1 -&gt; NULL
</code></pre><p>   /  \<br>  2 -&gt; 3 -&gt; NULL<br> / \  / \<br>4-&gt;5-&gt;6-&gt;7 -&gt; NULL</p>
<h2 id="解法一-层次遍历-2"><a href="#解法一-层次遍历-2" class="headerlink" title="解法一: 层次遍历"></a>解法一: 层次遍历</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>显而易见可以用层次遍历, 只需额外设置一个节点指针来维护当前节点的前一个节点(左兄弟节点).</p>
<p><strong>但是</strong>, 题目中要求只能使用常数空间, 因此该解法不是最优解.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; treeQ;</span><br><span class="line">        treeQ.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!treeQ.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = treeQ.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = treeQ.front();</span><br><span class="line">                treeQ.pop();</span><br><span class="line">                Node* nextNode;</span><br><span class="line">                <span class="keyword">if</span> ( i &lt; len <span class="number">-1</span>) &#123;</span><br><span class="line">                    nextNode = treeQ.front();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextNode = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node-&gt;next = nextNode;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    treeQ.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    treeQ.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-利用-next-指针的特性"><a href="#解法二-利用-next-指针的特性" class="headerlink" title="解法二: 利用 next 指针的特性"></a>解法二: 利用 <code>next</code> 指针的特性</h2><p><strong>时间复杂度:</strong> $O(n)$, 每个节点都要访问一次(仅访问一次)<br><strong>空间复杂度:</strong> $O(1)$</p>
<p><strong>由于是满二叉树</strong>, 因此我们可以轻易的利用<code>next</code>指针自身的特性来实现层次遍历.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        Node* curFirst = root;</span><br><span class="line">        <span class="keyword">while</span> (curFirst != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Node* curNode = curFirst;</span><br><span class="line">            <span class="keyword">while</span> (curNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curNode-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    curNode-&gt;left-&gt;next = curNode-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curNode-&gt;next != <span class="literal">nullptr</span> &amp;&amp; curNode-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    curNode-&gt;right-&gt;next = curNode-&gt;next-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                curNode = curNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            curFirst = curFirst-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118. Pascal’s Triangle"></a>118. Pascal’s Triangle</h1><p>Pascal 三角形</p>
<h2 id="Description-33"><a href="#Description-33" class="headerlink" title="Description"></a>Description</h2><p>Given a non-negative integer numRows, generate the first numRows of Pascal’s triangle.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-按照三角形的性质进行赋值"><a href="#解法一-按照三角形的性质进行赋值" class="headerlink" title="解法一: 按照三角形的性质进行赋值"></a>解法一: 按照三角形的性质进行赋值</h2><p>赋值时, 每一行的两端都是1, 无需重复赋值, 注意控制好边界条件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;numRows; i++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(i+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i; j++)&#123; <span class="comment">// 两边默认为1, 无需重复赋值</span></span><br><span class="line">                temp[j] = res[i<span class="number">-1</span>][j<span class="number">-1</span>]+res[i<span class="number">-1</span>][j];<span class="comment">// i和j的值只有在大于1时才会进入循环, 所以无需担心i-1或j-1&lt;0</span></span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="121-买卖股票的最佳时机-简单"><a href="#121-买卖股票的最佳时机-简单" class="headerlink" title="121. 买卖股票的最佳时机-简单"></a>121. 买卖股票的最佳时机-简单</h1><p>获取最大的股票利润<br>题目链接: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p>
<h2 id="Description-34"><a href="#Description-34" class="headerlink" title="Description"></a>Description</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Note that you cannot sell a stock before you buy one.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit = 0.</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-穷举-3"><a href="#解法一-穷举-3" class="headerlink" title="解法一: 穷举"></a>解法一: 穷举</h2><p>计算所有可能性, $O(n^2)$</p>
<h2 id="解法二-一次遍历-1"><a href="#解法二-一次遍历-1" class="headerlink" title="解法二: 一次遍历"></a>解法二: 一次遍历</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>维护两个变量 <code>min_price</code> 和 <code>max_profit</code>, 每次检查元素, 一方面如果当前价格更低, 则更改 <code>min_price</code> 变量, 另一方面如果当前利润超过 <code>max_profit</code>, 则更新之.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_price=prices[<span class="number">0</span>], max_profit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt;= min_price)&#123;</span><br><span class="line">                min_price = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]-min_price &gt; max_profit) max_profit = prices[i]-min_price;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>同样也是一次遍历, 下面的写法更加简洁, 我们这里记录一个变量 <code>buy</code>, 用来指示可能的买入下标, 之后, 如果下一个价格比 <code>buy</code> 对应的价格高, 我们就尝试更新最大利润, 否则, 就改变 <code>buy</code> 到当前的价格下标</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[buy] &lt; prices[i])&#123;</span><br><span class="line">                maxfit = max(maxfit, prices[i] - prices[buy]);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                buy = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>实际上, 我们只需要用一个变量记录迄今为止遇到的最小的股票值即可, 然后对于每一个新值, 我们都更新最高利润和最小值即可, 代码如下:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> low = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> p : prices) &#123;</span><br><span class="line">            res = <span class="built_in">std</span>::max(res, p - low);</span><br><span class="line">            low = <span class="built_in">std</span>::min(low, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法三-通用-DP-解法"><a href="#解法三-通用-DP-解法" class="headerlink" title="解法三: 通用 DP 解法"></a>解法三: 通用 DP 解法</h2><p>详细分析见后面的 “股票问题通用解法”</p>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">2</span>] = &#123;-prices[<span class="number">0</span>], <span class="number">0</span>&#125;; <span class="comment">// 持有, 不持有 base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> hold = <span class="built_in">std</span>::max(dp[<span class="number">0</span>], -prices[i]);</span><br><span class="line">            <span class="keyword">int</span> not_hold = <span class="built_in">std</span>::max(dp[<span class="number">1</span>], dp[<span class="number">0</span>] + prices[i]);</span><br><span class="line">            dp[<span class="number">0</span>] = hold; dp[<span class="number">1</span>] = not_hold;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) &lt;= <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [-prices[<span class="number">0</span>], <span class="number">0</span>] <span class="comment"># 持有, 不持有</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices[<span class="number">1</span>:]:</span><br><span class="line">            <span class="comment"># 持有: 要么之前买过, 要么第一次买入; 不持有: 要么维持之前不持有的状态, 要么今天买了</span></span><br><span class="line">            dp = [max(dp[<span class="number">0</span>], -price), max(dp[<span class="number">1</span>], dp[<span class="number">0</span>] + price)]</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure></p>
<h1 id="122-买卖股票的最佳时机-II-简单"><a href="#122-买卖股票的最佳时机-II-简单" class="headerlink" title="122. 买卖股票的最佳时机 II-简单"></a>122. 买卖股票的最佳时机 II-简单</h1><p>可以多次交易, 统计最大利润和<br>题目链接: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p>
<h2 id="Description-35"><a href="#Description-35" class="headerlink" title="Description"></a>Description</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>
<p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit = 0.</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-用变量维护最低价格"><a href="#解法一-用变量维护最低价格" class="headerlink" title="解法一: 用变量维护最低价格"></a>解法一: 用变量维护最低价格</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>寻找递增序列, 一旦出现递减的情况, 则说明应该及时卖出, 并将 <code>min_price</code> 重新赋值. 因为最后一个元素后面没有值来判断是否递减, 因此需要对最后一个元素进行单独判断<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size() ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min_price = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sum_profit = <span class="number">0</span>, pre_price=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; pre_price)&#123; <span class="comment">//如果小于之前的price, 则说明此时应该卖出</span></span><br><span class="line">                sum_profit += pre_price-min_price; <span class="comment">//计算卖出利润</span></span><br><span class="line">                min_price = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            pre_price = prices[i];</span><br><span class="line">            <span class="keyword">if</span>(i==prices.size()<span class="number">-1</span> &amp;&amp; prices[i] &gt; min_price) <span class="comment">//到了最后一个元素, 查看是否应该卖出</span></span><br><span class="line">                sum_profit += prices[i] - min_price;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>同样和上一道题一样, 利用 <code>buy</code> 可以更加整洁的实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[buy] &lt; prices[i])</span><br><span class="line">                max_profit += prices[i] - prices[buy];</span><br><span class="line">            buy = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-每两个相邻数字当做一次交易"><a href="#解法二-每两个相邻数字当做一次交易" class="headerlink" title="解法二: 每两个相邻数字当做一次交易"></a>解法二: 每两个相邻数字当做一次交易</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>实际上和解法一本质相同, 只不过在累加利润上有一点小区别.<br>该解法是将每两个相邻数字看做是一次交易, 如果后者大于前者, 说明应该执行交易, 并累加交易所的利润.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Cclass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum_profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span> ; i&lt;prices.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i<span class="number">-1</span>]) sum_profit += prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法三-通用-DP-解法-1"><a href="#解法三-通用-DP-解法-1" class="headerlink" title="解法三: 通用 DP 解法"></a>解法三: 通用 DP 解法</h2><p>详细分析见后面的 “股票问题通用解法”</p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) &lt;= <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [-prices[<span class="number">0</span>], <span class="number">0</span>] <span class="comment"># 持有, 不持有, base case</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices[<span class="number">1</span>:]:</span><br><span class="line">            <span class="comment"># 更新状态[max(维持持有; 之前不持有, 今天买入), max(维持不持有; 之前持有, 今天卖出)]</span></span><br><span class="line">            dp = [max(dp[<span class="number">0</span>], dp[<span class="number">1</span>]-price), max(dp[<span class="number">1</span>], dp[<span class="number">0</span>]+price)]</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure></p>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.size() &lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">2</span>] = &#123;-prices[<span class="number">0</span>], <span class="number">0</span>&#125;; <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> hold = <span class="built_in">std</span>::max(dp[<span class="number">0</span>], dp[<span class="number">1</span>]-prices[i]); <span class="comment">// update</span></span><br><span class="line">            <span class="keyword">int</span> not_hold = <span class="built_in">std</span>::max(dp[<span class="number">1</span>], dp[<span class="number">0</span>]+prices[i]);</span><br><span class="line">            dp[<span class="number">0</span>] = hold; dp[<span class="number">1</span>] = not_hold;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="123-买卖股票的最佳时机-III-困难"><a href="#123-买卖股票的最佳时机-III-困难" class="headerlink" title="123. 买卖股票的最佳时机 III-困难"></a>123. 买卖股票的最佳时机 III-困难</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/</a></p>
<h2 id="解法三-通用-DP-解法-2"><a href="#解法三-通用-DP-解法-2" class="headerlink" title="解法三: 通用 DP 解法"></a>解法三: 通用 DP 解法</h2><p>时间复杂度: $O(2n)$<br>空间复杂度: $O(2k)$, dp 数组的空间是否可以进一步压缩? 答案是不行的, 表面上看起来, dp[k] 只会用到 dp[k-1] 即相邻的状态, 但是实际上, 这里用到的是上一轮循环中的结果, 我们必须把这一轮训练的结果都存储下来, 才能进行到下一轮, 因此这里的空间复杂度不能优化了.</p>
<p>详细分析见后面的 “股票问题通用解法”</p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) &lt;= <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        k = <span class="number">2</span> <span class="comment"># k 代表最大的可交易次数, 该解法可以轻松扩展至 k 次的情况</span></span><br><span class="line">        dp = [<span class="keyword">None</span>] * (k+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = [<span class="number">0</span>, <span class="number">0</span>] <span class="comment"># 至多 0 次交易, 则均为0(不能持有)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>): <span class="comment"># base case, 至多 1 次交易时, dp 的状态</span></span><br><span class="line">            dp[i] = [-prices[<span class="number">0</span>], <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 至多进行 i 次交易, 以买入计算交易次数</span></span><br><span class="line">                <span class="comment"># 持有: 本次不买入(维持持有), 本次买入, 交易次数增加(之前不持有, 本次消费利润)</span></span><br><span class="line">                <span class="comment"># 不持有: 维持不持有, 或者之前持有, 本次卖出(只计入买入次数即可)</span></span><br><span class="line">                dp[i] = [max(dp[i][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]-price), max(dp[i][<span class="number">1</span>], dp[i][<span class="number">0</span>]+price)]</span><br><span class="line">        <span class="keyword">return</span> max(dp[k])</span><br></pre></td></tr></table></figure></p>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; dp(k+<span class="number">1</span>, &#123;-prices[<span class="number">0</span>], <span class="number">0</span>&#125;); <span class="comment">// base case: [hold, not_hold]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> hold = <span class="built_in">std</span>::max(dp[j].first, dp[j<span class="number">-1</span>].second-prices[i]); <span class="comment">// 买入计入交易次数</span></span><br><span class="line">                <span class="keyword">int</span> not_hold = <span class="built_in">std</span>::max(dp[j].second, dp[j].first+prices[i]); <span class="comment">// 卖出不计入次数</span></span><br><span class="line">                dp[j].first = hold; dp[j].second = not_hold;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(dp[k].first, dp[k].second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124. Binary Tree Maximum Path Sum"></a>124. Binary Tree Maximum Path Sum</h1><p>求二叉树中, 以任意节点为起始的路径和(这里是将二叉树看成无向图来计算路径的)的最大值, 例如对于下面的二叉树, 具有最大值的为:2-&gt;1-&gt;3 = 6<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br></pre></td></tr></table></figure></p>
<h2 id="Description-求最长路径加权和"><a href="#Description-求最长路径加权和" class="headerlink" title="Description: 求最长路径加权和"></a>Description: 求最长路径加权和</h2><p>Given a non-empty binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   3</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [-10,9,20,null,null,15,7]</span><br><span class="line">    -10</span><br><span class="line">    / \</span><br><span class="line">   9  20</span><br><span class="line">     /  \</span><br><span class="line">    15   7</span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-递归-10"><a href="#解法一-递归-10" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p>这道题的难点在于能否解读出题目的求值过程实际上是一个后序遍历的过程.</p>
<p>对于本题来说, 我们需要求得每个节点所在的路径的最大值, 以下面的例子来说:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  11 13</span><br><span class="line"> / \</span><br><span class="line">7   2</span><br></pre></td></tr></table></figure></p>
<p>我们需要求的最大和的路径为: 7-&gt;11-&gt;4-&gt;13. 而根据二叉树的遍历性质, 我们假设现在已经遍历到节点7, 此时, 左右子树均为空, 所以左右子树的最大和为0, 那么此时节点7所在的路径的最大和为: 左子树+右子树+当前节点值 = 7.  然后, 回溯到了节点11, 此时同理, 节点11所在的路径的最大和为: 左子树+右子树+当前节点值 = 11.(忽略节点2的遍历过程). 接下来对于节点4, 同理也应为: 左子树+右子树+当前节点值. 右子树返回的值很容易看出是13, 但是左子树应该返回多少呢? 由于我们希望求得当前的最大和, 因此, 左子树就应该返回它的最大和, 但是, 不能统计两条路径, 而应该选择以左节点为根节点的左右子树的较大者, 因此, 应该返回的是: max(左节点左子树, 左节点右子树)+左节点的值, 因此, 返回的是: 7+11 = 18. 于是, 节点4对应的最大和就为: 18+13+4. 可以看到, 这实际上就是一个后序遍历的过程.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=INT_MIN;</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* cur_node, <span class="keyword">int</span> &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur_node==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">std</span>::max(helper(cur_node-&gt;left, res), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">std</span>::max(helper(cur_node-&gt;right, res), <span class="number">0</span>);</span><br><span class="line">        res = <span class="built_in">std</span>::max(res, left+right+cur_node-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(left, right)+cur_node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代-6"><a href="#解法二-迭代-6" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p>后序遍历的迭代实现</p>
<h1 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125 Valid Palindrome"></a>125 Valid Palindrome</h1><p>判断是否为回文子串</p>
<h2 id="Description-36"><a href="#Description-36" class="headerlink" title="Description"></a>Description</h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p>Note: For the purpose of this problem, we define empty string as valid palindrome.</p>
<p>Example 1:</p>
<p>Input: “A man, a plan, a canal: Panama”<br>Output: true<br>Example 2:</p>
<p>Input: “race a car”<br>Output: false</p>
<h2 id="解法一-前后两个指示变量-向中间遍历判断"><a href="#解法一-前后两个指示变量-向中间遍历判断" class="headerlink" title="解法一: 前后两个指示变量, 向中间遍历判断"></a>解法一: 前后两个指示变量, 向中间遍历判断</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历一次<br><strong>空间复杂度:</strong> $O(1)$, 只额外用了两个变量</p>
<p>需要注意的是将大小写字母转换成同大写或者同小写的形式再进行判断</p>
<p><strong>写法一:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=s.size()<span class="number">-1</span>; i&lt;j; )&#123;</span><br><span class="line">            <span class="keyword">if</span>(is_alphanumeric(s[i]) == <span class="literal">false</span>)&#123;</span><br><span class="line">                i++; <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(is_alphanumeric(s[j]) == <span class="literal">false</span>)&#123;</span><br><span class="line">                j--; <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">std</span>::<span class="built_in">tolower</span>(s[i]) != <span class="built_in">std</span>::<span class="built_in">tolower</span>(s[j])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i++; j--;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_alphanumeric</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">'a'</span> &amp;&amp; c&lt;=<span class="string">'z'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">'A'</span> &amp;&amp; c&lt;=<span class="string">'Z'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>写法二</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=s.size()<span class="number">-1</span>; i&lt;=j;i++,j-- )&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;s.size() &amp;&amp; is_alphanumeric(s[i]) == <span class="literal">false</span>) i++;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; is_alphanumeric(s[j]) == <span class="literal">false</span>) j--;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">std</span>::<span class="built_in">tolower</span>(s[i]) != <span class="built_in">std</span>::<span class="built_in">tolower</span>(s[j])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_alphanumeric</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">'a'</span> &amp;&amp; c&lt;=<span class="string">'z'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">'A'</span> &amp;&amp; c&lt;=<span class="string">'Z'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="127-Word-Ladder"><a href="#127-Word-Ladder" class="headerlink" title="127. Word Ladder"></a>127. Word Ladder</h1><p>实际上是图的BFS(广度优先搜索)</p>
<h2 id="Description-37"><a href="#Description-37" class="headerlink" title="Description"></a>Description</h2><p>Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:</p>
<p>Only one letter can be changed at a time.<br>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.<br>Note:</p>
<p>Return 0 if there is no such transformation sequence.<br>All words have the same length.<br>All words contain only lowercase alphabetic characters.<br>You may assume no duplicates in the word list.<br>You may assume beginWord and endWord are non-empty and are not the same.<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">return its length 5.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-BFS"><a href="#解法一-BFS" class="headerlink" title="解法一: BFS"></a>解法一: BFS</h2><p><strong>时间复杂度:</strong> $O(nl)$, 其中, $l$ 为单词的长度, $n$ 是单词的数量, 因为广度优先遍历会对每个节点遍历一次, 而每个节点计算邻居时, 需要对 $l$ 个字母进行替换(替换26种, 常数级别), 另外, unordered_set 的 find 复杂度也为常数.<br><strong>空间复杂度:</strong> $O(n)$ 需要额外借助队列进行广度优先遍历, 另外还使用了 <code>unordered_set</code> 来存储单词表</p>
<p>我们可以将此题看做是图的广度优先搜索, 首先, 以 beginWord 为图的起始节点, 然后, 那些所有与 beginWord 只有一个字母不相同的单词都可以看做是 beginWord 的邻居节点, 依次类推, 直到找到一个单词, 与 endWord 相同为止, 此时, 返回当前 endWord 与 beginWord 的距离. (距离的记录方式和二叉树层次遍历时的方式差不多, 都是利用当前队列中的元素大小来控制<code>深度</code>的).</p>
<p>需要注意的地方有以下几点:</p>
<ul>
<li>这里的图和树不太一样, 这里图没有链表指针来指示, 因此, 在每次将某一个单词入队列以后, 都需要在单词列表中删除掉这个单词(或者额外设置标记也行), 以防止重复搜索</li>
<li>题目给的是没有重复单词的单词表, 因此推荐使用 set 结构来进行删除 (erase) 操作, vector 结构的删除 (erase) 操作的时间复杂度较高.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; word_dict;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : wordList)</span><br><span class="line">            word_dict.insert(word);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; to_visit;</span><br><span class="line">        <span class="comment">//word_dict.erase(beginWord); //beginWord本来就不在字典中</span></span><br><span class="line">        to_visit.push(beginWord);</span><br><span class="line">        <span class="keyword">int</span> dist = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!to_visit.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len = to_visit.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> word = to_visit.front(); to_visit.pop();</span><br><span class="line">                <span class="keyword">if</span>(word == endWord) <span class="keyword">return</span> dist;</span><br><span class="line">                add_next_word(word, word_dict, to_visit);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            dist++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_next_word</span><span class="params">(<span class="built_in">string</span> &amp;word, <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;word_dict, <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; &amp;to_visit)</span></span>&#123;</span><br><span class="line">       <span class="comment">// word_dict.erase(word);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;word.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> letter = word[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">26</span>; k++)&#123;</span><br><span class="line">                word[i] = <span class="string">'a'</span>+k;</span><br><span class="line">                <span class="keyword">if</span>(word_dict.find(word) != word_dict.end())&#123;</span><br><span class="line">                    to_visit.push(word);</span><br><span class="line">                    word_dict.erase(word);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            word[i] = letter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="128-Longest-Consecutive-Sequence"><a href="#128-Longest-Consecutive-Sequence" class="headerlink" title="128. Longest Consecutive Sequence"></a>128. Longest Consecutive Sequence</h1><p>返回无序数组中, 可以组成的最长的连续子串的长度</p>
<h2 id="Description-38"><a href="#Description-38" class="headerlink" title="Description"></a>Description</h2><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>Your algorithm should run in O(n) complexity.</p>
<p>Example:</p>
<p>Input: [100, 4, 200, 1, 3, 2]<br>Output: 4<br>Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</p>
<h2 id="解法一-排序"><a href="#解法一-排序" class="headerlink" title="解法一: 排序"></a>解法一: 排序</h2><p><strong>时间复杂度:</strong> $O(nlogn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>先排序, 然后在从头往后遍历, 并用一个变量维护当前的最长连续序列的长度.</p>
<h2 id="解法二-利用哈希表"><a href="#解法二-利用哈希表" class="headerlink" title="解法二: 利用哈希表"></a>解法二: 利用哈希表</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>利用 <code>unordered_set</code> 将所有的数字存储起来, 然后遍历每一个数字 <code>num</code>, 查看这个数字是否为所在连续序列的开头(即查看 <code>num-1</code> 是否存在). 若 <code>num</code> 就是所在连续序列的开头, 则查看当前序列的长度, 并更新最大长度. 故而时间复杂度为 $O(n+n) = O(n)$. 同时, 因为使用了 <code>unordered_set</code>, 所以空间复杂度为 $O(n)$.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; sets(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : sets)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sets.find(num<span class="number">-1</span>) == sets.end())&#123;</span><br><span class="line">                <span class="keyword">int</span> cur_len = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(sets.find(num+<span class="number">1</span>) !=sets.end())&#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    cur_len++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(longest &lt; cur_len) longest = cur_len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法三-另一种哈希表用法"><a href="#解法三-另一种哈希表用法" class="headerlink" title="解法三: 另一种哈希表用法"></a>解法三: 另一种哈希表用法</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>主题思想与解法二相同, 不过是从另一角度来使用 <code>unordered_map</code>, 首先, 依然利用 <code>unordered_map</code> 将 <code>nums</code> 存储起来, 然后遍历 <code>nums</code>, 对于 <code>nums</code> 中的每一个 <code>num</code>, 查看其是否存在于 <code>unordered_map</code> 中, 如果存在, 则分别向左向右查找当前数字 <code>num</code> 所在序列的最左端和最右端的数字, 同时, 将在 <code>unordered_map</code> 中遍历过的数字都移除(因为每个数字只可能唯一的属于一个连续序列). 之后, 利用最左端和最右端来更新最长连续序列的长度.  这样, 遍历的时间复杂度也为 $O(n+n) = O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; sets(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sets.find(num)!=sets.end())&#123;</span><br><span class="line">                sets.erase(num);</span><br><span class="line">                <span class="keyword">int</span> pre = num<span class="number">-1</span>, next = num+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(sets.find(pre)!=sets.end())</span><br><span class="line">                    sets.erase(pre--);</span><br><span class="line">                <span class="keyword">while</span>(sets.find(next)!=sets.end())</span><br><span class="line">                    sets.erase(next++);</span><br><span class="line">                <span class="keyword">if</span>(longest &lt; next-pre) longest = next-pre<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="130-Surrounded-Regions"><a href="#130-Surrounded-Regions" class="headerlink" title="130. Surrounded Regions"></a>130. Surrounded Regions</h1><p>类似于围棋, 将被包裹住(4连通)的字符 <code>O</code> 全部转换成字符 <code>X</code>.</p>
<h2 id="Descriptioin"><a href="#Descriptioin" class="headerlink" title="Descriptioin"></a>Descriptioin</h2><p>Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’.</p>
<p>A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.</p>
<p>Example:</p>
<p>X X X X<br>X O O X<br>X X O X<br>X O X X<br>After running your function, the board should be:</p>
<p>X X X X<br>X X X X<br>X X X X<br>X O X X<br>Explanation:</p>
<p>Surrounded regions shouldn’t be on the border, which means that any ‘O’ on the border of the board are not flipped to ‘X’. Any ‘O’ that is not on the border and it is not connected to an ‘O’ on the border will be flipped to ‘X’. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p>
<h2 id="解法一-递归-11"><a href="#解法一-递归-11" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(n)$, n 为 <code>board</code> 中的元素个数<br><strong>空间复杂度:</strong> $O(n)$, 递归深度优先遍历的递归次数最坏情况下为 n 次.</p>
<p>根据题目的要求, 我们可以从 <code>board</code> 的四个边界开始, 每遇到一次 <code>O</code> 就执行深度优先遍历, 将其相邻的所有 <code>O</code> 都变成另一个字符(如 <code>#</code>). 然后, 在顺序遍历整个 <code>board</code>, 将 <code>board</code> 中所有的 <code>O</code> 变成 <code>X</code>, 将所有的 <code>#</code> 变成 <code>O</code>, 即得解.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size()==<span class="number">0</span> || board[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; j&lt;board[i].size(); j++)  <span class="comment">//上边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) dfs_helper(i,j,board);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>, j=board[i].size()<span class="number">-1</span>; i&lt;board.size()<span class="number">-1</span>; i++)  <span class="comment">//右边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) dfs_helper(i,j,board);  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=board.size()<span class="number">-1</span>, j=<span class="number">0</span>; j&lt;board[i].size(); j++)  <span class="comment">//下边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) dfs_helper(i,j,board);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>, j=<span class="number">0</span>; i&lt;board.size()<span class="number">-1</span>; i++)  <span class="comment">//左边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) dfs_helper(i,j,board);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;board[i].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) board[i][j]=<span class="string">'X'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j]==<span class="string">'#'</span>) board[i][j]=<span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_helper</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board)</span></span>&#123;</span><br><span class="line">        board[i][j]=<span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; board[i<span class="number">-1</span>][j]==<span class="string">'O'</span>) dfs_helper(i<span class="number">-1</span>, j, board);        </span><br><span class="line">        <span class="keyword">if</span>(j&gt;<span class="number">0</span> &amp;&amp; board[i][j<span class="number">-1</span>]==<span class="string">'O'</span>) dfs_helper(i, j<span class="number">-1</span>, board);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;board.size()<span class="number">-1</span> &amp;&amp; board[i+<span class="number">1</span>][j]==<span class="string">'O'</span>) dfs_helper(i+<span class="number">1</span>, j, board);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;board[i].size()<span class="number">-1</span> &amp;&amp; board[i][j+<span class="number">1</span>]==<span class="string">'O'</span>) dfs_helper(i, j+<span class="number">1</span>, board); <span class="comment">//注意是 j&lt;board[i].size()-1, 不是 board.size()-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代-7"><a href="#解法二-迭代-7" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p><strong>时间复杂度:</strong> $O(n)$, n 为 <code>board</code> 中的元素个数<br><strong>空间复杂度:</strong> $O(n)$, 额外申请队列的大小为 n</p>
<p>思想和解法一相同, 不过采用 BFS 迭代实现, 利用一个队列来实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size()==<span class="number">0</span> || board[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; j&lt;board[i].size(); j++)  <span class="comment">//上边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) bfs_helper(i,j,board);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>, j=board[i].size()<span class="number">-1</span>; i&lt;board.size()<span class="number">-1</span>; i++)  <span class="comment">//右边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) bfs_helper(i,j,board);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=board.size()<span class="number">-1</span>, j=<span class="number">0</span>; j&lt;board[i].size(); j++)  <span class="comment">//下边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) bfs_helper(i,j,board);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>, j=<span class="number">0</span>; i&lt;board.size()<span class="number">-1</span>; i++)  <span class="comment">//左边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) bfs_helper(i,j,board);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;board[i].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) board[i][j]=<span class="string">'X'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j]==<span class="string">'#'</span>) board[i][j]=<span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs_helper</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board)</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; bfs_q;</span><br><span class="line">        <span class="keyword">int</span> len = board[i].size();</span><br><span class="line">        bfs_q.push(i*len +j);</span><br><span class="line">        board[i][j]=<span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">while</span>(!bfs_q.empty())&#123;</span><br><span class="line">            i = bfs_q.front()/len; j = bfs_q.front()%len; bfs_q.pop();           </span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; board[i<span class="number">-1</span>][j]==<span class="string">'O'</span>)&#123;  board[i<span class="number">-1</span>][j]=<span class="string">'#'</span>;bfs_q.push( (i<span class="number">-1</span>)*len+j); &#125;  <span class="comment">//注意这里一定要更改了字符以后再存入队列, 负责可能引起字符重复入队列, 最终内存超限</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;<span class="number">0</span> &amp;&amp; board[i][j<span class="number">-1</span>]==<span class="string">'O'</span>) &#123; board[i][j<span class="number">-1</span>]=<span class="string">'#'</span>; bfs_q.push( i*len+j<span class="number">-1</span>); &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;board.size()<span class="number">-1</span> &amp;&amp; board[i+<span class="number">1</span>][j]==<span class="string">'O'</span>) &#123;  board[i+<span class="number">1</span>][j]=<span class="string">'#'</span>; bfs_q.push( (i+<span class="number">1</span>)*len + j );&#125;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;board[i].size()<span class="number">-1</span> &amp;&amp; board[i][j+<span class="number">1</span>]==<span class="string">'O'</span>) &#123;  board[i][j+<span class="number">1</span>]=<span class="string">'#'</span>; bfs_q.push( i*len + j+<span class="number">1</span>); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="131-Palindrome-Partitioning"><a href="#131-Palindrome-Partitioning" class="headerlink" title="131. Palindrome Partitioning"></a>131. Palindrome Partitioning</h1><p>划分回文子串</p>
<h2 id="Description-39"><a href="#Description-39" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-回溯-验证回文子串"><a href="#解法一-回溯-验证回文子串" class="headerlink" title="解法一: 回溯+验证回文子串"></a>解法一: 回溯+验证回文子串</h2><p><strong>时间复杂度:</strong> $O(n\times 2^n)$, 其中, 可能的 partition 情况最多有 $2^n$ 种, 而对于每一种都要进行复杂度为 $O(n)$ 的回文子串检查<br><strong>空间复杂度:</strong> $O(n\times 2^n)$ ? 数组 <code>res</code> 的大小最坏情况下可达 $(n\times 2^n)$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; part_res;</span><br><span class="line">        dfs(s, <span class="number">0</span>, part_res, res);</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;part_res, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.size())&#123;</span><br><span class="line">            res.push_back(part_res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(is_palin(start, i, s))&#123;</span><br><span class="line">                part_res.push_back(s.substr(start, i-start+<span class="number">1</span>));</span><br><span class="line">                dfs(s, i+<span class="number">1</span>, part_res, res);</span><br><span class="line">                part_res.pop_back();</span><br><span class="line"></span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_palin</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[start]!=s[end]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            start++;end--;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-回溯-DP"><a href="#解法二-回溯-DP" class="headerlink" title="解法二: 回溯+DP"></a>解法二: 回溯+DP</h2><p><strong>时间复杂度:</strong> $O(2^n)$, 利用 DP 建立一个 $n\times n$ 的 bool 数组, 其中 <code>dp[i][j]</code> 代表字符串从第 i 个字符开始, 到第 j 个字符组成的子串是否为回文串. 因此, 检查回文串时无需执行 $O(n)$ 的检查.<br><strong>空间复杂度:</strong> $O(n\times 2^n + n^2)$, 需要额外的数组空间来实现 DP.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; part_res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(s.size(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(s.size(), <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;s.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=j; i++)&#123; <span class="comment">// 注意这两个for循环的顺序和控制条件, dp算法一定要保证在计算当前元素时, 之前的元素已经计算完成并且存入到了数组当中, 否则建立出的dp数组会出现漏解</span></span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j] &amp;&amp; (j-i&lt;=<span class="number">2</span> || dp[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="literal">true</span>))</span><br><span class="line">                    dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(s, <span class="number">0</span>, part_res, res, dp);</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;part_res, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;dp )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.size())&#123;</span><br><span class="line">            res.push_back(part_res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[start][i]==<span class="literal">true</span>)&#123;</span><br><span class="line">                part_res.push_back(s.substr(start, i-start+<span class="number">1</span>));</span><br><span class="line">                dfs(s, i+<span class="number">1</span>, part_res, res, dp);</span><br><span class="line">                part_res.pop_back();</span><br><span class="line"></span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_palin</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[start]!=s[end]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            start++;end--;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="134-Gas-Station"><a href="#134-Gas-Station" class="headerlink" title="134. Gas Station"></a>134. Gas Station</h1><p>加油站问题, 根据油量和消耗量判断是否能走完一圈</p>
<h2 id="Description-40"><a href="#Description-40" class="headerlink" title="Description"></a>Description</h2><p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p>You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p>
<p>Note:</p>
<p>If there exists a solution, it is guaranteed to be unique.<br>Both input arrays are non-empty and have the same length.<br>Each element in the input arrays is a non-negative integer.<br>Example 1:</p>
<p>Input:<br>gas  = [1,2,3,4,5]<br>cost = [3,4,5,1,2]</p>
<p>Output: 3</p>
<p>Explanation:<br>Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4<br>Travel to station 4. Your tank = 4 - 1 + 5 = 8<br>Travel to station 0. Your tank = 8 - 2 + 1 = 7<br>Travel to station 1. Your tank = 7 - 3 + 2 = 6<br>Travel to station 2. Your tank = 6 - 4 + 3 = 5<br>Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.<br>Therefore, return 3 as the starting index.<br>Example 2:</p>
<p>Input:<br>gas  = [2,3,4]<br>cost = [3,4,3]</p>
<p>Output: -1</p>
<p>Explanation:<br>You can’t start at station 0 or 1, as there is not enough gas to travel to the next station.<br>Let’s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4<br>Travel to station 0. Your tank = 4 - 3 + 2 = 3<br>Travel to station 1. Your tank = 3 - 3 + 3 = 3<br>You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.<br>Therefore, you can’t travel around the circuit once no matter where you start.</p>
<h2 id="解法-最优"><a href="#解法-最优" class="headerlink" title="解法: 最优"></a>解法: 最优</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>首先要知道, 如果总油量大于总消耗量, 那么就一定存在一个起始点, 使得可以走完全程. 因此, 设置两个变量 <code>total_left</code> 和 <code>cur_left</code>, 前者存储从0点开始的总的剩余量, 后者存储从起点 <code>start</code> 开始的剩余量. 当 <code>cur_left&lt;=0</code> 时, 说明从 <code>start</code> 开始一直到当前位置之间的任何一个加油站都不能够成为起点, 因此将 <code>start</code> 置为下一个位置, 重新开始, 并令 <code>cur_left=0</code>. 在遍历完所有加油站以后, 如果总的剩余量不小于0, 则此时 <code>start</code> 所指的位置就一定是解.(由题意知, 该解是唯一解).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total_left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_left =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;gas.size(); i++)&#123;</span><br><span class="line">            total_left += gas[i]-cost[i];</span><br><span class="line">            cur_left += gas[i]-cost[i];</span><br><span class="line">            <span class="keyword">if</span>(cur_left&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                start = i+<span class="number">1</span>;</span><br><span class="line">                cur_left=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total_left &lt; <span class="number">0</span> ? <span class="number">-1</span>:start;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136. Single Number"></a>136. Single Number</h1><p>数组中有一个数字出现了1次(奇数次), 其他均出现了2次(偶数次), 找到出现1次(奇数次)的数字.</p>
<h2 id="Description-41"><a href="#Description-41" class="headerlink" title="Description"></a>Description</h2><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</p>
<p>Note:</p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>Example 1:</p>
<p>Input: [2,2,1]<br>Output: 1<br>Example 2:</p>
<p>Input: [4,1,2,1,2]<br>Output: 4</p>
<h2 id="解法一-哈希"><a href="#解法一-哈希" class="headerlink" title="解法一: 哈希"></a>解法一: 哈希</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(n)$, 哈希表额外空间</p>
<p>遍历数组, 对于每一个数, 如果当前的数存在于hash表中, 则将表中哈希删除, 如果不存在, 则添加到哈希表中, 最终, 哈希表中存在的值就是只出现一次的值</p>
<h2 id="解法二-数学公式"><a href="#解法二-数学公式" class="headerlink" title="解法二: 数学公式"></a>解法二: 数学公式</h2><p><script type="math/tex">2\times (a + b + c) - (a+b+a+b+c) = c</script>.</p>
<p>将数组中的元素转换为 <code>set</code>(无重复元素), 然后利用上面的公式纠结<br><strong>时间复杂度:</strong> $O(n + n)=O(n)$, 转换为 <code>set</code> 需要 $O(n), 公式求解遍历也需要 $O(n)$<br><strong>空间复杂度:</strong> $O(n)$. <code>set</code> 所占额外空间</p>
<h2 id="解法三-异或"><a href="#解法三-异或" class="headerlink" title="解法三: 异或"></a>解法三: 异或</h2><p>任何数和0异或不变, 和自身异或变为0<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">            res ^= num;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>其他更多扩展问题可看剑指Offer<a href="../面试-算法刷题-剑指offer">第40题</a>.</strong></p>
<h1 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="138. Copy List with Random Pointer"></a>138. Copy List with Random Pointer</h1><p>复杂链表的复制, 复制带有随机指针的链表</p>
<h2 id="Description-42"><a href="#Description-42" class="headerlink" title="Description"></a>Description</h2><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
<h2 id="解法一-复制-拆分"><a href="#解法一-复制-拆分" class="headerlink" title="解法一: 复制+拆分"></a>解法一: 复制+拆分</h2><p><strong>时间复杂度:</strong> $O(n)$,  遍历三次链表<br><strong>空间复杂度:</strong> $O(1)$, 不包括复制链表占用的空间</p>
<p>先将每个节点复制到对应节点的后面, 然后给随机指针进行赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _next, Node* _random) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        random = _random;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node* node = head;</span><br><span class="line">        Node* copyNode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123; <span class="comment">// 复制节点</span></span><br><span class="line">            copyNode = <span class="keyword">new</span> Node(node-&gt;val, node-&gt;next, node-&gt;random);</span><br><span class="line">            node-&gt;next = copyNode;</span><br><span class="line">            node = node-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123; <span class="comment">// 设值 random 的值</span></span><br><span class="line">            copyNode = node-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;random != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                copyNode-&gt;random = node-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node = head;</span><br><span class="line">        Node* copyHead = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123; <span class="comment">// 拆分两个链表</span></span><br><span class="line">            copyNode = node-&gt;next;</span><br><span class="line">            node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (copyNode-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                copyNode-&gt;next = copyNode-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next; <span class="comment">// 不要忘了让 node 指向下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copyHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-一次遍历-2"><a href="#解法二-一次遍历-2" class="headerlink" title="解法二: 一次遍历"></a>解法二: 一次遍历</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(n)$, 需要申请链表长度的哈希表</p>
<p>利用一个哈希表来存储已经访问过的节点, 哈希表的键值为: <code>{cur_node, copy_node}</code>, 其中, <code>cur_node</code> 代表旧链表中的节点, <code>copy_node</code> 代表新链表中的节点. 顺序遍历旧链表, 对于旧链表中的每一个节点, 查看其 <code>next</code> 节点是否存在于哈希表 <code>visit</code> 中, 如果存在, 则将 <code>copy_node</code> 的 <code>next</code> 指针指向该节点(键)对应的复制节点(值). 对于 <code>random</code> 指针也是同理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        RandomListNode *cur_node = head;</span><br><span class="line">        RandomListNode *copy_node = <span class="keyword">new</span> RandomListNode(head-&gt;label);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;RandomListNode *, RandomListNode *&gt; visit;  <span class="comment">// key: old_node, value: copy_node</span></span><br><span class="line">        visit.insert(&#123;cur_node, copy_node&#125;); <span class="comment">//注意不要少了花括号</span></span><br><span class="line">        <span class="keyword">while</span>(cur_node!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line"></span><br><span class="line">            RandomListNode *next_node=<span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur_node-&gt;next==<span class="literal">nullptr</span>) copy_node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(visit.find(cur_node-&gt;next)==visit.end())&#123;</span><br><span class="line">                next_node = <span class="keyword">new</span> RandomListNode(cur_node-&gt;next-&gt;label);</span><br><span class="line">                copy_node-&gt;next = next_node;</span><br><span class="line">                visit.insert(&#123;cur_node-&gt;next, next_node&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                copy_node-&gt;next = visit[cur_node-&gt;next];</span><br><span class="line"></span><br><span class="line">            RandomListNode *random_node=<span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur_node-&gt;random==<span class="literal">nullptr</span>) copy_node-&gt;random = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(visit.find(cur_node-&gt;random) == visit.end())&#123;</span><br><span class="line">                random_node = <span class="keyword">new</span> RandomListNode(cur_node-&gt;random-&gt;label);</span><br><span class="line">                copy_node-&gt;random = random_node;</span><br><span class="line">                visit.insert(&#123;cur_node-&gt;random, random_node&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                copy_node-&gt;random = visit[cur_node-&gt;random];</span><br><span class="line"></span><br><span class="line">            cur_node = cur_node-&gt;next;</span><br><span class="line">            copy_node = copy_node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visit[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-递归"><a href="#解法三-递归" class="headerlink" title="解法三: 递归"></a>解法三: 递归</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$, 除了哈希表所占空间外, 递归还需额外空间, 但是可以近似看做是 $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;RandomListNode *, RandomListNode *&gt; visit;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(visit.find(head)!=visit.end())</span><br><span class="line">            <span class="keyword">return</span> visit[head];</span><br><span class="line">        RandomListNode *node = <span class="keyword">new</span> RandomListNode(head-&gt;label);</span><br><span class="line"></span><br><span class="line">        visit.insert(&#123;head, node&#125;);</span><br><span class="line">        node-&gt;next = copyRandomList(head-&gt;next);</span><br><span class="line">        node-&gt;random = copyRandomList(head-&gt;random);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="139-Word-Break"><a href="#139-Word-Break" class="headerlink" title="139. Word Break"></a>139. Word Break</h1><p>判断字符串是否可以划分成字典里面的单词</p>
<h2 id="Description-43"><a href="#Description-43" class="headerlink" title="Description"></a>Description</h2><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>Note:</p>
<p>The same word in the dictionary may be reused multiple times in the segmentation.<br>You may assume the dictionary does not contain duplicate words.<br>Example 1:</p>
<p>Input: s = “leetcode”, wordDict = [“leet”, “code”]<br>Output: true<br>Explanation: Return true because “leetcode” can be segmented as “leet code”.<br>Example 2:</p>
<p>Input: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>Output: true<br>Explanation: Return true because “applepenapple” can be segmented as “apple pen apple”.<br>             Note that you are allowed to reuse a dictionary word.<br>Example 3:</p>
<p>Input: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>Output: false</p>
<h2 id="解法一-回溯-2"><a href="#解法一-回溯-2" class="headerlink" title="解法一: 回溯"></a>解法一: 回溯</h2><p><strong>时间复杂度:</strong> 超时<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  纯回溯实现, 复杂度很高, 很容易超时</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; word_dict(wordDict.begin(), wordDict.end());</span><br><span class="line">        <span class="keyword">return</span> helper(s,<span class="number">-1</span>,word_dict);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> seg, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;word_dict)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(seg==s.size()<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">string</span> temp=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=seg+<span class="number">1</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            temp+=s[i];</span><br><span class="line">            <span class="keyword">if</span>(word_dict.find(temp) != word_dict.end() &amp;&amp; helper(s, i, word_dict)==<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-DP-1"><a href="#解法二-DP-1" class="headerlink" title="解法二: DP"></a>解法二: DP</h2><p><strong>时间复杂度:</strong> $O(n^2)$, $n$ 为字符串的长度<br><strong>空间复杂度:</strong> $O(n)$, dp 数组额外空间, unordered_set 额外空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; word_dict(wordDict.begin(), wordDict.end());</span><br><span class="line">        <span class="keyword">if</span>(wordDict.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(s.size(), <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j<span class="number">-1</span>&lt;<span class="number">0</span> || dp[j<span class="number">-1</span>]==<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="built_in">string</span> temp = s.substr(j, i-j+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(word_dict.find(temp) != word_dict.end())&#123;</span><br><span class="line">                        dp[i]=<span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// break to next i</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-DP-1"><a href="#解法三-DP-1" class="headerlink" title="解法三: DP"></a>解法三: DP</h2><p><strong>时间复杂度:</strong> $O(nm)$, $n$ 为字符串的长度, $m$ 为字典的 size<br><strong>空间复杂度:</strong> $O(n)$, dp 数组额外空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; word_dict(wordDict.begin(), wordDict.end());</span><br><span class="line">        <span class="keyword">if</span>(wordDict.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(s.size(), <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;wordDict.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=wordDict[j].size()<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> len = wordDict[j].size();</span><br><span class="line">                    <span class="built_in">string</span> temp= s.substr(i-len+<span class="number">1</span>, len);                    </span><br><span class="line">                    <span class="keyword">if</span>(temp == wordDict[j] &amp;&amp; ((i-len)&lt;<span class="number">0</span> || dp[i-len]==<span class="literal">true</span>))<span class="comment">// 这里注意, .size() 返回的类型并不是int, 如果使用i-wordDict[j].size() &lt;0, 就会造成runtime error, 正确做法是进行强制的类型转换, 或者用一个int变量代表之.</span></span><br><span class="line">                        dp[i]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>更简洁的写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(s.size(), <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; word : wordDict) &#123;</span><br><span class="line">                <span class="keyword">int</span> lenW = word.size();</span><br><span class="line">                <span class="keyword">if</span> (!dp[i] <span class="keyword">and</span> i+<span class="number">1</span> &gt;= lenW <span class="keyword">and</span> word == s.substr(i-lenW+<span class="number">1</span>, lenW)) &#123;</span><br><span class="line">                    dp[i] = (i-lenW+<span class="number">1</span> == <span class="number">0</span>) ? <span class="literal">true</span> : dp[i-lenW];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="140-Word-Break-II"><a href="#140-Word-Break-II" class="headerlink" title="140. Word Break II"></a>140. Word Break II</h1><h2 id="Description-44"><a href="#Description-44" class="headerlink" title="Description"></a>Description</h2><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.</p>
<p>Note:</p>
<p>The same word in the dictionary may be reused multiple times in the segmentation.<br>You may assume the dictionary does not contain duplicate words.<br>Example 1:</p>
<p>Input:<br>s = “catsanddog”<br>wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]<br>Output:<br>[<br>  “cats and dog”,<br>  “cat sand dog”<br>]<br>Example 2:</p>
<p>Input:<br>s = “pineapplepenapple”<br>wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br>Output:<br>[<br>  “pine apple pen apple”,<br>  “pineapple pen apple”,<br>  “pine applepen apple”<br>]<br>Explanation: Note that you are allowed to reuse a dictionary word.<br>Example 3:</p>
<p>Input:<br>s = “catsandog”<br>wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>Output:<br>[]</p>
<h2 id="解法一-DP-1"><a href="#解法一-DP-1" class="headerlink" title="解法一: DP"></a>解法一: DP</h2><p>直接使用回溯法, 有大量重复计算, 导致时间超时, 无法通过 OJ, 因此考虑 DP 思想. 将中间的计算结果缓存起来, 再次遇到的时候无需重复计算, 只需直接使用即可.<br>利用一个哈希表将每个字符串与该字符串能拆分出的句子联系起来, 其中, key 为字符串, value 为字符串拆分后的句子. 假设我们已经求出一个字符串的解为 <code>res</code>, 并将其存入到哈希表中, 此时, 如果在该字符串的前面再加上一个单词(单词表的中任意一个), 那么新的解就应该为: <code>word+&quot; &quot;+res[i]</code>. 代码实现如下.</p>
<p><strong>注意</strong>, 这里我们要对 wordDict 进行遍历来查找可以拆分的情况, 如果是对字符串 s 查找可拆分情况, 那么哈希表中的键将会大幅增加, 例如对于<code>&quot;aaaaaaaaaaa&quot;</code>这种情况.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; wordBreak(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; hash_dict;</span><br><span class="line">        <span class="keyword">return</span> DP_helper(s, wordDict, hash_dict);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; DP_helper(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;wordDict, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;hash_dict)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash_dict.find(s)!=hash_dict.end()) <span class="keyword">return</span> hash_dict[s];</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">""</span>) <span class="keyword">return</span> &#123;<span class="string">""</span>&#125;; <span class="comment">//这里必须返回具有一个元素("")的vector, 否则下面的push_back语句不会执行</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : wordDict)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.substr(<span class="number">0</span>, word.size()) != word) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res_word = DP_helper(s.substr(word.size()), wordDict, hash_dict); <span class="comment">//s.substr(word.size()) 代表截取剩余的字符, 所以有可能出现空字符的情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> str : res_word)&#123; <span class="comment">// 如果返回的是空的vector, 则不会执行该语句, 因此, 不能返回空vector, 当遇到空字符串时, 因该返回 &#123;""&#125;, 即只有一个元素的vector, 该元素为"".</span></span><br><span class="line">                res.push_back(word + (str==<span class="string">""</span>? <span class="string">""</span>:<span class="string">" "</span>) + str); <span class="comment">//这里根据 str的值来决定是否加空格, 如果str为空, 说明是word是最后一个字符, 则其后不应该添加空格</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hash_dict[s] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>内存超限的写法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; wordBreak(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; hash;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; word : wordDict) &#123;</span><br><span class="line">                <span class="keyword">int</span> lenW = word.size();</span><br><span class="line">                <span class="keyword">if</span> (i+<span class="number">1</span> &gt;= lenW <span class="keyword">and</span> s.substr(i-lenW+<span class="number">1</span>, lenW) == word) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i+<span class="number">1</span> == lenW) &#123;</span><br><span class="line">                        res.push_back(word);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">string</span> tmp_s = s.substr(<span class="number">0</span>, i-lenW+<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span> (hash.find(tmp_s) != hash.end()) &#123;</span><br><span class="line">                            <span class="keyword">auto</span> tmp_words = hash[tmp_s];</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">auto</span> str : tmp_words) &#123;</span><br><span class="line">                                res.push_back(str + <span class="string">" "</span> + word);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[s.substr(<span class="number">0</span>, i+<span class="number">1</span>)] = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hash.find(s) != hash.end()) <span class="keyword">return</span> hash[s];</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">""</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a>141. Linked List Cycle</h1><h2 id="Description-45"><a href="#Description-45" class="headerlink" title="Description"></a>Description</h2><p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<h2 id="解法一-Floyd-Cycle-Floyd-判圈算法"><a href="#解法一-Floyd-Cycle-Floyd-判圈算法" class="headerlink" title="解法一: Floyd Cycle(Floyd 判圈算法)"></a>解法一: Floyd Cycle(Floyd 判圈算法)</h2><p><strong>时间复杂度:</strong> $O(n+k)$, 可以认为是$O(n)$,  $n$ 为链表长度, $k$ 为环长<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>从头结点开始, slow每次走一步, fast每次走两步, 那么只要有环, slow和fast就一定会在环中的某个节点处相遇, 如果无环, 则fast一定先到达空指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> <span class="keyword">or</span> head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast <span class="keyword">and</span> fast!=<span class="literal">nullptr</span> <span class="keyword">and</span> fast-&gt;next != <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> slow == fast ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* slow=head, *fast=head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span> &amp;&amp; slow != fast)&#123;</span><br><span class="line">            slow= slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更多扩展见牛客第55题, 链表中环的入口节点</p>
<p><span id="142"></span></p>
<h1 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a>142. Linked List Cycle II</h1><h2 id="Description-求链表中环的开始节点"><a href="#Description-求链表中环的开始节点" class="headerlink" title="Description: 求链表中环的开始节点"></a>Description: 求链表中环的开始节点</h2><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>Note: Do not modify the linked list.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<h2 id="解法一-Floyd-的乌龟和兔子-Floyd-判环算法"><a href="#解法一-Floyd-的乌龟和兔子-Floyd-判环算法" class="headerlink" title="解法一: Floyd 的乌龟和兔子(Floyd 判环算法)"></a>解法一: Floyd 的乌龟和兔子(Floyd 判环算法)</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>此题更多解析可以看<a href="../面试-算法刷题-剑指offer/#55">剑指offer第55题</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>) <span class="keyword">return</span> fast;<span class="comment">// 不存在环</span></span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>) <span class="keyword">return</span> fast;<span class="comment">// 不存在环</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(slow!=fast);</span><br><span class="line"></span><br><span class="line">        fast = slow;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144. Binary Tree Preorder Traversal"></a>144. Binary Tree Preorder Traversal</h1><h2 id="Description-先根遍历"><a href="#Description-先根遍历" class="headerlink" title="Description: 先根遍历"></a>Description: 先根遍历</h2><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br></pre></td></tr></table></figure></p>
<p>Output: [1,2,3]<br>Follow up: Recursive solution is trivial, could you do it iteratively?</p>
<h2 id="解法一-递归-12"><a href="#解法一-递归-12" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        preorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        preorder(root-&gt;left, res);</span><br><span class="line">        preorder(root-&gt;right, res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代-8"><a href="#解法二-迭代-8" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() <span class="keyword">or</span> root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                res.push_back(root-&gt;val);</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h1><h2 id="Description-46"><a href="#Description-46" class="headerlink" title="Description"></a>Description</h2><p>题目链接: <a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p>
<p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br></pre></td></tr></table></figure></p>
<p>Output: [3,2,1]<br>Follow up: Recursive solution is trivial, could you do it iteratively?</p>
<h2 id="解法一-递归-13"><a href="#解法一-递归-13" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        postorder(root-&gt;left, res);</span><br><span class="line">        postorder(root-&gt;right, res);</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Python-实现-1"><a href="#Python-实现-1" class="headerlink" title="Python 实现"></a>Python 实现</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">post_order</span><span class="params">(root, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> (root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>): post_order(root.left, res)</span><br><span class="line">            <span class="keyword">if</span> (root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>): post_order(root.right, res)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span> res</span><br><span class="line">        post_order(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代-9"><a href="#解法二-迭代-9" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p>用一个变量 <code>pre</code> 来维护上一个输出的节点, 当上一个输出的节点是当前节点的右孩子的时候, 说明左右都遍历完了.</p>
<h3 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() <span class="keyword">or</span> root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!s.empty()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = s.top(); <span class="comment">// 注意这里要用 node,  因为要将有可能进入 else,  此时没有对 root 赋新值,  所以使用 root 的话会陷入死循环</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span> <span class="keyword">and</span> pre != node-&gt;right) &#123;</span><br><span class="line">                    root = node-&gt;right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.emplace_back(node-&gt;val);</span><br><span class="line">                    pre = node;</span><br><span class="line">                    s.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Python-实现-2"><a href="#Python-实现-2" class="headerlink" title="Python 实现"></a>Python 实现</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        pre = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span>(root <span class="keyword">or</span> stack): <span class="comment"># root 非空, 或者, 栈非空</span></span><br><span class="line">            <span class="keyword">while</span>(root): <span class="comment"># 左儿子一直入栈</span></span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            node = stack[<span class="number">-1</span>] <span class="comment"># 取栈尾, 注意此时不一定访问栈尾</span></span><br><span class="line">            <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> node.right == pre: <span class="comment"># 只有当右儿子为空或者右儿子已经被访问过时, 才能访问当前节点</span></span><br><span class="line">                res.append(node.val)</span><br><span class="line">                pre = stack.pop() <span class="comment"># 标记访问的节点, 以便进行右儿子的判断</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = node.right <span class="comment"># 继续循环入栈</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="146-LRU-Cache"><a href="#146-LRU-Cache" class="headerlink" title="146. LRU Cache"></a>146. LRU Cache</h1><p>实现一个 LRU 缓存器, 即 Least Recently Used (最近最少使用).</p>
<h2 id="Description-47"><a href="#Description-47" class="headerlink" title="Description"></a>Description</h2><p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</p>
<p>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p><strong>Follow up:</strong><br>Could you do both operations in O(1) time complexity?</p>
<p>Example:</p>
<p>LRUCache cache = new LRUCache( 2 ); // 2 is capacity</p>
<p>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // returns 1<br>cache.put(3, 3);    // evicts key 2<br>cache.get(2);       // returns -1 (not found)<br>cache.put(4, 4);    // evicts key 1<br>cache.get(1);       // returns -1 (not found)<br>cache.get(3);       // returns 3<br>cache.get(4);       // returns 4</p>
<h2 id="解法一-利用哈希表和双端链表"><a href="#解法一-利用哈希表和双端链表" class="headerlink" title="解法一: 利用哈希表和双端链表"></a>解法一: 利用哈希表和双端链表</h2><p><strong>时间复杂度:</strong> $O(n)$, <code>get</code>和<code>put</code>均为 $O(n)$</p>
<p><strong>空间复杂度:</strong>  $O(n)$, 哈希表和双端链表</p>
<p>利用哈希表(<code>unordered_map</code>)来存储键值对, 用于实现 $O(1)$ 复杂度的查找和返回特定键对应的值.<br>利用双端链表(<code>list</code>)来维护<code>LRU</code>逻辑, 即每次访问(<code>get</code>)时, 如果键存在, 那么在返回之前, 还应当将<code>list</code>中的键移到最顶端(最后), 首先, 顺序遍历找到该键($O(n)$复杂度), 然后将其删除($O(1)$复杂度), 接着, 将其插入到最后一位上($O(1)$复杂度). 对于插入(<code>put</code>)的情况, 首先判断是否已经存在($O(1)$复杂度), 如果已经存在, 那么将其<code>value</code>值更新并将其移动至最顶端($O(n)$复杂度). 否则, 判断当前是否溢出, 如果溢出, 则将<code>list</code>中的首部key值删除, 并将对应的hash键值对也删除($O(1)$复杂度), 然后执行插入逻辑($O(1)$复杂度). 如果没有溢出, 则直接插入.</p>
<h3 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> L_capacity;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; kv_map;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; key_l;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        L_capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(kv_map.find(key) != kv_map.end())&#123;<span class="comment">// 访问了key, 将其移到最顶端</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it=key_l.begin(); it!=key_l.end(); it++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(*it == key)&#123;</span><br><span class="line">                    key_l.erase(it);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            key_l.push_back(key); <span class="comment">// 访问了key, 将其移到最顶端</span></span><br><span class="line">            <span class="keyword">return</span> kv_map[key];</span><br><span class="line">        &#125;            </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(kv_map.find(key) != kv_map.end())&#123;<span class="comment">// 访问了key, 将其移到最顶端</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it=key_l.begin(); it!=key_l.end(); it++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(*it == key)&#123;</span><br><span class="line">                    key_l.erase(it);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            key_l.push_back(key);<span class="comment">// 访问了key, 将其移到最顶端</span></span><br><span class="line">            kv_map[key]=value; <span class="comment">//更新value值, 因为有可能同样的key对应的value不同</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key_l.size() == L_capacity)&#123;</span><br><span class="line">            <span class="keyword">int</span> evict_key = key_l.front(); key_l.pop_front(); <span class="comment">// 删除最少访问的key</span></span><br><span class="line">            kv_map.erase(evict_key); <span class="comment">// 删除最少访问的key</span></span><br><span class="line"></span><br><span class="line">            key_l.push_back(key);</span><br><span class="line">            kv_map.insert(&#123;key, value&#125;);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            key_l.push_back(key);</span><br><span class="line">            kv_map.insert(&#123;key, value&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="Python-实现-3"><a href="#Python-实现-3" class="headerlink" title="Python 实现:"></a>Python 实现:</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.cache = []</span><br><span class="line">        self.kv_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.kv_dict: <span class="comment"># get 时, 如果存在, 则先将 key 更新成最近访问, 然后返回对应value</span></span><br><span class="line">            self.cache.remove(key)</span><br><span class="line">            self.cache.insert(<span class="number">0</span>, key)</span><br><span class="line">            <span class="keyword">return</span> self.kv_dict[key]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.kv_dict: <span class="comment"># key 已存在, 此时容量不会爆, 只需更新最近访问值即可</span></span><br><span class="line">            self.kv_dict[key] = value</span><br><span class="line">            self.cache.remove(key)</span><br><span class="line">            self.cache.insert(<span class="number">0</span>, key)</span><br><span class="line">        <span class="keyword">elif</span> len(self.cache) &gt;= int(self.capacity): <span class="comment"># 容量要爆, 需要先删除最后的不常访问元素, 然后添加新元素</span></span><br><span class="line">            old_key = self.cache.pop()</span><br><span class="line">            <span class="keyword">del</span> self.kv_dict[old_key]</span><br><span class="line">            self.cache.insert(<span class="number">0</span>, key)</span><br><span class="line">            self.kv_dict[key] = value</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 容量不爆且原来没有, 则直接加入即可</span></span><br><span class="line">            self.cache.insert(<span class="number">0</span>, key)</span><br><span class="line">            self.kv_dict[key] = value</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure>
<h2 id="Follow-Up"><a href="#Follow-Up" class="headerlink" title="Follow Up"></a>Follow Up</h2><p><strong>时间复杂度:</strong> $O(1)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>上面的解法一的 $O(n)$ 复杂度主要是在查找满足键的迭代器上面, 而对于<code>list</code>来说, 有一个非常重要的性质, 那就是<code>list</code>的元素迭代器在<code>list</code>被修改后 <strong>仍然保持不变, 永远不会失效(永远删除该节点)</strong>, 因此, 我们可以做一个小小的改动, 就是让哈希表中存储的不再是<code>value</code>, 而是直接对应<code>list</code>中的迭代器, 这样, 就可以直接访问迭代器进行元素的移除操作.</p>
<h3 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++ 实现"></a>C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; linkList;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt; hash;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hash.find(key) != hash.end()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hash[key];</span><br><span class="line">            <span class="keyword">auto</span> keyValue = *it;</span><br><span class="line">            linkList.erase(it);</span><br><span class="line">            linkList.push_front(keyValue);</span><br><span class="line">            hash[key] = linkList.begin();</span><br><span class="line">            <span class="keyword">return</span> (*hash[key]).second;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (linkList.size() &lt; capacity) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.find(key) != hash.end()) &#123;</span><br><span class="line">                linkList.erase(hash[key]);</span><br><span class="line">            &#125;</span><br><span class="line">            linkList.push_front(<span class="built_in">std</span>::make_pair(key, value));</span><br><span class="line">            hash[key] = linkList.begin();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.find(key) != hash.end()) &#123; <span class="comment">// 如果已经存在, 则将其移动到list最前</span></span><br><span class="line">                linkList.erase(hash[key]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> keyValue = linkList.back();</span><br><span class="line">                hash.erase(keyValue.first);</span><br><span class="line">                linkList.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            linkList.push_front(<span class="built_in">std</span>::make_pair(key, value));</span><br><span class="line">            hash[key] = linkList.begin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="Python-实现-4"><a href="#Python-实现-4" class="headerlink" title="Python 实现"></a>Python 实现</h3><p>有两种方法, 一种是使用普通的字典和双端链表实现, 另一种是使用<code>OrderedDict</code></p>
<p>使用<code>OrderedDict</code></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.ordered_dict = collections.OrderedDict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.ordered_dict:</span><br><span class="line">            self.ordered_dict.move_to_end(key)</span><br><span class="line">            <span class="keyword">return</span> self.ordered_dict[key]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.ordered_dict[key] = value</span><br><span class="line">        self.ordered_dict.move_to_end(key)</span><br><span class="line">        <span class="keyword">if</span> len(self.ordered_dict) &gt; self.capacity:</span><br><span class="line">            self.ordered_dict.popitem(last=<span class="keyword">False</span>) <span class="comment"># False 弹出最不常用的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure>
<p>使用普通字典 + 双端链表</p>
<p>作者：liye-3<br>链接：<a href="https://leetcode-cn.com/problems/two-sum/solution/shu-ju-jie-gou-fen-xi-python-ha-xi-shuang-xiang-li/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/solution/shu-ju-jie-gou-fen-xi-python-ha-xi-shuang-xiang-li/</a></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key=None, value=None)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="keyword">None</span></span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.hashmap = &#123;&#125;</span><br><span class="line">        <span class="comment"># 新建两个节点 head 和 tail</span></span><br><span class="line">        self.head = ListNode()</span><br><span class="line">        self.tail = ListNode()</span><br><span class="line">        <span class="comment"># 初始化链表为 head &lt;-&gt; tail</span></span><br><span class="line">        self.head.next = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 因为get与put操作都可能需要将双向链表中的某个节点移到末尾, 所以定义一个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move_node_to_tail</span><span class="params">(self, key)</span>:</span></span><br><span class="line">            <span class="comment"># 先将哈希表key指向的节点拎出来, 为了简洁起名node</span></span><br><span class="line">            <span class="comment">#      hashmap[key]                               hashmap[key]</span></span><br><span class="line">            <span class="comment">#           |                                          |</span></span><br><span class="line">            <span class="comment">#           V              --&gt;                         V</span></span><br><span class="line">            <span class="comment"># prev &lt;-&gt; node &lt;-&gt; next         pre &lt;-&gt; next   ...   node</span></span><br><span class="line">            node = self.hashmap[key]</span><br><span class="line">            node.prev.next = node.next</span><br><span class="line">            node.next.prev = node.prev</span><br><span class="line">            <span class="comment"># 之后将node插入到尾节点前</span></span><br><span class="line">            <span class="comment">#                 hashmap[key]                 hashmap[key]</span></span><br><span class="line">            <span class="comment">#                      |                            |</span></span><br><span class="line">            <span class="comment">#                      V        --&gt;                 V</span></span><br><span class="line">            <span class="comment"># prev &lt;-&gt; tail  ...  node                prev &lt;-&gt; node &lt;-&gt; tail</span></span><br><span class="line">            node.prev = self.tail.prev</span><br><span class="line">            node.next = self.tail</span><br><span class="line">            self.tail.prev.next = node</span><br><span class="line">            self.tail.prev = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.hashmap:</span><br><span class="line">            <span class="comment"># 如果已经在链表中了久把它移到末尾（变成最新访问的）</span></span><br><span class="line">            self.move_node_to_tail(key)</span><br><span class="line">        res = self.hashmap.get(key, <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> res == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> res.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.hashmap:</span><br><span class="line">            <span class="comment"># 如果key本身已经在哈希表中了就不需要在链表中加入新的节点</span></span><br><span class="line">            <span class="comment"># 但是需要更新字典该值对应节点的value</span></span><br><span class="line">            self.hashmap[key].value = value</span><br><span class="line">            <span class="comment"># 之后将该节点移到末尾</span></span><br><span class="line">            self.move_node_to_tail(key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(self.hashmap) == self.capacity:</span><br><span class="line">                <span class="comment"># 去掉哈希表对应项</span></span><br><span class="line">                self.hashmap.pop(self.head.next.key)</span><br><span class="line">                <span class="comment"># 去掉最久没有被访问过的节点, 即头节点之后的节点</span></span><br><span class="line">                self.head.next = self.head.next.next</span><br><span class="line">                self.head.next.prev = self.head</span><br><span class="line">            <span class="comment"># 如果不在的话就插入到尾节点前</span></span><br><span class="line">            new = ListNode(key, value)</span><br><span class="line">            self.hashmap[key] = new</span><br><span class="line">            new.prev = self.tail.prev</span><br><span class="line">            new.next = self.tail</span><br><span class="line">            self.tail.prev.next = new</span><br><span class="line">            self.tail.prev = new</span><br></pre></td></tr></table></figure>
<h1 id="148-Sort-List"><a href="#148-Sort-List" class="headerlink" title="148. Sort List"></a>148. Sort List</h1><p>对链表进行排序, 要求时间复杂度为 $O(nlogn)$, 空间复杂度为常数</p>
<h2 id="Description-48"><a href="#Description-48" class="headerlink" title="Description"></a>Description</h2><p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-递归-自顶向下"><a href="#解法一-递归-自顶向下" class="headerlink" title="解法一: 递归 自顶向下"></a>解法一: 递归 自顶向下</h2><p><strong>时间复杂度:</strong> $O(nlogn)$<br><strong>空间复杂度:</strong> $O(logn)$</p>
<p>首先对于链表的排序最先想到的就是归并排序, 因为题目的要求是空间复杂度为常数, 因为不能使用递归实现(递归会占用额外空间), 但是, 递归是一种很好理解的排序方法, 因此, 这里我们先给链表归并排序的递归实现.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head; <span class="comment">//链表中至少应有两个元素, 否则不能进行融合, 会产生运行时错误</span></span><br><span class="line">        ListNode *slow=head, *fast=head, *pre=head; <span class="comment">// 两指针, 找到最中间的元素, 用slow指向</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span> &amp;&amp; fast-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 将前后两个链断开</span></span><br><span class="line">        ListNode* sort1 = sortList(head); <span class="comment">// 将前一半排序</span></span><br><span class="line">        ListNode* sort2 = sortList(slow); <span class="comment">// 将后一半排序</span></span><br><span class="line">        <span class="keyword">return</span> merge_sort(sort1, sort2); <span class="comment">// 融合两个有序链表</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge_sort</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;  </span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="literal">nullptr</span>) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2!=<span class="literal">nullptr</span>) cur-&gt;next = l2; <span class="comment">// 将最后的一个非空元素加入排序链表</span></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代-自底向上"><a href="#解法二-迭代-自底向上" class="headerlink" title="解法二: 迭代 自底向上"></a>解法二: 迭代 自底向上</h2><p><strong>时间复杂度:</strong> $O(nlogn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>先两两合并, 再四四合并, 逐渐向上, 直到完全合并. 注意这里之所以可以在 $O(1)$ 的空间复杂度内进行归并排序, 是因为采用了链表的底层结构, 使得 merge 操作可以在 $O(1)$ 的空间复杂度下进行. 但是对于一般的归并排序, 采用的是数组结构, 数组结构在进行 merge 时, 要么在 $O(n)$ 的空间复杂度下执行, 要么每次插入都需要移动其他元素, 增加时间复杂度.</p>
<p>接下来, 我们考虑如何实现归并排序的迭代算法, 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">splitList</span><span class="params">(ListNode* l1, <span class="keyword">int</span> blockSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (blockSize &gt; <span class="number">1</span> <span class="keyword">and</span> l1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            blockSize--;</span><br><span class="line">        &#125; <span class="comment">// 找到 l1 的尾部</span></span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* l2 = l1-&gt;next; <span class="comment">// l1 尾部的下一个就是 l2 的头部</span></span><br><span class="line">        l1-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// split l1 and l2</span></span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2, ListNode* dummy)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> <span class="keyword">and</span> l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = (l1 != <span class="literal">nullptr</span>) ? l1 : l2;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> cur; <span class="comment">// 该节点是下一段链表的 dummy 节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> blockSize = <span class="number">1</span>; blockSize &lt; length ; blockSize &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            ListNode* curDummy = dummy;</span><br><span class="line">            ListNode* curHead = dummy-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (curHead != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                ListNode* l1 = curHead;</span><br><span class="line">                ListNode* l2 = splitList(l1, blockSize);</span><br><span class="line">                curHead = splitList(l2, blockSize); <span class="comment">// 获取下一段链表的头节点, 并将l2的尾部置为nullptr</span></span><br><span class="line">                curDummy = mergeList(l1, l2, curDummy); <span class="comment">// 合并, 并获取当前段的最后一个非空节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="149-Max-Points-on-a-Line"><a href="#149-Max-Points-on-a-Line" class="headerlink" title="149. Max Points on a Line"></a>149. Max Points on a Line</h1><h2 id="Description-最大的共线点个数"><a href="#Description-最大的共线点个数" class="headerlink" title="Description 最大的共线点个数"></a>Description 最大的共线点个数</h2><p>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p>
<p>Example 1:</p>
<p>Input: [[1,1],[2,2],[3,3]]<br>Output: 3<br>Explanation:<br>^<br>|<br>|        o<br>|     o<br>|  o<br>+——————-&gt;<br>0  1  2  3  4<br>Example 2:</p>
<p>Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]<br>Output: 4<br>Explanation:<br>^<br>|<br>|  o<br>|     o        o<br>|        o<br>|  o        o<br>+—————————-&gt;<br>0  1  2  3  4  5  6</p>
<h2 id="解法一-哈希表"><a href="#解法一-哈希表" class="headerlink" title="解法一: 哈希表"></a>解法一: 哈希表</h2><p><strong>时间复杂度:</strong> $O(n^2)$, 求取任意两点间的斜率<br><strong>空间复杂度:</strong> $O(n)$, 哈希表, 存储斜率</p>
<p>由于要求共线点个数, 就必须获取任意两点间的斜率, 因此, 时间复杂度最少为 $O(n^2)$. 算法流程如下:</p>
<ul>
<li>对于每一个点来说, 构造一个哈希表, 表中的键为斜率, 表中的值为对应斜率的点的个数, 这里注意, 当我们求完第i个点与第j个点之间的斜率之后, 就不用再求第j个点与第i个点之间的斜率情况了(即令<code>int j = i+1</code>, 而不是<code>int j = 0</code>)</li>
<li>对于重点的情况, 需要单独设置一个变量来记录, 之后将该重复次数加入到该点所在的每条直线上(因为重点也算是共线)</li>
<li>对于斜率不存在的情况, 可以考虑利用<code>INT_MAX</code>来作为键值</li>
<li><strong>精度:</strong> 在求取斜率时, 会进行除法, 而在计算机内部, 除法在精度上始终会有一定误差, 会造成斜率相同的两对点在计算成浮点数以后斜率不同, 因此, 要 <strong>避免使用除法</strong>, 解决办法是利用 <strong>最大公约数</strong>, 求取<code>y2-y1</code>与<code>x2-x1</code>之间的最大公约数, 然后对进行约分, 用约分后的值作为键来存储, 就不会造成精度上的损失, 但是, 此时需要用<code>pair</code>作为键, 故不能用<code>unordered_map</code>(C++没有为pair类型提供对应的哈希函数), 而只能用<code>map</code>(键只有重载了<code>&lt;</code>和<code>&gt;</code>就可以使用<code>map</code>, 搜索的时间复杂度为 $O(logn)$), 另一种可选做法是利用<code>string</code>类型, 将两个<code>int</code>数值转换成<code>string</code>后再拼接, 此时就可以使用<code>unordered_map</code>了(搜索的时间复杂度为 $O(1)$, 但是<code>int</code>和<code>string</code>的类型转换也需要消耗时间).</li>
<li>当采用公约数以后, 因为没有了除法, 因此可以不用特殊处理斜率不存在的情况, 代码更加简洁.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">C<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a point.</span></span><br><span class="line"><span class="comment"> * struct Point &#123;</span></span><br><span class="line"><span class="comment"> *     int x;</span></span><br><span class="line"><span class="comment"> *     int y;</span></span><br><span class="line"><span class="comment"> *     Point() : x(0), y(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Point(int a, int b) : x(a), y(b) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt;&amp; points)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;points.size(); i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> duplicate = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; lines_hash; <span class="comment">//这里用map的原因是因为unordered_map的键的类型只能是基本类型, 不能是pair</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;points.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(points[i].x==points[j].x &amp;&amp; points[i].y==points[j].y)&#123;</span><br><span class="line">                    duplicate++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> a = points[j].y-points[i].y;</span><br><span class="line">                    <span class="keyword">int</span> b = points[j].x-points[i].x;</span><br><span class="line">                    <span class="keyword">int</span> d = gcd(a, b);</span><br><span class="line">                    lines_hash[&#123;a/d, b/d&#125;]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, duplicate); <span class="comment">// 如果points里面只有一个点, 则哈希表中不会有键值, 因此需要先处理只有一个点的情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> line : lines_hash)&#123;</span><br><span class="line">                res = max(res, duplicate+line.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="comment">// 求a与b的最大公约数</span></span><br><span class="line">        <span class="keyword">return</span> (b==<span class="number">0</span>) ? a : gcd(b, a%b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>用 string 做键, 使用哈希表而不是map:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a%b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; line_hash;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> duplicate = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (points[i].x == points[j].x <span class="keyword">and</span> points[i].y == points[j].y) &#123;</span><br><span class="line">                    duplicate++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> a = points[j].y - points[i].y;</span><br><span class="line">                <span class="keyword">int</span> b = points[j].x - points[i].x;</span><br><span class="line">                <span class="keyword">int</span> d = gcd(a, b);</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> slope = <span class="built_in">std</span>::to_string(a/d) + <span class="built_in">std</span>::to_string(b/d);</span><br><span class="line">                line_hash[slope]++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">std</span>::max(res, duplicate);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it : line_hash) &#123;</span><br><span class="line">                res = <span class="built_in">std</span>::max(res, duplicate + it.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="150-Evaluate-Reverse-Polish-Notation"><a href="#150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="150. Evaluate Reverse Polish Notation"></a>150. Evaluate Reverse Polish Notation</h1><p>计算逆波兰表达式</p>
<h2 id="Description-49"><a href="#Description-49" class="headerlink" title="Description"></a>Description</h2><p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p>
<p>Note:</p>
<p>Division between two integers should truncate toward zero.<br>The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation.<br>Example 1:</p>
<p>Input: [“2”, “1”, “+”, “3”, “<em>“]<br>Output: 9<br>Explanation: ((2 + 1) </em> 3) = 9<br>Example 2:</p>
<p>Input: [“4”, “13”, “5”, “/“, “+”]<br>Output: 6<br>Explanation: (4 + (13 / 5)) = 6<br>Example 3:</p>
<p>Input: [“10”, “6”, “9”, “3”, “+”, “-11”, “<em>“, “/“, “</em>“, “17”, “+”, “5”, “+”]<br>Output: 22<br>Explanation:<br>  ((10 <em> (6 / ((9 + 3) </em> -11))) + 17) + 5<br>= ((10 <em> (6 / (12 </em> -11))) + 17) + 5<br>= ((10 <em> (6 / -132)) + 17) + 5<br>= ((10 </em> 0) + 17) + 5<br>= (0 + 17) + 5<br>= 17 + 5<br>= 22</p>
<h2 id="解法一-栈-1"><a href="#解法一-栈-1" class="headerlink" title="解法一: 栈"></a>解法一: 栈</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(n)$, 需要一个额外的栈来存储中间结果</p>
<p>用栈来实现, 从到开始扫描字符串vector, 如果当前字符串不为运算符, 则直接入栈, 如果为运算符 , 则取栈顶两个元素进行运算然后将计算结果入栈. 最终, 栈中只剩一个结果值</p>
<p>需要注意的是: 首先要确保输入的逆波兰表达式是没有问题的, 其次还有要进行零除判断, 这几点本题没有考查, 但仍需注意</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;  polish;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> token : tokens)&#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,c;</span><br><span class="line">            <span class="keyword">if</span>(token.back()==<span class="string">'+'</span> || token.back()==<span class="string">'-'</span> || token.back()==<span class="string">'*'</span> || token.back()==<span class="string">'/'</span>)&#123; <span class="comment">// 用back的原因是数字有可能是 -13 这种形式</span></span><br><span class="line">                b = polish.top(); polish.pop();</span><br><span class="line">                a = polish.top(); polish.pop();</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">switch</span>(token.back())&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>: c=a+b; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>: c=a-b; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>: c=a*b; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'/'</span>: c= (b==<span class="number">0</span>) ? <span class="number">0</span> : a/b; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: c = c=<span class="built_in">std</span>::stoi(token);</span><br><span class="line">            &#125;</span><br><span class="line">            polish.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> polish.top();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-栈-异常"><a href="#解法二-栈-异常" class="headerlink" title="解法二: 栈+异常"></a>解法二: 栈+异常</h2><p>解法与上面相同, 不同借助了异常, 显得更加简洁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; rpn;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;tokens.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                rpn.push(stoi(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (exception e)&#123;</span><br><span class="line">                <span class="keyword">int</span> num1 = rpn.top(); rpn.pop();</span><br><span class="line">                <span class="keyword">int</span> num2 = rpn.top(); rpn.pop();</span><br><span class="line">                <span class="keyword">switch</span>(tokens[i][<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'+'</span>: rpn.push(num2+num1);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'-'</span>: rpn.push(num2-num1);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'*'</span>: rpn.push(num2*num1);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'/'</span>: rpn.push(num2/num1);<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rpn.size()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> rpn.top();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-栈-lambda"><a href="#解法三-栈-lambda" class="headerlink" title="解法三: 栈+lambda"></a>解法三: 栈+lambda</h2><p><strong>思路与解法一一直, 另一种写法:</strong> 借助哈希表和lambda表达式, 使程序更加整洁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; op_map=&#123;</span><br><span class="line">            &#123;<span class="string">"+"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a+b;&#125;&#125;, <span class="comment">//注意要用双引号, 因为token是stirng类型, 而不是char类型</span></span><br><span class="line">            &#123;<span class="string">"-"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a-b;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">"*"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a*b;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">"/"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> (b==<span class="number">0</span>) ? <span class="number">0</span> : a/b;&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;  polish;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> token : tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!op_map.count(token))</span><br><span class="line">                polish.push(<span class="built_in">std</span>::stoi(token));</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> b = polish.top(); polish.pop();</span><br><span class="line">                <span class="keyword">int</span> a = polish.top(); polish.pop();</span><br><span class="line">                polish.push(op_map[token](a, b));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> polish.top();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-栈-lambda-异常"><a href="#解法四-栈-lambda-异常" class="headerlink" title="解法四: 栈+lambda+异常"></a>解法四: 栈+lambda+异常</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span> &lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; op = &#123;</span><br><span class="line">            &#123;<span class="string">"+"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a+b;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">"-"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a-b;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">"*"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a*b;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">"/"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> b == <span class="number">0</span> ? <span class="number">0</span> : a/b;&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; polish;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; token : tokens) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                polish.push(<span class="built_in">std</span>::stoi(token));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (exception e) &#123;</span><br><span class="line">                <span class="keyword">int</span> b = polish.top(); polish.pop();</span><br><span class="line">                <span class="keyword">int</span> a = polish.top(); polish.pop();</span><br><span class="line">                polish.push(op[token](a, b));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> polish.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152. Maximum Product Subarray"></a>152. Maximum Product Subarray</h1><p>求连续子序列的最大乘积</p>
<h2 id="Description-50"><a href="#Description-50" class="headerlink" title="Description"></a>Description</h2><p>Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>Example 1:</p>
<p>Input: [2,3,-2,4]<br>Output: 6<br>Explanation: [2,3] has the largest product 6.<br>Example 2:</p>
<p>Input: [-2,0,-1]<br>Output: 0<br>Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</p>
<h2 id="解法一-递归-14"><a href="#解法一-递归-14" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历一次<br><strong>空间复杂度:</strong> $O(n)$, 递归 $n$ 次</p>
<p>这道题和连续子序列的最大和比较相似, 但是更难一些, 我们需要考虑负负得正这种情况, 因此, 我们不仅仅要维护最大值, 还要维护最小值. 考虑利用递归的方法来实现, 假设我们现在已经知道了以第 <code>i-1</code> 个数为结尾的连续子序列的最大乘积值<code>max</code>和最小乘积值<code>min</code>, 那么如果数组中新来一个数 <code>nums[i]</code>, 则以第 <code>i</code> 个数为结尾的连续子序列的最大乘积就一定是<code>max * nums[i]</code>, <code>min*nums[i]</code>, <code>nums[i]</code>之中的最大者, 最小值为这三者的最小者. 由于我们还不知道最终的连续子序列是以第几个字符为结尾的, 因此我们利用一个变量<code>res</code>来维护当前找到的最大的子序列乘积, 并且随着循环的进行不断更新这个值, 最终, <code>res</code>的值就是我们要求的解, 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">        helper(nums, nums.size()<span class="number">-1</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; helper(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> index, <span class="keyword">int</span> &amp;res)&#123; <span class="comment">//注意这里要设置一个引用res来不断更新最大值</span></span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>) <span class="keyword">return</span> make_pair(nums[<span class="number">0</span>], nums[<span class="number">0</span>]);</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; max_min = helper(nums, index<span class="number">-1</span>, res);</span><br><span class="line">        <span class="keyword">int</span> a = max_min.first * nums[index];</span><br><span class="line">        <span class="keyword">int</span> b = max_min.second * nums[index];</span><br><span class="line">        <span class="keyword">int</span> c = nums[index];</span><br><span class="line">        max_min.first = max(a, max(b,c));</span><br><span class="line">        max_min.second = min(a, min(b,c));</span><br><span class="line">        res = max(res, max_min.first);</span><br><span class="line">        <span class="keyword">return</span> max_min;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代实现"><a href="#解法二-迭代实现" class="headerlink" title="解法二 迭代实现"></a>解法二 迭代实现</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>思路和解法一相同, 只不过换成了迭代实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_neg = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max_pos = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">int</span> a = num * max_neg;</span><br><span class="line">            <span class="keyword">int</span> b = num * max_pos;</span><br><span class="line">            max_neg = <span class="built_in">std</span>::min(num, <span class="built_in">std</span>::min(a, b));</span><br><span class="line">            max_pos = <span class="built_in">std</span>::max(num, <span class="built_in">std</span>::max(a, b));</span><br><span class="line">            <span class="keyword">if</span> (max_pos &gt; res) res = max_pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法三-DP-迭代"><a href="#解法三-DP-迭代" class="headerlink" title="解法三: DP 迭代"></a>解法三: DP 迭代</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$, 该解法需要额外数组, 实际上这是不必要的, 详细可看解法二</p>
<p>上面的递归写法, 可以转换成DP迭代, 为此需要两个dp数组, 一个用来保存以第i个元素为结尾的连续子序列的最大值, 另一个保存最小值. 代码如下:</p>
<p><strong>写法一: new数组</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> *dp_max = <span class="keyword">new</span> <span class="keyword">int</span>[nums.size()]();</span><br><span class="line">        <span class="keyword">int</span> *dp_min = <span class="keyword">new</span> <span class="keyword">int</span>[nums.size()]();</span><br><span class="line">        dp_max[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp_min[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = dp_max[i<span class="number">-1</span>]*nums[i];</span><br><span class="line">            <span class="keyword">int</span> b = dp_min[i<span class="number">-1</span>]*nums[i];</span><br><span class="line">            <span class="keyword">int</span> c = nums[i];</span><br><span class="line">            dp_max[i] = max(a, max(b,c));</span><br><span class="line">            dp_min[i] = min(a, min(b,c));</span><br><span class="line">            res = max(res, dp_max[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] dp_max;</span><br><span class="line">        <span class="keyword">delete</span>[] dp_min;</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>写法二: vector数组:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CCclass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp_max(nums.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp_min(nums.size(), <span class="number">0</span>);</span><br><span class="line">        dp_max[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp_min[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = dp_max[i<span class="number">-1</span>]*nums[i];</span><br><span class="line">            <span class="keyword">int</span> b = dp_min[i<span class="number">-1</span>]*nums[i];</span><br><span class="line">            <span class="keyword">int</span> c = nums[i];</span><br><span class="line">            dp_max[i] = max(a, max(b,c));</span><br><span class="line">            dp_min[i] = min(a, min(b,c));</span><br><span class="line">            res = max(res, dp_max[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155. Min Stack"></a>155. Min Stack</h1><p>获取栈中最小的元素</p>
<h2 id="Description-51"><a href="#Description-51" class="headerlink" title="Description"></a>Description</h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<p>push(x) — Push element x onto stack.<br>pop() — Removes the element on top of the stack.<br>top() — Get the top element.<br>getMin() — Retrieve the minimum element in the stack.<br>Example:<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   —&gt; Returns -3.<br>minStack.pop();<br>minStack.top();      —&gt; Returns 0.<br>minStack.getMin();   —&gt; Returns -2.</p>
<h2 id="解法一-两个栈"><a href="#解法一-两个栈" class="headerlink" title="解法一: 两个栈"></a>解法一: 两个栈</h2><p><strong>时间复杂度:</strong> $O(1)$<br><strong>空间复杂度:</strong> $O(n)$, 两个栈</p>
<p>申请两个栈, 一个栈正常操作, 另一个栈只有当当前元素小于或等于栈顶元素时才入栈</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line">    MinStack()&#123;       </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.push(x);</span><br><span class="line">        <span class="keyword">if</span>(s2.empty() || x &lt;= s2.top()) s2.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.top() == s2.top()) s2.pop();</span><br><span class="line">        s1.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a>160. Intersection of Two Linked Lists</h1><p>两个链表的第一个公共节点</p>
<h2 id="Description-52"><a href="#Description-52" class="headerlink" title="Description"></a>Description</h2><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure></p>
<p>begin to intersect at node c1.</p>
<p>Notes:</p>
<p>If the two linked lists have no intersection at all, return null.<br>The linked lists must retain their original structure after the function returns.<br>You may assume there are no cycles anywhere in the entire linked structure.<br>Your code should preferably run in O(n) time and use only O(1) memory.</p>
<h2 id="解法一：栈"><a href="#解法一：栈" class="headerlink" title="解法一：栈"></a>解法一：栈</h2><p><strong>时间复杂度:</strong> $O(m+n)$, 遍历两个链表<br><strong>空间复杂度:</strong> $O(m+n)$, 两个栈</p>
<p>分析公共子节点的特点, 首先, 是单向链表, 因此, 从第一个公共子节点开始, 后面的都是一样的, 所以最好是能从链表的最后一项还是比较. 但由于是单向链表, 因此只能从头访问, 从能访问最后的节点.  <strong>就像是先进先出一样</strong>  因此, 考虑用两个辅助栈来帮助实现～</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; s1;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; s2;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* cur = pHead1; cur!=<span class="literal">nullptr</span>; cur = cur-&gt;next)&#123;</span><br><span class="line">            s1.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* cur = pHead2; cur!=<span class="literal">nullptr</span>; cur = cur-&gt;next)&#123;</span><br><span class="line">            s2.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* firstCN = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s1.empty() &amp;&amp; !s2.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.top() == s2.top())&#123;</span><br><span class="line">                firstCN = s1.top();</span><br><span class="line">                s1.pop();</span><br><span class="line">                s2.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> firstCN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-常数空间复杂度"><a href="#解法二-常数空间复杂度" class="headerlink" title="解法二: 常数空间复杂度"></a>解法二: 常数空间复杂度</h2><p><strong>时间复杂度:</strong> $O(m+n)$, 遍历两次<br><strong>空间复杂度:</strong> $O(1)$, 不使用额外空间</p>
<p>首先遍历得到两个链表的长度, 然后先让长链表前进长度差个节点, 接着两个链表共同向前遍历, 当相遇时即为第一个公共节点.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lengthA = <span class="number">0</span>;</span><br><span class="line">        ListNode* nodeA = headA;</span><br><span class="line">        <span class="keyword">while</span> (nodeA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nodeA = nodeA-&gt;next;</span><br><span class="line">            lengthA++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lengthB = <span class="number">0</span>;</span><br><span class="line">        ListNode* nodeB = headB;</span><br><span class="line">        <span class="keyword">while</span> (nodeB != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nodeB = nodeB-&gt;next;</span><br><span class="line">            lengthB++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* longNode = lengthA &gt; lengthB ? headA : headB;</span><br><span class="line">        ListNode* shortNode = lengthA &gt; lengthB ? headB : headA;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">std</span>::<span class="built_in">abs</span>(lengthA - lengthB);</span><br><span class="line">        <span class="keyword">while</span> (l--) &#123;</span><br><span class="line">            longNode = longNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (shortNode != longNode) &#123;</span><br><span class="line">            shortNode = shortNode-&gt;next;</span><br><span class="line">            longNode = longNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shortNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="162-Find-Peak-Element"><a href="#162-Find-Peak-Element" class="headerlink" title="162. Find Peak Element"></a>162. Find Peak Element</h1><h2 id="Description-局部最大值"><a href="#Description-局部最大值" class="headerlink" title="Description: 局部最大值"></a>Description: 局部最大值</h2><p>A peak element is an element that is greater than its neighbors.</p>
<p>Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.</p>
<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>
<p>You may imagine that nums[-1] = nums[n] = -∞.</p>
<p>Example 1:</p>
<p>Input: nums = [1,2,3,1]<br>Output: 2<br>Explanation: 3 is a peak element and your function should return the index number 2.<br>Example 2:</p>
<p>Input: nums = [1,2,1,3,5,6,4]<br>Output: 1 or 5<br>Explanation: Your function can return either index number 1 where the peak element is 2,<br>             or index number 5 where the peak element is 6.</p>
<h2 id="解法一-O-n-复杂度"><a href="#解法一-O-n-复杂度" class="headerlink" title="解法一: $O(n)$ 复杂度"></a>解法一: $O(n)$ 复杂度</h2><p>$O(n)$ 的时间复杂度, 不合符题目要求, 仅仅记录一下.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() ==<span class="number">1</span> || nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.size()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>] &amp;&amp; nums[i] &gt; nums[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[nums.size()<span class="number">-2</span>] &lt; nums[nums.size()<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> nums.size()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-O-logn-复杂度"><a href="#解法二-O-logn-复杂度" class="headerlink" title="解法二: $O(logn)$ 复杂度"></a>解法二: $O(logn)$ 复杂度</h2><p>二分查找, 分为以下几种情况:</p>
<ul>
<li>If num[i-1] &lt; num[i] &gt; num[i+1], then num[i] is peak</li>
<li>If num[i-1] &lt; num[i] &lt; num[i+1], then num[i+1…n-1] must contains a peak</li>
<li>If num[i-1] &gt; num[i] &gt; num[i+1], then num[0…i-1] must contains a peak</li>
<li>If num[i-1] &gt; num[i] &lt; num[i+1], then both sides have peak</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;        </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.size()<span class="number">-1</span>;        </span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high<span class="number">-1</span>)&#123; <span class="comment">//避免low和high相邻, 使得mid-1或mid+1可能非法</span></span><br><span class="line">            mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid<span class="number">-1</span>] &lt; nums[mid] &amp;&amp; nums[mid] &gt; nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[mid+<span class="number">1</span>]) low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low]&gt;nums[high] ? low : high; <span class="comment">// 当low或high相邻时, 即为两端时的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>; <span class="comment">// 向下取整</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid+<span class="number">1</span>]) high = mid;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>递归实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low == high) &#123;</span><br><span class="line">            <span class="keyword">return</span> low;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> helper(nums, low, mid);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> helper(nums, mid+<span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="166-Fraction-to-Recurring-Decimal"><a href="#166-Fraction-to-Recurring-Decimal" class="headerlink" title="166. Fraction to Recurring Decimal"></a>166. Fraction to Recurring Decimal</h1><h2 id="Description-无限循环小数"><a href="#Description-无限循环小数" class="headerlink" title="Description: 无限循环小数"></a>Description: 无限循环小数</h2><p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p>
<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>
<p>Example 1:</p>
<p>Input: numerator = 1, denominator = 2<br>Output: “0.5”<br>Example 2:</p>
<p>Input: numerator = 2, denominator = 1<br>Output: “2”<br>Example 3:</p>
<p>Input: numerator = 2, denominator = 3<br>Output: “0.(6)”</p>
<h2 id="解法一-用余数作为哈希表的key"><a href="#解法一-用余数作为哈希表的key" class="headerlink" title="解法一: 用余数作为哈希表的key"></a>解法一: 用余数作为哈希表的key</h2><p><strong>时间复杂度:</strong> $O(logn)$, 每次都会乘以10再取余数<br><strong>空间复杂度:</strong> $O(logn)$, 余数的哈希表</p>
<p>首先, 获取最终浮点数的符号和整数部分, 此处由于可能出现分子为<code>-2147483648</code>, 而分母为<code>-1</code>的情况, 为此, 建议使用<code>long</code>长整型来避免溢出.<br>在计算小数部分时, 将余数作为<code>key</code>, 小数当前位置作为<code>value</code>存入哈希表中, 然后将余数乘以10, 再计算当前小数位的值, 并将取余得到新的余数.<br>题目指明浮点数是无限循环小数, 则如果小数部分没有循环, 那么一定会出现余数为0的情况, 此时, 返回当前的<code>res</code>即可. 如果小数存在循环, 那么循环一定出现在余数相同的时刻, 此时, 将添加后扩号, 并根据哈希表中的<code>value</code>添加前括号.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numerator == <span class="number">0</span> || denominator == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">if</span>(numerator&lt;<span class="number">0</span> ^ denominator&lt;<span class="number">0</span>) res+=<span class="string">"-"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> numer = (numerator &lt; <span class="number">0</span>) ? (<span class="keyword">long</span>)(numerator)*<span class="number">-1</span> : (<span class="keyword">long</span>)numerator; <span class="comment">// 注意, 不能写成 (long)(numerator*-1)</span></span><br><span class="line">        <span class="keyword">long</span> denom = (denominator &lt; <span class="number">0</span>) ? (<span class="keyword">long</span>)(denominator)*<span class="number">-1</span> : (<span class="keyword">long</span>)denominator;</span><br><span class="line">        <span class="keyword">long</span> integral = numer/denom;</span><br><span class="line">        res += <span class="built_in">std</span>::to_string(integral); <span class="comment">// 添加整数部分</span></span><br><span class="line">        <span class="keyword">long</span> rmd = numer % denom;</span><br><span class="line">        <span class="keyword">if</span>(rmd!=<span class="number">0</span>)</span><br><span class="line">            res += <span class="string">"."</span>; <span class="comment">// 存在小数</span></span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">long</span>, <span class="keyword">long</span>&gt; hash;</span><br><span class="line">        <span class="keyword">while</span>(rmd!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.find(rmd) != hash.end())&#123; <span class="comment">// 判断余数</span></span><br><span class="line">                res.insert(hash[rmd], <span class="string">"("</span>);</span><br><span class="line">                res += <span class="string">")"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[rmd] = res.size();</span><br><span class="line">            rmd = rmd*<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">long</span> quotient = rmd/denom;</span><br><span class="line">            res += <span class="built_in">std</span>::to_string(quotient);</span><br><span class="line">            rmd = rmd%denom;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169 Majority Element"></a>169 Majority Element</h1><h2 id="Description-找出数组中超过一半的数字"><a href="#Description-找出数组中超过一半的数字" class="headerlink" title="Description: 找出数组中超过一半的数字"></a>Description: 找出数组中超过一半的数字</h2><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p>Example 1:</p>
<p>Input: [3,2,3]<br>Output: 3<br>Example 2:</p>
<p>Input: [2,2,1,1,1,2,2]<br>Output: 2</p>
<p><strong>题目中指明了该数字一定存在, 所以无需进行count检查, 如果该数字有可能不存在, 则根据情况需要进行 $O(n)$ 复杂度的count检查(即检查当前的数字是否出现了大于 n/2 次).</strong></p>
<h2 id="解法一-排序-1"><a href="#解法一-排序-1" class="headerlink" title="解法一: 排序"></a>解法一: 排序</h2><p><strong>时间复杂度:</strong> $O(nlogn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>先排序, 然后取中间元素, 即为 majority element.<br>(如有需要可进行count检查, $O(n)$)</p>
<h2 id="解法二-哈希-1"><a href="#解法二-哈希-1" class="headerlink" title="解法二: 哈希"></a>解法二: 哈希</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>每个元素的值为哈希的 key, 每个元素出现的次数为哈希的 value, 如果某个 key 的 value 大于 n/2, 则该元素即为 majority element.<br>哈希法记录的元素的出现次数, 所以无需进行 count 检查.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt; <span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num: nums)&#123;</span><br><span class="line">            hash[num]++;</span><br><span class="line">            <span class="keyword">if</span>(hash[num] &gt; nums.size()/<span class="number">2</span>) <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-同增异减"><a href="#解法三-同增异减" class="headerlink" title="解法三: 同增异减"></a>解法三: 同增异减</h2><p>如果数组中存在这样一个数, 那么这个数的出现次数一定大于其他所有数的出现次数总和, 因此, 设置两个变量, 一个 cur_num 用来存储当前数组中的可能解, 另一个 count 为统计差值. 即每遇到一个和可能解相同的元素, 就 count++, 否则, count—. 如果 count=0, 则说明当前的可能解已经注定不是最终的解, 则令新的元素为可能解.<br>最终, 对可能解进行 $O(n)$ 的 count 检查, 判断是否存在 majority element (题目假设一定存在, 所以可以不做此检查).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> major = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == major) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    major = num;</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> major; <span class="comment">// 因为题目保证major一定存在, 所以可以直接返回, 否则的话还需要再判断major的个数是否大于 n/2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-随机"><a href="#解法四-随机" class="headerlink" title="解法四: 随机"></a>解法四: 随机</h2><p>如果确定数组中存在 majority element 的话, 则我们可以从数组中随机选取一个元素, 并判断这个元素是否为 majority element.  这种解法依赖于统计学的概率知识, 实际的时间复杂度与数组的组成规律有关.</p>
<h1 id="171-Excel-Sheet-Column-Number"><a href="#171-Excel-Sheet-Column-Number" class="headerlink" title="171. Excel Sheet Column Number"></a>171. Excel Sheet Column Number</h1><h2 id="Description-Excel列表数字"><a href="#Description-Excel列表数字" class="headerlink" title="Description: Excel列表数字"></a>Description: Excel列表数字</h2><p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>
<p>For example:</p>
<pre><code>A -&gt; 1
B -&gt; 2
C -&gt; 3
...
Z -&gt; 26
AA -&gt; 27
AB -&gt; 28
...
</code></pre><p>Example 1:</p>
<p>Input: “A”<br>Output: 1<br>Example 2:</p>
<p>Input: “AB”<br>Output: 28<br>Example 3:</p>
<p>Input: “ZY”<br>Output: 701</p>
<h2 id="解法一-遍历字符串"><a href="#解法一-遍历字符串" class="headerlink" title="解法一: 遍历字符串"></a>解法一: 遍历字符串</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            res += res*<span class="number">25</span> + <span class="keyword">int</span>(c-<span class="string">'A'</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="172-Factorial-Trailing-Zeroes"><a href="#172-Factorial-Trailing-Zeroes" class="headerlink" title="172. Factorial Trailing Zeroes"></a>172. Factorial Trailing Zeroes</h1><h2 id="Description-阶乘的尾部含有0的个数"><a href="#Description-阶乘的尾部含有0的个数" class="headerlink" title="Description: 阶乘的尾部含有0的个数"></a>Description: 阶乘的尾部含有0的个数</h2><h2 id="解法一-统计5的个数"><a href="#解法一-统计5的个数" class="headerlink" title="解法一: 统计5的个数"></a>解法一: 统计5的个数</h2><p><strong>首先, 求出阶乘值在取余求0个数的方法肯定不可以, 阶乘会轻松溢出(n=13时就已经 int 溢出了)</strong></p>
<p><strong>时间复杂度:</strong> $O(logn)$, 以5位基数<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>因为尾部的0只可能来自于 $2\times 5$ 这样的数, 对于 $n$ 的阶乘 $1\times 2\times 3\times, …, n$ 来说, $2$ 一定是充足的, 所以我们只需要统计 $5$ 的个数就可以.<br>统计时, 每个5个数字会出现一次5, 每隔25个数字会额外出现一次5, 每个125个数字又会额外出现一次5…, 如此循环下去, 最终5的个数就是尾部0的个数.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i =<span class="number">5</span>; n/i &gt;<span class="number">0</span>; i*=<span class="number">5</span>)&#123;</span><br><span class="line">            <span class="comment">//注意这里的i的字节数一定要大于n, 因为n有可能为INT_MAX, 而 n/i &gt;0 时, i必须&gt;n</span></span><br><span class="line">            res += n/i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-另一个角度"><a href="#解法二-另一个角度" class="headerlink" title="解法二: 另一个角度"></a>解法二: 另一个角度</h2><p><strong>时间复杂度:</strong> $O(logn)$, 以5位基数<br><strong>空间复杂度:</strong> $O(1)$ (迭代), $O(logn)$ (递归需额外空间)</p>
<p>核心思想是相同的, 同样是统计5的出现个数, 只不过这里我们是先求出 n 中 5 的倍数, 然后再求 n/5 中 5 的倍数, 实际上这里就是相当于求 n 中 25 的倍数. 因此, 和解法一是相同的, 只不过解法二因为是通过减小 n, 而不是增大 i (5,25,125,..)的方式来统计 5 个数, 因此解法二有个好处就是可以不使用 <code>long</code> 类型的变量, 下面分别是该方法的递归实现和迭代实现.</p>
<p><strong>递归:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &lt; <span class="number">5</span> ? <span class="number">0</span> : n / <span class="number">5</span> + trailingZeroes(n / <span class="number">5</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>迭代:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;        </span><br><span class="line">        <span class="keyword">while</span>(n&gt;=<span class="number">5</span>)&#123;</span><br><span class="line">            res += n/<span class="number">5</span>;</span><br><span class="line">            n /= <span class="number">5</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="179-Largest-Number"><a href="#179-Largest-Number" class="headerlink" title="179. Largest Number"></a>179. Largest Number</h1><h2 id="Description-排列数字使其字符串形式的数字为最大"><a href="#Description-排列数字使其字符串形式的数字为最大" class="headerlink" title="Description: 排列数字使其字符串形式的数字为最大"></a>Description: 排列数字使其字符串形式的数字为最大</h2><p>Given a list of non negative integers, arrange them such that they form the largest number.</p>
<p>Example 1:</p>
<p>Input: [10,2]<br>Output: “210”<br>Example 2:</p>
<p>Input: [3,30,34,5,9]<br>Output: “9534330”</p>
<h2 id="解法一-构造比较函数-快排排序"><a href="#解法一-构造比较函数-快排排序" class="headerlink" title="解法一: 构造比较函数, 快排排序"></a>解法一: 构造比较函数, 快排排序</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 快排时间复杂度<br><strong>空间复杂度:</strong> $O(logn)$, 快排空间复杂度, <strong>如果使用其他排序算法, 可将空间复杂度降为 $O(1)$</strong></p>
<p>我们可以构造一个新的比较函数来决定两个元素的先后关系, 对于任意两个元素 <code>a</code> 和 <code>b</code>, 首先将其转换成字符串形式 <code>s_a</code> 和 <code>s_b</code>, 我们知道, 若整形 a&gt;b, 则一定有 <code>s_a</code> &gt; <code>s_b</code>, 因此我们可以比较 <code>s_a+s_b</code> 和 <code>s_b+s_a</code> 的大小关系, 根据题目要求, 我们要进行递减排序. 得到比较函数以后, 利用快排排序即可.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        q_sort(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);        </span><br><span class="line">        <span class="keyword">if</span>(nums.size()!=<span class="number">0</span> &amp;&amp; nums[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>; <span class="comment">// 对于输入[0, 0, 0] 应该返回 "0", 而不是"000", 必须要放在排序后, nums[0] == 0 说明所有元素均为0</span></span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num: nums)&#123;</span><br><span class="line">            res += <span class="built_in">std</span>::to_string(num);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">str_geq</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s_a = <span class="built_in">std</span>::to_string(a);</span><br><span class="line">        <span class="built_in">string</span> s_b = <span class="built_in">std</span>::to_string(b);</span><br><span class="line">        <span class="keyword">if</span>(s_a+s_b &gt;= s_b+s_a) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//注意是递减排序, 所以为 &gt;=</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> P = nums[low];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; str_geq(P, nums[high])) high--;</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; str_geq(nums[low], P)) low++;</span><br><span class="line">            nums[high] = nums[low];                  </span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = P;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">q_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = partition(nums, low, high);</span><br><span class="line">        <span class="keyword">if</span>(mid&gt;low) q_sort(nums, low, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;high) q_sort(nums, mid+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-利用-STL-sort-函数"><a href="#解法二-利用-STL-sort-函数" class="headerlink" title="解法二: 利用 STL sort() 函数"></a>解法二: 利用 STL sort() 函数</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 快排时间复杂度<br><strong>空间复杂度:</strong> $O(logn)$, 快排空间复杂度, <strong>如果使用其他排序算法, 可将空间复杂度降为 $O(1)$</strong></p>
<p>思路与解法一一致, 只不过省略了排序算法的实现, 使用了 STL 的 <code>sort</code> 函数.</p>
<p><strong>需要注意, 在 C++ STL 的 sort 函数中, bool 返回真的时候, 必须是绝对大于或者绝对小于, 对于等于的情况, 只能返回 false</strong>(因为当返回 true 时, 元素会继续下一个, 这样对于极端情况, 如所有元素都一样时, 会出现越界, 从而导致段错误)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">str_geq</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;    </span><br><span class="line">    <span class="built_in">string</span> s_a = <span class="built_in">std</span>::to_string(a);</span><br><span class="line">    <span class="built_in">string</span> s_b = <span class="built_in">std</span>::to_string(b);</span><br><span class="line">    <span class="keyword">if</span>(s_a+s_b &gt; s_b+s_a) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 这里用 &gt;= 会产生运行时错误, 用 &gt; 则可以通过, 为什么?</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end(), str_geq);     </span><br><span class="line">        <span class="keyword">if</span>(nums.size()!=<span class="number">0</span> &amp;&amp; nums[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>; <span class="comment">// 对于输入[0, 0, 0] 应该返回 "0", 而不是"000", 必须要放在排序后, nums[0] == 0 说明所有元素均为0</span></span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num: nums)&#123;</span><br><span class="line">            res += <span class="built_in">std</span>::to_string(num);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a>188. 买卖股票的最佳时机 IV</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/</a></p>
<h2 id="解法-通用-DP-解法"><a href="#解法-通用-DP-解法" class="headerlink" title="解法: 通用 DP 解法"></a>解法: 通用 DP 解法</h2><p>注意, 本题由于 k 的大小可以非常大, 所以在声明 dp 数组前, 一定要先判断 k 的大小, 如果超过范围, 则要转换为无限次的股票买卖, 否则会导致爆栈.</p>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//std::vector&lt;std::pair&lt;int, int&gt;&gt; dp(k+1, &#123;-prices[0], 0&#125;);</span></span><br><span class="line">        <span class="comment">// 这里有一个隐藏很深的 bug, 就如果 k 的值很大, 就会直接把栈爆掉!!</span></span><br><span class="line">        <span class="comment">// 所以应该按照 k 值做优化, 将 vector 声明在 if 语句内部</span></span><br><span class="line">        <span class="keyword">if</span> (k &lt; prices.size() / <span class="number">2</span>)  &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; dp(k+<span class="number">1</span>, &#123;-prices[<span class="number">0</span>], <span class="number">0</span>&#125;);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j &lt; k+<span class="number">1</span>; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> hold = <span class="built_in">std</span>::max(dp[j].first, dp[j<span class="number">-1</span>].second-prices[i]);</span><br><span class="line">                        <span class="keyword">int</span> not_hold = <span class="built_in">std</span>::max(dp[j].second, dp[j].first+prices[i]);</span><br><span class="line">                        dp[j].first = hold; dp[j].second = not_hold;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[k].second; <span class="comment">//max(dp[k].first, dp[k].second);</span></span><br><span class="line">        &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">            <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dp = &#123;-prices[<span class="number">0</span>], <span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> hold = <span class="built_in">std</span>::max(dp.first, dp.second-prices[i]);</span><br><span class="line">                <span class="keyword">int</span> not_hold = <span class="built_in">std</span>::max(dp.second, dp.first+prices[i]);</span><br><span class="line">                dp.first = hold; dp.second = not_hold;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k: int, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) &lt;= <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (k &lt; len(prices) // <span class="number">2</span>) :</span><br><span class="line">            dp = [[-prices[<span class="number">0</span>], <span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(k+<span class="number">1</span>)]</span><br><span class="line">            <span class="keyword">for</span> price <span class="keyword">in</span> prices[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">                    dp[i] = [max(dp[i][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]-price), max(dp[i][<span class="number">1</span>], dp[i][<span class="number">0</span>]+price)]</span><br><span class="line">            <span class="keyword">return</span> dp[k][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp = [-prices[<span class="number">0</span>], <span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> price <span class="keyword">in</span> prices[<span class="number">1</span>:]:</span><br><span class="line">                dp = [max(dp[<span class="number">0</span>], dp[<span class="number">1</span>]-price), max(dp[<span class="number">1</span>], dp[<span class="number">0</span>]+price)]</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<h1 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a>189. 旋转数组</h1><h2 id="Description-循环右移数组"><a href="#Description-循环右移数组" class="headerlink" title="Description: 循环右移数组"></a>Description: 循环右移数组</h2><p>Given an array, rotate the array to the right by k steps, where k is non-negative.</p>
<p>Example 1:</p>
<p>Input: [1,2,3,4,5,6,7] and k = 3<br>Output: [5,6,7,1,2,3,4]<br>Explanation:<br>rotate 1 steps to the right: [7,1,2,3,4,5,6]<br>rotate 2 steps to the right: [6,7,1,2,3,4,5]<br>rotate 3 steps to the right: [5,6,7,1,2,3,4]</p>
<p>Example 2:</p>
<p>Input: [-1,-100,3,99] and k = 2<br>Output: [3,99,-1,-100]<br>Explanation:<br>rotate 1 steps to the right: [99,-1,-100,3]<br>rotate 2 steps to the right: [3,99,-1,-100]</p>
<p>Note:<br>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.<br>Could you do it in-place with O(1) extra space?</p>
<h2 id="解法一-暴力-4"><a href="#解法一-暴力-4" class="headerlink" title="解法一: 暴力"></a>解法一: 暴力</h2><p><strong>时间复杂度:</strong> $O(nk)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>所有的数字每次移动一步, 攻移动 k 次. 超时</p>
<h2 id="解法二-使用额外数组"><a href="#解法二-使用额外数组" class="headerlink" title="解法二: 使用额外数组"></a>解法二: 使用额外数组</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>申请一个长度相等的数组, 复制原数组中的 $i$ 号元素到新数组中的 $i+k$ 号位置.</p>
<h2 id="解法三-循环置换"><a href="#解法三-循环置换" class="headerlink" title="解法三: 循环置换"></a>解法三: 循环置换</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历一次<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>每次直接将元素放置在正确的位置, 放置前, 需要用一个临时变量将被放置的元素保存起来以防止覆盖, 然后将临时变量的元素再直接放到正确的位置, 循环进行, 知道临时变量指向了最开始的变量, 然后再继续从下一个元素开始这个过程. 在代码中设置一个 <code>count</code> 变量, 用来统计放置的次数, 当次数等于数组长度时, 说明已经完成移动.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start=<span class="number">0</span>; count&lt;nums.size(); start++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur_pos = start;</span><br><span class="line">            <span class="keyword">int</span> cur_val = nums[start];</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> next_pos = (cur_pos + k) % nums.size();</span><br><span class="line">                <span class="keyword">int</span> temp = nums[next_pos];</span><br><span class="line">                nums[next_pos] = cur_val;</span><br><span class="line">                cur_pos = next_pos;</span><br><span class="line">                cur_val = temp;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">while</span>(start!=cur_pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-reverse"><a href="#解法四-reverse" class="headerlink" title="解法四: reverse"></a>解法四: reverse</h2><p><strong>时间复杂度:</strong> $O(n)$, 调用三次 reverse 函数<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::reverse(nums.begin(), nums.end()-k);</span><br><span class="line">        <span class="built_in">std</span>::reverse(nums.end()-k, nums.end());</span><br><span class="line">        <span class="built_in">std</span>::reverse(nums.begin(), nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="190-Reverse-Bits"><a href="#190-Reverse-Bits" class="headerlink" title="190. Reverse Bits"></a>190. Reverse Bits</h1><h2 id="Description-按位逆置"><a href="#Description-按位逆置" class="headerlink" title="Description: 按位逆置"></a>Description: 按位逆置</h2><p>Reverse bits of a given 32 bits unsigned integer.</p>
<p>Example:</p>
<p>Input: 43261596<br>Output: 964176192<br>Explanation: 43261596 represented in binary as 00000010100101000001111010011100,<br>             return 964176192 represented in binary as 00111001011110000010100101000000.<br>Follow up:<br>If this function is called many times, how would you optimize it?</p>
<h2 id="解法一-按位进行32次操作"><a href="#解法一-按位进行32次操作" class="headerlink" title="解法一: 按位进行32次操作"></a>解法一: 按位进行32次操作</h2><p>每次取 <code>n</code> 的最后一位, 如果为 1, 则令<code>res</code>左移一位并加一, 如果为0, 则只左移一位. 进行32次(<code>n</code>的32位).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> res= <span class="number">0</span>;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">            res = (res&lt;&lt;<span class="number">1</span>) | ((n&gt;&gt;i)&amp;<span class="number">1</span>); <span class="comment">//res = (res&lt;&lt;1) | (n&amp;1); n = (n&gt;&gt;1);            </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-按位二分进行5次操作"><a href="#解法二-按位二分进行5次操作" class="headerlink" title="解法二: 按位二分进行5次操作"></a>解法二: 按位二分进行5次操作</h2><p>先将前16位和后16位交换(利用位移和位操作实现)<br>然后再将16位中的前8位和后8位交换<br>然后再将8位中的前4位和后4位交换<br>然后再将4位中的前2位和后2位交换<br>最后将2位中的前1位和后1位交换.</p>
<p>上述交换全部采用位操作实现, 因此, 速度上有所优化.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">        n = (n&gt;&gt;<span class="number">16</span>) | (n&lt;&lt;<span class="number">16</span>);</span><br><span class="line">        n = ( ((n &amp; <span class="number">0xff00ff00</span>)&gt;&gt;<span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>)&lt;&lt;<span class="number">8</span>) );</span><br><span class="line">        n = ( ((n &amp; <span class="number">0xf0f0f0f0</span>)&gt;&gt;<span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>)&lt;&lt;<span class="number">4</span>) );</span><br><span class="line">        n = ( ((n &amp; <span class="number">0xcccccccc</span>)&gt;&gt;<span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>)&lt;&lt;<span class="number">2</span>) );</span><br><span class="line">        n = ( ((n &amp; <span class="number">0xaaaaaaaa</span>)&gt;&gt;<span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>)&lt;&lt;<span class="number">1</span>) );</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="191-Number-of-1-Bits"><a href="#191-Number-of-1-Bits" class="headerlink" title="191. Number of 1 Bits"></a>191. Number of 1 Bits</h1><h2 id="Description-统计二进制中1的个数"><a href="#Description-统计二进制中1的个数" class="headerlink" title="Description: 统计二进制中1的个数"></a>Description: 统计二进制中1的个数</h2><p>Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the Hamming weight).</p>
<p>Example 1:</p>
<p>Input: 11<br>Output: 3<br>Explanation: Integer 11 has binary representation 00000000000000000000000000001011<br>Example 2:</p>
<p>Input: 128<br>Output: 1<br>Explanation: Integer 128 has binary representation 00000000000000000000000010000000</p>
<h2 id="解法一-逐位统计"><a href="#解法一-逐位统计" class="headerlink" title="解法一: 逐位统计"></a>解法一: 逐位统计</h2><p><strong>时间复杂度:</strong> $O(1)$, 循环32次<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>查看每一位上的二进制是否为1, 若为1, 则<code>count++</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (n &amp; (<span class="number">1</span>&lt;&lt;i)) != <span class="number">0</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-和-n-1-按位与"><a href="#解法二-和-n-1-按位与" class="headerlink" title="解法二: 和 $n-1$ 按位与"></a>解法二: 和 $n-1$ 按位与</h2><p><strong>时间复杂度:</strong> $O(1)$, 循环次数为二进制中1的个数.<br><strong>空间复杂度:</strong> $O(1)$</p>
<p><img src="https://wx1.sinaimg.cn/large/d7b90c85ly1fxlbg7qyk9j21cs0nwq4u.jpg" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n&amp;(n<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="198-打家劫舍-简单"><a href="#198-打家劫舍-简单" class="headerlink" title="198. 打家劫舍-简单"></a>198. 打家劫舍-简单</h1><h2 id="Description-房屋小偷获取最大收益"><a href="#Description-房屋小偷获取最大收益" class="headerlink" title="Description: 房屋小偷获取最大收益"></a>Description: 房屋小偷获取最大收益</h2><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<p>Example 1:</p>
<p>Input: [1,2,3,1]<br>Output: 4<br>Explanation:<br>Rob house 1 (money = 1) and then rob house 3 (money = 3).<br>Total amount you can rob = 1 + 3 = 4.<br>Example 2:</p>
<p>Input: [2,7,9,3,1]<br>Output: 12<br>Explanation:<br>Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).<br>Total amount you can rob = 2 + 9 + 1 = 12.</p>
<h2 id="解法一-DP-2"><a href="#解法一-DP-2" class="headerlink" title="解法一: DP"></a>解法一: DP</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>依据 DP 的思想, 对于一个任意价格的房子, 我们有两种选择: 偷或不偷. 如果选择不偷, 那么前 $(i+1)$ 个房子的最大收益, 就应该是前 $i$ 个房子的最大收益(偷或者不偷第 $i$ 个房子收益中的较大者), 如果选择偷, 那么就不能偷第 $i$ 个房子.<br>根据上面的描述, 我们可以维护两个变量 <code>cur_rob</code> 和 <code>cur_nrob</code>, 前者代表偷第 $i$ 个房子的收益, 后者代表不偷第 $i$ 个房子的收益, 则最大收益就应该为二者中的较大者. 详细代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur_rob=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_nrob=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = cur_nrob;</span><br><span class="line">            cur_nrob = <span class="built_in">std</span>::max(cur_rob, cur_nrob);            </span><br><span class="line">            cur_rob = temp+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(cur_rob, cur_nrob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-根据房屋的编号奇偶性"><a href="#解法二-根据房屋的编号奇偶性" class="headerlink" title="解法二: 根据房屋的编号奇偶性"></a>解法二: 根据房屋的编号奇偶性</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>因为偷取的房屋不能相邻, 因此我们可以维护两个变量, <code>even</code> 是前偶数个房屋的最大收益, <code>odd</code> 是前奇数个房屋的最大收益, 对于任意的一个新来的房屋, 如果该新房屋的编号为奇数, 那么它的最大收益就是 <code>odd+new</code> 和 <code>even</code> 当中的较大者(因为不能相邻, 所以只能令 <code>odd+new</code>). 对于偶数的情况同理. 最终返回 <code>odd</code> 和 <code>even</code> 的较大者.(因为有可能包含最后一个元素, 也有可能不包含) 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> odd=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> even=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>) even = <span class="built_in">std</span>::max(odd, even+nums[i]);</span><br><span class="line">            <span class="keyword">else</span> odd = <span class="built_in">std</span>::max(odd+nums[i], even);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(odd, even);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="200-Number-of-Islands"><a href="#200-Number-of-Islands" class="headerlink" title="200. Number of Islands"></a>200. Number of Islands</h1><h2 id="Description-区块的个数"><a href="#Description-区块的个数" class="headerlink" title="Description: 区块的个数"></a>Description: 区块的个数</h2><p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p>Example 1:</p>
<p>Input:<br>11110<br>11010<br>11000<br>00000</p>
<p>Output: 1<br>Example 2:</p>
<p>Input:<br>11000<br>11000<br>00100<br>00011</p>
<p>Output: 3</p>
<h2 id="解法一-DFS-遍历"><a href="#解法一-DFS-遍历" class="headerlink" title="解法一: DFS 遍历"></a>解法一: DFS 遍历</h2><p><strong>时间复杂度:</strong> $O(n)$, 至多遍历两次 grid<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>遍历 grid 中的每一个元素, 如果为1, 则将与之相连的所有的1都置为0, 并且区块个数加1, 这样, 最坏的情况就是 grid 中的所有数字均为1, 此时, 需要遍历两边数组.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;grid.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;grid[i].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    fill(grid, i, j);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        grid[i][j] = <span class="string">'2'</span>;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;=<span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;=<span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; grid[x][y] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                fill(grid, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="202. Happy Number"></a>202. Happy Number</h1><h2 id="Description-判断一个数字是否是-Happer-Number"><a href="#Description-判断一个数字是否是-Happer-Number" class="headerlink" title="Description: 判断一个数字是否是 Happer Number"></a>Description: 判断一个数字是否是 Happer Number</h2><p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p>Example:</p>
<p>Input: 19<br>Output: true<br>Explanation:<br>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1</p>
<h2 id="解法一-模拟计算过程"><a href="#解法一-模拟计算过程" class="headerlink" title="解法一: 模拟计算过程"></a>解法一: 模拟计算过程</h2><p><strong>时间复杂度:</strong> $O(logn)$, 基数为10<br><strong>空间复杂度:</strong> 未知, 取决于无序集合的size.</p>
<p>按照题目中的逻辑, 模拟整个计算过程, 如果出现1, 则返回 <code>true</code>, 如果出现循环(即在集合中发现已存在元素), 则返回 <code>false</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; num_set;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">1</span> &amp;&amp; num_set.find(n)==num_set.end())&#123;</span><br><span class="line">            num_set.insert(n);</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">                temp += (n%<span class="number">10</span>) * (n%<span class="number">10</span>);</span><br><span class="line">                n = n/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-Floyd-判圈算法"><a href="#解法二-Floyd-判圈算法" class="headerlink" title="解法二: Floyd 判圈算法"></a>解法二: Floyd 判圈算法</h2><p><strong>时间复杂度:</strong> $O(logn)$, 时间复杂度不变<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>利用 Floyd 判圈算法维护两个变量 <code>slow</code> 和 <code>fast</code>, <code>fast</code> 每次都比 <code>flow</code> 多走一步, 那么, 当 <code>fast==1</code> 时, 说明应该返回 <code>true</code>, 当 <code>slow==fast</code> 时, 说明存在循环, 应该返回 <code>false</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow=n, fast=n;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = digitSquareSum(slow);</span><br><span class="line">            fast = digitSquareSum(fast);</span><br><span class="line">            fast = digitSquareSum(fast);</span><br><span class="line">        &#125;<span class="keyword">while</span>(fast!=<span class="number">1</span> &amp;&amp; slow!=fast);</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">digitSquareSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            temp += (n%<span class="number">10</span>) * (n%<span class="number">10</span>);</span><br><span class="line">            n = n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="204-Count-Primes"><a href="#204-Count-Primes" class="headerlink" title="204. Count Primes"></a>204. Count Primes</h1><h2 id="Description-素数的个数"><a href="#Description-素数的个数" class="headerlink" title="Description: 素数的个数"></a>Description: 素数的个数</h2><p>Count the number of prime numbers less than a non-negative number, n.</p>
<p>Example:</p>
<p>Input: 10<br>Output: 4<br>Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.</p>
<h2 id="解法一-填充非素数"><a href="#解法一-填充非素数" class="headerlink" title="解法一: 填充非素数"></a>解法一: 填充非素数</h2><p><strong>时间复杂度:</strong> $O(n)$, 至多遍历两次 $n$ 大小的数组, 可优化为只遍历一次.<br><strong>空间复杂度:</strong> $O(n)$, 申请了 $n$ 大小的一维布尔数组来标识是否为负数</p>
<p><img src="http://wx3.sinaimg.cn/large/d7b90c85ly1fxngsjxjyag20cd0a9q6x.gif" alt=""></p>
<p>如上图, 我们从 $2\times 2$ 开始填充, 将所有能与2相乘切乘积小于 $n$ 的数对应下标置为 <code>false</code>, 然后从 $3\times 3$ 开始填充(注意不是从 $3\times 2$, 因为这样会与前面的 $2\times 3$ 重复), 接着从 $4\times 4$ 开始填充, 因此, 填充的开始位置最大为 $\sqrt{n}$. 另外需要注意的是, 0 和 1 均不是素数.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> div_n = <span class="built_in">sqrt</span>(n)+<span class="number">1</span>; <span class="comment">// 注意这里是开根号</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; is_primes(n, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;div_n; i++)&#123;            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i*i; j&lt;n; j+=i)&#123;</span><br><span class="line">                is_primes[j]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res_count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> primes : is_primes)&#123;</span><br><span class="line">            <span class="keyword">if</span>(primes==<span class="literal">true</span>) res_count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res_count<span class="number">-2</span>; <span class="comment">//去掉0和1的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>优化1: 因为任何一个合数都可以拆分成素数的乘积, 因此我们只在当前元素为素数的时候才开始填充, 例如, 对于4, 我们不填充16, 20, ..等数字, 因为这些数字在开始元素为2的时候已经填充过了. 因此, 可以避免这些重复填充, 减少迭代次数, 代码如下(多加了一条<code>if</code>语句).</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> div_n = <span class="built_in">sqrt</span>(n)+<span class="number">1</span>; <span class="comment">// 注意这里是开根号</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; is_primes(n, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;div_n; i++)&#123;    </span><br><span class="line">            <span class="keyword">if</span>(is_primes[i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i*i; j&lt;n; j+=i)&#123;</span><br><span class="line">                    is_primes[j]=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::count(is_primes.begin(), is_primes.end(), <span class="literal">true</span>)<span class="number">-2</span>; <span class="comment">//去掉0和1的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>优化2: 只遍历一次.</strong> 首先我们将判断数组<code>isPrime</code>的初始状态设为<code>true</code>, 这样, 每次只在遇到奇数时才检查其是否为素数, 如果该奇数是素数, 那么就将该奇数的倍数全部置为非素数, 同时, 将速度的count加1. 这样, 不仅可以减少判断次数(不再判断偶数), 同时可以在一次遍历的时间内完成素数统计.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; isPrime(n, <span class="literal">true</span>); <span class="comment">// 默认全是素数</span></span><br><span class="line">        <span class="keyword">int</span> upper = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(n); <span class="comment">// 控制 i*i, 防止越界</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 判断 0 ~ n-1 是否为素数, 当 n = 2 时, 返回0</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">// 2 也为素数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i+=<span class="number">2</span>) &#123; <span class="comment">// 只有奇数才有可能是速度, 并且 1 不是素数</span></span><br><span class="line">            <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; upper) <span class="keyword">continue</span>; <span class="comment">// 这里必须进行判断, 否则 i*i 有可能越界</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i*i; j &lt; n; j+=i) &#123; <span class="comment">// 将 i 的倍数全部置为非素数</span></span><br><span class="line">                    isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h1><h2 id="Description-逆置链表"><a href="#Description-逆置链表" class="headerlink" title="Description: 逆置链表"></a>Description: 逆置链表</h2><p>Reverse a singly linked list.</p>
<p>Example:</p>
<p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<h2 id="解法一-迭代-2"><a href="#解法一-迭代-2" class="headerlink" title="解法一: 迭代"></a>解法一: 迭代</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历一次链表<br><strong>空间复杂度:</strong> $O(1)$, 借助3个复制指针完成逆置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* next = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-递归-3"><a href="#解法二-递归-3" class="headerlink" title="解法二: 递归"></a>解法二: 递归</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(n)$, 迭代需要占用 $O(n)$ 大小的栈空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *P = reverseList(head-&gt;next); <span class="comment">//令下一个开始的节点逆置, 返回新链表的头结点</span></span><br><span class="line">        head-&gt;next-&gt;next = head; <span class="comment">// 将当前节点逆置</span></span><br><span class="line">        head-&gt;next=<span class="literal">nullptr</span>; <span class="comment">// 将当前节点的下一个置空, 主要是处理新的尾节点, 其他节点的next会在递归中正确赋值</span></span><br><span class="line">        <span class="keyword">return</span> P; <span class="comment">//返回新的头结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="207-Course-Schedule"><a href="#207-Course-Schedule" class="headerlink" title="207. Course Schedule"></a>207. Course Schedule</h1><h2 id="Description-课程表-判断有向图是否存在环"><a href="#Description-课程表-判断有向图是否存在环" class="headerlink" title="Description: 课程表 / 判断有向图是否存在环"></a>Description: 课程表 / 判断有向图是否存在环</h2><p>There are a total of n courses you have to take, labeled from 0 to n-1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<p>Example 1:<br>Input: 2, [[1,0]]<br>Output: true<br>Explanation:<br>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p>
<p>Example 2:<br>Input: 2, [[1,0],[0,1]]<br>Output: false<br>Explanation:<br>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p>
<h2 id="解法一-BFS-拓扑排序"><a href="#解法一-BFS-拓扑排序" class="headerlink" title="解法一: BFS / 拓扑排序"></a>解法一: BFS / 拓扑排序</h2><p><strong>时间复杂度:</strong> $O(V+E)$, 统计入度时需要 $O(V)$, 处理队列需要 $O(E)$, 其中 $V$ 为节点个数, $E$ 为边的个数<br><strong>空间复杂度:</strong> $O(V+E)$, 入度数组和队列分别需要 $(V)$, 邻接表需要 $O(V+E)$.</p>
<p>首先将图的边表示结构转换成邻接表形式(用<code>vector</code>来实现邻接表, 使其支持随机访问). 然后再申请一个 $O(V)$ 大小的数组来存储每个节点的入度. 在拓扑排序时, 先将所有入度为0的节点添加都一个队列当中, 然后从队列顶端拿出一个节点, 将该节点的所有直接后序节点的入度都减1, 然后再将所有入度为0的节点入队列. 如此迭代下去, 直至所有队列为空. 此时, 如果还有某个节点的入度不为0, 则说明存在环, 应该返回 false, 否则, 返回 true.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph_c(numCourses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in_degree(numCourses, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : prerequisites)&#123;</span><br><span class="line">            graph_c[p.second].push_back(p.first);</span><br><span class="line">            in_degree[p.first]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">// 入度为0的节点队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in_degree[i]==<span class="number">0</span>) q.push(i); <span class="comment">//将所有入度为0的节点入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> cur_c = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> next_c : graph_c[cur_c])&#123; <span class="comment">// next_c为cur_c的直接后序课程</span></span><br><span class="line">                in_degree[next_c]--; <span class="comment">// 后序节点的入度减1</span></span><br><span class="line">                <span class="keyword">if</span>(in_degree[next_c]==<span class="number">0</span>) q.push(next_c);<span class="comment">//如果减为0, 则入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> in : in_degree)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-DFS"><a href="#解法二-DFS" class="headerlink" title="解法二: DFS"></a>解法二: DFS</h2><p><strong>时间复杂度:</strong> $O(V+E)$, 复杂度和 BFS 算法近似, 其中 $V$ 为节点个数, $E$ 为边的个数<br><strong>空间复杂度:</strong> $O(V+E)$, <code>visit</code>数组和递归栈分别需要 $(V)$, 邻接表需要 $O(V+E)$.</p>
<p>首先, 和 BFS 一样, 建立关于图的邻接表结构, 然后, 申请 $O(V)$ 大小的访问数组<code>visit</code>, 初始值全部为0, 表示所有节点均为访问. 然后, 根据 DFS 算法的执行过程. 将当前正在访问的节点置为<code>-1</code>, 将已经访问过且确认无环的节点置为<code>1</code>. 则则DFS过程中, 如果访问到了一个已经被置为<code>-1</code>的节点, 则说明该节点是当前循环内的正在访问的节点, 因此, 构成了一个环, 返回 <code>false</code>. 如果遇到了一个被置为<code>1</code>的节点, 因为已经确认该节点无环, 因此可以直接返回 <code>true</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph_c(numCourses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visit(numCourses, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : prerequisites)</span><br><span class="line">            graph_c[p.second].push_back(p.first);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numCourses; i++)&#123; <span class="comment">// 因为当前的图并不是一个连通图, 所以必须遍历所有的节点</span></span><br><span class="line">            <span class="keyword">if</span>(canFinishDFS(graph_c, visit, i) == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinishDFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph_c, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;visit, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(visit[i] == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        visit[i] = <span class="number">-1</span>; <span class="comment">// 将当前节点置为正在访问状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> node : graph_c[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(canFinishDFS(graph_c, visit, node) == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 当前节点上存在环</span></span><br><span class="line">        &#125;</span><br><span class="line">        visit[i] = <span class="number">1</span>; <span class="comment">// 将当前节点置为已经访问过且确认无环状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 确认节点i无环, 返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="208-Implement-Trie-Prefix-Tree"><a href="#208-Implement-Trie-Prefix-Tree" class="headerlink" title="208. Implement Trie (Prefix Tree)"></a>208. Implement Trie (Prefix Tree)</h1><h2 id="Description-实现字典树-前缀树"><a href="#Description-实现字典树-前缀树" class="headerlink" title="Description: 实现字典树(前缀树)"></a>Description: 实现字典树(前缀树)</h2><p>Implement a trie with insert, search, and startsWith methods.</p>
<p>Example:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(<span class="string">"apple"</span>);</span><br><span class="line">trie.search(<span class="string">"apple"</span>);   <span class="comment">// returns true</span></span><br><span class="line">trie.search(<span class="string">"app"</span>);     <span class="comment">// returns false</span></span><br><span class="line">trie.startsWith(<span class="string">"app"</span>); <span class="comment">// returns true</span></span><br><span class="line">trie.insert(<span class="string">"app"</span>);   </span><br><span class="line">trie.search(<span class="string">"app"</span>);     <span class="comment">// returns true</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fxnm0ibh7vj20jc0ggadn.jpg" alt=""></p>
<h2 id="解法一-2"><a href="#解法一-2" class="headerlink" title="解法一"></a>解法一</h2><p><a href="https://www.cnblogs.com/grandyang/p/4491665.html" target="_blank" rel="noopener">https://www.cnblogs.com/grandyang/p/4491665.html</a></p>
<p><strong>时间复杂度:</strong> $O(k)$, 插入, 查找, 找前缀均只需要 $O(k)$复杂度, $k$ 为字符串长度<br><strong>空间复杂度:</strong> 与字符串的公共部分的多少有关, 公共部分越多, 越节省空间, 反之, 空间复杂度较高. 最差情况下为 $O(wk)$, 其中, $w$ 为单词的个数, $k$ 为单词的最长长度.</p>
<p>字母字典树是一个26叉树, 树的根节点没有字符, 其他节点有且仅有一个字符, 我们模仿二叉树的定义, 构建一个26叉树的数据结构, 用子节点的编号代表字母(即0号节点代表字母a, 1号代表b,…,25号代表z), 另外需要定义一个布尔值来标识当前节点是否构成一个单词. 插入时, 根据字符串遍历树, 如果当前字符不存在, 则新建一个. 查找和找前缀时, 如果不存在则直接返回<code>false</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> is_word;</span><br><span class="line">    TrieNode():is_word(<span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : child)&#123; <span class="comment">// 对c进行改动, 需要用引用&amp;</span></span><br><span class="line">            c = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> letter : word)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = letter - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;child[i] == <span class="literal">nullptr</span>) p-&gt;child[i]=<span class="keyword">new</span> TrieNode();</span><br><span class="line">            p = p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;is_word = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> letter : word)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = letter - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;child[i]==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (p-&gt;is_word == <span class="literal">true</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> letter : prefix)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = letter - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;child[i]==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> * /</span></span><br></pre></td></tr></table></figure>
<h1 id="210-Course-Schedule-II"><a href="#210-Course-Schedule-II" class="headerlink" title="210. Course Schedule II"></a>210. Course Schedule II</h1><h2 id="Description-判断有向图是否有环-若无环-则返回拓扑序列"><a href="#Description-判断有向图是否有环-若无环-则返回拓扑序列" class="headerlink" title="Description: 判断有向图是否有环, 若无环, 则返回拓扑序列"></a>Description: 判断有向图是否有环, 若无环, 则返回拓扑序列</h2><p>There are a total of n courses you have to take, labeled from 0 to n-1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</p>
<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>
<p>Example 1:<br>Input: 2, [[1,0]]<br>Output: [0,1]<br>Explanation:<br>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] .</p>
<p>Example 2:<br>Input: 4, [[1,0],[2,0],[3,1],[3,2]]<br>Output: [0,1,2,3] or [0,2,1,3]<br>Explanation:<br>There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .</p>
<h2 id="解法一-BFS-拓扑排序-1"><a href="#解法一-BFS-拓扑排序-1" class="headerlink" title="解法一: BFS, 拓扑排序"></a>解法一: BFS, 拓扑排序</h2><p><strong>时间复杂度:</strong> $O(V+E)$, 统计入度时需要 $O(V)$, 处理队列需要 $O(E)$, 其中 $V$ 为节点个数, $E$ 为边的个数<br><strong>空间复杂度:</strong> $O(V+E)$, 入度数组和队列分别需要 $(V)$, 邻接表需要 $O(V+E)$, 相比于第207题, 多了一个拓扑序列的数组, 大小为 $O(V)$.</p>
<p>和第207题差不多, 不过在判断是否有环的同时, 还要记录正确的拓扑序列并返回.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph_c(numCourses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 构建图的邻接表</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in_degree(numCourses);<span class="comment">// 构建入度数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c_pair : prerequisites)&#123;</span><br><span class="line">            graph_c[c_pair.second].push_back(c_pair.first);</span><br><span class="line">            in_degree[c_pair.first]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">//入度为0的队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in_degree[i]==<span class="number">0</span>) q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res; <span class="comment">// 记录拓扑序列        </span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> cur_c = q.front(); q.pop();</span><br><span class="line">            res.push_back(cur_c);            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;next_c : graph_c[cur_c])&#123;</span><br><span class="line">                in_degree[next_c]--; <span class="comment">// 后修课的入度减1</span></span><br><span class="line">                <span class="keyword">if</span>(in_degree[next_c]==<span class="number">0</span>) q.push(next_c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.size() == numCourses) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-DFS-1"><a href="#解法二-DFS-1" class="headerlink" title="解法二: DFS"></a>解法二: DFS</h2><p><strong>时间复杂度:</strong> $O(V+E)$, 复杂度和 BFS 算法近似, 其中 $V$ 为节点个数, $E$ 为边的个数<br><strong>空间复杂度:</strong> $O(V+E)$, <code>visit</code>数组和递归栈分别需要 $(V)$, 邻接表需要 $O(V+E)$, 拓扑序列需要 $O(V)$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph_c(numCourses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 构建图的邻接表</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visit(numCourses, <span class="number">0</span>);<span class="comment">// 构建入度数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c_pair : prerequisites)&#123;</span><br><span class="line">            graph_c[c_pair.second].push_back(c_pair.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numCourses; i++)&#123; <span class="comment">//非连通图, 需要遍历所有节点</span></span><br><span class="line">            <span class="keyword">if</span>(findOrderDFS(graph_c, i, visit, res)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();            </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="built_in">std</span>::reverse(res.begin(), res.end()); <span class="comment">//等于dfs来说, 最后的课程会先加入结果数组, 因此, res中的序列逆置后才是最终的拓扑序列.</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findOrderDFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph_c, <span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;visit, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i]==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 重复访问, 存在环</span></span><br><span class="line">        <span class="keyword">if</span>(visit[i]==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 已经访问过且确认无环, 可直接返回</span></span><br><span class="line">        visit[i] = <span class="number">-1</span>; <span class="comment">// 置为正在访问状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> next_c : graph_c[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(findOrderDFS(graph_c, next_c, visit, res) == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[i] = <span class="number">1</span>; <span class="comment">//确认无环</span></span><br><span class="line">        res.push_back(i); <span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="212-Word-Search-II"><a href="#212-Word-Search-II" class="headerlink" title="212. Word Search II"></a>212. Word Search II</h1><h2 id="Description-返回字符矩阵中含有的所有单词"><a href="#Description-返回字符矩阵中含有的所有单词" class="headerlink" title="Description: 返回字符矩阵中含有的所有单词"></a>Description: 返回字符矩阵中含有的所有单词</h2><p>Given a 2D board and a list of words from the dictionary, find all words in the board.</p>
<p>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>
<p>Example:</p>
<p>Input:<br>words = [“oath”,”pea”,”eat”,”rain”] and board =<br>[<br>  [‘o’,’a’,’a’,’n’],<br>  [‘e’,’t’,’a’,’e’],<br>  [‘i’,’h’,’k’,’r’],<br>  [‘i’,’f’,’l’,’v’]<br>]</p>
<p>Output: [“eat”,”oath”]</p>
<h2 id="解法一-穷举-4"><a href="#解法一-穷举-4" class="headerlink" title="解法一: 穷举"></a>解法一: 穷举</h2><p><strong>时间复杂度:</strong> $O(w mn 4^k)$, 暴力求解, $mn$ 为字符矩阵的宽和高, 也即 cell 数量, 对于 dfs 中的每个 cell, 有4个扩展方向, 一共需要扩展 $k$ 次($k$ 为单词的长度). 总共有 $w$ 个单词, 因此复杂度为$O(w mn 4^k)$<br><strong>空间复杂度:</strong> $O(mn)$ , 和79题相同, 回溯时, 用<code>#</code>来记录已经遍历过的点, 无需申请额外空间来记录. 但是递归程序需要占用 $O(mn)$ 的空间复杂度.</p>
<p>该题和79题类似, 只不过给定的是一个单词列表, 而不是一个单词, 因此, 可以对这个单词列表循环调用79题的解. 不过时间复杂度过高, 无法通过 OJ.</p>
<h2 id="解法二-字典树"><a href="#解法二-字典树" class="headerlink" title="解法二: 字典树"></a>解法二: 字典树</h2><p><strong>时间复杂度:</strong> $O(mn 4^k)$, 暴力求解, $mn$ 为字符矩阵的 cell 数量, 对于 dfs 中的每个 cell, 有4个扩展方向, 一共需要扩展 $k$ 次($k$ 为单词的长度).<br><strong>空间复杂度:</strong> $O(mn)$ , 和79题相同, 回溯时, 用<code>#</code>来记录已经遍历过的点, 无需申请额外空间来记录. 但是递归程序需要占用 $O(mn)$ 的空间复杂度. <strong>另外, 还有构建字典树所需的空间复杂度, 这部分复杂度与具体的字符串数组有关, 当字符串公共部分较多时, 复杂度较低, 反之, 复杂度较高, 最差情况下为 $O(wk)$, 即无公共前缀</strong></p>
<p>相对于第79题来说, 本题增加的复杂度主要体现在需要同时查看 $w$ 个单词的字符, 查询这些单词字符的复杂度约为 $O(wk)$, 其中, $k$ 为单词的最大长度, 那么, 我们能否将这里的复杂度降低成 $k$ 呢? 如果降低成 $k$ 的话, 就相当是在查找一个单词, 那么整体的复杂度就和79题相同, 变成了 $O(mn 4^k)$.<br>实际上, 字典树正是这种数据结构! 在由 $w$ 个字符串构成的字典树中查询某个字符串或者字符子串的复杂度为 $k$. 因此, 我们可以借助字典树来降低整体的时间复杂度. 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *child[<span class="number">26</span>];</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    TrieNode():str(<span class="string">""</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;node : child) node=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line"></span><br><span class="line">    Trie():root(<span class="keyword">new</span> TrieNode())&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = c - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;child[i] == <span class="literal">nullptr</span>) p-&gt;child[i] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            p = p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;str = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findWords(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(words.size()==<span class="number">0</span> || board.size()==<span class="number">0</span> || board[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visit(board.size(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(board[<span class="number">0</span>].size(), <span class="literal">false</span>));</span><br><span class="line">        Trie T;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : words) T.insert(word);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;board[i].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(T.root-&gt;child[board[i][j] - <span class="string">'a'</span>] != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    search(board, T.root-&gt;child[board[i][j]-<span class="string">'a'</span>], i, j, visit, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, TrieNode *node, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;visit, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;str.empty())&#123;</span><br><span class="line">            res.push_back(node-&gt;str);</span><br><span class="line">            node-&gt;str.clear(); <span class="comment">// 重新置为空 node-&gt;str = ""; 防止重复push_back</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> direct[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125; &#125;;</span><br><span class="line">        visit[i][j] = <span class="literal">true</span>; <span class="comment">// 将当前位置设置为已访问, 因为题目要求同一个位置只能在一个字符串中被访问一次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d : direct)&#123;</span><br><span class="line">            <span class="keyword">int</span> new_i = i + d[<span class="number">0</span>]; <span class="keyword">int</span> new_j = j + d[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(new_i&gt;=<span class="number">0</span> &amp;&amp; new_j&gt;=<span class="number">0</span> &amp;&amp; new_i&lt;board.size() &amp;&amp; new_j&lt;board[<span class="number">0</span>].size() &amp;&amp; visit[new_i][new_j]==<span class="literal">false</span> &amp;&amp; node-&gt;child[board[new_i][new_j] - <span class="string">'a'</span>] != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                search(board, node-&gt;child[board[new_i][new_j] - <span class="string">'a'</span>], new_i, new_j, visit, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[i][j] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="213-打家劫舍-II-中等"><a href="#213-打家劫舍-II-中等" class="headerlink" title="213. 打家劫舍 II-中等"></a>213. 打家劫舍 II-中等</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber-ii/</a></p>
<h2 id="解法-动态规划-2"><a href="#解法-动态规划-2" class="headerlink" title="解法: 动态规划"></a>解法: 动态规划</h2><p><strong>C++ 实现:</strong><br>在 198 题打家劫舍的基础上进行扩展, 由题意知, 该题的难点在于第一家和最后一家是紧挨着的, 因此, 我们可以分两种情况进行讨论, 第一种情况是允许偷第一家, 那么就一定不能偷最后一家, 第二种情况是允许偷最后一家, 那么就一定不能偷第一家. <strong>注意, 这里用的是允许偷, 而不是一定偷, 偷与不偷的取舍会在动态规划中自行决定.</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dp1[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dp2[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; nums.size()<span class="number">-1</span>) &#123; <span class="comment">// 可以偷第一家, 就一定不能偷最后一家</span></span><br><span class="line">                <span class="keyword">int</span> rob = dp1[<span class="number">1</span>] + nums[i];</span><br><span class="line">                <span class="keyword">int</span> not_rob = <span class="built_in">std</span>::max(dp1[<span class="number">0</span>], dp1[<span class="number">1</span>]);</span><br><span class="line">                dp1[<span class="number">0</span>] = rob;</span><br><span class="line">                dp1[<span class="number">1</span>] = not_rob;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123; <span class="comment">// 可以偷最后一家, 就一定不能偷第一家</span></span><br><span class="line">                <span class="keyword">int</span> rob = dp2[<span class="number">1</span>] + nums[i];</span><br><span class="line">                <span class="keyword">int</span> not_rob = <span class="built_in">std</span>::max(dp2[<span class="number">0</span>], dp2[<span class="number">1</span>]);</span><br><span class="line">                dp2[<span class="number">0</span>] = rob;</span><br><span class="line">                dp2[<span class="number">1</span>] = not_rob;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m1 = <span class="built_in">std</span>::max(dp1[<span class="number">0</span>], dp1[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> m2 = <span class="built_in">std</span>::max(dp2[<span class="number">0</span>], dp2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(m1, m2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        dp1 = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        dp2 = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> i &lt; len(nums)<span class="number">-1</span>: <span class="comment"># 允许偷第一家, 不能偷最后一家</span></span><br><span class="line">                rob = dp1[<span class="number">1</span>] + num</span><br><span class="line">                not_rob = max(dp1[<span class="number">0</span>], dp1[<span class="number">1</span>])</span><br><span class="line">                dp1 = [rob, not_rob]</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span>: <span class="comment"># 允许偷最后一家, 不能偷第一家</span></span><br><span class="line">                rob = dp2[<span class="number">1</span>] + num</span><br><span class="line">                not_rob = max(dp2[<span class="number">0</span>], dp2[<span class="number">1</span>])</span><br><span class="line">                dp2 = [rob, not_rob]</span><br><span class="line">        <span class="keyword">return</span> max(dp1[<span class="number">0</span>], dp1[<span class="number">1</span>], dp2[<span class="number">0</span>], dp2[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p>
<h1 id="215-Kth-Largest-Element-in-an-Array"><a href="#215-Kth-Largest-Element-in-an-Array" class="headerlink" title="215. Kth Largest Element in an Array"></a>215. Kth Largest Element in an Array</h1><h2 id="Description-找出无序数组中第k大的数"><a href="#Description-找出无序数组中第k大的数" class="headerlink" title="Description: 找出无序数组中第k大的数"></a>Description: 找出无序数组中第k大的数</h2><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>Example 1:</p>
<p>Input: [3,2,1,5,6,4] and k = 2<br>Output: 5<br>Example 2:</p>
<p>Input: [3,2,3,1,2,4,5,5,6] and k = 4<br>Output: 4</p>
<h2 id="解法一-小顶堆"><a href="#解法一-小顶堆" class="headerlink" title="解法一: 小顶堆"></a>解法一: 小顶堆</h2><p><strong>时间复杂度:</strong> $O(nlogk)$, 堆的插入复杂度为 $O(logk)$, 最多需要进行 $n$ 次插入.<br><strong>空间复杂度:</strong> $O(k)$, 堆的大小</p>
<p>构建一个大小为 $k$ 的小顶堆, 对于任意一个新来的元素, 如果该元素大于堆顶, 将则堆顶退出, 并将该元素插入. 最终, 堆内的元素就是数组的最大的前 $k$ 个元素, 而堆顶刚好为第 $k$ 大的元素.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; heap_k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;        </span><br><span class="line">            <span class="keyword">if</span>(heap_k.size() &lt; k)&#123;</span><br><span class="line">                heap_k.push(num);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt; heap_k.top())&#123;</span><br><span class="line">                heap_k.pop();</span><br><span class="line">                heap_k.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap_k.top();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-部分排序-nth-element"><a href="#解法二-部分排序-nth-element" class="headerlink" title="解法二: 部分排序(nth_element)"></a>解法二: 部分排序(nth_element)</h2><p><a href="http://www.voidcn.com/article/p-qyrpnkse-gx.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-qyrpnkse-gx.html</a></p>
<p><strong>最优解法</strong></p>
<p><strong>时间复杂度:</strong> 平均为 $O(n)$. nth_element 的时间复杂度为 $T(n) = T(n/2) + O(n) = O(n) + O(n/2) + O(n/4) + …$, 也就是 $O(n)$.<br><strong>空间复杂度:</strong> $O(1)$, 不占用额外空间</p>
<p>直接调用 STL 的部分排序算法<code>nth_element</code>.<br><code>nth_element</code>算法将重新排列区间[first, last)的序列元素, 算法执行完毕后, 会使得</p>
<ul>
<li>第 $k$ 个位置的元素在最终的算法执行完毕后, 和整个区间完全排序后该位置的元素相同.</li>
<li>这个新的<code>nth</code>元素之前的所有元素均 &lt;= (&gt;=) <code>nth</code>元素之后的所有元素.<br>但是该算法并不保证位于第 $k$ 个元素两边区间的元素有序. 该算法和 <code>partial_sort</code> 算法之间一个很大的区别在于: <code>nth_element</code>对于除第 $k$ 位置的元素之外的区间元素的顺序不做保证, 而<code>partial_sort</code>排序后会使得前 $m$ 个数的子区间是有序的. 正因为如此, <strong>在需要无序的前 <code>top_k</code> 个值时, <code>nth_element</code> 相对于 <code>partial_sort</code> 要更快.(只需要找第 $k$ 个值, 其前面的元素即为 top_k, 时间复杂度为 $O(n)$). 如果需要有序, 也可以先使用 <code>nth_element</code>, 再对前 k 个数组排序, 总的复杂度为 $O(n+klogk)$</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::nth_element(nums.begin(), nums.begin()+k<span class="number">-1</span>, nums.end(), <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">return</span> nums[k<span class="number">-1</span>];    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-基于-Partition"><a href="#解法三-基于-Partition" class="headerlink" title="解法三: 基于 Partition"></a>解法三: 基于 Partition</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>该解法和解法二思路相同, 只不过是我们自己手动实现 Partition 的算法逻辑, 而不是调用 STL 函数.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>, high=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> pth = Partition(nums, low, high);</span><br><span class="line">        <span class="keyword">while</span>(pth != k<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pth &gt; k<span class="number">-1</span>)</span><br><span class="line">                high = pth<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = pth+<span class="number">1</span>;</span><br><span class="line">            pth = Partition(nums, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[pth];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> P = nums[low];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P&gt;= nums[high]) high--;</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P&lt;=nums[low]) low++;</span><br><span class="line">            nums[high] = nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = P;</span><br><span class="line">        <span class="keyword">return</span> low;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="217-Contains-Duplicate"><a href="#217-Contains-Duplicate" class="headerlink" title="217. Contains Duplicate"></a>217. Contains Duplicate</h1><h2 id="Description-判断数组中是否有重复元素"><a href="#Description-判断数组中是否有重复元素" class="headerlink" title="Description: 判断数组中是否有重复元素"></a>Description: 判断数组中是否有重复元素</h2><p>Given an array of integers, find if the array contains any duplicates.</p>
<p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<p>Example 1:</p>
<p>Input: [1,2,3,1]<br>Output: true<br>Example 2:</p>
<p>Input: [1,2,3,4]<br>Output: false<br>Example 3:</p>
<p>Input: [1,1,1,3,3,4,3,2,4,2]<br>Output: true</p>
<h2 id="解法一-暴力-5"><a href="#解法一-暴力-5" class="headerlink" title="解法一: 暴力"></a>解法一: 暴力</h2><p><strong>时间复杂度:</strong> $O(n^2)$, 暴力求解, 双重循环<br><strong>空间复杂度:</strong> $O(1)$, 无需额外空间</p>
<p>时间超限, 无法通过 OJ</p>
<h2 id="解法二-排序-遍历"><a href="#解法二-排序-遍历" class="headerlink" title="解法二: 排序+遍历"></a>解法二: 排序+遍历</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 先排序, 然后遍历看是否有相邻元素相等, 即 $O(nlogn + n)$, 也就是 $O(nlogn)$.<br><strong>空间复杂度:</strong> $O(1)$, 基于不同的排序算法决定, 使用堆排序则为 $O(1)$.</p>
<h2 id="解法三-unordered-set-哈希"><a href="#解法三-unordered-set-哈希" class="headerlink" title="解法三: unordered_set(哈希)"></a>解法三: unordered_set(哈希)</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历一遍数组, 在 unordered_set 中查询的复杂度为常数<br><strong>空间复杂度:</strong> $O(n)$, unordered_set占用额外空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; nums_set;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums_set.find(num) == nums_set.end())</span><br><span class="line">                nums_set.insert(num);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="218-The-Skyline-Problem"><a href="#218-The-Skyline-Problem" class="headerlink" title="218. The Skyline Problem"></a>218. The Skyline Problem</h1><h2 id="Description-天际线问题"><a href="#Description-天际线问题" class="headerlink" title="Description: 天际线问题"></a>Description: 天际线问题</h2><p>A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).</p>
<p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fxr32nc4xoj215u0guq3p.jpg" alt=""></p>
<p>The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 &lt; Hi ≤ INT_MAX, and Ri - Li &gt; 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</p>
<p>For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .</p>
<p>The output is a list of “key points” (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], … ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.</p>
<p>For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].</p>
<h2 id="解法一-multiset"><a href="#解法一-multiset" class="headerlink" title="解法一: multiset"></a>解法一: multiset</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 拆分三元组到二元组为 $O(n)$, 排序为 $O(nlogn)$, 更新轮廓节点为 $O(nlogn)$ (插入高度为 $O(log)$, 总共有 $O(n)$ 组高度).<br><strong>空间复杂度:</strong> $O(n)$, 存储高度的二元组 vector, 以及维护当前建筑物高度顺序的 multiset.</p>
<p>首先我们将表示建筑物的所有三元组<code>(Li, Ri, Hi)</code>进行拆分, 将其分成<code>(Li, -Hi)</code>, <code>(Ri, Hi)</code>的两个二元组, 将这些二元组存放在一个数组 vector 中, 然后按照 x 轴的下标进行排序, 注意如果当一个建筑物的右侧和另一个建筑物的左侧重叠时, 我们为了不丢失当前建筑物的高度, 必须先考虑将另一个建筑物的左侧添加进 multiset 里, 然后获取最高高度. 接着在下一次循环时, 再将重合的右侧边界对应的建筑物剔除, 因此我们需要令二元组中的左侧为负, 使其在排序时可以排到前面.<br>得到有序的建筑物二元组序列以后, 我们遍历该序列, 如果遇到了某个建筑物的左侧边界, 则将该边界对应建筑物的高度加入到 multiset 中, 如果遇到了某个建筑物的右侧边界, 则将对应建筑物的高度剔除. 假设我们已经得到了前 i 个坐标的建筑物组成的轮廓坐标点, 现在来到第 i+1 个坐标, 只有可能对应下面几种情况:</p>
<ul>
<li>i+1 坐标上新来的建筑物(遇到该建筑物左侧就行)完全被之前的建筑物覆盖, 此时不更新 res 轮廓. 说明添加了该建筑物后, 并不改变当前建筑群的最高高度.</li>
<li>i+1 坐标上新来的建筑物比当前建筑群最高的高度还要高, 则需要记录当前的点.</li>
<li>i+1 坐标上没有新来建筑物, 但是有一个建筑物遇到了右侧边界, 此时建筑群的高度会变成第二高建筑物的高度, 同样需要记录当前的坐标点.</li>
<li>i+1 坐标上既没有新来建筑物, 也没有遇到建筑物右侧, 此时无需记录任何值, 可继续探测 i+2 坐标.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; getSkyline(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; buildings) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; heights, res; <span class="comment">// height 用于存放建筑物的高度, res存放结果</span></span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; m; <span class="comment">// 用 multiset 数据结构来维护当前x坐标之前的建筑物高度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;b : buildings)&#123;</span><br><span class="line">            <span class="comment">//用负高度代表当前的边是左侧的边. 因为后面有排序, 所以必须令左侧为负, 而不能令右侧为负.</span></span><br><span class="line">            <span class="comment">//因为当x坐标相同时, 当前的building的右侧还不能剔除,</span></span><br><span class="line">            <span class="comment">//否则, 有可能"低估" 轮廓高度所以要将左侧的排在前面</span></span><br><span class="line">            heights.push_back(&#123;b[<span class="number">0</span>], -b[<span class="number">2</span>]&#125;);</span><br><span class="line">            heights.push_back(&#123;b[<span class="number">1</span>], b[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(heights.begin(), heights.end()); <span class="comment">// 按照x坐标排序, 当x一样时, 按照高度排序</span></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>; <span class="comment">// pre代表之前的最高建筑物的高度, 初始为0</span></span><br><span class="line">        <span class="keyword">int</span> cur; <span class="comment">// cur 代表当前的最高建筑物的高度, 会在for循环中赋值.</span></span><br><span class="line">        m.insert(<span class="number">0</span>); <span class="comment">// 开始的时候, m中的最高高度为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;h : heights)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h.second &lt; <span class="number">0</span>) m.insert(-h.second); <span class="comment">// 如果是左侧边, 则加入当前建筑物高度集合, 并自动排序</span></span><br><span class="line">            <span class="keyword">else</span> m.erase(m.find(h.second)); <span class="comment">// 如果遇到了右侧边, 则将对应的建筑物从当前建筑物集合内剔除</span></span><br><span class="line">            <span class="comment">// 注意, 这里在使用erase时, 是先找到key值匹配的某一个元素的迭代器(多个存在多个匹配), 然后再删除</span></span><br><span class="line">            <span class="comment">// 如果直接使用 erase(key) 的话, 则会将满足key值的所有元素都擦除, 这样会导致程序出错.</span></span><br><span class="line">            cur = * m.rbegin(); <span class="comment">// 获取当前的最大高度</span></span><br><span class="line">            <span class="keyword">if</span>(cur != pre)&#123; <span class="comment">// 说明此时要么新加入了更高的高度, 要么被用于最高高度的建筑物被剔除, 需要更新轮廓点</span></span><br><span class="line">                res.push_back(&#123;h.first, cur&#125;); <span class="comment">//新更新的轮廓点的x坐标即为当前h的x坐标.</span></span><br><span class="line">                pre = cur; <span class="comment">// 更新pre</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-priority-queue-堆"><a href="#解法二-priority-queue-堆" class="headerlink" title="解法二: priority_queue(堆)"></a>解法二: priority_queue(堆)</h2><p>在解法一中, 用了 multiset, 之所以不用 priority_queue 的原因是因为, C++ 的 priority_queue 容器并没有提供<code>erase</code>或者<code>find</code>之类的方法, 因此, 在删除指定高度时, 比较麻烦. 而 multiset 不仅完成堆的功能(最后一个元素就是最大的), 同时还支持在对数复杂度时间内删除指定的高度.</p>
<p>因此, 如果想要使用 priority_queue 的话, 就需要调整算法的逻辑, 下面是使用 priority_queue 的解法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; getSkyline(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; buildings) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, cur_X, cur_H = <span class="number">-1</span>, len = buildings.size();</span><br><span class="line">        <span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; liveBlg;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; len <span class="keyword">or</span> !liveBlg.empty()) &#123;</span><br><span class="line">            cur_X = liveBlg.empty() ? buildings[cur][<span class="number">0</span>] : liveBlg.top().second;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur &gt;= len <span class="keyword">or</span> buildings[cur][<span class="number">0</span>] &gt; cur_X) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!liveBlg.empty() &amp;&amp; (liveBlg.top().second &lt;= cur_X)) &#123;</span><br><span class="line">                    liveBlg.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur_X = buildings[cur][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">while</span> (cur &lt; len &amp;&amp; buildings[cur][<span class="number">0</span>] == cur_X) &#123;</span><br><span class="line">                    liveBlg.push(&#123;buildings[cur][<span class="number">2</span>], buildings[cur][<span class="number">1</span>]&#125;);</span><br><span class="line">                    cur++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur_H = liveBlg.empty() ? <span class="number">0</span> : liveBlg.top().first;</span><br><span class="line">            <span class="keyword">if</span> (res.empty() <span class="keyword">or</span> (res.back().second != cur_H)) &#123;</span><br><span class="line">                res.push_back(&#123;cur_X, cur_H&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a>221. 最大正方形</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximal-square/</a></p>
<h2 id="解法一-动态规划-1"><a href="#解法一-动态规划-1" class="headerlink" title="解法一: 动态规划"></a>解法一: 动态规划</h2><p>时间复杂度：$O(mn)$<br>空间复杂度: $O(n)$</p>
<p>申请一个长度为矩阵列数的一维数组<code>dp</code>, <code>dp[j]</code>代表以<code>matrix[i][j]</code>为结尾的正方形的边长, 于是当我们计算矩阵中以某个点为右下角的正方形边长时, 就可以利用右上角已经计算过的变量直接获取相应的信息, 这里在使用<code>dp</code>时, 需要注意的一点是, 由于仅仅需要右上角的值, 因此, 每次新的<code>dp</code>生成时, 都要向后移一位, 前面补0.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] != <span class="string">'0'</span>: <span class="comment"># 注意, 字符 '0' 在 bool 中是 True 的, 所以不能直接用 if matrix[i][j]</span></span><br><span class="line">                    edge = dp[j]</span><br><span class="line">                    k = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> (k &lt;= edge <span class="keyword">and</span> matrix[i-k][j]!=<span class="string">'0'</span> <span class="keyword">and</span> matrix[i][j-k]!=<span class="string">'0'</span>): <span class="comment"># 利用之前已经求得的正方形基础上算当前正方形边长</span></span><br><span class="line">                        k += <span class="number">1</span></span><br><span class="line">                    dp[j] = k <span class="comment"># 更新正方形边长</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = <span class="number">0</span></span><br><span class="line">                res = max(res, dp[j]) <span class="comment"># 更新 res</span></span><br><span class="line">            dp = [<span class="number">0</span>] + dp[<span class="number">0</span>:<span class="number">-1</span>] <span class="comment"># dp 数组最前方加0, 其他元素后移, 最后一个元素再后面用不到, 舍去</span></span><br><span class="line">        <span class="keyword">return</span> res*res</span><br></pre></td></tr></table></figure>
<h2 id="解法二-优化的动态规划"><a href="#解法二-优化的动态规划" class="headerlink" title="解法二: 优化的动态规划"></a>解法二: 优化的动态规划</h2><p>时间复杂度：$O(mn)$<br>空间复杂度: $O(1)$</p>
<p>由于仅仅需要右上角的值, 因此我们可以把<code>dp</code>压缩到一个常数, 此时<code>matrix</code>的便利方式就不能是先行后列了, 而应该是沿着对角线进行遍历才行.</p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; m <span class="keyword">or</span> j &lt; n:</span><br><span class="line">            <span class="keyword">if</span> i &lt; m:</span><br><span class="line">                ii = i</span><br><span class="line">                jj = <span class="number">0</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> j &lt; n:</span><br><span class="line">                ii = <span class="number">0</span></span><br><span class="line">                jj = j</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            dp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> ii &lt; m <span class="keyword">and</span> jj &lt; n:</span><br><span class="line">                <span class="keyword">if</span> matrix[ii][jj] == <span class="string">'0'</span>:</span><br><span class="line">                    dp = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    edge = dp</span><br><span class="line">                    k = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> (k &lt;= edge <span class="keyword">and</span> matrix[ii-k][jj] == <span class="string">'1'</span> <span class="keyword">and</span> matrix[ii][jj-k] == <span class="string">'1'</span>):</span><br><span class="line">                        k += <span class="number">1</span></span><br><span class="line">                    dp = k</span><br><span class="line">                res = max(res, dp)</span><br><span class="line">                ii += <span class="number">1</span></span><br><span class="line">                jj += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res*res</span><br></pre></td></tr></table></figure></p>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>, ii = <span class="number">0</span>, jj = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m <span class="keyword">or</span> j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; m) &#123;</span><br><span class="line">                ii = i;</span><br><span class="line">                jj = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; n) &#123;</span><br><span class="line">                ii = <span class="number">0</span>;</span><br><span class="line">                jj = j;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> dp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (ii &lt; m <span class="keyword">and</span> jj &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[ii][jj] == <span class="string">'0'</span>)</span><br><span class="line">                    dp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (k &lt;= dp <span class="keyword">and</span> matrix[ii-k][jj] == <span class="string">'1'</span> <span class="keyword">and</span> matrix[ii][jj-k] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp = k;</span><br><span class="line">                &#125;</span><br><span class="line">                ii++; jj++;</span><br><span class="line">                res = <span class="built_in">std</span>::max(res, dp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invert-binary-tree/</a></p>
<p>谷歌: 我们90％的工程师使用您编写的软件(Homebrew), 但是您却无法在面试时在白板上写出翻转二叉树这道题, 这太糟糕了.</p>
<h2 id="解法一-递归-15"><a href="#解法一-递归-15" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>Python 实现:</strong></p>
<p>编写递归函数, 先翻转两个子树, 再把左右子树翻转<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">invert</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            invert(root.right)</span><br><span class="line">            invert(root.left)</span><br><span class="line">            root.right, root.left = root.left, root.right</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        invert(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p>先翻转左右节点, 再翻转子树也可以:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">invert</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            root.right, root.left = root.left, root.right</span><br><span class="line">            invert(root.right)</span><br><span class="line">            invert(root.left)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        invert(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p><strong>C++ 实现(先根, 其他同理):</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">std</span>::swap(root-&gt;right, root-&gt;left);</span><br><span class="line">        invertTree(root-&gt;left);</span><br><span class="line">        invertTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-迭代-10"><a href="#解法二-迭代-10" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p>该题用递归非常好解, 所以如果面试问道, 一定会考察迭代解法. 核心思想就是遍历二叉树的每一个节点, 然后把节点的的左右子树交换即可, 故而有先根, 中根, 后根遍历三种解法, 分别如下:</p>
<p>先根遍历<br><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> node != <span class="keyword">None</span> <span class="keyword">or</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> node != <span class="keyword">None</span>:</span><br><span class="line">                node.left, node.right = node.right, node.left <span class="comment"># 先根遍历</span></span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.right <span class="comment"># 左右子树已经交换了, 所以要入栈原来的左子树, 就需要入栈right</span></span><br><span class="line"></span><br><span class="line">            node = stack.pop()</span><br><span class="line">            node = node.left <span class="comment">#  注意, 由于已经将左右子树交换了, 所以这里的左子树实际是原来未入栈的右子树</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p>实际上, 树的左右孩子是等价的, 因此, 即使这里入栈交换后的left, 也没有问题, 只要保证后面即将入栈的和之前入栈是相反的孩子即可.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> node != <span class="keyword">None</span> <span class="keyword">or</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> node != <span class="keyword">None</span>:</span><br><span class="line">                node.left, node.right = node.right, node.left <span class="comment"># 先根遍历</span></span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left <span class="comment"># 实际上, 树的左右孩子是等价的, 因此, 即使这里入栈交换后的left, 也没有问题,</span></span><br><span class="line">            node = stack.pop()</span><br><span class="line">            node = node.right <span class="comment">#  只要保证这里即将入栈的和之前入栈是相反的孩子即可</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">auto</span> node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span> <span class="keyword">or</span> !s.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(node-&gt;left, node-&gt;right);</span><br><span class="line">                s.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = s.top(); s.pop();</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>中根遍历<br><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> node != <span class="keyword">None</span> <span class="keyword">or</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> node != <span class="keyword">None</span>:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left</span><br><span class="line">            <span class="comment"># 中根遍历</span></span><br><span class="line">            node = stack.pop()</span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line">            node = node.left <span class="comment">#  注意, 由于已经将左右子树交换了, 所以这里的左子树实际是原来未入栈的右子树</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">auto</span> node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span> <span class="keyword">or</span> !s.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                s.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = s.top(); s.pop();</span><br><span class="line">            <span class="built_in">std</span>::swap(node-&gt;left, node-&gt;right);</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>后根遍历<br><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        pre = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> node != <span class="keyword">None</span> <span class="keyword">or</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> node != <span class="keyword">None</span>:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left <span class="comment"># 实际上, 树的左右孩子是等价的, 因此, 即使这里入栈交换后的left, 也没有问题,</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> pre == stack[<span class="number">-1</span>].right <span class="keyword">or</span> stack[<span class="number">-1</span>].right == <span class="keyword">None</span>: <span class="comment"># 只有当右子树为空或者已经访问过时, 才能访问根</span></span><br><span class="line">                r_node = stack.pop() <span class="comment"># 注意, 访问根时, 不能将根的值赋给 node, 否则外部node会陷入死循环</span></span><br><span class="line">                pre = r_node</span><br><span class="line">                r_node.left, r_node.right = r_node.right, r_node.left <span class="comment"># 交换左右子树</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = stack[<span class="number">-1</span>].right</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">auto</span> node = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span> <span class="keyword">or</span> !s.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                s.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> tmpnode = s.top();</span><br><span class="line">            <span class="keyword">if</span> (tmpnode-&gt;right == <span class="literal">nullptr</span> <span class="keyword">or</span> tmpnode-&gt;right == pre) &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                pre = tmpnode;</span><br><span class="line">                <span class="built_in">std</span>::swap(tmpnode-&gt;right, tmpnode-&gt;left);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = tmpnode-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="227-Basic-Calculator-II"><a href="#227-Basic-Calculator-II" class="headerlink" title="227. Basic Calculator II"></a>227. Basic Calculator II</h1><h2 id="Description-基本计算器-二"><a href="#Description-基本计算器-二" class="headerlink" title="Description: 基本计算器(二)"></a>Description: 基本计算器(二)</h2><p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string contains only non-negative integers, +, -, * , / operators and empty spaces . The integer division should truncate toward zero.</p>
<p>Example 1:</p>
<p>Input: “3+2*2”<br>Output: 7<br>Example 2:</p>
<p>Input: “ 3/2 “<br>Output: 1<br>Example 3:</p>
<p>Input: “ 3+5 / 2 “<br>Output: 5</p>
<h2 id="解法一-栈-2"><a href="#解法一-栈-2" class="headerlink" title="解法一: 栈"></a>解法一: 栈</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历字符串一遍, 遍历栈一遍<br><strong>空间复杂度:</strong> $O(n)$, 栈的大小</p>
<p>因为本题没有带括号, 因此优先级关系比较明朗, 可以简单的用栈来实现. 对于任意一个符号, 如果是加号或者减号, 就直接将其后面的数字入栈, 其中减号的情况需要给入栈数字加负号. 如果是乘号或除号, 将先从栈顶取出一个数字, 然后将该数字与符号后的数字进行计算, 并将计算结果入栈. 如此遍历, 直到遍历完所有字符, 最终将栈中的所有数字相加.<br>此题需要注意两个地方, 一是对于第一个数字, 需要在特别的将该数字前的符号对应成加号. 二是需要处理字符串中出现的空格.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; cal_s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); )&#123;</span><br><span class="line">            <span class="keyword">while</span>(i!=s.size() &amp;&amp; s[i] == <span class="string">' '</span>) i++; <span class="comment">// 跳过空格</span></span><br><span class="line">            <span class="keyword">if</span>(i==s.size()) <span class="keyword">break</span>; <span class="comment">// 达到字符串尾部, 直接跳出</span></span><br><span class="line">            <span class="keyword">char</span> op;</span><br><span class="line">            <span class="keyword">if</span>(cal_s.empty()) op = <span class="string">'+'</span>;</span><br><span class="line">            <span class="keyword">else</span>  op = s[i++];</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s[i] == <span class="string">' '</span>) i++; <span class="comment">// 跳过空格</span></span><br><span class="line">            <span class="keyword">while</span>( i!=s.size() &amp;&amp; s[i] &lt;= <span class="string">'9'</span> &amp;&amp; s[i] &gt;= <span class="string">'0'</span>)&#123;</span><br><span class="line">                num = num*<span class="number">10</span> + s[i++] - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> pre_num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>: cal_s.push(num); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>: cal_s.push(-num); <span class="keyword">break</span>;</span><br><span class="line">                case '* ':</span><br><span class="line">                    pre_num = cal_s.top(); cal_s.pop();</span><br><span class="line">                    cal_s.push(pre_num * num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                    pre_num = cal_s.top(); cal_s.pop();</span><br><span class="line">                    cal_s.push(pre_num / num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> op; <span class="comment">//error</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!cal_s.empty())&#123;</span><br><span class="line">            res += cal_s.top();</span><br><span class="line">            cal_s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-字符串流"><a href="#解法二-字符串流" class="headerlink" title="解法二: 字符串流"></a>解法二: 字符串流</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历每个字符<br><strong>空间复杂度:</strong> $O(1)$, 无需额外空间</p>
<p>字符串流可以自动的格式化读取字符串信息, 简化了代码编写量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(<span class="string">"+"</span>+s+<span class="string">"+"</span>)</span></span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>, pre_num = <span class="number">0</span>, num;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        <span class="keyword">while</span>(in&gt;&gt;op) &#123;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="string">'+'</span> <span class="keyword">or</span> op == <span class="string">'-'</span>) &#123;</span><br><span class="line">                sum += pre_num;</span><br><span class="line">                in &gt;&gt; pre_num;</span><br><span class="line">                <span class="keyword">int</span> sign = (op == <span class="string">'+'</span> ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">                pre_num * = sign;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                in &gt;&gt; num;</span><br><span class="line">                <span class="keyword">if</span> (op == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    pre_num * = num;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'/'</span>) &#123;</span><br><span class="line">                    pre_num /= num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="230-Kth-Smallest-Element-in-a-BST"><a href="#230-Kth-Smallest-Element-in-a-BST" class="headerlink" title="230. Kth Smallest Element in a BST"></a>230. Kth Smallest Element in a BST</h1><h2 id="Description-找出二叉搜索树中的最小元素"><a href="#Description-找出二叉搜索树中的最小元素" class="headerlink" title="Description: 找出二叉搜索树中的最小元素"></a>Description: 找出二叉搜索树中的最小元素</h2><p>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</p>
<p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p><strong>Follow up:</strong><br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>
<h2 id="解法一-非递归中根遍历"><a href="#解法一-非递归中根遍历" class="headerlink" title="解法一: 非递归中根遍历"></a>解法一: 非递归中根遍历</h2><p><strong>时间复杂度:</strong> $O(k)$, 遍历到第 $k$ 个元素为止<br><strong>空间复杂度:</strong> $O(k)$, 栈中最多存储 $k$ 个元素.</p>
<p>非递归中根遍历二叉搜索树, 当遍历到第k个元素时, 将其返回.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">1</span>) <span class="keyword">return</span> INT_MIN;<span class="comment">// error</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span> || !s.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">                cur = s.top(); s.pop();</span><br><span class="line">                <span class="keyword">if</span>(++count == k)&#123;</span><br><span class="line">                    <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INT_MIN;<span class="comment">// error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-递归中根遍历"><a href="#解法二-递归中根遍历" class="headerlink" title="解法二: 递归中根遍历"></a>解法二: 递归中根遍历</h2><p><strong>时间复杂度:</strong> $O(k)$<br><strong>空间复杂度:</strong> $O(k)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        helper(root, count, k, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode * root, <span class="keyword">int</span> &amp;count, <span class="keyword">int</span> &amp;k, <span class="keyword">int</span> &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==k || root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; <span class="comment">// 如果已经统计了k个, 则直接返回</span></span><br><span class="line">        helper(root-&gt;left, count, k, res);</span><br><span class="line">        <span class="keyword">if</span>(count==k) <span class="keyword">return</span>; <span class="comment">// 如果已经统计了k个, 则直接返回 // 加上该语句可省去后面的过程, 加速迭代结束, 当然不加也可以</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(++count == k)&#123; <span class="comment">// 访问当前节点</span></span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count!=k) helper(root-&gt;right, count, k, res); <span class="comment">// 如果已经统计了k个, 则不再遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>更简洁的写法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; count, <span class="keyword">int</span> k, <span class="keyword">int</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        helper(root-&gt;left, count, k, res);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(k == count) &#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root-&gt;right, count, k, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        helper(root, count, k, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-二叉搜索"><a href="#解法三-二叉搜索" class="headerlink" title="解法三: 二叉搜索"></a>解法三: 二叉搜索</h2><p><strong>时间复杂度:</strong> $O(logn)+ O(n)$, 搜索的复杂度为树的高度, 但是计算count的复杂度为 $O(n)$.<br><strong>空间复杂度:</strong> $O(logn)$, 递归占用的空间, 若采用非递归实现, 则空间复杂度为 $O(1)$.</p>
<p>二叉搜索, 统计当前节点之前的元素个数, 如果大于 $k$, 则继续在左子树中搜索第 $k$ 小的元素, 如果 count 小于 $k$ , 则在右子树中搜索第 $k-count-1$ 小的元素.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = countNode(root-&gt;left); <span class="comment">// 左子树元素个数</span></span><br><span class="line">        <span class="keyword">if</span>(count+<span class="number">1</span> &gt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> kthSmallest(root-&gt;left, k);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count+<span class="number">1</span> &lt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> kthSmallest(root-&gt;right, k - count - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNode</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+countNode(root-&gt;left)+countNode(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解答Follow-up"><a href="#解答Follow-up" class="headerlink" title="解答Follow up"></a>解答Follow up</h2><p><strong>方法一:</strong></p>
<p>根据解法三我们可以知道, 在计算子树节点个数的时候 <code>int count = countNode(root-&gt;left);</code>, 有很多的重复计算, 因此, 我们可以修改树的结构定义, 使得每个节点都持有其左子树中的节点个数, 那么在查找第 $k$ 小的元素的时候, 就可以用 $O(1)$ 的时间复杂度获取到左子树的节点个数, 因此, 最终查询第 $k$ 小的时间复杂度变为 $O(logn)$.</p>
<p><strong>方法二:</strong></p>
<p>在中根遍历的同时, 用一个大小为 $k$ 的大顶堆(<code>priority_queue</code>), 这些可以将二叉搜索树中最小的 $k$ 个数存储起来, 并且可以用 $O(1)$ 的时间复杂度获取到第 $k$ 小的元素. (二叉搜索树的中根遍历下, 未遍历到的都是较大的元素, 因此无需遍历整个树, 只需要遍历到第 $k$ 个元素即可). 在对树进行修改时, 同步更新大顶堆, 前者时间复杂度为 $O(logn)$, 后者为 $O(logk)$.</p>
<h1 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234. Palindrome Linked List"></a>234. Palindrome Linked List</h1><h2 id="Description-回文链表判断"><a href="#Description-回文链表判断" class="headerlink" title="Description: 回文链表判断"></a>Description: 回文链表判断</h2><p>Given a singly linked list, determine if it is a palindrome.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p><strong>Follow up:</strong><br>Could you do it in O(n) time and O(1) space?</p>
<h2 id="解法一-借助辅助数组"><a href="#解法一-借助辅助数组" class="headerlink" title="解法一: 借助辅助数组"></a>解法一: 借助辅助数组</h2><p><strong>时间复杂度:</strong> $O(n)$, 两次遍历<br><strong>空间复杂度:</strong> $O(n)$, 额外数组</p>
<p>最简单的做法就是遍历链表, 将其转换成一个可随机访问的数组, 然后进行回文串的判断.</p>
<h2 id="解法二-不借助辅助数组"><a href="#解法二-不借助辅助数组" class="headerlink" title="解法二: 不借助辅助数组"></a>解法二: 不借助辅助数组</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>先利用两个指针变量<code>slow</code>和<code>fast</code>找到链表的中点(<code>slow</code>每次走一步, <code>fast</code>每次走两步), 然后将后半段逆置, 接着将前半段和后半段进行比较. 最后根据具体需要将链表后半段复原. (在实际工作中, 不存在 $O(1)$ 空间复杂度的解法, 因为通常情况下是不允许修改链表的值的).</p>
<p><strong>不复原链表:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = node-&gt;next;</span><br><span class="line">            node-&gt;next = prev;</span><br><span class="line">            prev = node;</span><br><span class="line">            node = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast != <span class="literal">nullptr</span>) &#123; <span class="comment">// 奇数个节点, 始终令slow指向后半段的开始节点</span></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = reverseList(slow); <span class="comment">// 令slow指向后半段逆置后的开始节点</span></span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;val == slow-&gt;val) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow == <span class="literal">nullptr</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复原链表:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span> &amp;&amp; fast-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode * rail = slow; <span class="comment">// 记录前半段的最后一个节点, 以便复原链表</span></span><br><span class="line">        slow = slow-&gt;next; <span class="comment">// 令slow指向回文串后半段的第一个节点</span></span><br><span class="line">        ListNode *rhead = reverseList(slow); <span class="comment">// 令fast 指向回文串后半段逆置后的连接头(奇数回文串时, 中间的节点算作前半段)</span></span><br><span class="line">        slow = head;</span><br><span class="line">        fast = rhead;</span><br><span class="line">        <span class="keyword">bool</span> res=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow!=<span class="literal">nullptr</span> &amp;&amp; fast!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow-&gt;val != fast-&gt;val)&#123;</span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;        </span><br><span class="line">        rail-&gt;next = reverseList(rhead); <span class="comment">// 复原链表</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *cur)</span></span>&#123;</span><br><span class="line">        ListNode* next = cur-&gt;next;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">            <span class="keyword">if</span>(next!=<span class="literal">nullptr</span>) next = next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a>236. Lowest Common Ancestor of a Binary Tree</h1><h2 id="Description-查找二叉树中任意两个节点的公共祖先"><a href="#Description-查找二叉树中任意两个节点的公共祖先" class="headerlink" title="Description: 查找二叉树中任意两个节点的公共祖先"></a>Description: 查找二叉树中任意两个节点的公共祖先</h2><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p>
<p>Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______3______</span><br><span class="line">    /              \</span><br><span class="line"> __5__           __1__</span><br><span class="line">/      \        /      \</span><br><span class="line">6       2       0       8</span><br><span class="line">       /  \</span><br><span class="line">      7   4</span><br></pre></td></tr></table></figure></p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of nodes 5 and 1 is 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>All of the nodes values will be unique.</li>
<li>p and q are different and both values will exist in the binary tree.</li>
</ul>
<h2 id="解法一-递归-16"><a href="#解法一-递归-16" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(n)$, 需遍历 $n$ 个节点.(任何情况下都需遍历n个节点)<br><strong>空间复杂度:</strong> $O(n)$, 需进行 $n$ 次递归调用.( $n$ 包含空节点)</p>
<p>对于最小公共祖先来说, 它相对于其他祖先有一个特点, 即节点 <code>p</code> 和 <code>q</code> 只可能是以下面三种情况分布在树中:</p>
<ul>
<li><code>p</code>和<code>q</code>分别处于当前节点的左子树 <strong>和</strong> 右子树之中.</li>
<li><code>p</code>为当前节点, <code>q</code>处于当前节点的左子树 <strong>或</strong> 右子树之中</li>
<li><code>q</code>为当前节点, <code>p</code>处于当前节点的左子树 <strong>或</strong> 右子树之中</li>
</ul>
<p>而对于其他祖先来说, <strong>绝对不可能出现上面三种情况</strong>, 因为 <strong><code>p</code>和<code>q</code>一定处于其他祖先的同一侧子树之中.</strong>, 即要么都处在右子树中, 要么都处在左子树中. 因此我们可以用<code>p</code>和<code>q</code>在当前节点构成的子树中的分布情况来判断是否为最小祖先.</p>
<p>**注意, 题目中说了<code>p, q</code>一定存在, 并且树中节点都是唯一的, 因此, 下面的代码无需对<code>p, q</code>进行存在性检查.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode * left;</span></span><br><span class="line"><span class="comment"> *     TreeNode * right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* res = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        res = <span class="literal">nullptr</span>;</span><br><span class="line">        recurseHelper(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">recurseHelper</span><span class="params">(TreeNode * root, TreeNode * p, TreeNode * q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)  <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 遇到空节点, 说明没有目标节点               </span></span><br><span class="line">        <span class="keyword">int</span> left = recurseHelper(root-&gt;left, p, q) ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 左子树中有p或q</span></span><br><span class="line">        <span class="keyword">int</span> right = recurseHelper(root-&gt;right, p, q) ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 右子树中有p或q</span></span><br><span class="line">        <span class="keyword">int</span> mid =  (root==p || root==q) ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 找到了p或q, 这里相当于做了存在性检查</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( left+right+mid &gt;= <span class="number">2</span>) res = root; <span class="comment">// 如果左,右或当前节点中有两个以上为true, 则说明当前节点为最小公共祖先</span></span><br><span class="line">        <span class="keyword">return</span> (left+right+mid)&gt;<span class="number">0</span>; <span class="comment">// 只要不是空节点, 就可以返回 true.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面用了是将<code>res</code>作为成员函数进行赋值, 更好的做法是用指针引用.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        TreeNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">        lcaHelper(root, p, q, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lcaHelper</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q, TreeNode*&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> left= lcaHelper(root-&gt;left, p, q, res) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = lcaHelper(root-&gt;right, p, q, res) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (root == p || root == q) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left+right+mid &gt;= <span class="number">2</span>) res = root;</span><br><span class="line">        <span class="keyword">return</span> (left+right+mid) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-迭代-存储父节点"><a href="#解法二-迭代-存储父节点" class="headerlink" title="解法二: 迭代(存储父节点)"></a>解法二: 迭代(存储父节点)</h2><p><strong>时间复杂度:</strong> $O(n)$, 最坏需遍历 $n$ 个节点.<br><strong>空间复杂度:</strong> $O(n+n+n) = O(n)$, 栈, 哈希表, 集合的空间复杂度在最坏情况下均为 $O(n)$</p>
<p>如果我们能够获取到父节点, 那么我们就可以反向遍历<code>q</code>和<code>p</code>来访问他们的祖先节点. 那么, 第一个公共的祖先节点就一定是 LCA node. 我们可以将节点的父节点指针保存在一个字典(hash)当中. 具体的算法流程如下所示:</p>
<ol>
<li>从根节点开始遍历整个树(任意一种遍历算法都可以, 只要能找到<code>p</code>和<code>q</code>即可);</li>
<li>直到找到节点<code>p</code>和<code>q</code>之前, 将所有节点的父节点都保存在字典(hash)中;</li>
<li>一旦我们找到了<code>q</code>和<code>q</code>, 我们就将所有<code>p</code>的祖先节点放入了一个集合(set)当中;</li>
<li>然后, 我们反向遍历<code>q</code>的祖先节点, 当找到一个存在时集合中的祖先节点时, 该节点就是第一个公共的租店节点, 也就是 LCA node, 将其返回.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;TreeNode*, TreeNode*&gt; hash;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;TreeNode*&gt; ancestors;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            s.push(root);</span><br><span class="line">            hash.insert(&#123;root, <span class="literal">nullptr</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(hash.find(p) == hash.end() || hash.find(q) == hash.end()) &#123;</span><br><span class="line">            TreeNode* node = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                hash.insert(&#123;node-&gt;left, node&#125;);   </span><br><span class="line">                s.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                hash.insert(&#123;node-&gt;right, node&#125;);</span><br><span class="line">                s.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* parent = p;</span><br><span class="line">        <span class="keyword">while</span> (parent != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ancestors.insert(parent);</span><br><span class="line">            parent = hash[parent];   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* lcaNode = q;</span><br><span class="line">        <span class="keyword">while</span> (ancestors.find(lcaNode) == ancestors.end()) &#123;</span><br><span class="line">            lcaNode = hash[lcaNode];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcaNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-迭代-不存储父节点"><a href="#解法三-迭代-不存储父节点" class="headerlink" title="解法三: 迭代(不存储父节点)"></a>解法三: 迭代(不存储父节点)</h2><p><strong>时间复杂度:</strong> $O(n)$, 最坏需遍历 $n$ 个节点.<br><strong>空间复杂度:</strong> $O(n)$, 采用后序遍历, 只需维护一个栈, 空间复杂度在最坏情况下为 $O(n)$</p>
<p>在解法二中, 我们是通过反向遍历的方法来查找 LCA 的, 实际上我们可以省去这一步, 直接要一个指针时刻指向可能的 LCA, 当我们找到<code>p</code>和<code>q</code>两个节点时, 我们可以直接返回当前的 LCA. 具体算法步骤如下:</p>
<ol>
<li>从根节点开始;</li>
<li>将<code>(root, root_state)</code>压入栈中, <code>root_state</code>定义了根节点的剩余的子节点是否可以被遍历;</li>
<li>当栈非空时, 查看栈顶元素<code>(parent_node, parent_state)</code>;</li>
<li>在遍历<code>parent_node</code>的任何子节点之前, 首先确认<code>parent_node</code>是否是节点<code>p</code>或<code>q</code>;</li>
<li>当首次找到<code>p</code>或<code>q</code>时, 将标志变量<code>one_node_found</code>设置为<code>True</code>. 同时根据栈中的节点跟踪 LCA (栈中的所有元素都是当前节点的祖先);</li>
<li>当再次找到<code>p</code>或<code>q</code>时, 说明我们已经将两个节点都找到了, 此时返回 LCA node.</li>
<li>无论何时访问<code>parent_node</code>的子节点, 都需要将<code>(parent_node, updated_parent_state)</code>更新到栈中.</li>
<li>A node finally gets popped off from the stack when the state becomes BOTH_DONE implying both left and right subtrees have been pushed onto the stack and processed. If one_node_found is True then we need to check if the top node being popped could be one of the ancestors of the found node. In that case we need to reduce LCA_index by one. Since one of the ancestors was popped off</li>
</ol>
<p>Whenever both p and q are found, LCA_index would be pointing to an index in the stack which would contain all the common ancestors between p and q. And the LCA_index element has the lowest ancestor common between p and q.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> &#123;</span></span><br><span class="line">        BOTH_PENDING = <span class="number">2</span>, <span class="comment">// 代表左右子节点均未访问</span></span><br><span class="line">        LEFT_DONE = <span class="number">1</span>, <span class="comment">// 代表已经访问了一个节点</span></span><br><span class="line">        BOTH_DONE = <span class="number">0</span> <span class="comment">// 代表两个子节点都已经访问, 当前节点可以出栈</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="built_in">std</span>::pair&lt;TreeNode*, State&gt; &gt; s;</span><br><span class="line">        s.push(<span class="built_in">std</span>::make_pair(root, State::BOTH_PENDING));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> one_node_found = <span class="literal">false</span>; <span class="comment">// 标记是否找到p或q</span></span><br><span class="line">        TreeNode* LCA = <span class="literal">nullptr</span>; <span class="comment">// 跟踪LCA</span></span><br><span class="line">        TreeNode* child_node = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> top  = s.top();</span><br><span class="line">            TreeNode* parent_node = top.first;</span><br><span class="line">            State parent_state = top.second;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (parent_state != State::BOTH_DONE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent_state == State::BOTH_PENDING) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent_node == p || parent_node == q) &#123;</span><br><span class="line">                        <span class="comment">// 找到了 p 或 q 中的一个, 如果是第二次找到, 则可以返回LCA</span></span><br><span class="line">                        <span class="comment">// 如果是第一次找到, 则更新 LCA.</span></span><br><span class="line">                        <span class="keyword">if</span> (one_node_found) &#123;</span><br><span class="line">                            <span class="keyword">return</span> LCA;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            one_node_found = <span class="literal">true</span>;</span><br><span class="line">                            LCA = parent_node;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 当状态为 BOTH_PENDING, 说明左右子树都没遍历, 应先遍历左子树</span></span><br><span class="line">                    child_node = parent_node-&gt;left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果状态为 LEFT_DONE, 说明已经遍历完左子树, 该遍历右子树</span></span><br><span class="line">                    child_node = parent_node-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                s.pop();</span><br><span class="line">                parent_state = <span class="keyword">static_cast</span>&lt;State&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(parent_state) - <span class="number">1</span>);</span><br><span class="line">                s.push(<span class="built_in">std</span>::make_pair(parent_node, parent_state));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (child_node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    s.push(<span class="built_in">std</span>::make_pair(child_node, State::BOTH_PENDING));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// state 为　BOTH_DONE, 说明当前节点可以出栈</span></span><br><span class="line">                <span class="comment">// 如果当前节点为LCA, 则需要更新LCA</span></span><br><span class="line">                <span class="keyword">auto</span> node = s.top().first;</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">if</span> (LCA == node &amp;&amp; one_node_found) &#123;</span><br><span class="line">                    LCA = s.top().first;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="237-Delete-Node-in-a-Linked-List"><a href="#237-Delete-Node-in-a-Linked-List" class="headerlink" title="237. Delete Node in a Linked List"></a>237. Delete Node in a Linked List</h1><h2 id="Description-删除链表中的某个节点"><a href="#Description-删除链表中的某个节点" class="headerlink" title="Description: 删除链表中的某个节点"></a>Description: 删除链表中的某个节点</h2><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Given linked list — head = [4,5,1,9], which looks like following:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 -&gt; 5 -&gt; 1 -&gt; 9</span><br></pre></td></tr></table></figure></p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [4,5,1,9], node = 5</span><br><span class="line">Output: [4,1,9]</span><br><span class="line">Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [4,5,1,9], node = 1</span><br><span class="line">Output: [4,5,9]</span><br><span class="line">Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>The linked list will have at least two elements.<br>All of the nodes’ values will be unique.<br>The given node will not be the tail and it will always be a valid node of the linked list.<br>Do not return anything from your function.</p>
<h2 id="解法一-复制-跳过节点"><a href="#解法一-复制-跳过节点" class="headerlink" title="解法一: 复制+跳过节点"></a>解法一: 复制+跳过节点</h2><p><strong>时间复杂度:</strong> $O(1)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>这是一道非常取巧(也可以说是投机)的题, 题目给的参数是需要删除的节点指针, 同时该指针不会是最后一个节点, 因此我们可以利用先复制, 再跳过的方式实现删除.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">c<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val; <span class="comment">// 题目假设node 不是最后一个节点</span></span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next; <span class="comment">// 跳过node节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="238-Product-of-Array-Except-Self"><a href="#238-Product-of-Array-Except-Self" class="headerlink" title="238. Product of Array Except Self"></a>238. Product of Array Except Self</h1><h2 id="Description-计算数组内其他元素之积-不能使用除法"><a href="#Description-计算数组内其他元素之积-不能使用除法" class="headerlink" title="Description: 计算数组内其他元素之积(不能使用除法)"></a>Description: 计算数组内其他元素之积(不能使用除法)</h2><p>Given an array nums of n integers where n &gt; 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  [1,2,3,4]</span><br><span class="line">Output: [24,12,8,6]</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong> Please solve it without division and in O(n).</p>
<p><strong>Follow up:</strong><br>Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)</p>
<h2 id="解法一-借助辅助数组-1"><a href="#解法一-借助辅助数组-1" class="headerlink" title="解法一: 借助辅助数组"></a>解法一: 借助辅助数组</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历两次数组<br><strong>空间复杂度:</strong> $O(n)$, 额外申请 $n$ size 的数组(不计算 res 的空间占用)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; productExceptSelf(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; from_begin(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; from_end(n);</span><br><span class="line">        from_begin[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        from_end[n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            from_begin[i] = from_begin[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>]; <span class="comment">// from_begin[i] 为 nums[i] 之前的所有元素的乘积</span></span><br><span class="line">            from_end[ n-i<span class="number">-1</span>] = from_end[n-i] * nums[n-i]; <span class="comment">// from_end[i] 为 nums[i] 之后所有元素的乘积</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;n ; i++)&#123;</span><br><span class="line">            from_end[i] = from_begin[i] * from_end[i]; <span class="comment">// 用 nums[i] 之前的所有元素的乘积和 nums[i] 之后所有元素的乘积相乘</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> from_end;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-用一个变量代替数组"><a href="#解法二-用一个变量代替数组" class="headerlink" title="解法二: 用一个变量代替数组"></a>解法二: 用一个变量代替数组</h2><p><strong>时间复杂度:</strong> $O(n)$, 两次遍历<br><strong>空间复杂度:</strong> $O(1)$, 用变量代替数组</p>
<p>对解法一进行改写, 具体的做法是用一个变量来维护 from_begin 数组中的值(当然也可以选择代替 from_end)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; productExceptSelf(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="comment">// vector&lt;int&gt; from_begin(n);</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; from_end(n);</span><br><span class="line">        <span class="comment">// from_begin[0] = 1;</span></span><br><span class="line">        from_end[n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="comment">// from_begin[i] = from_begin[i-1] * nums[i-1]; // from_begin[i] 为 nums[i] 之前的所有元素的乘积</span></span><br><span class="line">            from_end[ n-i<span class="number">-1</span>] = from_end[n-i] * nums[n-i]; <span class="comment">// from_end[i] 为 nums[i] 之后所有元素的乘积</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> from_begin = <span class="number">1</span>; <span class="comment">// 用一个变量代替 from_begin 数组的作用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;n ; i++)&#123;</span><br><span class="line">            from_end[i] = from_begin * from_end[i]; <span class="comment">// 用 nums[i] 之前的所有元素的乘积和 nums[i] 之后所有元素的乘积相乘, 作为结果</span></span><br><span class="line">            from_begin = from_begin * nums[i]; <span class="comment">// 维护 from_begin的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> from_end;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-用两个变量代替数组"><a href="#解法三-用两个变量代替数组" class="headerlink" title="解法三: 用两个变量代替数组"></a>解法三: 用两个变量代替数组</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(1)$, 不计算结果数组的空间</p>
<p>观察到解法二的做法, 虽然将空间复杂度压缩到 $O(1)$, 但是仍然使用了两次<code>for</code>循环, 实际上, 我们可以同时用变量<code>from_begin</code>和变量<code>from_end</code>替换掉对应的数组, 并且同一个<code>for</code>循环中更新这两个变量, 如下所示.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; productExceptSelf(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> from_begin = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> from_end = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123; <span class="comment">// 同时从前后分别计算, from_begin记录i之前的元素之和, from_end记录i之后的元素之和</span></span><br><span class="line">            res[i] = from_begin * res[i];</span><br><span class="line">            from_begin = from_begin * nums[i];</span><br><span class="line">            res[n-i<span class="number">-1</span>] = from_end * res[n-i<span class="number">-1</span>];</span><br><span class="line">            from_end = from_end * nums[n-i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239. Sliding Window Maximum"></a>239. Sliding Window Maximum</h1><h2 id="Description-滑动窗口的最大值"><a href="#Description-滑动窗口的最大值" class="headerlink" title="Description: 滑动窗口的最大值"></a>Description: 滑动窗口的最大值</h2><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3</span><br><span class="line">Output: [3,3,5,5,6,7]</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ input array’s size for non-empty array.</p>
<p><strong>Follow up:</strong><br>Could you solve it in linear time?</p>
<h2 id="解法一-双端队列"><a href="#解法一-双端队列" class="headerlink" title="解法一: 双端队列"></a>解法一: 双端队列</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(k)$, 双端队列的 size 为 $k$.</p>
<p>使用双端队列deque, 从下标0开始, 一直到n-1, 每次进行如下步骤:</p>
<ul>
<li>当前元素是否比队列中最后一个元素大, 如果大, 说明队列元素以后也不可能再成为较大值, 直接pop, 如此循环, 直到队列为空或者遇到比当前值大的元素</li>
<li>判断队列中队首的元素是否过期(若队空则直接下一步, 无需判断), 若过期, 则pop, 否则, 不管( 只看队首, 队内的元素是否过期不影响算法, 因为就算过期后面也会将其淘汰)</li>
<li>将当前元素的下标存到队尾</li>
<li>将新的队首元素存到结果向量max_res中</li>
</ul>
<p><strong>注意:</strong> 队列里面存的是下标, 而不是元素本身的值, 后面在提到队列的元素值时, 均是指队列中存储的下标对应的元素值.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span> || k ==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dq.empty())</span><br><span class="line">                dq.push_back(i);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(dq.front() &lt; i-k+<span class="number">1</span>) dq.pop_front(); <span class="comment">//过期元素, 出队列</span></span><br><span class="line">                <span class="keyword">while</span>(!dq.empty() &amp;&amp; nums[dq.back()] &lt;= nums[i]) dq.pop_back(); <span class="comment">// 将队列中小于当前元素的都出队列(因为它们不可能成为max)</span></span><br><span class="line">                dq.push_back(i); <span class="comment">// 将当前元素入队列.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k<span class="number">-1</span>) res.push_back(nums[dq.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="240-Search-a-2D-Matrix-II"><a href="#240-Search-a-2D-Matrix-II" class="headerlink" title="240. Search a 2D Matrix II"></a>240. Search a 2D Matrix II</h1><h2 id="Description-矩阵搜索"><a href="#Description-矩阵搜索" class="headerlink" title="Description: 矩阵搜索"></a>Description: 矩阵搜索</h2><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<p>Integers in each row are sorted in ascending from left to right.<br>Integers in each column are sorted in ascending from top to bottom.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Consider the following matrix:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>Given target = 5, return true.</p>
<p>Given target = 20, return false.</p>
<h2 id="解法一-从左下角开始"><a href="#解法一-从左下角开始" class="headerlink" title="解法一: 从左下角开始"></a>解法一: 从左下角开始</h2><p><strong>时间复杂度:</strong> $O(n+m)$, 最多走 $n+m$ 步, $n$ 和 $m$ 分别为矩阵的宽和高<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span> || matrix[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i=matrix.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>; <span class="comment">// 从左下角开始搜索</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&lt;matrix[<span class="number">0</span>].size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &lt; target) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &gt; target) i--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242. Valid Anagram"></a>242. Valid Anagram</h1><p>变位词: 改变某个词或短语的字母顺序后构成的新词或短语</p>
<h2 id="Description-判断变位词"><a href="#Description-判断变位词" class="headerlink" title="Description: 判断变位词"></a>Description: 判断变位词</h2><p>Given two strings s and t , write a function to determine if t is an anagram of s.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>You may assume the string contains only lowercase alphabets.</p>
<p><strong>Follow up:</strong><br>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p>
<h2 id="解法一-排序-2"><a href="#解法一-排序-2" class="headerlink" title="解法一: 排序"></a>解法一: 排序</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 对两个字符串进行排序<br><strong>空间复杂度:</strong> $O(1)$, 可以原地排序, 不占用额外空间</p>
<p>对两个字符串排序后, 看是否相等. 该方式可以无缝的解决 Follow up 中的问题.</p>
<h2 id="解法二-哈希表"><a href="#解法二-哈希表" class="headerlink" title="解法二: 哈希表"></a>解法二: 哈希表</h2><p><strong>时间复杂度:</strong> $O(n1+n2)$, $n1$, $n2$ 分别为两个字符串的长度, 二者必须相等, 否则一定不是变位词.<br><strong>空间复杂度:</strong> $O(1)$, 哈希表的 size 为 26, 常数级</p>
<p>构造一个字母哈希表, 先统计</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() != t.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> ana_hash[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            ana_hash[c-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : t)&#123;</span><br><span class="line">            ana_hash[c-<span class="string">'a'</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (ana_hash[c-<span class="string">'a'</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        因为长度相等, 所以一旦不是异构词, 就一定会出现某个哈希位上的值小于0的情况, 因此无需在这里再次判断</span></span><br><span class="line"><span class="comment">        for(auto i : ana_hash)&#123;</span></span><br><span class="line"><span class="comment">            if(i != 0) return false;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解答-Follow-up"><a href="#解答-Follow-up" class="headerlink" title="解答 Follow up:"></a>解答 Follow up:</h2><p>用 <code>unordered_map</code> 来代替数组哈希表, 此时复杂度与输入的字符种类数目有关, 哈希表的空间复杂度变成 $O(n)$.</p>
<h1 id="268-Missing-Number"><a href="#268-Missing-Number" class="headerlink" title="268. Missing Number"></a>268. Missing Number</h1><h2 id="Description-缺失的数字"><a href="#Description-缺失的数字" class="headerlink" title="Description: 缺失的数字"></a>Description: 缺失的数字</h2><p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p>
<p>Example 1:</p>
<p>Input: [3,0,1]<br>Output: 2<br>Example 2:</p>
<p>Input: [9,6,4,2,3,5,7,0,1]<br>Output: 8<br>Note:<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p>
<h2 id="解法一-排序-3"><a href="#解法一-排序-3" class="headerlink" title="解法一: 排序"></a>解法一: 排序</h2><p><strong>时间复杂度:</strong> $O(nlogn)$<br><strong>空间复杂度:</strong> $O(1)$ 或 $O(n)$</p>
<h2 id="解法二-哈希表-1"><a href="#解法二-哈希表-1" class="headerlink" title="解法二: 哈希表"></a>解法二: 哈希表</h2><p><strong>时间复杂度:</strong> $O(n)$, 两次遍历, 第一次构建哈希, 第二次查询缺失数字<br><strong>空间复杂度:</strong> $O(n)$, 哈希表所占空间</p>
<p>另一种解法: 用下表做哈希, 将数字放置在与下标相同的位置上, 最终放错位置的元素的下标就是缺失的数字, 如果位置都正确, 则缺失 n. 复杂度与哈希表相同, 代码实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != nums[i] &amp;&amp; nums[i] &lt; n) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[i], nums[nums[i]]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != nums[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-异或-1"><a href="#解法三-异或-1" class="headerlink" title="解法三: 异或"></a>解法三: 异或</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(1)$, 无需额外空间</p>
<p>因为题目是从 <code>0, 1, 2, ..., n</code> 共 $n+1$ 个数字中选出了 $n$ 个不相同的数字, 因此, 如果将 $n+1$ 大小的数组和 $n$ 大小的数组合并成一个大数组, 那么在大数组中, 除了那个缺失的数字以外, 所有的数字都恰好出现了两次, 因此题目变成了求数组中出现一次的唯一数字, 此时可以利用异或在 $O(n)$ 时间复杂度内解决.</p>
<p><strong>该解法还可以解决丢失两个数字, 丢失三个数字的情况, 具体可参考用异或解决奇数偶数数字的问题.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> res = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            res = res ^ i ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-高斯求和公式"><a href="#解法四-高斯求和公式" class="headerlink" title="解法四: 高斯求和公式"></a>解法四: 高斯求和公式</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(1)$, 无需任何额外空间</p>
<p>前 $n$ 项和的求和公式为: $1+2+3+\cdots+n = \frac{(n+1)n}{2}$<br>因此, 我们只需要计算出当前数组的和, 然后在计算当前和与高斯和之间的差即可.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> gauss_sum = n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">            sum += num;</span><br><span class="line">        <span class="keyword">return</span> gauss_sum - sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="279-Perfect-Squares"><a href="#279-Perfect-Squares" class="headerlink" title="279. Perfect Squares"></a>279. Perfect Squares</h1><h2 id="Description-找到最少的平方和个数"><a href="#Description-找到最少的平方和个数" class="headerlink" title="Description: 找到最少的平方和个数"></a>Description: 找到最少的平方和个数</h2><p>Given a positive integer n, find the <strong>least</strong> number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 12</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 12 = 4 + 4 + 4.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 13</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 13 = 4 + 9.</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-四平方和定理-最优"><a href="#解法一-四平方和定理-最优" class="headerlink" title="解法一: 四平方和定理(最优)"></a>解法一: 四平方和定理(最优)</h2><p><strong>时间复杂度:</strong> $O(\sqrt n)$, 最坏情况为 $O(\sqrt n)$, 最好情况为 $O(1)$.<br><strong>空间复杂度:</strong> $O(1)$, 无需额外空间</p>
<p><strong>四平方和定理:</strong>  任何一个正整数, 都可以表示成四个整数的平方和(如果不算 0 的话, 就是可以用小于等于 4 个整数的平方和来表示任意一个整数).</p>
<p>对于题目, 要求我们返回组合平方和的数字的 <strong>最少</strong> 个数(不算0), 因此, 这里还可以使用到两个特别的性质来加速计算:</p>
<ul>
<li>如果 $n$ 可以被 4 整除, 那么 $n$ 和 $n/4$ 的最少平方和数字个数相同.</li>
<li>如果 $n \% 8=7$, 那么 $n$ 的最少平方和个数一定为 4.</li>
</ul>
<p>因此, 本题的解法流程如下:</p>
<ol>
<li>循环整除 4, 降低 $n$ 的大小;</li>
<li>判断是否有 $n \% 8 =7$, 如果有, 则直接返回 4;</li>
<li>查看 $n$ 是否能够拆分成两个数(其中一个可以为0), 如果可以, 则返回 <code>!!i + !!j</code>, 即返回正整数的个数. 此处需要注意, <code>i</code> 需要从 0 开始遍历, 因为对于 $3^2+4^2 = 0^2 + 5^2 = 25$ 来说, 我们希望返回的是后者(即返回最少的平方和个数);</li>
<li>如果上面都不行, 则只可能反正 3(因为 $n&gt;0$).</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(n%<span class="number">4</span> == <span class="number">0</span>) n = n/<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">8</span> == <span class="number">7</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i*i&lt;=n; i++)&#123; <span class="comment">// i必须从0开始, 否则会找到其他组合, eg: 3^2 + 4^2 = 0^2 + 5^2</span></span><br><span class="line">            <span class="keyword">int</span> j = <span class="built_in">sqrt</span>(n - i * i);</span><br><span class="line">            <span class="keyword">if</span>(i*i + j*j == n)</span><br><span class="line">                <span class="keyword">return</span> !!i+!!j; <span class="comment">// 返回1(只有一个正整数)或2(两个都是正整数)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>; <span class="comment">//既不是4, 也不是1,2, 返回3(因为n&gt;0, 所以不可能返回0)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-DP-2"><a href="#解法二-DP-2" class="headerlink" title="解法二: DP"></a>解法二: DP</h2><p><strong>时间复杂度:</strong> $O(n\sqrt n)$, 外层循环约为 $n$ 次, 内层循环约为 $\sqrt n$ 次.<br><strong>空间复杂度:</strong> $O(n)$, 需要额外申请 $n+1$ 大小的 DP 数组.</p>
<p>对于解法一来说, 虽然它的时间和空间复杂度最优, 但是其中使用到了很多不常用的定理和性质, 如果不知道这些定理和性质, 很难想到解法一的实现. 因此, 我们更容易想到的是使用动态规划来解决这道题, 具体解题步骤如下:</p>
<ol>
<li>申请 $n+1$ 大小的 DP 数组, 并令 <code>dp[0]=0</code>, 令其他元素为 <code>INT_MAX</code>, <code>dp[i]</code> 的值代表组成数字 $i$ 所需的最少的平方和数字个数;</li>
<li>由于我们已经求得 <code>dp[0]</code> 的值, 因此, 对于 <code>j=1, 2, ...</code> 来说, 我们可以顺势求得 <code>dp[0+j*j] = dp[0]+1=1</code>.</li>
<li>对于已经求得的 <code>dp[i]</code>, 我们可以求得 <code>dp[i+j*j] = min(dp[i+j*j], dp[i]+1)</code>, 这里的 <code>min</code> 是为了保证组成数字的平方和个数最少.</li>
<li>最终, 返回 <code>dp.back()</code> 即为组成 $n$ 的最少的平方和个数.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>, INT_MAX);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>; <span class="comment">// 赋初值        </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; i+j*j &lt; n+<span class="number">1</span>; j++)&#123;</span><br><span class="line">                dp[i+j*j] = <span class="built_in">std</span>::min(dp[i+j*j], dp[i]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-DP-2"><a href="#解法三-DP-2" class="headerlink" title="解法三: DP"></a>解法三: DP</h2><p><strong>时间复杂度:</strong> $O(n\sqrt n)$, 外层循环约为 $n$ 次, 内层循环约为 $\sqrt n$ 次.<br><strong>空间复杂度:</strong> $O(n)$, 需要额外申请 $n+1$ 大小的 DP 数组.</p>
<p>复杂度和解法二没有区别, 但是我们可以从另一个角度来实现 DP 算法, 具体流程如下:</p>
<ol>
<li>申请只含有一个元素的 DP 数组 <code>dp[0]=0</code>;</li>
<li>根据 <code>dp[0]</code> 的值计算 <code>dp[1]</code>.(计算方法和解法二类似, 具体请看代码)</li>
<li>根据 <code>dp[0]~dp[i-1]</code> 的值计算 <code>dp[i]</code>.</li>
<li>当 <code>i==n</code> 时, 返回 <code>dp[i]</code>.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(dp.size()&lt;=n)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = dp.size(); <span class="keyword">int</span> val = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j*j &lt;= m; j++)&#123; <span class="comment">//这里必须 &lt;= m, 否则会缺少 dp[0]+1 的情况.</span></span><br><span class="line">                val = <span class="built_in">std</span>::min(val, dp[m - j*j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dp.push_back(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-递归"><a href="#解法四-递归" class="headerlink" title="解法四: 递归"></a>解法四: 递归</h2><p><a href="http://www.cnblogs.com/grandyang/p/4800552.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/4800552.html</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recrusion</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = n, num = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (num * num &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = n / (num * num), b = n % (num * num);</span><br><span class="line">            res = min(res, a + numSquares(b));</span><br><span class="line">            ++num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="283-Move-Zeroes"><a href="#283-Move-Zeroes" class="headerlink" title="283. Move Zeroes"></a>283. Move Zeroes</h1><h2 id="Description-将-0-移动到最后-保持其他元素相对位置不变"><a href="#Description-将-0-移动到最后-保持其他元素相对位置不变" class="headerlink" title="Description: 将 0 移动到最后, 保持其他元素相对位置不变"></a>Description: 将 0 移动到最后, 保持其他元素相对位置不变</h2><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>Example:</p>
<p>Input: [0,1,0,3,12]<br>Output: [1,3,12,0,0]<br>Note:</p>
<p>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.</p>
<h2 id="解法一-交换法"><a href="#解法一-交换法" class="headerlink" title="解法一: 交换法"></a>解法一: 交换法</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$, 无需额外空间</p>
<p>利用交换将不符合要求的元素交换, 具体做法如下:</p>
<ol>
<li>令 <code>i</code> 指向第一个 0 元素;</li>
<li>令 <code>j</code> 指向 <code>i</code> 之后的第一个非 0 元素; (注意 <code>j</code> 必须在 <code>i</code> 的后面才能执行交换)</li>
<li>交换 <code>i</code> 和 <code>j</code> 指向的元素, 更新 <code>i</code> 和 <code>j</code> 的值.</li>
<li>重复以上步骤, 直到 <code>j</code> 越界.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums[i]!=<span class="number">0</span>) i++;</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">while</span>(nums[j]==<span class="number">0</span>) j++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.size())&#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(nums[i], nums[j]);</span><br><span class="line">            <span class="keyword">while</span>(nums[i]!=<span class="number">0</span>) i++;</span><br><span class="line">            j = i;</span><br><span class="line">            <span class="keyword">while</span>(nums[j]==<span class="number">0</span>) j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-更简洁的交换法"><a href="#解法二-更简洁的交换法" class="headerlink" title="解法二: 更简洁的交换法"></a>解法二: 更简洁的交换法</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>这道题可以从另一个角度来理解, 即可以看做是要将所有的非 0 元素保持相对位置不变地移动到数组的前面, 那么我们可以遍历数组, 并用一个变量 <code>i</code> 来记录当前元素之前的非 0 元素的个数, 那么如果当前元素为非 0 元素, 则可以令当前元素与 <code>nums[i]</code> 交换, 同时 <code>i++</code>, 这样便可以同时保证将非 0 元素移动到数组前以及保持相对位置不变两个条件.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        for(int i=0, j=0; j&lt;nums.size(); j++)&#123;</span><br><span class="line">            if(nums[j] != 0)&#123;</span><br><span class="line">                std::swap(nums[i], nums[j]);</span><br><span class="line">                i++; // 非0元素个数加1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="287-Find-the-Duplicate-Number"><a href="#287-Find-the-Duplicate-Number" class="headerlink" title="287. Find the Duplicate Number"></a>287. Find the Duplicate Number</h1><h2 id="Description-寻找重复元素"><a href="#Description-寻找重复元素" class="headerlink" title="Description: 寻找重复元素"></a>Description: 寻找重复元素</h2><p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,4,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,3,4,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong></p>
<ul>
<li>You must not modify the array (assume the array is read only).</li>
<li>You must use only constant, O(1) extra space.</li>
<li>Your runtime complexity should be less than O(n2).</li>
<li>There is only one duplicate number in the array, but it could be repeated more than once.</li>
</ul>
<h2 id="解法一-哈希表-1"><a href="#解法一-哈希表-1" class="headerlink" title="解法一: 哈希表"></a>解法一: 哈希表</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(n)$, 哈希表额外空间</p>
<p>这道题用哈希表很容易解, 但是这是最简单的解法之一(更简单的还有暴力法), 因此这里贴出来只用做参考.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; nums_set;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums_set.find(num) != nums_set.end())</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            nums_set.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另一种解法是不建立哈希表, 而是利用数组的元素值和元素下标建立对应关系, 即将所有的数字放置在数字对应的下标位置上, 这样, 最终重复的元素就会出现的下标为 0 的位置上, 当然, 期间如果已经发现重复, 则可以直接返回, 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>] != nums[nums[<span class="number">0</span>]]) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[<span class="number">0</span>], nums[nums[<span class="number">0</span>]]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-排序"><a href="#解法二-排序" class="headerlink" title="解法二: 排序"></a>解法二: 排序</h2><p><strong>时间复杂度:</strong> $O(nlogn)$<br><strong>空间复杂度:</strong> $O(1)$ 或者 $O(n)$</p>
<p>先对数组排序, 然后遍历查找重复元素, 但是这种解法会改变原有数组中的元素分布, 题目要是数组是只读的, 因此该解法也只作为参考贴出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i+<span class="number">1</span>]) <span class="keyword">return</span> nums[i]; <span class="comment">// 一定存在重复元素, 因此 i+1 不会越界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-Floyd-的乌龟和兔子-Floy-判圈算法"><a href="#解法三-Floyd-的乌龟和兔子-Floy-判圈算法" class="headerlink" title="解法三: Floyd 的乌龟和兔子(Floy 判圈算法)"></a>解法三: Floyd 的乌龟和兔子(Floy 判圈算法)</h2><p>Floyd’s Tortoise and Hare, 该算法是用来判断链表中是否含有环的. 对于此题, 我们换一个角度来解读, 数组中总共有 $n+1$ 个数, 这些数都是 $[1,n]$ 中的正整数, 因此, 至少会存在一个重复的数, 根据题目的假设, 有且仅有一个重复的数字, 那么, 我们假设该数字为 $k$, 于是, 我们可以将该数组表示成下面的形式(表中的 $x$ 代表该元素的值不为 $k$ ):</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>下标</th>
<th>$0$</th>
<th>$1$</th>
<th>$2$</th>
<th>…</th>
<th>$k$</th>
<th>…</th>
<th>$n$</th>
</tr>
</thead>
<tbody>
<tr>
<td>元素</td>
<td>$x$</td>
<td>$k$</td>
<td>…</td>
<td>$k$</td>
<td>$x$</td>
<td>…</td>
<td>$x$</td>
</tr>
</tbody>
</table>
</div>
<p>如果我们将上面的 <code>(下标, 元素)</code> 看做是链表结构中的 <code>(val, next)</code>, 那么可以看出, 当某一个节点(上面假设为节点 1)的 <code>next</code> 指向 <code>k</code> 以后, <code>k</code> 又会重新指向另一个元素, 但是, 经过一定步数以后, <strong>一定</strong> 又会重新指向 <code>k</code> (因为元素存在重复), 这在链表中称之为 “环”, 因此, 这道题就变成了求链表中环的开始节点, 该题正好是<a href="../面试-算法刷题-剑指offer/#55">剑指offer第55题</a>和 <a href="#142">LeetCode第142题</a></p>
<p><strong>这道题有一个很关键的条件就是, 元素的值是在1~n之间, 因此, 下标 0 位置上的元素值一定不为 0, 只有这样, 我们才可以将下标 0 选做起点, 如果选取其他的下标坐标起点, 那么有可能在第一步就死循环了.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>; <span class="comment">// 实际上 fast 和 slow 可以指向环前的任意节点, 不影响最终结果.</span></span><br><span class="line">        <span class="keyword">do</span>&#123; <span class="comment">// 因为一定存在环, 所以fast不会越界</span></span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow!=fast);</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>; <span class="comment">// 求环长度</span></span><br><span class="line">        fast = nums[fast];</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">            len ++;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">            fast = nums[fast]; <span class="comment">// 先让fast走环长的距离</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123; <span class="comment">// 再次相遇时即为环的开始节点</span></span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>更简洁的写法:</strong><br>上面在求环的开始节点时, 是先求环长, 再让 <code>fast</code> 走环长距离, 然后 <code>slow</code> 和 <code>fast</code> 同步前进, 最终相遇点即为开始点, 这么写比较容易理解, 但难免有些繁琐. 实际上, 我们只需要令 <code>slow</code> 从头开始, 即 <code>slow=0</code>, 接着令 <code>fast</code> 和 <code>slow</code> 同步前进, 那么相遇点就是开始节点. 原因是因为, 二者是从同一点出发的, fast 的步长较快, 当二者相遇时, 他们一定是在环中的某一点相遇, 这个时候再把slow重新放回起点, 那么fast领先slow的距离就等于: 环外的距离 + 若干圈 + 当前圈内已经走的距离. 而此时 fast 距离环入口还有一段距离, 因为第一次相遇点的位置, 因此, 我们如果此时从起点出发, 最终正好可以弥补这一部分距离, 因此, 最终会在环入口相遇.</p>
<p><strong>一句话总结: 令fast和slow一起开始, fast步长是slow步长的二者, 找到二者相遇的点, 然后令slow重新回到起点, 此时步长一致, 再次相遇时即为环的入口点</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>; <span class="comment">// head;</span></span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>; <span class="comment">// head-&gt;next; 指向head也没错, 因为, 最终仍会slow=fast</span></span><br><span class="line">        <span class="keyword">do</span>&#123; <span class="comment">// 因为一定存在环, 所以fast不会越界</span></span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow!=fast);</span><br><span class="line"></span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="289-Game-of-Life"><a href="#289-Game-of-Life" class="headerlink" title="289. Game of Life"></a>289. Game of Life</h1><h2 id="Description-游戏人生"><a href="#Description-游戏人生" class="headerlink" title="Description: 游戏人生"></a>Description: 游戏人生</h2><p>According to the Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”</p>
<p>Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p>
<ol>
<li>Any live cell with fewer than two live neighbors dies, as if caused by under-population.</li>
<li>Any live cell with two or three live neighbors lives on to the next generation.</li>
<li>Any live cell with more than three live neighbors dies, as if by over-population..</li>
<li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</li>
</ol>
<p>Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,1],</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,1,1],</span><br><span class="line">  [0,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p><strong>Follow up:</strong></p>
<ol>
<li>Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.</li>
<li>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?</li>
</ol>
<h2 id="解法一-状态机"><a href="#解法一-状态机" class="headerlink" title="解法一: 状态机"></a>解法一: 状态机</h2><p><strong>时间复杂度:</strong> $O(mn)$, 遍历两次二维数组<br><strong>空间复杂度:</strong> $O(1)$, 无需额外空间</p>
<p>根据细胞的更新规则, 我们可以设计出下面的状态转移:<br>0: 从 0 到 0;<br>1: 从 1 到 1:<br>2: 从 1 到 0;<br>3: 从 0 到 1;</p>
<p>因此, 本解法需要遍历两边 <code>board</code> 矩阵, 第一遍先计算每个 cell 的状态, 第二遍根据状态赋予 cell 不同的值, 具体来说就是如果当前状态 <code>board[i][j]%2==0</code>, 那么就令 <code>board[i][j]=0</code>, 反之, 令 <code>board[i][j]=1</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size()==<span class="number">0</span> || board[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> n = board.size();</span><br><span class="line">        <span class="keyword">int</span> m = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> direct[<span class="number">8</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                          &#123; <span class="number">0</span>,<span class="number">-1</span>&#125;,          &#123; <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                          &#123; <span class="number">1</span>,<span class="number">-1</span>&#125;, &#123; <span class="number">1</span>, <span class="number">0</span>&#125;, &#123; <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> count_1 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">8</span>; k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> i_k = i+direct[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> j_k = j+direct[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(i_k&gt;=<span class="number">0</span> &amp;&amp; i_k&lt;n &amp;&amp; j_k&gt;=<span class="number">0</span> &amp;&amp; j_k&lt;m</span><br><span class="line">                       &amp;&amp; (board[i_k][j_k]==<span class="number">1</span> || board[i_k][j_k]==<span class="number">2</span>) )</span><br><span class="line">                        count_1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( (count_1&lt;<span class="number">2</span> || count_1&gt;<span class="number">3</span>) &amp;&amp; board[i][j]==<span class="number">1</span>)</span><br><span class="line">                    board[i][j] = <span class="number">2</span>; <span class="comment">// 2:1-&gt;0, 0:0-&gt;0</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(count_1==<span class="number">3</span> &amp;&amp; board[i][j]==<span class="number">0</span>)</span><br><span class="line">                    board[i][j] = <span class="number">3</span>; <span class="comment">// 3:0-&gt;1</span></span><br><span class="line">                <span class="comment">// 剩余情况维持不变</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;cells : board)&#123; <span class="comment">// 如果要对board进行修改, 需要使用引用号 &amp;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;cell : cells)</span><br><span class="line">                <span class="keyword">if</span>(cell%<span class="number">2</span>==<span class="number">1</span>) cell=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> cell=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up"></a>Follow up</h2><ol>
<li>常数空间复杂度: 正如解法一</li>
<li>无边界限制: 修改边界空间条件, 使其变成 “循环” 二维矩阵.</li>
</ol>
<h1 id="295-Find-Median-from-Data-Stream"><a href="#295-Find-Median-from-Data-Stream" class="headerlink" title="295. Find Median from Data Stream"></a>295. Find Median from Data Stream</h1><h2 id="Description-返回数据流的中位数"><a href="#Description-返回数据流的中位数" class="headerlink" title="Description: 返回数据流的中位数"></a>Description: 返回数据流的中位数</h2><p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>
<p>For example,<br><code>[2,3,4]</code>, the median is <code>3</code><br><code>[2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code></p>
<p>Design a data structure that supports the following two operations:</p>
<ul>
<li>void addNum(int num) - Add a integer number from the data stream to the data structure.</li>
<li>double findMedian() - Return the median of all elements so far.</li>
</ul>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addNum(1)</span><br><span class="line">addNum(2)</span><br><span class="line">findMedian() -&gt; 1.5</span><br><span class="line">addNum(3)</span><br><span class="line">findMedian() -&gt; 2</span><br></pre></td></tr></table></figure></p>
<p><strong>Follow up:</strong></p>
<ol>
<li>If all integer numbers from the stream are between 0 and 100, how would you optimize it?</li>
<li>If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?</li>
</ol>
<h2 id="解法一-传统排序"><a href="#解法一-传统排序" class="headerlink" title="解法一: 传统排序"></a>解法一: 传统排序</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 添加数字时不排序, 返回中位数时排序<br><strong>空间复杂度:</strong> $O(n)$, 排序需要额外空间</p>
<p>添加数字时, 直接添加, 时间复杂度为 $O(1)$, 每次需要输出中位数时, 都对数组内当前所有元素排序, 时间复杂度为 $O(nlogn)$, <strong>该方法超时</strong>.</p>
<h2 id="解法二-插入排序"><a href="#解法二-插入排序" class="headerlink" title="解法二: 插入排序"></a>解法二: 插入排序</h2><p><strong>时间复杂度:</strong> $O(n)$, 二分搜索位置需要 $O(logn)$, 插入需要 $O(n)$.<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>每次新来一个数字时, 都执行插入排序, 先利用二分搜索(因为当前数组已经有序)找到应该插入的位置, 时间复杂度为 $O(logn)$, 然后将数字插入到该位置, 插入的时间复杂度是 $O(n)$, 由于已经排序好, 因此返回中位数的时间复杂度是 $O(1). 该解法 <strong>同样超时</strong>.</p>
<h2 id="解法三-大顶堆-小顶堆"><a href="#解法三-大顶堆-小顶堆" class="headerlink" title="解法三: 大顶堆+小顶堆"></a>解法三: 大顶堆+小顶堆</h2><p><strong>时间复杂度:</strong> $O(5\times logn) = O(logn)$<br><strong>空间复杂度:</strong> $O(n)$, 大顶堆和小顶堆的大小之和为 $n$.</p>
<p>元素首先加入大顶堆($O(logn)$), 得到前面数字的最大值, 然后将该最大值弹出($O(logn)$)并加入到小顶堆当中($O(logn)$), 以维护当前小顶堆的元素合法(例如, 新的大顶堆堆顶的元素大于当前小顶堆堆顶元素, 这就不合法了), 然后, 看看当前大顶堆和小顶堆的元素个数是否符合要求, 如果不符合的话, 就小顶堆的堆顶弹出($O(logn)$)并加入大顶堆($O(logn)$). 由此可知, 添加元素的时间复杂度为: $O(5\times logn)$. 返回中位数时可以直接获取堆顶, 而无需更改堆结构, 故而为 $O(1)$. 所以, 最终的时间复杂度就为 $O(5\times logn) = O(logn)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; max_heap; <span class="comment">// 大顶堆, 维护前 (n+1)/2 个元素</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;&gt; min_heap; <span class="comment">//小顶堆, 维护后n/2个元素</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        max_heap.push(num); <span class="comment">// 先将当前元素添加到大顶堆中, 找到前半段最大元素</span></span><br><span class="line">        min_heap.push(max_heap.top()); max_heap.pop(); <span class="comment">// 调节最小堆, 这一步是必须的, 是为了同时确保大顶堆和小顶堆的元素正确</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数字会随着元素size的变化而不断在大顶堆和小顶堆之间切换</span></span><br><span class="line">        <span class="keyword">if</span>(max_heap.size() &lt; min_heap.size())&#123; <span class="comment">//调节后, 平衡大顶堆和小顶堆的size</span></span><br><span class="line">            max_heap.push(min_heap.top());</span><br><span class="line">            min_heap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (max_heap.size() + min_heap.size())%<span class="number">2</span>==<span class="number">1</span> ? <span class="keyword">double</span>(max_heap.top()) : (max_heap.top() + min_heap.top())*<span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj.addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="解法四-multiset-指示器"><a href="#解法四-multiset-指示器" class="headerlink" title="解法四: multiset+指示器"></a>解法四: multiset+指示器</h2><p><strong>时间复杂度:</strong> $O(logn+1) = O(logn)$<br><strong>空间复杂度:</strong> $O(n)$, multiset 容器需要 $n$ 大小的空间.</p>
<p>用两个迭代指示器分别指向当前数组内的中位数(元素数目为奇数时, 二者指向同一点), 那么当新来一个元素时, 这个元素只可能有三种插入情况:</p>
<ul>
<li>插在两指示器的前面</li>
<li>插在两指示器的后面</li>
<li>插在两指示器的中间(只在未插入前元素数目为偶数时才可以)</li>
</ul>
<p>由于迭代指示器是随着元素移动而移动的(这点和下标就有区别了), 因此, 我们可以通过对指示器操作来使其指向新的中位数, 对应三种情况分别为:</p>
<ul>
<li>前面元素变多, 说明指示器应该后挪(最多一位)</li>
<li>后面元素变多, 说明指示器应该前挪(最多一位)</li>
<li>插在中间, 说明当前插入的元素正是中位数, 令指示器指向即可.</li>
</ul>
<p>当然, 上面只是核心思想, 具体的挪动算法还要分元素数目的奇偶性来分情况讨论, 代码如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator low_mid, high_mid; <span class="comment">// 迭代指示器会随着容器的变动而变动, 这个性质是该解法可行的重要因素之一</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MedianFinder():low_mid(data.end()), high_mid(data.end()) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> n = data.size();</span><br><span class="line">        data.insert(num);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            low_mid = data.begin();</span><br><span class="line">            high_mid = data.begin();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n &amp; <span class="number">1</span>==<span class="number">1</span>)&#123; <span class="comment">// 插入之前元素数量为奇数, low_mid=high_mid</span></span><br><span class="line">            <span class="keyword">if</span>(num &lt; *low_mid) <span class="comment">// 会插入到 low_mid/high_mid 之前, 因此, 前半段元素增加</span></span><br><span class="line">                low_mid--;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 如果 &gt;=, 则会插入到low_mid/high_mid 之后</span></span><br><span class="line">                high_mid++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 插入之前元素数量为偶数, low_mid+1 = high_mid</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(num &gt;= *low_mid &amp;&amp; num &lt; *high_mid)&#123; <span class="comment">//插入的元素刚好在中间, 注意前面要用 &gt;=, 后面用 &lt;, 因为相等时, 会插在后面</span></span><br><span class="line">                low_mid++;</span><br><span class="line">                high_mid--; <span class="comment">// 两个指针都想中间靠拢.</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &lt; *low_mid)&#123; <span class="comment">// 插入元素会插在前面, 则前面元素数量增加</span></span><br><span class="line">                high_mid--; <span class="comment">// 令high_mid=low_mid;</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 插在了后面</span></span><br><span class="line">                low_mid++; <span class="comment">// 令low_mid=high_mid;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (*low_mid + *high_mid) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的指示器实际上可以简化成一个(因为两个指示器只能互相挨着或者重叠), 因此, 我们可以只维护一个指示器, 简化代码如下(但是不太好理解):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator mid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MedianFinder()</span><br><span class="line">        : mid(data.end())</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = data.size();</span><br><span class="line">        data.insert(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!n)                                 <span class="comment">// first element inserted</span></span><br><span class="line">            mid = data.begin();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; *mid)                    <span class="comment">// median is decreased</span></span><br><span class="line">            mid = (n &amp; <span class="number">1</span> ? mid : prev(mid));</span><br><span class="line">        <span class="keyword">else</span>                                    <span class="comment">// median is increased</span></span><br><span class="line">            mid = (n &amp; <span class="number">1</span> ? next(mid) : mid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.size() &amp; <span class="number">1</span> == <span class="number">1</span> ? (*mid) : (*mid + *next(mid)) * <span class="number">0.5</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Follow-Up-1"><a href="#Follow-Up-1" class="headerlink" title="Follow Up"></a>Follow Up</h2><ol>
<li>If all integer numbers from the stream are between 0 and 100, how would you optimize it?</li>
</ol>
<p>用bucket?</p>
<ol>
<li>If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?</li>
</ol>
<h1 id="297-Serialize-and-Deserialize-Binary-Tree"><a href="#297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="297. Serialize and Deserialize Binary Tree"></a>297. Serialize and Deserialize Binary Tree</h1><h2 id="Description-序列化和反序列化二叉树"><a href="#Description-序列化和反序列化二叉树" class="headerlink" title="Description: 序列化和反序列化二叉树"></a>Description: 序列化和反序列化二叉树</h2><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">You may serialize the following tree:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">     / \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">as &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure></p>
<p><strong>Clarification:</strong> The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>
<p><strong>Note:</strong> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>
<h2 id="解法一-DFS"><a href="#解法一-DFS" class="headerlink" title="解法一: DFS"></a>解法一: DFS</h2><p><strong>时间复杂度:</strong> $O(n)$, 在序列化和反序列化递归中, 各遍历每个节点一次<br><strong>空间复杂度:</strong> $O(n\times v + n) = O(n)$, 其中, $n$ 为节点个数, $v$ 为节点上的值所占空间大小, 最后的一个 $n$ 代表递归调用所占的空间大小.</p>
<p>使用 <code>ostringstream</code> 和 <code>istringstream</code> 来缓存字符串, 中间用空格分隔, 利用流操作 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 可以方便的对字符串进行存入和读取, 而无需额外进行分词操作.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode *root, <span class="built_in">ostringstream</span> &amp;out)</span></span>&#123; <span class="comment">// 函数重载</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) out &lt;&lt; <span class="string">"# "</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            out &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            serialize(root-&gt;left, out);</span><br><span class="line">            serialize(root-&gt;right, out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">deserialize</span><span class="params">(<span class="built_in">istringstream</span> &amp;in)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> cur_val;</span><br><span class="line">        in &gt;&gt; cur_val;</span><br><span class="line">        <span class="keyword">if</span>(cur_val==<span class="string">"#"</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode *node = <span class="keyword">new</span> TreeNode(<span class="built_in">std</span>::stoi(cur_val));</span><br><span class="line">            node-&gt;left = deserialize(in);</span><br><span class="line">            node-&gt;right = deserialize(in);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ostringstream</span> out;</span><br><span class="line">        serialize(root, out);</span><br><span class="line">        <span class="keyword">return</span> out.str();        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> deserialize(in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>
<h2 id="解法二-BFS"><a href="#解法二-BFS" class="headerlink" title="解法二: BFS"></a>解法二: BFS</h2><p><strong>时间复杂度:</strong> $O(n)$, 在序列化和反序列化中, 每个节点都遍历一次<br><strong>空间复杂度:</strong></p>
<p>BFS 的会按照层次遍历的顺序将树的节点序列化, 序列化的代码比较好写, 只需对普通的层次遍历稍加改动即可. 反序列化的代码有一点麻烦, 需要控制树节点的左右子节点的值, 具体如下.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ostringstream</span> out;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode *node = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                out &lt;&lt; node-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                out &lt;&lt; <span class="string">"# "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.str();        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">        <span class="built_in">string</span> val;</span><br><span class="line">        in &gt;&gt; val;</span><br><span class="line">        TreeNode *res = <span class="keyword">new</span> TreeNode(<span class="built_in">std</span>::stoi(val));</span><br><span class="line">        TreeNode *cur = res;</span><br><span class="line">        q.push(cur);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode *node = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!(in&gt;&gt;val)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(val!=<span class="string">"#"</span>)&#123;</span><br><span class="line">                cur = <span class="keyword">new</span> TreeNode(<span class="built_in">std</span>::stoi(val));</span><br><span class="line">                node-&gt;left = cur;</span><br><span class="line">                q.push(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!(in&gt;&gt;val)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(val!=<span class="string">"#"</span>)&#123;</span><br><span class="line">                cur = <span class="keyword">new</span> TreeNode(<span class="built_in">std</span>::stoi(val));</span><br><span class="line">                node-&gt;right = cur;</span><br><span class="line">                q.push(cur);</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a>300. Longest Increasing Subsequence</h1><h2 id="Description-求最长递增序列-可以不连续-的长度"><a href="#Description-求最长递增序列-可以不连续-的长度" class="headerlink" title="Description: 求最长递增序列(可以不连续)的长度"></a>Description: 求最长递增序列(可以不连续)的长度</h2><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [10,9,2,5,3,7,101,18]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong></p>
<ul>
<li>There may be more than one LIS combination, it is only necessary for you to return the length.</li>
<li>Your algorithm should run in O(n2) complexity.</li>
</ul>
<p><strong>Follow up:</strong><br>Could you improve it to O(n log n) time complexity?</p>
<h2 id="解法一-暴力-6"><a href="#解法一-暴力-6" class="headerlink" title="解法一: 暴力"></a>解法一: 暴力</h2><p><strong>时间复杂度:</strong> $O(2^n)$<br><strong>空间复杂度:</strong> $O(n^2)$</p>
<p>对于任意一个数字, 只有两种情况, 即处于最长递增数组内, 或者不处于最长递增数组内, 需要同时将这两种情况考虑, 然后选择最长的情况. 该方法时间超限.</p>
<h2 id="解法二-Recursion-with-memorization-Memory-Limit-Exceeded"><a href="#解法二-Recursion-with-memorization-Memory-Limit-Exceeded" class="headerlink" title="解法二: Recursion with memorization [Memory Limit Exceeded]"></a>解法二: Recursion with memorization [Memory Limit Exceeded]</h2><h2 id="解法三-DP-3"><a href="#解法三-DP-3" class="headerlink" title="解法三: DP"></a>解法三: DP</h2><p>分析题目可以得出, 第 $i$ 个下标对应的数字是否存在于递增序列中, 与该下标之后的元素是无关的, 因此, 很自然的想到利用 DP 的方法来解决这道题. 我们令 <code>dp[i]</code> 代表 <strong>包含第 $i$ 个下标对应元素的递增序列的长度.</strong> 在求取 <code>dp[i+1]</code> 时, 我们需要遍历前面 <code>dp[0~i]</code> 个数组元素才能决定 <code>dp[i+1]</code> 的值, 因此, 时间复杂度为 $O(n^2)$, 空间复杂度为 $O(n)$. (比递归方法好很多).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(nums.size(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res_max=<span class="number">1</span>; <span class="comment">// 记录最长的递增序列长度, 因为最少有一个元素, 所以长度最少为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> max_val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123; <span class="comment">// 只有当当前元素大于前面的元素时, 才能构成递增序列</span></span><br><span class="line">                    max_val = <span class="built_in">std</span>::max(max_val, dp[j]);<span class="comment">//当前元素与nums[j]可以组成递增序列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = max_val+<span class="number">1</span>; <span class="comment">// 将当前元素加入, 因此, 长度增1</span></span><br><span class="line">            res_max = <span class="built_in">std</span>::max(res_max, dp[i]); <span class="comment">//用当前长度更新最长长度的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res_max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-DP-二分搜索-最优"><a href="#解法四-DP-二分搜索-最优" class="headerlink" title="解法四: DP+二分搜索(最优)"></a>解法四: DP+二分搜索(最优)</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 每次搜索的复杂度为 $O(logn)$, 总共需要搜索 $n$ 次<br><strong>空间复杂度:</strong> $O(m)$, $m$ 为最长递增序列的长度.</p>
<p>同样还是 DP 解法, 但是我们重新赋予 <code>dp[]</code> 数组另一个含义, 我们令 <code>dp[]</code> 数组内储存的元素的数量刚好等于当前最长递增序列的数量, <strong>注意, <code>dp[]</code> 数组内的值不一定是递增序列的值</strong>. 核心算过过程如下所示:</p>
<ol>
<li>初始时, 令 <code>dp[]</code> 数组为空, 即 <code>dp=[]</code>;</li>
<li>对于每一个元素 <code>num</code>, 我们查找 <code>num</code> 在 <code>dp</code> 数组中的 <code>upper_bound</code> 迭代器(首个大于 <code>num</code> 的元素的迭代器), 假设取名为 <code>upper</code>;(<strong>注意</strong>, <code>dp</code> 数组是有序的, 所以这里的查询复杂度为 $O(logn)$)</li>
<li>查看 <code>upper-1</code> 指向的元素是否和 <code>num</code> 相等, 如果相等, 则说明该元素已经存在, 那么就跳过该元素, 重新回到步骤2;</li>
<li>如果 <code>num</code> 大于 <code>dp</code> 数组内的所有元素, 则将 <code>num</code> 添加进 <code>dp</code> 数组; 否则, 就将 <code>dp</code> 数组中大于 <code>num</code> 的第一个元素的值赋为 <code>num</code>.</li>
<li>重复步骤2,3,4, 直到遍历完数组为止.</li>
</ol>
<p>为了更好的解释这种解法, 我们通过举例进行说明, 假定输入的数字序列为: <code>[4,10,3,4,10,3,2]</code>, 那么我们的 <code>dp[]</code> 数组的变化情况如下:</p>
<p><code>dp=[]</code>,初始时, 数组为空;<br><code>dp=[4]</code>, 遍历元素4, 加入到数组中;<br><code>dp=[4,10]</code>, 遍历元素10, 10大于所有元素, 将其添加到数组中;<br><code>dp=[3,10]</code>, 遍历元素3, 发现第一个大于3的值为4, 将其赋值为3;<br><code>dp=[3,4]</code>, 遍历元素4, 发现第一个大于4的的值为10, 将其赋值为4;<br><code>dp=[3,4,10]</code>, 遍历元素10, 10大于所有元素, 将其添加到数组中;<br><code>dp=[3,4,10]</code>, 遍历元素3, 3在数组中已经存在, 跳过该元素;<br><code>dp=[2,4,10]</code>, 遍历元素2, 发现第一个大于2个值为3, 将其赋值为2.</p>
<p>综上, 我们可以看到, <code>dp</code> 数组的长度始终等于当前数组的最长子序列的长度, 故而, 直接返回 <code>dp.size()</code> 即为最终的结果. <strong>注意, <code>dp</code> 内的值不一定为递增子序列的值.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">auto</span> upper = <span class="built_in">std</span>::upper_bound(dp.begin(), dp.end(), num);</span><br><span class="line">            <span class="keyword">if</span>(upper!=dp.begin() &amp;&amp; *(upper<span class="number">-1</span>) == num) <span class="keyword">continue</span>; <span class="comment">// 如果num在dp数组中已经存在, 则跳过该num.</span></span><br><span class="line">            <span class="keyword">if</span>(upper==dp.end())&#123;</span><br><span class="line">                    dp.push_back(num); <span class="comment">// 当前num比dp数组内的所有值都大, 则添加进dp数组</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                *upper = num; <span class="comment">// 用更小的值替代当前dp数组内的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.size(); <span class="comment">// 最终, dp数组的长度即为最长递增序列的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a>309. 最佳买卖股票时机含冷冻期</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p>
<h2 id="解法一-动态规划-2"><a href="#解法一-动态规划-2" class="headerlink" title="解法一: 动态规划"></a>解法一: 动态规划</h2><p>时间: $O(n)$, 空间: $O(1)$</p>
<p>难点主要在于想到动态规划的方程, 将每一天的状态分成持有股票和不持有股票两种, 则每一天状态的更新方式如下:</p>
<ul>
<li>持有(取较大者):<ul>
<li>保持昨天的持有</li>
<li><strong>前天</strong> 不持有(包含前天卖出的情况), 今天买入;</li>
</ul>
</li>
<li>不持有(取较大者):<ul>
<li>则为昨天持有, 今天卖出</li>
<li>保持昨天的不持有</li>
</ul>
</li>
</ul>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 对于任意一天的股票, 均由持有和不持有两种状态, 记录两种状态下当前的余额</span></span><br><span class="line">        <span class="comment">// 由于存在冷冻期, 因此, 我们要先求出第一天和第二天的状态, 然后从第三天开始根据前天和昨天的状态进行判断</span></span><br><span class="line">        <span class="keyword">int</span> dp_q[<span class="number">2</span>] = &#123;-prices[<span class="number">0</span>], <span class="number">0</span>&#125;; <span class="comment">// 第一天, 若持有, 则需要买入, 若不持有, 则余额为 0(没有支出)</span></span><br><span class="line">        <span class="comment">// 第二天, 若持有, 则为保持前一天的持有, 或者前一天不持有, 第二天买入; 若不持有, 则为第一天买入, 第二天卖出, 或者保持第一天的不持有</span></span><br><span class="line">        <span class="keyword">int</span> dp_z[<span class="number">2</span>] = &#123;<span class="built_in">std</span>::max(-prices[<span class="number">0</span>], -prices[<span class="number">1</span>]), <span class="built_in">std</span>::max(prices[<span class="number">1</span>] - prices[<span class="number">0</span>], <span class="number">0</span>)&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 对于任意一天的状态来说, 若持有, 则为保持昨天的持有, 或者前天不持有(包含前天卖出的情况), 今天买入; 若不持有, 则为昨天持有, 今天卖出, 或者保持昨天的不持有</span></span><br><span class="line">            <span class="keyword">int</span> dp[<span class="number">2</span>] = &#123;<span class="built_in">std</span>::max(dp_z[<span class="number">0</span>], dp_q[<span class="number">1</span>]-prices[i]), <span class="built_in">std</span>::max(dp_z[<span class="number">0</span>]+prices[i], dp_z[<span class="number">1</span>])&#125;;</span><br><span class="line">            dp_q[<span class="number">0</span>] = dp_z[<span class="number">0</span>]; dp_q[<span class="number">1</span>] = dp_z[<span class="number">1</span>]; <span class="comment">// 进入下一天, 昨天变前天</span></span><br><span class="line">            dp_z[<span class="number">0</span>] = dp[<span class="number">0</span>]; dp_z[<span class="number">1</span>] = dp[<span class="number">1</span>]; <span class="comment">// 进入下一天, 今天变昨天</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(dp_z[<span class="number">0</span>], dp_z[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) &lt;= <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dp_q = [-prices[<span class="number">0</span>], <span class="number">0</span>] <span class="comment"># first day, [y, n]</span></span><br><span class="line">        dp_z = [max(-prices[<span class="number">0</span>], -prices[<span class="number">1</span>]), max(<span class="number">0</span>, prices[<span class="number">1</span>] - prices[<span class="number">0</span>])] <span class="comment"># second day, [y, n]</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices[<span class="number">2</span>:]:</span><br><span class="line">            dp = [max(dp_z[<span class="number">0</span>], dp_q[<span class="number">1</span>]-price), max(dp_z[<span class="number">1</span>], dp_z[<span class="number">0</span>]+price)]</span><br><span class="line">            dp_q, dp_z = dp_z, dp</span><br><span class="line">        <span class="keyword">return</span> max(dp_z)</span><br></pre></td></tr></table></figure></p>
<h1 id="315-Count-of-Smaller-Numbers-After-Self"><a href="#315-Count-of-Smaller-Numbers-After-Self" class="headerlink" title="315. Count of Smaller Numbers After Self"></a>315. Count of Smaller Numbers After Self</h1><h2 id="Description-统计右边比当前数字小的个数"><a href="#Description-统计右边比当前数字小的个数" class="headerlink" title="Description: 统计右边比当前数字小的个数"></a>Description: 统计右边比当前数字小的个数</h2><p>You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,2,6,1]</span><br><span class="line">Output: [2,1,1,0]</span><br><span class="line">Explanation:</span><br><span class="line">To the right of 5 there are 2 smaller elements (2 and 1).</span><br><span class="line">To the right of 2 there is only 1 smaller element (1).</span><br><span class="line">To the right of 6 there is 1 smaller element (1).</span><br><span class="line">To the right of 1 there is 0 smaller element.</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-multiset-1"><a href="#解法一-multiset-1" class="headerlink" title="解法一: multiset"></a>解法一: multiset</h2><p><strong>时间复杂度:</strong> $O(n\times(logn+n+logn)=O(n^2)$<br><strong>空间复杂度:</strong> $O(n+n) = O(n)$</p>
<p>先介绍一下利用 <code>multiset</code> 的解法, <code>multiset</code> 的底层实现使用了红黑树, 所以在插入和查找的时候复杂度都为 $O(logn)$, 但是求 <code>distance</code> 时, 由于 <code>multiset</code> 的迭代器不是随机访问的, 因此复杂度为 $O(n)$, 故而最后的时间复杂度为 $O(n^2)$. 该方法在 OJ 上超时, 此处仅用于记录.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countSmaller(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; nums_set;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(nums.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">auto</span> itlow = nums_set.lower_bound(nums[i]);</span><br><span class="line"></span><br><span class="line">            res[i] = <span class="built_in">std</span>::distance(nums_set.begin(), itlow);</span><br><span class="line">            <span class="comment">// multiset 求distance的复杂度为线性, 因此, 总复杂度为 O(n^2)</span></span><br><span class="line"></span><br><span class="line">            nums_set.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-有序数组"><a href="#解法二-有序数组" class="headerlink" title="解法二: 有序数组"></a>解法二: 有序数组</h2><p><strong>时间复杂度:</strong> $O(n\times (logn+n) = O(n^2)$, 在有序数组中找指定位置需要 $O(logn)$, 将当前元素插入到数组的指定位置需要 $O(n)$, 这个过程需要进行 $n$ 次.<br><strong>空间复杂度:</strong> $O(n+n) = O(n)$, 一个有序数组, 一个结果数组, 大小都为 $n$.</p>
<p>我们从后往前遍历, 将遍历过的数字维护成一个有序数组, 然后对于任意一个新来的数字, 我们可以在有序数组中查询小于该数字的元素个数, 查询的时间复杂度为 $O(logn)$, 然后我们需要将该数字也插入到有序数组中并保持有序, 插入操作需要的时间复杂度为 $O(n)$, 总共有 $n$ 个数字, 因此需要执行 $n$ 次, 故时间复杂度约为 $O(n^2)$, (虽然是 $O(n^2)$, 但是仍然没超时, 考虑是因为只有一个 $logn$, 而解法一具有两个 $logn$.) 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countSmaller(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order_nums;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//计算第一个不小于nums[i]的数字之前的数字个数</span></span><br><span class="line">            <span class="keyword">int</span> d = <span class="built_in">std</span>::lower_bound(order_nums.begin(), order_nums.end(), nums[i]) - order_nums.begin();</span><br><span class="line">            res[i] = d; <span class="comment">//将数字个数填进结果数字</span></span><br><span class="line">            order_nums.insert(order_nums.begin()+d, nums[i]); <span class="comment">// 当 nums[i] 插入到合适位置, 保持order_nums有序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-二叉搜索树-BST"><a href="#解法三-二叉搜索树-BST" class="headerlink" title="解法三: 二叉搜索树(BST)"></a>解法三: 二叉搜索树(BST)</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 内部只有一个 $logn$ 复杂度的插入操作, 没有其他操作, 但是由于不是平衡的, 所以在最坏情况下的复杂度为 $O(n^2)$, 最好情况即为平衡树, 复杂度为 $O(nlogn)$.<br><strong>空间复杂度:</strong> $O(n+n)$, <code>res</code> 数组和二叉树结构各占 $n$ 大小的空间. 如果采用递归实现插入, 则可能额外需要 $n$ 大小的递归空间.</p>
<p>在解法一中, 通过 <code>multiset</code> 红黑树的结构使得插入时的复杂度为 $logn$, 但是最终需要进行的操作过多, 导致时间超时, 为此, 我们可以自己实现一个二叉搜索树, 从后往前的遍历数组, 并且在插入元素的时候就统计出小于当前元素的节点的个数(为此我们需要在树的结构中额外添加一个变量 <code>smaller</code>, 只是小于当前节点的元素个数), 故而只需要一次 $logn$, 且没有其他多于操作, 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> smaller;</span><br><span class="line">        TreeNode *left;</span><br><span class="line">        TreeNode *right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> v, <span class="keyword">int</span> s):val(v), smaller(s), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(TreeNode *&amp;root, <span class="keyword">int</span> val)</span></span>&#123; <span class="comment">//  注意, 这要insert函数中, root的值要影响函数外的指针, 所以要用引用&amp;</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            root = <span class="keyword">new</span> TreeNode(val, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root-&gt;val)&#123;</span><br><span class="line">            root-&gt;smaller++; <span class="comment">// 如果新来的数比当前root的的值还小, 则smaller增1</span></span><br><span class="line">            <span class="keyword">return</span> insert(root-&gt;left, val); <span class="comment">// 递归插入到左子树中</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 递归插入到右子树中, 返回的小于元素的数量为: 根左侧的数量+右子树的数量+根(0:1)</span></span><br><span class="line">            <span class="keyword">return</span> root-&gt;smaller + insert(root-&gt;right, val) + (root-&gt;val==val ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 这里要千万注意三目运算符的优先级, 一定要用括号整个括起来才行!!!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countSmaller(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, <span class="number">0</span>);</span><br><span class="line">        TreeNode *root = <span class="literal">nullptr</span>;              </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123; <span class="comment">// 如果题目问的是左侧, 则i从0开始</span></span><br><span class="line">            res[i] = insert(root, nums[i]);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-归并排序"><a href="#解法四-归并排序" class="headerlink" title="解法四: 归并排序"></a>解法四: 归并排序</h2><p><strong>时间复杂度:</strong> $O(nlogn)$<br><strong>空间复杂度:</strong> $O(n+n) = O(n)$</p>
<p>由于解法三构造的二叉树并不是一个平衡的二叉树, 导致在树的极端情况下, 时间复杂度为 $O(n^2)$, 而要手动实现二叉树的平衡逻辑, 又有些复杂, 不适合解此题. 所以, 我们可以考虑此题的另一种解法, 即利用归并排序来解决.</p>
<p>【链接】Loading…<br><a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/76607/C%2B%2B-O(nlogn)-Time-O(n)-Space-MergeSort-Solution-with-Detail-Explanation" target="_blank" rel="noopener">https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/76607/C%2B%2B-O(nlogn)-Time-O(n)-Space-MergeSort-Solution-with-Detail-Explanation</a></p>
<h1 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a>322. Coin Change</h1><h2 id="Description-硬币凑面额"><a href="#Description-硬币凑面额" class="headerlink" title="Description: 硬币凑面额"></a>Description: 硬币凑面额</h2><p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: coins = [1, 2, 5], amount = 11</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: coins = [2], amount = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-DP-3"><a href="#解法一-DP-3" class="headerlink" title="解法一: DP"></a>解法一: DP</h2><p><strong>时间复杂度:</strong> $O(nm)$, $n$ 为总面额的大小, $m$ 为硬币的数量.<br><strong>空间复杂度:</strong> $O(n)$, DP 数组的大小为总面额的大小.</p>
<p>当我们求组成面额 $i$ 时所需的最少硬币数时, 我们可以用面额 $j$ 和面额 $i-j$ ($j\in[0,i]$)所需的硬币数之和来代替, 因此, 也就是说只与 $i$ 之前的面额数有关, 所以我们可以考虑使用 DP 算法来求解. 我们令 <code>dp[i]</code> 代表组成面额 $i$ 时所需的最少的硬币数, 要求 <code>dp[i]</code>, 我们可以根据硬币的面额来求解, 假设硬币的面额是 $j$, 那么就有 <code>dp[i] = min(dp[j] + dp[i-j])</code>, 其中 <code>dp[j]=1</code>, 因为组成这种面额只需要一个硬币就可以了, 我们根据此公式就可以写出相应的 DP 代码, 如下所示.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为不可能为负值, 所以使用无符号整数, 防止溢出</span></span><br><span class="line">        <span class="comment">// 额外多了一个0面额, 初值也可以设置为 amount+1, 因为最多的硬币数就是amount个1元.</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; dp(amount+<span class="number">1</span>, amount+<span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 为面额0赋初值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;amount+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> ci=<span class="number">0</span>; ci&lt;coins.size(); ci++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = coins[ci];</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= j) dp[i] = <span class="built_in">std</span>::min(dp[i], <span class="number">1</span>+dp[i-j]); <span class="comment">// 注意不能少了if语句, 否则会运行时错误</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span> : dp[amount];        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你可能会觉得我们进行了一些无用计算, 例如如果 $i$ 为 11, 而 <code>coins</code> 为 [1,5], 那么我们是否只需要计算 dp[6] 就可以了呢? 实际上, 如果有面额为 1 的硬币存在, 那么我们就必须计算所有的小于 $i$ 的dp值, 因为这些都是解, 至于是否为最小数量, 则需要利用 min 来不断筛选.</p>
<h2 id="解法二-DP-递归实现"><a href="#解法二-DP-递归实现" class="headerlink" title="解法二: DP 递归实现"></a>解法二: DP 递归实现</h2><p><strong>时间复杂度:</strong> $O(nm)$, $n$ 为总面额的大小, $m$ 为硬币的数量.<br><strong>空间复杂度:</strong> $O(n+n)=O(n)$, DP 数组的大小为总面额的大小, 另外, 递归还需额外占用一定空间.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount+<span class="number">1</span>, INT_MAX);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> coin_dfs(coins, amount, dp);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coin_dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;coins, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// invalid combination</span></span><br><span class="line">        <span class="keyword">if</span>(dp[target] != INT_MAX) <span class="keyword">return</span> dp[target]; <span class="comment">// already computed, return it</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;coins.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = coin_dfs(coins, target-coins[i], dp);</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;=<span class="number">0</span>) dp[target] = min(dp[target], <span class="number">1</span>+tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[target] = (dp[target] == INT_MAX) ? <span class="number">-1</span> : dp[target];</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-对暴力解法剪枝"><a href="#解法三-对暴力解法剪枝" class="headerlink" title="解法三: 对暴力解法剪枝"></a>解法三: 对暴力解法剪枝</h2><p><strong>时间复杂度:</strong> $O(logn+mlogm)$, 每次都用当前面额除以硬币面额, 故时间复杂度为 $O(logn)$, $O(mlogm)$ 为对硬币面额的排序复杂度, 当 $m&lt;&lt;n$ 时, 可忽略不计.<br><strong>空间复杂度:</strong> $O(logn)$, 无需申请额外空间, 仅仅是递归过程需要占用空间.</p>
<p>下面的方法利用余数对暴力解法进行剪枝, 剪枝后的程序运行速度十分快, 远远快于前两个算法.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX; <span class="comment">// results count</span></span><br><span class="line">        <span class="keyword">int</span> n = coins.size();</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>; <span class="comment">// current count</span></span><br><span class="line">        <span class="built_in">std</span>::sort(coins.begin(), coins.end()); <span class="comment">// sort from small to large</span></span><br><span class="line">        helper(coins, amount, n<span class="number">-1</span>, cur, res);</span><br><span class="line">        <span class="keyword">return</span> res==INT_MAX ? <span class="number">-1</span> : res;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;coins, <span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="keyword">int</span> cur, <span class="keyword">int</span> &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target%coins[start]==<span class="number">0</span>)&#123; <span class="comment">// 如果可以整除, 说明找到了合适的组合</span></span><br><span class="line">            res = min(res, cur+target/coins[start]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=target/coins[start]; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur+i &gt;= res<span class="number">-1</span>)</span><br><span class="line">                <span class="comment">// 如果当前的硬币数已经超过了 res-1, 说明之后肯定需要更多的硬币,</span></span><br><span class="line">                <span class="comment">// 因为后面的硬币面额变小了, 所以需要至少cur+i+1个硬币才能凑齐</span></span><br><span class="line">                <span class="comment">// 因此, 无需再进行循环, 直接跳出即可</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(start&gt;<span class="number">0</span>) <span class="comment">// start不能为负值, 因此start要大于0才能继续递归</span></span><br><span class="line">                helper(coins, target-i*coins[start], start<span class="number">-1</span>, cur+i, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于此算法的更详细解释(<a href="http://www.cnblogs.com/grandyang/p/5138186.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/5138186.html</a>):<br>难道这题一定要DP来做吗, 我们来看网友hello_world00提供的一种解法, 这其实是对暴力搜索的解法做了很好的优化, 不仅不会TLE, 而且击败率相当的高！对比Brute Force的方法, 这里在递归函数中做了很好的优化. 首先是判断start是否小于0, 因为我们需要从coin中取硬币, 不能越界. 下面就是优化的核心了, 看target是否能整除coins[start], 这是相当叼的一步, 比如假如我们的目标值是15, 如果我们当前取出了大小为5的硬币, 我们做除法, 可以立马知道只用大小为5的硬币就可以组成目标值target, 那么我们用cur + target/coins[start] 来更新结果res. 之后的for循环也相当叼, 不像暴力搜索中的那样从start位置开始往前遍历coins中的硬币, 而是遍历 target/coins[start] 的次数, 由于不能整除, 我们只需要对余数调用递归函数, 而且我们要把次数每次减1, 并且再次求余数. 举个例子, 比如coins=[1,2,3], amount=11, 那么 11除以3, 得3余2, 那么我们的i从3开始遍历, 这里有一步非常有用的剪枝操作, 没有这一步, 还是会TLE, 而加上了这一步, 直接击败百分之九十九以上, 可以说是天壤之别. 那就是判断若 cur + i &gt;= res - 1 成立, 直接break, 不调用递归. 这里解释一下, cur + i 自不必说, 是当前硬币个数cur 加上新加的i个硬币, 我们都是知道cur+i如果大于等于res的话, 那么res是不会被更新的, 那么为啥这里是大于等于res-1呢？因为能运行到这一步, 说明之前是无法整除的, 那么余数一定存在, 所以再次调用递归函数的target不为0, 那么如果整除的话, cur至少会加上1, 所以又跟res相等了, 还是不会使得res变得更小.</p>
<h1 id="324-Wiggle-Sort-II"><a href="#324-Wiggle-Sort-II" class="headerlink" title="324. Wiggle Sort II"></a>324. Wiggle Sort II</h1><h2 id="Description-“驼峰”-排序"><a href="#Description-“驼峰”-排序" class="headerlink" title="Description: “驼峰” 排序"></a>Description: “驼峰” 排序</h2><p>Given an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]….</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1, 5, 1, 1, 6, 4]</span><br><span class="line">Output: One possible answer is [1, 4, 1, 5, 1, 6].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1, 3, 2, 2, 3, 1]</span><br><span class="line">Output: One possible answer is [2, 3, 1, 3, 1, 2].</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>You may assume all input has valid answer.</p>
<p><strong>Follow Up:</strong><br>Can you do it in O(n) time and/or in-place with O(1) extra space?</p>
<h2 id="解法一-排序-4"><a href="#解法一-排序-4" class="headerlink" title="解法一: 排序"></a>解法一: 排序</h2><p><strong>时间复杂度:</strong> $O(nlogn + n)$, 排序的时间复杂度为 $O(nlogn)$, 构造 “驼峰” 数组的复杂度为 $O(n)$<br><strong>空间复杂度:</strong> $O(n)$, 额外数组需要占用 $O(n)$ 空间</p>
<p>该问题的解法可能有多个, 我们只需要找到其中一个即可, 核心思路是将一个数组分成两半, 其中前一半的元素都小于后一半的元素, 然后我们只需要依次从两个数组中取值组成新数组, 就可以满足 “驼峰” 排序.<br>首先, 对数组中的元素排序, 这样, 任意的相邻元素, 都满足 <code>nums[i] &lt;= nums[i+1]</code>, 我们将数组分成两半, 这样, 前半段的元素都小于等于后半段的元素, <strong>注意, 题目中已经指明数组是合法的有效数组, 所以一定可以组成驼峰</strong>, 因此, 我们先取前半段的最后一个元素, 再取后半段的最后一个元素, 这两个元素一定满足绝对小于关系(否则无法形成 “驼峰”), 然后我们再取倒数第二个, 依次类推, 直至取完. <strong>注意, 我们不能从前往后取, 因为不能保证前半段的第二个元素绝对小于后半段的第一个元素, 例如[4,5,5,6], 从前往后取就会变成[4,5,5,6], 不符合驼峰, 从后往前取为[5,6,4,5], 符合驼峰</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> mid = (nums.size()+<span class="number">1</span>)/<span class="number">2</span>; <span class="comment">// 令mid指向中间的位置</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid<span class="number">-1</span>, j=nums.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span> ; i--, j--)&#123; <span class="comment">// 从后往前选择元素, 分别放到tmp中</span></span><br><span class="line">            tmp.push_back(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=mid) tmp.push_back(nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        nums = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-partition"><a href="#解法二-partition" class="headerlink" title="解法二: partition"></a>解法二: partition</h2><p><strong>时间复杂度:</strong> $O(n+n)= O(n)$, 查找中位数需要 $O(n)$, 填充数组需要 $O(n)$.<br><strong>空间复杂度:</strong> $O(n)$, 填充时使用了额外的数组空间来辅助.</p>
<p>如果当数组中的元素不含有重复时, 此题很容易就用基于 partition 的方法解决, 因为, 我们可以找到将数组分成两个具有绝对小于关系的数组, 然后依次用两个数组填充即可, 但是, 此题的元素是可重复的, 所以必须考虑重复元素的影响.<br>首先我们利用 <code>nth_element()</code> 找到中位数, 虽然 <code>nth_element()</code> 的时间复杂度已经不是 $O(n)$, 但是这里我们为了简化代码, 仍然使用 <code>nth_element()</code> 来查找中位数 <code>mid</code>(后面也会更多稍复杂一点的 partition 算法, 面试时建议使用 <code>nth_element</code>, 注意要向面试官说明复杂度问题), 之后, 对于其他的任意一个数组元素, 都有三种不同的情况:</p>
<ul>
<li>大于 <code>mid</code>, 将大于 <code>mid</code> 的元素放在数组开始的奇数位上面;</li>
<li>小于 <code>mid</code>, 将小于 <code>mid</code> 的元素放在数组的偶数位上面;</li>
<li>等于 <code>mid</code>, 用所有等于 <code>mid</code> 的元素填充剩下的位置.</li>
</ul>
<p>由于题目指明输入的数组一定是有效的, 因此当我们进行了上面遍历后, 数组一定会变成 “驼峰” 数组, 因为当和 <code>mid</code> 相等的元素处于 “驼峰” 底部时, 它一定位于偶数位(奇数位都是大于 <code>mid</code> 的元素), 同理, 当 <code>mid</code> 处于 “驼峰” 顶部时, 它一定位于奇数位, 因为偶数位都被小于 <code>mid</code> 的元素填充. 故最终的数组是 “驼峰” 数组.</p>
<p><strong>nth_element()</strong>(该函数在 C++17 后不是 $O(n)$, 而是 $O(nlogn)$, 但是在 C++11 中仍然是 $O(n)$):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">std</span>::nth_element(nums.begin(), nums.begin()+n/<span class="number">2</span>, nums.end());</span><br><span class="line">        <span class="keyword">int</span> mid = nums[n/<span class="number">2</span>]; <span class="comment">// 找到中位数</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, mid); <span class="comment">// 先将所有元素置为中位数</span></span><br><span class="line">        <span class="keyword">int</span> even_i = (n<span class="number">-1</span>)/<span class="number">2</span>*<span class="number">2</span>; <span class="comment">// 令 even_i 指向数组的最后一个偶数位</span></span><br><span class="line">        <span class="keyword">int</span> odd_i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; mid)&#123; <span class="comment">// 将大于中位数的放到前面的奇数位上</span></span><br><span class="line">                res[odd_i] = nums[i];</span><br><span class="line">                odd_i += <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; mid)&#123; <span class="comment">//将小于中位数的放到后面的偶数位上</span></span><br><span class="line">                res[even_i] = nums[i];</span><br><span class="line">                even_i -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// 剩下的位置都是中位数</span></span><br><span class="line">        nums = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>自己利用partition实现 $O(n)$ 的中位数查找:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> P = nums[low];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P &lt;= nums[high]) high--;</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P &gt;= nums[low]) low++;</span><br><span class="line">            nums[high] = nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = P;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> target = n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = partition(nums, low, high);</span><br><span class="line">            <span class="keyword">if</span>(m &lt; target) low = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m &gt; target) high = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = nums[target]; <span class="comment">// 找到中位数</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, mid); <span class="comment">// 先将所有元素置为中位数</span></span><br><span class="line">        <span class="keyword">int</span> even_i = (n<span class="number">-1</span>)/<span class="number">2</span>*<span class="number">2</span>; <span class="comment">// 令 even_i 指向数组的最后一个偶数位</span></span><br><span class="line">        <span class="keyword">int</span> odd_i = <span class="number">1</span>; <span class="comment">// 指向第一个奇数位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; mid)&#123; <span class="comment">// 将大于中位数的放到前面的奇数位上</span></span><br><span class="line">                res[odd_i] = nums[i];</span><br><span class="line">                odd_i += <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; mid)&#123; <span class="comment">//将小于中位数的放到后面的偶数位上</span></span><br><span class="line">                res[even_i] = nums[i];</span><br><span class="line">                even_i -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// 剩下的位置都是中位数</span></span><br><span class="line">        nums = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Follow-up-three-way-partition"><a href="#Follow-up-three-way-partition" class="headerlink" title="Follow up: three-way partition"></a>Follow up: three-way partition</h2><p><strong>时间复杂度:</strong> $O(n+n) = O(n)$, 找中位数时的复杂度为 $O(n)$, 调整数组的复杂度为 $O(n)$.<br><strong>空间复杂度:</strong> $O(1)$, 无需占用额外空间</p>
<p>解法二的时间复杂度满足要求, 问题在于我们如何能够在 $O(1)$ 的空间复杂度限制下, 完成数组的填充工作, 很自然的我们可以想到利用 <code>swap</code> 来实现, 具体流程如下所示:</p>
<ol>
<li>先令 <code>even_i</code> 指向数组的最后一个偶数位(从0位开始, 0算作偶数位), 令 <code>odd_i</code> 指向第一个奇数位(下标为1). 我们从最后一个偶数位元素(用下标 <code>i</code> 指示)开始进行判断;</li>
<li>如果 <code>nums[i]&lt;mid</code>, 则将 <code>nums[i]</code> 与 <code>nums[even_i]</code> 交换, 交换后, <code>even_i</code> 不可再被访问, 令 <code>even_i -= 2</code>, <strong>同时注意, 由于刚开始的时候 <code>i</code> 与 <code>even_i</code> 是相等的, 故也要令 <code>i -= 2</code>, 当 <code>i&lt;0</code> 以后, 要令 <code>i</code> 指向最后一个奇数位</strong>.</li>
<li>如果 <code>nums[i]&gt;mid</code>, 则将 <code>nums[i]</code> 与 <code>nums[odd_i]</code> 交换, 同时令 <code>odd_i += 2</code>, 注意, 此时, <code>i</code> 指向的数字是交换后的原来 <code>odd_i</code> 指向的数字, 因此, 我们需要对该数字进行判断, <strong>故不能改变 <code>i</code> 的值.</strong></li>
<li>如果和 <code>mid</code> 相等, 则无需进行交换填充, 令其保存原值即可, 判断下一个元素, 令 <code>i -=2</code>, 同时还要判断 <code>i</code> 是否小于 0, 若小于, 则需令 <code>i</code> 指向最后的奇数位.</li>
</ol>
<p><strong>nth_element():</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">std</span>::nth_element(nums.begin(), nums.begin()+n/<span class="number">2</span>, nums.end());</span><br><span class="line">        <span class="keyword">int</span> mid = nums[n/<span class="number">2</span>]; <span class="comment">// 找到中位数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(1) 空间复杂度填充数组</span></span><br><span class="line">        <span class="keyword">int</span> even_i = (n<span class="number">-1</span>)/<span class="number">2</span>*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> odd_i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = even_i; <span class="comment">// 令i指向最后一个偶数位</span></span><br><span class="line">        <span class="keyword">int</span> count = n;</span><br><span class="line">        <span class="keyword">while</span>(count--)&#123; <span class="comment">//每次都会判断一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; mid)&#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[i], nums[even_i]);</span><br><span class="line">                even_i -= <span class="number">2</span>;</span><br><span class="line">                i -= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">0</span>) i = n/<span class="number">2</span>*<span class="number">2</span> - <span class="number">1</span>; <span class="comment">// 令 i 指向最后一个奇数位</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; mid)&#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[i], nums[odd_i]);</span><br><span class="line">                odd_i += <span class="number">2</span>; <span class="comment">// 奇数位增加</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 保持原值不变, 判断下一个值</span></span><br><span class="line">                i -= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">0</span>) i = n/<span class="number">2</span>*<span class="number">2</span> - <span class="number">1</span>; <span class="comment">// 令 i 指向最后一个奇数位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>partition:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> P = nums[low];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P &lt;= nums[high]) high--;</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P &gt;= nums[low]) low++;</span><br><span class="line">            nums[high] = nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = P;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> target = n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = partition(nums, low, high);</span><br><span class="line">            <span class="keyword">if</span>(m &lt; target) low = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m &gt; target) high = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = nums[target]; <span class="comment">// 找到中位数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(1) 空间复杂度填充数组</span></span><br><span class="line">        <span class="keyword">int</span> even_i = (n<span class="number">-1</span>)/<span class="number">2</span>*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> odd_i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = even_i; <span class="comment">// 令i指向最后一个偶数位</span></span><br><span class="line">        <span class="keyword">int</span> count = n;</span><br><span class="line">        <span class="keyword">while</span>(count--)&#123; <span class="comment">//每次都会判断一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; mid)&#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[i], nums[even_i]);</span><br><span class="line">                even_i -= <span class="number">2</span>;</span><br><span class="line">                i -= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">0</span>) i = n/<span class="number">2</span>*<span class="number">2</span> - <span class="number">1</span>; <span class="comment">// 令 i 指向最后一个奇数位</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; mid)&#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[i], nums[odd_i]);</span><br><span class="line">                odd_i += <span class="number">2</span>; <span class="comment">// 奇数位增加</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 保持原值不变, 判断下一个值</span></span><br><span class="line">                i -= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">0</span>) i = n/<span class="number">2</span>*<span class="number">2</span> - <span class="number">1</span>; <span class="comment">// 令 i 指向最后一个奇数位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="326-Power-of-Three"><a href="#326-Power-of-Three" class="headerlink" title="326. Power of Three"></a>326. Power of Three</h1><h2 id="Description-三的幂次"><a href="#Description-三的幂次" class="headerlink" title="Description: 三的幂次"></a>Description: 三的幂次</h2><p>Given an integer, write a function to determine if it is a power of three.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 27</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 0</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 9</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 45</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-自下而上-超时"><a href="#解法一-自下而上-超时" class="headerlink" title="解法一: 自下而上(超时)"></a>解法一: 自下而上(超时)</h2><p><strong>时间复杂度:</strong> $O(logn)$, 计算3的幂次, 总共需要计算 $log_3n$ 次<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>该方法从 3 开始, 逐渐计算 3 的幂次, 但是由于对于任何数都要计算 $log3n$ 次, 故当数很大时会超时</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">pow</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">pow</span> &lt; n)&#123;</span><br><span class="line">            <span class="built_in">pow</span> = <span class="built_in">pow</span>*<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>==n ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-自上而下"><a href="#解法二-自上而下" class="headerlink" title="解法二: 自上而下"></a>解法二: 自上而下</h2><p><strong>时间复杂度:</strong> $O(logn)$, 利用除法判断是否能整除 3, 当不能整除时, 可以提前退出, 起到剪枝效果, 最多需要计算 $log_3n$ 次<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>解法一采用的自下而上的乘法方法对于任何的数字都需要进行 $log_3n$ 次乘法才能判断是否为 3 的幂次, 这显然是不需要的, 我们只需要利用除法, 不断判断是否能被 3 整除即可, 一旦发现不能整除, 则肯定不是 3 的幂次, 可提前退出, 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;        </span><br><span class="line">        <span class="keyword">while</span> (n%<span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-进制转换-不使用循环或迭代"><a href="#解法三-进制转换-不使用循环或迭代" class="headerlink" title="解法三: 进制转换(不使用循环或迭代)"></a>解法三: 进制转换(不使用循环或迭代)</h2><p>十进制的 pow 形式为: 10, 100, 1000 (分别代表十, 一百, 一千)<br>二进制的 pow 形式为: 10, 100, 1000 (分别代表二, 四, 八)<br>因此我们可以推出三进制的形式为: 10, 100, 1000 (分别代表三, 九, 二十七)</p>
<p>故此, 我们可以将十进制先转换成三进制, 然后判断三进制形式是否首位为一, 其他位均为零, 如果满足, 则说明当前的数字是三的幂次. 该方法不需要循环和迭代(实际上在转换的过程仍然使用了循环和迭代).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="328-Odd-Even-Linked-List"><a href="#328-Odd-Even-Linked-List" class="headerlink" title="328. Odd Even Linked List"></a>328. Odd Even Linked List</h1><h2 id="Description-奇偶链表"><a href="#Description-奇偶链表" class="headerlink" title="Description: 奇偶链表"></a>Description: 奇偶链表</h2><p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>
<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL</span><br><span class="line">Output: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>The relative order inside both the even and odd groups should remain as it was in the input.<br>The first node is considered odd, the second node even and so on …</p>
<h2 id="解法一-一次遍历"><a href="#解法一-一次遍历" class="headerlink" title="解法一: 一次遍历"></a>解法一: 一次遍历</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历每个节点一次<br><strong>空间复杂度:</strong> $O(1)$, 未使用任何额外空间</p>
<p>我们利用两个变量分别来维护奇数链表和偶数链表, 最后令奇数链表的最后一个节点的 <code>next</code> 指针指向偶数链表的头结点, 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *odd_head = head; <span class="comment">// 奇数链表头</span></span><br><span class="line">        ListNode *even_head = head-&gt;next; <span class="comment">// 偶数链表头</span></span><br><span class="line">        ListNode *odd_node = odd_head; <span class="comment">// 奇数链表节点</span></span><br><span class="line">        ListNode *even_node = even_head; <span class="comment">// 偶数链表节点</span></span><br><span class="line">        ListNode *node = head-&gt;next-&gt;next; <span class="comment">// 令当前节点指向第三个节点</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">3</span>; <span class="comment">// 记录节点编号(从1开始)</span></span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="literal">nullptr</span>)&#123;            </span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span> == <span class="number">1</span>)&#123; <span class="comment">// 奇数链表</span></span><br><span class="line">                odd_node-&gt;next = node;</span><br><span class="line">                odd_node = odd_node-&gt;next;</span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 偶数链表</span></span><br><span class="line">                even_node-&gt;next = node;</span><br><span class="line">                even_node = even_node-&gt;next;</span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;           </span><br><span class="line">        &#125;</span><br><span class="line">        odd_node-&gt;next = even_head;</span><br><span class="line">        even_node-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 少了这句话会超时, 原因是even_node会指向前面的某个节点, 形成环, 使得程序判断时无法终止</span></span><br><span class="line">        <span class="keyword">return</span> odd_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>更简洁的写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == null) <span class="keyword">return</span> null;</span><br><span class="line">        ListNode odd = head, even = head.next, evenHead = even;</span><br><span class="line">        <span class="keyword">while</span> (even != null &amp;&amp; even.next != null) &#123;</span><br><span class="line">            odd.next = even.next;</span><br><span class="line">            odd = odd.next;</span><br><span class="line">            even.next = odd.next;</span><br><span class="line">            even = even.next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd.next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="329-Longest-Increasing-Path-in-a-Matrix"><a href="#329-Longest-Increasing-Path-in-a-Matrix" class="headerlink" title="329. Longest Increasing Path in a Matrix"></a>329. Longest Increasing Path in a Matrix</h1><h2 id="Description-寻找矩阵中的最长递增序列"><a href="#Description-寻找矩阵中的最长递增序列" class="headerlink" title="Description: 寻找矩阵中的最长递增序列"></a>Description: 寻找矩阵中的最长递增序列</h2><p>Given an integer matrix, find the length of the longest increasing path.</p>
<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: nums =</span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest increasing path is [1, 2, 6, 9].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: nums =</span><br><span class="line">[</span><br><span class="line">  [3,4,5],</span><br><span class="line">  [3,2,6],</span><br><span class="line">  [2,2,1]</span><br><span class="line">]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-DP-dfs"><a href="#解法一-DP-dfs" class="headerlink" title="解法一: DP + dfs"></a>解法一: DP + dfs</h2><p><strong>时间复杂度:</strong> $O(mn)$, 每个节点都会遍历一次, 当遍历一次后, 下次再访问时可以直接通过 dp 数组得知答案.<br><strong>空间复杂度:</strong> $O(mn+mn=mn)$, $n$ 行 $m$ 列的 DP 数组所占用的空间大小, 另外还有递归所占用的空间($mn?$)</p>
<p>申请和矩阵相同大小的 DP 数组, 令 <code>dp[i][j]</code> 代表从 <code>(i,j)</code> 位置为起点的绝对递增数列的长度, 每遍历一个位置后, 下一次再访问该位置时就无需重复计算, 可以直接通过 dp 数组获取到相应长度. 在查找当前节点的最大长度时, 我们利用 dfs 算法, 依次从四个方向进行查找, 最终取最大值作为本位置的最长递增序列长度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;dp, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> &amp;n, <span class="keyword">int</span> &amp;m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j]!=<span class="number">0</span>) <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        dp[i][j] = <span class="number">1</span>; <span class="comment">//长度至少为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d : dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i+d[<span class="number">0</span>], y = j+d[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;m &amp;&amp; matrix[x][y] &gt; matrix[i][j])&#123; <span class="comment">// 绝对递增, 因此不能有 =</span></span><br><span class="line">                <span class="keyword">int</span> len =  <span class="number">1</span>+dfs(matrix, dp, x, y, n, m);</span><br><span class="line">                dp[i][j] = <span class="built_in">std</span>::max(dp[i][j], len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span> || matrix[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++)&#123;</span><br><span class="line">                res = <span class="built_in">std</span>::max(res, dfs(matrix, dp, i, j, n, m));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-DP-BFS"><a href="#解法二-DP-BFS" class="headerlink" title="解法二: DP + BFS"></a>解法二: DP + BFS</h2><p>TODO: <a href="http://www.cnblogs.com/grandyang/p/5148030.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/5148030.html</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size(), res = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs&#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q&#123;&#123;&#123;i, j&#125;&#125;&#125;;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                    <span class="keyword">int</span> len = q.size();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; ++k) &#123;</span><br><span class="line">                        <span class="keyword">auto</span> t = q.front(); q.pop();</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dirs) &#123;</span><br><span class="line">                            <span class="keyword">int</span> x = t.first + dir[<span class="number">0</span>], y = t.second + dir[<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || matrix[x][y] &lt;= matrix[t.first][t.second] || cnt &lt;= dp[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">                            dp[x][y] = cnt;</span><br><span class="line">                            res = max(res, cnt);</span><br><span class="line">                            q.push(&#123;x, y&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="334-Increasing-Triplet-Subsequence"><a href="#334-Increasing-Triplet-Subsequence" class="headerlink" title="334. Increasing Triplet Subsequence"></a>334. Increasing Triplet Subsequence</h1><h2 id="Description-递增的三元子序列"><a href="#Description-递增的三元子序列" class="headerlink" title="Description: 递增的三元子序列"></a>Description: 递增的三元子序列</h2><p>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.</p>
<p>Formally the function should:</p>
<p>Return true if there exists i, j, k<br>such that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.<br><strong>Note:</strong> Your algorithm should run in O(n) time complexity and O(1) space complexity.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,4,3,2,1]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-用辅助变量指向-min-和-mid"><a href="#解法一-用辅助变量指向-min-和-mid" class="headerlink" title="解法一: 用辅助变量指向 min 和 mid"></a>解法一: 用辅助变量指向 min 和 mid</h2><p><strong>时间复杂度:</strong> $O(n)$, 每个元素之遍历一次<br><strong>空间复杂度:</strong> $O(1)$, 无需额外空间</p>
<p>我们利用两个变量 <code>min</code> 和 <code>mid</code> 分别指向三元子序列中的最小元素和中间元素, 最开始时, 二者赋初值为 <code>INT_MAX</code>, 然后遍历数组, 对于数组中的每一个数 <code>num</code>, 进行如下判断:</p>
<ol>
<li>是否小于等于 <code>min</code>, 若满足, 则令 <code>min=num</code>;</li>
<li>若不满足(1), 则说明 <code>num &gt; min</code>, 判断 <code>num</code> 是否小于等于 <code>mid</code>, 若满足, 责令 <code>mid=num</code>;(此时 <code>mid</code> 一定大于 <code>min</code>, 且下标也大于 <code>min</code> 下标)</li>
<li>若不满足(1)(2), 则说明 <code>num</code> 不仅大于 <code>min</code>, 而且大于 <code>mid</code>, 同时 <code>num</code> 的下标也大于前两者, 由此, 我们找到了一个满足条件的递增三元组子序列, 可直接返回 <code>true</code>. 否则, 重复以上步骤直至遍历完数组</li>
<li>如果遍历完整个数组后, 仍然找不到符合条件的序列, 则说明不存在这样的序列, 返回 false.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">increasingTriplet</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> min=INT_MAX, mid=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &lt;= min) <span class="comment">// 等于号不能少, 否则会跳到最后的else中, 直接返回true</span></span><br><span class="line">                min = num;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &lt;= mid) <span class="comment">// 如输入为 11111111 时, 若没有等于号, 则会跳到else中返回true</span></span><br><span class="line">                mid = num;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//当前数字比min和mid都大, 所以找到了一个三元组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="337-打家劫舍-III-中等"><a href="#337-打家劫舍-III-中等" class="headerlink" title="337. 打家劫舍 III-中等"></a>337. 打家劫舍 III-中等</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber-iii/</a></p>
<p>二叉树型的偷家</p>
<h2 id="解法-树形动态规划"><a href="#解法-树形动态规划" class="headerlink" title="解法: 树形动态规划"></a>解法: 树形动态规划</h2><p><strong>动态方程:</strong></p>
<ul>
<li>某个树的最大收益 = max（包含根节点的最大收益，以及不包含根节点的最大收益）；</li>
<li>不包含根节点的最大收益 = 左子树的最大收益 + 右子树最大收益</li>
<li>包含根节点的最大收益 = 不包含左子节点的左子树最大收益 + 根节点 + 不包含右子节点的最大收益</li>
<li>maxSum = max（maxSum，当前树的最大收益）</li>
</ul>
<p><strong>复杂度分析:</strong><br>时间复杂度：O（n）。只遍历一遍所有节点<br>空间复杂度：O（n）。递归栈的调用，如果树极度不平衡，空间复杂度为O（n）；如果树平衡，为O（log N）。</p>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; traverse(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">int</span> rob = <span class="number">0</span>, not_rob = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;rob, not_rob&#125;;</span><br><span class="line">        <span class="keyword">auto</span> left = traverse(root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> right = traverse(root-&gt;right);</span><br><span class="line">        rob = left[<span class="number">1</span>] + right[<span class="number">1</span>] + root-&gt;val;</span><br><span class="line">        not_rob = <span class="built_in">std</span>::max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">std</span>::max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;rob, not_rob&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = traverse(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="keyword">None</span>: <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line">            l_rob, l_not_rob = helper(root.left)</span><br><span class="line">            r_rob, r_not_rob = helper(root.right)</span><br><span class="line">            rob = l_not_rob + r_not_rob + root.val</span><br><span class="line">            not_rob = max(l_rob, l_not_rob) + max(r_rob, r_not_rob)</span><br><span class="line">            <span class="keyword">return</span> rob, not_rob</span><br><span class="line">        <span class="keyword">return</span> max(helper(root))</span><br></pre></td></tr></table></figure></p>
<h1 id="341-Flatten-Nested-List-Iterator"><a href="#341-Flatten-Nested-List-Iterator" class="headerlink" title="341. Flatten Nested List Iterator"></a>341. Flatten Nested List Iterator</h1><h2 id="Description-将嵌套的多维列表展开成一维"><a href="#Description-将嵌套的多维列表展开成一维" class="headerlink" title="Description: 将嵌套的多维列表展开成一维"></a>Description: 将嵌套的多维列表展开成一维</h2><p>Given a nested list of integers, implement an iterator to flatten it.</p>
<p>Each element is either an integer, or a list — whose elements may also be integers or other lists.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1],2,[1,1]]</span><br><span class="line">Output: [1,1,2,1,1]</span><br><span class="line">Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,[4,[6]]]</span><br><span class="line">Output: [1,4,6]</span><br><span class="line">Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-栈-3"><a href="#解法一-栈-3" class="headerlink" title="解法一: 栈"></a>解法一: 栈</h2><p><strong>PS: 这道题可以在初始化时将列表全部展开并存储, 这样 <code>hasNext()</code> 就可以达到 $O(1)$ 的时间复杂度, 但是, 这是很不好的! 因为实际实现迭代器时, 我们往往只在需要的时候才会对元素进行展开, 这样可以获得最大的平均效率</strong></p>
<p><strong>时间复杂度:</strong> $O(n)$, 每个节点至多遍历一次, 其中, <code>next()</code> 复杂度为 $O(1)$, 初始化和 <code>hasNext()</code> 的复杂度均为 $O(n)$<br><strong>空间复杂度:</strong> $O(n)$, 栈所需空间</p>
<p>先将数组中的所有元素从后往前的放进栈中, 这样栈顶元素即为数组中的第一个元素, 然后对栈顶元素进行判断, 如果 <code>isInteger()</code> 为真, 则直接返回 <code>true</code>, 否则, 就获取栈顶对应的 <code>vector&lt;NestedInteger&gt;</code> 数组, 并将栈顶 <code>pop()</code>, 然后将数组从后往前再放到栈中, 重复以上操作直至栈为空, 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;NestedInteger&gt; s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NestedIterator(<span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nestedList.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            s.push(nestedList[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">return</span> res.getInteger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            NestedInteger top = s.top();</span><br><span class="line">            <span class="keyword">if</span>(top.isInteger()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="built_in">vector</span>&lt;NestedInteger&gt; <span class="built_in">list</span> = top.getList();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">list</span>.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">                    s.push(<span class="built_in">list</span>[i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NestedIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NestedIterator i(nestedList);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="解法二-deque"><a href="#解法二-deque" class="headerlink" title="解法二: deque"></a>解法二: deque</h2><p><strong>时间复杂度:</strong> $O(n)$, 每个节点至多遍历一次, 其中, <code>next()</code> 复杂度为 $O(1)$, 初始化和 <code>hasNext()</code> 的复杂度均为 $O(n)$<br><strong>空间复杂度:</strong> $O(n)$, 双端队列所需空间</p>
<p>同样的思路, 也可以用双端队列解决.(栈有的功能双端队列也有)</p>
<h1 id="344-Reverse-String"><a href="#344-Reverse-String" class="headerlink" title="344. Reverse String"></a>344. Reverse String</h1><h2 id="Description-反转字符串"><a href="#Description-反转字符串" class="headerlink" title="Description: 反转字符串"></a>Description: 反转字符串</h2><p>Write a function that takes a string as input and returns the string reversed.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;hello&quot;</span><br><span class="line">Output: &quot;olleh&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: &quot;amanaP :lanac a ,nalp a ,nam A&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-使用-reverse-函数"><a href="#解法一-使用-reverse-函数" class="headerlink" title="解法一: 使用 reverse 函数"></a>解法一: 使用 reverse 函数</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;        </span><br><span class="line">        <span class="built_in">std</span>::reverse(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-基于-swap"><a href="#解法二-基于-swap" class="headerlink" title="解法二: 基于 swap"></a>解法二: 基于 swap</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(s[i], s[len<span class="number">-1</span>-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="347-Top-K-Frequent-Elements"><a href="#347-Top-K-Frequent-Elements" class="headerlink" title="347. Top K Frequent Elements"></a>347. Top K Frequent Elements</h1><h2 id="Description-寻找频率最高的-k-个数字"><a href="#Description-寻找频率最高的-k-个数字" class="headerlink" title="Description: 寻找频率最高的 k 个数字"></a>Description: 寻找频率最高的 k 个数字</h2><p>Given a non-empty array of integers, return the k most frequent elements.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1], k = 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure></p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ number of unique elements.<br>Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size.</p>
<h2 id="解法一-哈希-大顶堆"><a href="#解法一-哈希-大顶堆" class="headerlink" title="解法一: 哈希+大顶堆"></a>解法一: 哈希+大顶堆</h2><p><strong>时间复杂度:</strong> $O(n+nlogn)=O(nlogn)$, 遍历复杂度为 $O(n)$, 堆排序复杂度为 $O(nlogn)$<br><strong>空间复杂度:</strong> $O(n+n) = O(n)$, <code>unordered_map</code> 和 <code>priority_queue</code> 各占 $O(n)$ 大小的空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">            hash[num]++; <span class="comment">//对于不存在的关键字, 其值默认为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:hash)</span><br><span class="line">            q.push(&#123;it.second, it.first&#125;); <span class="comment">// 注意, sceond在前作为排序依据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;k; i++)&#123;</span><br><span class="line">            res.push_back(q.top().second); q.pop();</span><br><span class="line">            <span class="comment">// 注意, 因为插入的时候将first插在了第二位, 因此, 获取时应该用second获取数字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-哈希-小顶堆"><a href="#解法二-哈希-小顶堆" class="headerlink" title="解法二: 哈希+小顶堆"></a>解法二: 哈希+小顶堆</h2><p><strong>时间复杂度:</strong> $O(n+nlogk)=O(nlogk)$, 遍历复杂度为 $O(n)$, 堆排序时, 用小顶堆, 只保存最大的 k 个元素即可.<br><strong>空间复杂度:</strong> $O(n+n) = O(n)$, <code>unordered_map</code> 和 <code>priority_queue</code> 各占 $O(n)$ 大小的空间</p>
<p>整体思路和解法一相同, 只不过我们需要得到最大的 $k$ 个元素即可, 因此无需维护 $n$ 大小的大顶堆. 相反, 我们选择维护 $k$ 大小的小顶堆, 对于任意一个新来的元素, 如果它大于堆顶, 则将堆顶退出, 然后将新来元素加入堆中. 因为小顶堆的堆顶是最小的元素, 因此堆中用于 $k-1$ 个比堆顶大的元素, 故这 $k$ 个元素就是最大的 $k$ 个元素, 最终我们只需要将堆中数据依次取出, 然后执行一次 <code>reverse()</code> 即可.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这里小顶堆的定义, 其元素是 pair 类型</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;, <span class="built_in">std</span>::greater&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;&gt; q; <span class="comment">// 小顶堆</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">            hash[num]++; <span class="comment">//对于不存在的关键字, 其值默认为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : hash)&#123; <span class="comment">// 注意, 必须是遍历哈希表, 而不能遍历原数组, 因为原数组存在重复数字</span></span><br><span class="line">            <span class="keyword">if</span>(q.size() &lt; k)</span><br><span class="line">                q.push(&#123;it.second, it.first&#125;);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(q.top().first &lt; it.second)&#123;</span><br><span class="line">                q.pop();</span><br><span class="line">                q.push(&#123;it.second, it.first&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;k; i++)&#123;</span><br><span class="line">            res.push_back(q.top().second); q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::reverse(res.begin(), res.end()); <span class="comment">//因为结果是从小顶堆中得到的, 所以需要逆置一下, 也可以不逆置</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-哈希-桶"><a href="#解法三-哈希-桶" class="headerlink" title="解法三: 哈希+桶"></a>解法三: 哈希+桶</h2><p><strong>时间复杂度:</strong> $O(n+n+k)=O(n)$, 构建哈希表, 构建桶, 从桶找到 $k$ 个最大数字的复杂度分别为: $O(n)$, $O(n)$, 和 $O(k)$.<br><strong>空间复杂度:</strong> $O(n+n) = O(n)$, 哈希表和桶各占 $O(n)$</p>
<p>当我们拥有关于元素频率的哈希表以后, 我们可以利用此表构建桶结构, 桶的 “关键字” 为元素频率, 之后, 我们可以用 $O(n)$ 的复杂度对桶进行遍历, 当找到 $k$ 个最大元素时, 跳出遍历循环, 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash; <span class="comment">// 哈希</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num : nums) hash[num]++;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; buckets(nums.size()+<span class="number">1</span>); <span class="comment">// 根据数组的大小申请桶的空间, 多申请一个是为了方便下标对齐</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> h : hash) buckets[h.second].push_back(h.first); <span class="comment">// 用频率来做桶的索引, 并且对应数字放入桶中</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=buckets.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123; <span class="comment">// 最后往前遍历, 寻找频率最高的k个元素</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bucket = buckets[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; num : bucket)&#123;</span><br><span class="line">                res.push_back(num);</span><br><span class="line">                <span class="keyword">if</span>(res.size() &gt;= k) <span class="keyword">return</span> res; <span class="comment">// 找到k个元素, 直接返回并退出</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="350-Intersection-of-Two-Arrays-II"><a href="#350-Intersection-of-Two-Arrays-II" class="headerlink" title="350. Intersection of Two Arrays II"></a>350. Intersection of Two Arrays II</h1><h2 id="Description-求两数组的交集"><a href="#Description-求两数组的交集" class="headerlink" title="Description: 求两数组的交集"></a>Description: 求两数组的交集</h2><p>Given two arrays, write a function to compute their intersection.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">Output: [2,2]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">Output: [4,9]</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>Each element in the result should appear as many times as it shows in both arrays.<br>The result can be in any order.</p>
<p><strong>Follow up:</strong></p>
<ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
<li>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?</li>
<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>
</ul>
<h2 id="解法一-哈希-1"><a href="#解法一-哈希-1" class="headerlink" title="解法一: 哈希"></a>解法一: 哈希</h2><p><strong>时间复杂度:</strong> $O(n1+n2)$, 构建哈希表和查询哈希表, 需要将两数组的元素都遍历一次<br><strong>空间复杂度:</strong> $O(n1)$, 用 <code>nums1</code> 构建哈希表, 然后用 <code>nums2</code> 进行查询.(也可以多做一步判断, 选择用数组长度较小数组来构建哈希表, 减少空间复杂度)</p>
<p>用一个数组构建哈希表, 哈希表的键为元素值, 哈希表的值为元素的出现次数, 然后用另一个数组的元素对哈希表进行查询, 如果能找到, 则将该元素加入结果数组 <code>res</code>, 并将哈希表对应键的值减一, 如果减到零, 则删除该键.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash; <span class="comment">// 构建哈希</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num : nums1) hash[num]++;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.find(num) != hash.end())&#123;</span><br><span class="line">                res.push_back(num);</span><br><span class="line">                hash[num]--;</span><br><span class="line">                <span class="keyword">if</span>(hash[num]==<span class="number">0</span>) hash.erase(num); <span class="comment">// 当键对应值为0时, 将该键擦除                    </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-排序-1"><a href="#解法二-排序-1" class="headerlink" title="解法二: 排序"></a>解法二: 排序</h2><p><strong>时间复杂度:</strong> $O(n1logn1 + n2logn2 + n1 + n2) = max(n1, n2)\times log(max(n1, n2))$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums1.begin(), nums1.end());</span><br><span class="line">        <span class="built_in">std</span>::sort(nums2.begin(), nums2.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i1=<span class="number">0</span>, i2=<span class="number">0</span>; <span class="comment">// 设置两个指示变量</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(i1&lt;nums1.size() &amp;&amp; i2&lt;nums2.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i1] == nums2[i2])&#123;</span><br><span class="line">                res.push_back(nums1[i1]);</span><br><span class="line">                i1++;</span><br><span class="line">                i2++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i1] &lt; nums2[i2])</span><br><span class="line">                i1++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i2++;                </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Follow-up-1"><a href="#Follow-up-1" class="headerlink" title="Follow up"></a>Follow up</h2><h3 id="当给定数组已经有序时"><a href="#当给定数组已经有序时" class="headerlink" title="当给定数组已经有序时"></a>当给定数组已经有序时</h3><p>可以设置两个指示变量, 分别指向两个数组, 然后按照指向元素的大小关系进行判断并递进, 这样, 时间复杂度为 $O(n1+n2)$, 空间复杂度为 $O(1)$, 代码可见解法二.</p>
<h3 id="当-nums1-远远小于-nums2-时"><a href="#当-nums1-远远小于-nums2-时" class="headerlink" title="当 nums1 远远小于 nums2 时"></a>当 <code>nums1</code> 远远小于 <code>nums2</code> 时</h3><p>正如前面所说, 选用元素数量较少的数组来构建哈希表, 可以降低空间复杂度</p>
<h3 id="如果-nums2-存放在磁盘上-同时内存不足以加载整个-nums2-数组"><a href="#如果-nums2-存放在磁盘上-同时内存不足以加载整个-nums2-数组" class="headerlink" title="如果 nums2 存放在磁盘上, 同时内存不足以加载整个 nums2 数组"></a>如果 <code>nums2</code> 存放在磁盘上, 同时内存不足以加载整个 <code>nums2</code> 数组</h3><p>将 <code>nums2</code> 分片, 逐个求交集, 最后再合并</p>
<h1 id="371-Sum-of-Two-Integers"><a href="#371-Sum-of-Two-Integers" class="headerlink" title="371. Sum of Two Integers"></a>371. Sum of Two Integers</h1><h2 id="Description-不用加减乘除做加法"><a href="#Description-不用加减乘除做加法" class="headerlink" title="Description: 不用加减乘除做加法"></a>Description: 不用加减乘除做加法</h2><p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a = 1, b = 2</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a = -2, b = 3</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-位操作-递归"><a href="#解法一-位操作-递归" class="headerlink" title="解法一: 位操作(递归)"></a>解法一: 位操作(递归)</h2><p>对于两个数相加, 例如 759+674, 在计算机中我们可以按照如下步骤求解:</p>
<ol>
<li>不考虑进位, 相加得到 323;</li>
<li>只考虑进位, 进位为 1110;</li>
<li>将上面两个数字相加, 得到 1433, 即为最终结果</li>
</ol>
<p>因此, 我们可以用 <strong>异或</strong> 求得不考虑进位的加, 用 <strong>与操作</strong> 来得到当前数字的进位, 由于进位与数字相加后, 有可能产生新的进位, 所以我们还要假设将新的进位加上, 直到进位位为0, 此时可以此时返回当前的和, 代码如下所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a ; <span class="comment">// 如果进位为0, 则可直接返回</span></span><br><span class="line">        <span class="keyword">int</span> sum = a ^ b; <span class="comment">// 计算不带进位的加法</span></span><br><span class="line">        <span class="keyword">int</span> carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;  <span class="comment">// 计算进位</span></span><br><span class="line">        <span class="keyword">return</span> getSum(sum, carry); <span class="comment">// 结合并返回        </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>上面的代码可以简化成一行:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> b==<span class="number">0</span> ? a : getSum(a^b, (a&amp;b)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-位操作-迭代"><a href="#解法二-位操作-迭代" class="headerlink" title="解法二: 位操作(迭代)"></a>解法二: 位操作(迭代)</h2><p>思路和解法一相同, 只不过写成了迭代的形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = a ^ b; <span class="comment">// 不考虑进位的加</span></span><br><span class="line">            b = (a&amp;b) &lt;&lt; <span class="number">1</span>; <span class="comment">// 进位</span></span><br><span class="line">            a = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="378-Kth-Smallest-Element-in-a-Sorted-Matrix"><a href="#378-Kth-Smallest-Element-in-a-Sorted-Matrix" class="headerlink" title="378. Kth Smallest Element in a Sorted Matrix"></a>378. Kth Smallest Element in a Sorted Matrix</h1><h2 id="Description-找到半有序数组中的第-k-小的元素"><a href="#Description-找到半有序数组中的第-k-小的元素" class="headerlink" title="Description: 找到半有序数组中的第 k 小的元素"></a>Description: 找到半有序数组中的第 k 小的元素</h2><p>Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>
<p>Note that it is the kth smallest element in the sorted order, not the kth distinct element.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">   [ 1,  5,  9],</span><br><span class="line">   [10, 11, 13],</span><br><span class="line">   [12, 13, 15]</span><br><span class="line">],</span><br><span class="line">k = 8,</span><br><span class="line"></span><br><span class="line">return 13.</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ n2.</p>
<h2 id="解法一-堆"><a href="#解法一-堆" class="headerlink" title="解法一: 堆"></a>解法一: 堆</h2><p><strong>基于堆的 baseline 解法:</strong><br>最简单的堆解法就是不使用矩阵的有序性质, 直接当成无序数组来做, 我们申请一个 $k$ 大小的大顶堆, 然后遍历矩阵中的所有元素, 如果某元素小于堆顶就将堆顶弹出, 并压入该元素, 最终, 大顶堆的堆顶就是整个矩阵中第 $k$ 小的元素. 该解法的时间复杂度为 $O(nmlogk)$, 空间复杂度为 $O(k)$, 由于没有使用到有序矩阵的性质, 故不做讨论.</p>
<p><strong>更优的基于堆的解法(超屌的解法!):</strong></p>
<p><strong>时间复杂度:</strong> $O(klogn)$, $k$ 代表 kth, $n$ 代表矩阵的行数<br><strong>空间复杂度:</strong> $O(n)$, 堆的大小, $n$ 代表矩阵的行数</p>
<p>我们需要利用矩阵行列分别有序的性质, 首先, 具体思路如下:</p>
<ol>
<li>利用将矩阵中每一行的首元素(也就是第一列元素, 同理, 这里也可以用第一行元素)构造一个最小堆(这一步的复杂度小于 $O(nlogn)$), 堆中的元素是一个 <code>pair</code>, 其中 <code>first</code> 为元素的值, <code>second</code> 又是一个 <code>pair</code>, 存储着值的行列坐标 <code>(i, j)</code></li>
<li>将最小堆中的一个元素弹出(弹出的是当前堆最小的元素), 然后再将弹出元素的同一行的下一个元素(通过元素坐标获取)压入堆, 压入后, 堆会自动排序, 使得最小的元素位于堆顶.</li>
<li>重复步骤(2) k-1 次以后. 我们已经弹出了整个矩阵的最小的 k-1 个元素, 那么现在堆顶中的元素就是第 k 小的元素, 将其返回即可</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pair&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; &amp;a, pair&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; &amp;b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a.first &gt; b.first; <span class="comment">// 小顶堆</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span> || matrix[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m=matrix[<span class="number">0</span>].size();</span><br><span class="line">        priority_queue&lt; pair&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;, cmp&gt; min_heap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123; <span class="comment">// 用矩阵每一行的首元素构建堆, 堆的元素组成为&lt;(val, (i,j))&gt;</span></span><br><span class="line">            min_heap.push(make_pair(matrix[i][<span class="number">0</span>], make_pair(i, <span class="number">0</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = min_heap.top().first;</span><br><span class="line">            <span class="keyword">int</span> i = min_heap.top().second.first;</span><br><span class="line">            <span class="keyword">int</span> j = min_heap.top().second.second;</span><br><span class="line">            min_heap.pop(); <span class="comment">// 弹出堆</span></span><br><span class="line">            res = val;</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span>&lt;m) <span class="comment">// 将同行的下一个元素放入堆</span></span><br><span class="line">                min_heap.push(make_pair(matrix[i][j+<span class="number">1</span>], make_pair(i, j+<span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-二分查找-2"><a href="#解法二-二分查找-2" class="headerlink" title="解法二: 二分查找"></a>解法二: 二分查找</h2><p><strong>时间复杂度:</strong> $O(nlogm\times logD$, $n$ 为矩阵的行数, $m$ 为矩阵的列数, $D$ 为矩阵中最大元素与最小元素之间的差值.<br><strong>空间复杂度:</strong> $O(1)$, 没有利用额外空间</p>
<p>算法利用了每一行中, 元素都是有序的这个性质(但是没有用到列有序的性质), 步骤如下:</p>
<ol>
<li>获取矩阵中元素的最小值 <code>low</code> 和最大值 <code>high</code></li>
<li>令 <code>mid = (high+low)/2</code>, 然后我们利用 <code>upper_bound()</code> 函数来查找矩阵中第一个大于 <code>mid</code> 的元素(耗时 $O(logn)$), 接着计算这个元素之前的元素数量. 对矩阵的每一行重复这个步骤, 并将所有的元素数量累加起来</li>
<li>如果累加元素数 <code>count &lt; k</code>, 说明, <code>mid</code> 的值较小, 我们令 <code>low=mid+1</code>, 否则, 说明 <code>count&gt;=k</code>, 我们令 <code>high=mid</code>, <strong>注意, 这里的赋值关系最好不要改动, 并且要知道为什么令 <code>high=mid</code>, 而不是 <code>mid-1</code>.</strong></li>
<li>重复上述过程直至 <code>low=high</code>, 此时, <code>low</code> 或 <code>high</code> 的值就是矩阵中第 k 小的值</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span> || matrix[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> low = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> high = matrix[n<span class="number">-1</span>][m<span class="number">-1</span>]; <span class="comment">//题目中是方阵, 这里故意写成nm的矩阵, 以适应更普通的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low+high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">                <span class="comment">// 找到第一个大于 mid 的数, 然后计算这之前的元素个数</span></span><br><span class="line">                <span class="keyword">int</span> row_count = <span class="built_in">std</span>::upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();</span><br><span class="line">                count += row_count;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(count &lt; k)&#123; <span class="comment">// 注意, 这里不能令小于号来包括等于号时的情况, 因为 (low+high)/2 是偏向左边的, 这样会造成死循环</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 当 count&gt;=k 时, 说明 mid之前就能满足 k 个元素, 故令 high=mid;  注意, 这里不要尝试令low=mid</span></span><br><span class="line">                high = mid;</span><br><span class="line">            &#125; <span class="comment">// 这里的二分查找不同于普通的数组, 因为 mid 有可能不是数组中的值, 所以即使count=k时, 也不能直接返回mid</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> low; <span class="comment">// 最终, 当 low=high时, 即为第k小的元素. 因为当, high指向第k小的元素时, 它就不可能再减小, 而只能是low一点点靠近high, 直至相等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-二分查找"><a href="#解法三-二分查找" class="headerlink" title="解法三: 二分查找"></a>解法三: 二分查找</h2><p><strong>时间复杂度:</strong> $O((n+m)logD)$, $n$ 为矩阵行数, $m$ 为矩阵列数, $D$ 为矩阵中元素的最大差值<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>解法二中并没有完全使用到矩阵所有的性质, 考虑到矩阵在列上也是有序的, 我们可以进一步优化算法. 我们应该还记得在剑指offer的第一题中, 考察了这种行列有序数组的元素查找算法, 我们可以在 $O(n+m)$ 的时间里找到指定的元素, 因此, 我们可以利用该算法替换解法二中对每一行执行二分查找的算法, 故而时间复杂度就变成了 $O((n+m)logD)$, 其中, $n$ 为矩阵行数, $m$ 为矩阵列数, $D$ 为矩阵中元素的最大差值, 代码如下.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span> || matrix[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> low = matrix[<span class="number">0</span>][<span class="number">0</span>], high = matrix[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low+high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> count = search(matrix, mid); <span class="comment">// 查找小于等于mid的元素数量</span></span><br><span class="line">            <span class="keyword">if</span>(count &lt; k)</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> i = n<span class="number">-1</span>, j=<span class="number">0</span>;  <span class="comment">// 从左下角开始</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>; <span class="comment">// 记录小于等于 target 的元素数量</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&lt;m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &lt;= target)&#123;</span><br><span class="line">                j++;</span><br><span class="line">                count += i+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="380-Insert-Delete-GetRandom-O-1"><a href="#380-Insert-Delete-GetRandom-O-1" class="headerlink" title="380. Insert Delete GetRandom O(1)"></a>380. Insert Delete GetRandom O(1)</h1><h2 id="Description-常数时间复杂度的插入-删除-和随机获取"><a href="#Description-常数时间复杂度的插入-删除-和随机获取" class="headerlink" title="Description: 常数时间复杂度的插入,删除,和随机获取"></a>Description: 常数时间复杂度的插入,删除,和随机获取</h2><p>Design a data structure that supports all following operations in average O(1) time.</p>
<ul>
<li>insert(val): Inserts an item val to the set if not already present.</li>
<li>remove(val): Removes an item val from the set if present.</li>
<li>getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.</li>
</ul>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Init an empty set.</span><br><span class="line">RandomizedSet randomSet = new RandomizedSet();</span><br><span class="line"></span><br><span class="line">// Inserts 1 to the set. Returns true as 1 was inserted successfully.</span><br><span class="line">randomSet.insert(1);</span><br><span class="line"></span><br><span class="line">// Returns false as 2 does not exist in the set.</span><br><span class="line">randomSet.remove(2);</span><br><span class="line"></span><br><span class="line">// Inserts 2 to the set, returns true. Set now contains [1,2].</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">// getRandom should return either 1 or 2 randomly.</span><br><span class="line">randomSet.getRandom();</span><br><span class="line"></span><br><span class="line">// Removes 1 from the set, returns true. Set now contains [2].</span><br><span class="line">randomSet.remove(1);</span><br><span class="line"></span><br><span class="line">// 2 was already in the set, so return false.</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">// Since 2 is the only number in the set, getRandom always return 2.</span><br><span class="line">randomSet.getRandom();</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-哈希表-数组"><a href="#解法一-哈希表-数组" class="headerlink" title="解法一: 哈希表+数组"></a>解法一: 哈希表+数组</h2><p><strong>时间复杂度:</strong> $O(1)$, 符合题意<br><strong>空间复杂度:</strong> $O(n)$, 数组和哈希表的大小各为 $O(n)$.</p>
<p>解题思路:</p>
<ul>
<li>插入: 用数组的 <code>push_back()</code> 存储新来的元素, 同时存入哈希表, <code>key</code> 为元素值, <code>val</code> 为元素在数组中的下标;</li>
<li>删除: 先用哈希表获取元素的下标, 然后将数组中的该元素和数组的最后一个元素交换, 接着用 <code>pop_back()</code> 删除该元素, 然后用 <code>erase()</code> 从哈希表中删除该元素, 最后在哈希表中更新被交换元素的下标;</li>
<li>获取随机元素: 利用 C++ 的内置随机函数 <code>rand()</code> 来获取随机数. <strong>但是注意, rand() 对生成的随机数质量无法保证, 在 C++11 中, 已经建议使用<a href="https://zh.cppreference.com/w/cpp/numeric/random" target="_blank" rel="noopener">随机数生成设施</a>来替换 rand().</strong> 另外注意: 如果想要使用 <code>srand()</code> 来播种, 那么不能将该语句放在 <code>getRandom()</code> 函数中, 因为重复播种会使得每次生成的随机数都一样, 正确的做法是将其放在构造函数中, 只进行一次播种.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    RandomizedSet() &#123;</span><br><span class="line">        srand(time(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.find(val) != hash.end()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        vec.push_back(val);</span><br><span class="line">        hash[val] = vec.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.find(val) == hash.end()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = hash[val];</span><br><span class="line">        <span class="keyword">int</span> j = vec.size() - <span class="number">1</span>;</span><br><span class="line">        swap(vec[i], vec[j]);</span><br><span class="line">        vec.pop_back(); <span class="comment">// 将元素和最后一位元素交换, 然后在删除, 满足 O(1) 复杂度</span></span><br><span class="line">        hash[vec[i]] = i;</span><br><span class="line">        hash.erase(val); <span class="comment">// 在哈希表中删除指定键值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// srand(time(0)); // 不能放在这里, 要放只能放在构造函数中</span></span><br><span class="line">        <span class="keyword">return</span> vec[rand()%vec.size()];</span><br><span class="line">        <span class="comment">// rand 无法保证生成的随机数质量, C++11推荐用随机数生成设施来替换该函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj.insert(val);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj.remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="384-Shuffle-an-Array"><a href="#384-Shuffle-an-Array" class="headerlink" title="384. Shuffle an Array"></a>384. Shuffle an Array</h1><h2 id="Description-打乱数组"><a href="#Description-打乱数组" class="headerlink" title="Description: 打乱数组"></a>Description: 打乱数组</h2><p>Shuffle a set of numbers without duplicates.</p>
<p>Example:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init an array with set 1, 2, and 3.</span></span><br><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Solution solution = <span class="keyword">new</span> Solution(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.</span></span><br><span class="line">solution.shuffle();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Resets the array back to its original configuration [1,2,3].</span></span><br><span class="line">solution.reset();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the random shuffling of array [1,2,3].</span></span><br><span class="line">solution.shuffle();</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-随机交换"><a href="#解法一-随机交换" class="headerlink" title="解法一: 随机交换"></a>解法一: 随机交换</h2><p><strong>时间复杂度:</strong> $O(n)$, 打乱需要 $O(n)$, <code>reset</code> 为 $O(1)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<ul>
<li>shuffle: 打乱时, 遍历数组的下标, 然后随机生成一个下标, 令二者指向的元素交换. 更多分析请看<a href="../面试-KnuthShuffle算法">Knuth shuffle算法</a></li>
<li>reset: 直接返回缓存的原始数组</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums): v(nums)&#123;</span><br><span class="line">        <span class="built_in">std</span>::srand(<span class="built_in">std</span>::time(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Resets the array to its original configuration and return it. */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; reset() &#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns a random shuffling of the array. */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shuffle() &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sv(v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sv.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + rand() % (sv.size()-i); <span class="comment">//这里生成的 j 只可能在 i 之后</span></span><br><span class="line">            swap(sv[i], sv[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_1 = obj.reset();</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj.shuffle();</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<h1 id="387-First-Unique-Character-in-a-String"><a href="#387-First-Unique-Character-in-a-String" class="headerlink" title="387. First Unique Character in a String"></a>387. First Unique Character in a String</h1><h2 id="Description-寻找字符串中的首个不重复字符"><a href="#Description-寻找字符串中的首个不重复字符" class="headerlink" title="Description: 寻找字符串中的首个不重复字符"></a>Description: 寻找字符串中的首个不重复字符</h2><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p>
<p>Examples:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;leetcode&quot;</span><br><span class="line">return 0.</span><br><span class="line"></span><br><span class="line">s = &quot;loveleetcode&quot;,</span><br><span class="line">return 2.</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong> You may assume the string contain only lowercase letters.</p>
<h2 id="解法一-哈希表-2"><a href="#解法一-哈希表-2" class="headerlink" title="解法一: 哈希表"></a>解法一: 哈希表</h2><p><strong>时间复杂度:</strong> $O(n+n)=O(n)$, 第一个 $n$ 用于建立哈希表, 第二个 $n$ 用于查询首个出现次数为 1 的字符, $n$ 为字符串的长度<br><strong>空间复杂度:</strong> $O(26)$, 哈希表的大小为字符集的大小 26 (如果是 unicode 字符, 就为 256).</p>
<p>遍历两边字符串, 第一遍构建哈希表, 第二遍按照字符串序列查询, 遇到值 1 的字符出现时, 就将其下标返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            hash[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[s[i]]==<span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a>394. 字符串解码</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-string/</a></p>
<h2 id="解法一-遍历"><a href="#解法一-遍历" class="headerlink" title="解法一: 遍历"></a>解法一: 遍历</h2><p>逐次的遍历字符串, 每次解码一层, 知道所有的数字都被消除为止</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            length = len(s)</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            flag = <span class="keyword">False</span></span><br><span class="line">            tmp_s = <span class="string">''</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; length:</span><br><span class="line">                <span class="keyword">if</span> s[i] &lt;= <span class="string">'9'</span> <span class="keyword">and</span> s[i] &gt;= <span class="string">'0'</span>:</span><br><span class="line">                    flag = <span class="keyword">True</span> <span class="comment"># whether have num</span></span><br><span class="line">                    dup_num = <span class="string">''</span></span><br><span class="line">                    <span class="keyword">while</span> s[i] &lt;= <span class="string">'9'</span> <span class="keyword">and</span> s[i] &gt;=<span class="string">'0'</span>:</span><br><span class="line">                        dup_num += s[i]</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                    dup_num = int(dup_num)</span><br><span class="line">                    i += <span class="number">1</span> <span class="comment"># skip '['</span></span><br><span class="line">                    dup_str = <span class="string">''</span></span><br><span class="line">                    pre_num = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">while</span> s[i] != <span class="string">']'</span> <span class="keyword">or</span> pre_num &gt; <span class="number">0</span>: <span class="comment"># get duplicate str in [...]</span></span><br><span class="line">                        <span class="keyword">if</span> s[i] == <span class="string">'['</span>:</span><br><span class="line">                            pre_num += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">elif</span> s[i] == <span class="string">']'</span>:</span><br><span class="line">                            pre_num -= <span class="number">1</span></span><br><span class="line">                        dup_str += s[i]</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">for</span> _ <span class="keyword">in</span> range(dup_num):</span><br><span class="line">                        tmp_s += dup_str</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp_s += s[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> flag: <span class="comment"># flag = True, have num, continue loop</span></span><br><span class="line">                s = tmp_s</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># have no num, compelete decode</span></span><br><span class="line">                <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<h2 id="解法二-栈"><a href="#解法二-栈" class="headerlink" title="解法二: 栈"></a>解法二: 栈</h2><p>涉及到括号匹配类的问题, 一般用栈解决起来比较方便</p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c != <span class="string">']'</span>: <span class="comment"># 不是右括号就一直进栈</span></span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                string = <span class="string">''</span> <span class="comment"># 先收集要加倍的字符串</span></span><br><span class="line">                <span class="keyword">while</span> <span class="keyword">not</span> stack[<span class="number">-1</span>].isdigit():</span><br><span class="line">                    string = stack.pop() + string</span><br><span class="line">                times = <span class="string">''</span> <span class="comment"># 再收集加倍倍数</span></span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>].isdigit():</span><br><span class="line">                    times = stack.pop() + times</span><br><span class="line">                <span class="keyword">if</span> times: <span class="comment"># 如果有倍数则加倍</span></span><br><span class="line">                    string = string[<span class="number">1</span>:] * int(times)</span><br><span class="line">                <span class="keyword">if</span> stack: <span class="comment"># 还有没处理完的上级，把处理好的字符串入栈等待处理</span></span><br><span class="line">                    <span class="comment">#stack += list(string)</span></span><br><span class="line">                    stack.append(string)</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 前面的字符串处理完毕了，直接把字符串加入答案</span></span><br><span class="line">                    res += string    </span><br><span class="line">        <span class="keyword">return</span> res + <span class="string">''</span>.join(stack) <span class="comment"># 最后可能有没有右括号收尾的字符串</span></span><br></pre></td></tr></table></figure></p>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; s;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : str) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">']'</span>) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> tmp_s = <span class="string">"x"</span>;</span><br><span class="line">                tmp_s[<span class="number">0</span>] = c;</span><br><span class="line">                s.push(tmp_s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> dup_str = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">while</span> (!s.empty() <span class="keyword">and</span> s.top() &lt; <span class="string">"0"</span> <span class="keyword">or</span> s.top() &gt; <span class="string">"9"</span>) &#123;</span><br><span class="line">                    dup_str = s.top() + dup_str; s.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dup_str != <span class="string">""</span>) dup_str = dup_str.substr(<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> times = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">while</span> (!s.empty() <span class="keyword">and</span> s.top() &lt;= <span class="string">"9"</span> <span class="keyword">and</span> s.top() &gt;= <span class="string">"0"</span>) &#123;</span><br><span class="line">                    times = s.top() + times; s.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> times_str = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; !times.empty() <span class="keyword">and</span> i &lt; <span class="built_in">std</span>::stoi(times); i++) &#123;</span><br><span class="line">                    times_str += dup_str;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s.empty()) &#123;</span><br><span class="line">                    res += times_str;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s.push(times_str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> rear_s = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            rear_s = s.top() + rear_s; s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + rear_s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="395-Longest-Substring-with-At-Least-K-Repeating-Characters"><a href="#395-Longest-Substring-with-At-Least-K-Repeating-Characters" class="headerlink" title="395. Longest Substring with At Least K Repeating Characters"></a>395. Longest Substring with At Least K Repeating Characters</h1><h2 id="Description-53"><a href="#Description-53" class="headerlink" title="Description"></a>Description</h2><p>Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;aaabb&quot;, k = 3</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">The longest substring is &quot;aaa&quot;, as &apos;a&apos; is repeated 3 times.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;ababbc&quot;, k = 2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">The longest substring is &quot;ababb&quot;, as &apos;a&apos; is repeated 2 times and &apos;b&apos; is repeated 3 times.</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-哈希表-位标志"><a href="#解法一-哈希表-位标志" class="headerlink" title="解法一: 哈希表+位标志"></a>解法一: 哈希表+位标志</h2><p><strong>时间复杂度:</strong> 平均情况下为 $O(n)$, 最坏情况(待查找子串不存在)下为 $O(n^2)$<br><strong>空间复杂度:</strong> $O(26 + 1)$, 26 为哈希表的大小, 1 为 <code>mask</code> 的大小.</p>
<p>对于字母集, 可以利用哈希表来实现 $O(n)$ 复杂度的字符数量统计, 我们设置一个变量 <code>mask</code>, 该变量每一个比特位上的值有两种含义: 当某比特位为 1 时, 代表该比特位对应的字母在当前字符子串中的数量小于 k, 反之, 则该比特位为 0. 那么, 只要当 <code>mask=0</code>, 就说明此时的子串符合题目的要求, 我们计算当前子串的长度, 并更新最长长度值, 由于子串必须是连续的, 所以下一个子串的开始字符一定不会在当前子串的结束字符之前, 因为如果这样的话, 就一定会在当前子串的结束字符处终止, 故判断下一个子串时, 我们可以从当前子串结束字符的下一位开始判断. 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+k &lt;= n; )&#123; <span class="comment">// i 代表其实字符的位置</span></span><br><span class="line">            <span class="keyword">int</span> max_end = i; <span class="comment">// 注意要把这三行放在第一个for循环内部, 每次都要初始化一次</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> hash[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;n; j++)&#123; <span class="comment">// j 代表终止字符的位置, 从 i 开始</span></span><br><span class="line">                <span class="keyword">int</span> t = s[j] - <span class="string">'a'</span>;</span><br><span class="line">                hash[t]++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(hash[t] &lt; k) mask |= (<span class="number">1</span>&lt;&lt;t); <span class="comment">// set t bit to 1</span></span><br><span class="line">                <span class="keyword">else</span> mask &amp;=  (~(<span class="number">1</span>&lt;&lt;t)); <span class="comment">//这里外边的括号可以省, 但是位操作最好显式加括号</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(mask == <span class="number">0</span>)&#123; <span class="comment">// 如果mask=0, 说明所有的字符要么没有出现, 要么数量&gt;=k.</span></span><br><span class="line">                    <span class="keyword">int</span> length = j-i+<span class="number">1</span>;</span><br><span class="line">                    res = <span class="built_in">std</span>::max(res, length);</span><br><span class="line">                    max_end = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i = max_end + <span class="number">1</span>; <span class="comment">// 下一个最长的子串的开始一定不会在 i 与 max_end 之间,</span></span><br><span class="line">            <span class="comment">// 因为如果在这之间, 那么就一定会在 max_end 处终止</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-分而治之-递归"><a href="#解法二-分而治之-递归" class="headerlink" title="解法二: 分而治之, 递归"></a>解法二: 分而治之, 递归</h2><p><strong>时间复杂度:</strong> $O(n)$, 最坏情况下为 $O(n)$, 因为递归调用的深度最多为 26, 而每一层的复杂度约为 $O(n)$. <strong>(这种说法是网上的说法, 但是这里我个人觉得最坏情况是 $O(n^2), 只不过有的递归调用很快退出, 是的程序运行时间很短)</strong><br><strong>空间复杂度:</strong> $O(26+log_{26}n)$, 哈希表空间为, 递归占用空间为 $O(log_{26}n)$.</p>
<p>对于任意的字符串, 我们都执行下面的算法步骤:</p>
<ol>
<li>根据当前的字符串, 构建相应的哈希表, 表内数据为没一个字符的出现次数, 所以哈希表的大小为 26(或 256);</li>
<li>如果哈希表内所有字符的出现次数都满足条件(出现 0 次出现 k 次以上), 那么当前字符串满足条件, 可直接输出长度</li>
<li>如果字符串中存在不满足条件的字符, 那么就以这些字符</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l; i&lt;=r; i++)&#123; <span class="comment">// 构建 l,r 范围内的字符数哈希表</span></span><br><span class="line">            hash[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l; i&lt;=r; i++)&#123; <span class="comment">// 如果当前 l, r范围内的字符满足要求, 则直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(hash[s[i]] &amp;&amp; hash[s[i]] &lt; k)&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">return</span> (r-l+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = l;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=l; j&lt;=r; j++)&#123;</span><br><span class="line">            <span class="comment">//以所有不满足条件的字符为分界线, 递归获取前半段和后半段的最长子串长度</span></span><br><span class="line">            <span class="keyword">if</span>(hash[s[j]] &amp;&amp; hash[s[j]] &lt; k)&#123;</span><br><span class="line">                res = <span class="built_in">std</span>::max(res, helper(s, i, j<span class="number">-1</span>, k));</span><br><span class="line">                i = j+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 这里虽然对于多个相同的不满足条件的字符会进行多次调用</span></span><br><span class="line">                <span class="comment">// 但是由于传入的子串很短, 所以会很快接结束调用, 故可忽略不计此次调用</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(res, helper(s, i, r, k));<span class="comment">// i, r 为最后一段</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(s, l, r, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-更简洁的递归"><a href="#解法三-更简洁的递归" class="headerlink" title="解法三: 更简洁的递归"></a>解法三: 更简洁的递归</h2><p><strong>时间复杂度:</strong> $O(n)$, 最差情况下为 $O(kn)$, 详细见下面的分析<br><strong>空间复杂度:</strong> $O(n)$, 哈希+递归</p>
<p><strong>真正的 $O(n)$ 复杂度的实现:</strong> 和上面的思路一致, 也是利用不满足条件的字符作为分隔(因为只有符合条件的字符组成的字符串从 <strong>有可能</strong> 具有正确的长度), 但是不同于上面程序的是, 此次我们只对满足条件的子串进行递归, 故而那些重复的不满足条件的字符不会被重复用于递归(上面的代码就是重复调用了, 因为是在发现 &lt;k 时就进行调用), 下面的代码更加精炼易懂, 我们首先会跳过所有不满足条件的字符, 然后从满足条件的字符开始, 找到连续的满足条件的子串的最后一个字符, 然后对这个子串进行递归调用, 也就是说, <strong>我们最多会进行不超过 k 次递归调用</strong>, 因为最坏的情况是 26 个字符中, 只有一个字符不满足条件, 而这个字符最多将字符串分割成 k 段, 如果分割成 k+1 段, 那么就必须用 k 个字符, 此时与假设矛盾.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l; i&lt;=r; i++) hash[s[i]-<span class="string">'a'</span>]++; <span class="comment">// 构建哈希</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l; i&lt;=r; )&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=r &amp;&amp; hash[s[i]-<span class="string">'a'</span>]&lt;k) i++; <span class="comment">// 跳过不符合的字符, 注意也要跳过未出现的字符, 所以=0也要跳过</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;r) <span class="keyword">break</span>; <span class="comment">// 如果所有字符都不符合, 则直接break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;=r &amp;&amp; hash[s[j]-<span class="string">'a'</span>]&gt;=k) j++; <span class="comment">// 找到当前子串中符合条件的最后一个连续字符</span></span><br><span class="line">            j--; <span class="comment">// 此时 j 指向的是符合条件字符的下一个位置, 因此, 我们要令 j--</span></span><br><span class="line">            <span class="comment">//if(j&gt;r) j=r; // j如果超限, 说明所有字符都符合, 则令 j 指向尾部字符即可</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i==l &amp;&amp; j==r) <span class="keyword">return</span> r-l+<span class="number">1</span>; <span class="comment">// 当前范围所有字符满足条件, 直接返回长度</span></span><br><span class="line">            res = <span class="built_in">std</span>::max(res, helper(s, i, j, k)); <span class="comment">// 对符合条件的子串进行调用, 最多会进行不超过 k 次调用</span></span><br><span class="line">            i = j+<span class="number">1</span>; <span class="comment">// 开始下一个子串的查询</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(s, l, r, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>上面的边界控制比较麻烦, 下面我们用超尾的方式来进行边界控制, 会使程序更加简洁, 如下所示:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=begin; i&lt;end; i++) hash[s[i]-<span class="string">'a'</span>]++; <span class="comment">// 构建哈希</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=begin; i&lt;end; )&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;end &amp;&amp; hash[s[i]-<span class="string">'a'</span>]&lt;k) i++; <span class="comment">// 跳过不符合的字符, 注意也要跳过未出现的字符, 所以=0也要跳过</span></span><br><span class="line">            <span class="keyword">if</span>(i==end) <span class="keyword">break</span>; <span class="comment">// 如果所有字符都不符合, 则直接break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;end &amp;&amp; hash[s[j]-<span class="string">'a'</span>]&gt;=k) j++; <span class="comment">// 找到当前子串中符合条件的最后一个连续字符</span></span><br><span class="line">            <span class="comment">//当使用超尾时, 无需对j特殊处理</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i==begin &amp;&amp; j==end) <span class="keyword">return</span> end-begin; <span class="comment">// 当前范围所有字符满足条件, 直接返回长度</span></span><br><span class="line">            res = <span class="built_in">std</span>::max(res, helper(s, i, j, k)); <span class="comment">// 对符合条件的子串进行调用, 最多会进行不超过 k 次调用</span></span><br><span class="line">            i = j+<span class="number">1</span>; <span class="comment">// 开始下一个子串的查询</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, end = s.size();</span><br><span class="line">        <span class="keyword">return</span> helper(s, begin, end, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="399-除法求值"><a href="#399-除法求值" class="headerlink" title="399. 除法求值"></a>399. 除法求值</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/evaluate-division/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/evaluate-division/</a></p>
<h2 id="解法一-构建有向图"><a href="#解法一-构建有向图" class="headerlink" title="解法一: 构建有向图"></a>解法一: 构建有向图</h2><p>先构造图，使用dict实现，其天然的hash可以在in判断时做到O(1)复杂度。</p>
<p>对每个equation如”a/b=v”构造a到b的带权v的有向边和b到a的带权1/v的有向边，</p>
<p>之后对每个query，只需要进行dfs并将路径上的边权重叠乘就是结果了，如果路径不可达则结果为-1。</p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calcEquation</span><span class="params">(self, equations: List[List[str]], values: List[float], queries: List[List[str]])</span> -&gt; List[float]:</span></span><br><span class="line">        graph = dict() <span class="comment"># construct a directed graph</span></span><br><span class="line">        <span class="keyword">for</span> (x, y), v <span class="keyword">in</span> zip(equations, values):</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> graph:</span><br><span class="line">                graph[x][y] = v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                graph[x] = &#123;y: v&#125;</span><br><span class="line">            <span class="keyword">if</span> y <span class="keyword">in</span> graph:</span><br><span class="line">                graph[y][x] = <span class="number">1</span> / v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                graph[y] = &#123;x: <span class="number">1</span>/v&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start, end, graph, visited)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> start <span class="keyword">not</span> <span class="keyword">in</span> graph <span class="keyword">or</span> end <span class="keyword">not</span> <span class="keyword">in</span> graph: <span class="comment"># 如果开始节点或者结束节点不在图中, 则返回 -1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1.0</span></span><br><span class="line">            <span class="keyword">elif</span> start == end: <span class="comment"># 开始节点就是结束节点, 则可认为权重为 1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> node <span class="keyword">in</span> graph[start].keys(): <span class="comment"># 遍历当前节点的所有下一个节点</span></span><br><span class="line">                    <span class="keyword">if</span> node == end:</span><br><span class="line">                        <span class="keyword">return</span> graph[start][end]</span><br><span class="line">                    <span class="keyword">elif</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited: <span class="comment"># 未被访问</span></span><br><span class="line">                        visited[node] = <span class="number">1</span> <span class="comment"># 加入访问字典</span></span><br><span class="line">                        v = dfs(node, end, graph, visited)</span><br><span class="line">                        <span class="keyword">if</span> v != <span class="number">-1</span>: <span class="comment"># 如果能从 node 抵达 end, 则返回该node</span></span><br><span class="line">                            <span class="keyword">return</span> graph[start][node] * v</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1.0</span> <span class="comment"># 没有找到路径 返回 -1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> query <span class="keyword">in</span> queries:</span><br><span class="line">            visited = &#123;(query[<span class="number">0</span>]): <span class="number">1</span>&#125; <span class="comment"># 注意要先将开始节点加入到已访问字典中</span></span><br><span class="line">            res.append(dfs(query[<span class="number">0</span>], query[<span class="number">1</span>], graph, visited))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> start, <span class="built_in">string</span> end, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt;&gt; graph, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (graph.find(start) == graph.end() <span class="keyword">or</span> graph.find(end) == graph.end()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; node : graph[start]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.first == end) &#123;</span><br><span class="line">                    <span class="keyword">return</span> node.second;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visited.find(node.first) == visited.end()) &#123;</span><br><span class="line">                    visited.insert(node.first);</span><br><span class="line">                    <span class="keyword">auto</span> v = dfs(node.first, end, graph, visited);</span><br><span class="line">                    <span class="keyword">if</span> (v != <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> node.second * v;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; calcEquation(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; equations, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="comment">// 构建有向图</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt;&gt; graph;</span><br><span class="line">        <span class="keyword">int</span> n = values.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node1 = equations[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">auto</span> node2 = equations[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">auto</span> weight = values[i];</span><br><span class="line">            graph[node1][node2] = weight;</span><br><span class="line">            graph[node2][node1] = <span class="number">1.0</span> / weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> &amp;query : queries) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited&#123;query[<span class="number">0</span>]&#125;; <span class="comment">// 已访问节点</span></span><br><span class="line">            res.emplace_back(dfs(query[<span class="number">0</span>], query[<span class="number">1</span>], graph, visited));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-并查集"><a href="#解法二-并查集" class="headerlink" title="解法二: 并查集"></a>解法二: 并查集</h2><h1 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a>406. 根据身高重建队列</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/queue-reconstruction-by-height/</a></p>
<h2 id="解法一-排序-5"><a href="#解法一-排序-5" class="headerlink" title="解法一: 排序"></a>解法一: 排序</h2><p>根据题目要求, 排序，然后插入。</p>
<p>假设候选队列为 A，已经站好队的队列为 B.</p>
<p>从 A 里挑身高最高的人 x 出来，插入到 B. 因为 B 中每个人的身高都比 x 要高，因此 x 插入的位置，就是看 x 前面应该有多少人就行了。比如 x 前面有 5 个人，那 x 就插入到队列 B 的第 5 个位置。</p>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">my_sort2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec2)</span> </span>&#123; <span class="comment">// 自定义函数必须写在最外面, 否则无法通过</span></span><br><span class="line">        <span class="keyword">if</span> (vec1[<span class="number">0</span>] == vec2[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> vec1[<span class="number">1</span>] &lt; vec2[<span class="number">1</span>];   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> vec1[<span class="number">0</span>] &gt; vec2[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (vec1[<span class="number">0</span>] == vec2[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> vec1[<span class="number">1</span>] &lt; vec2[<span class="number">1</span>];   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> vec1[<span class="number">0</span>] &gt; vec2[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; my_sort; <span class="comment">// 匿名结构体变量</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reconstructQueue(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(people.begin(), people.end(), my_sort); <span class="comment">// 排序, 按照 h 降序, k 升序</span></span><br><span class="line">        <span class="comment">//std::sort(people.begin(), people.end(), my_sort2); //与上面一行等价</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> vec : people) &#123;</span><br><span class="line">            res.insert(res.begin()+vec[<span class="number">1</span>], vec); <span class="comment">// 按照 k 进行插入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span><span class="params">(self, people: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        people.sort(key = <span class="keyword">lambda</span> x: [-x[<span class="number">0</span>], x[<span class="number">1</span>]])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> people:</span><br><span class="line">            res.insert(p[<span class="number">1</span>], p)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h1 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="412. Fizz Buzz"></a>412. Fizz Buzz</h1><h2 id="Description-输出指定字符串"><a href="#Description-输出指定字符串" class="headerlink" title="Description: 输出指定字符串"></a>Description: 输出指定字符串</h2><p>Write a program that outputs the string representation of numbers from 1 to n.</p>
<p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">n = 15,</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">[</span><br><span class="line">    &quot;1&quot;,</span><br><span class="line">    &quot;2&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;4&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;7&quot;,</span><br><span class="line">    &quot;8&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;11&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;13&quot;,</span><br><span class="line">    &quot;14&quot;,</span><br><span class="line">    &quot;FizzBuzz&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-条件判断直接输出"><a href="#解法一-条件判断直接输出" class="headerlink" title="解法一: 条件判断直接输出"></a>解法一: 条件判断直接输出</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; fizzBuzz(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">15</span>==<span class="number">0</span>)</span><br><span class="line">                res.push_back(<span class="string">"FizzBuzz"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">5</span>==<span class="number">0</span>)</span><br><span class="line">                res.push_back(<span class="string">"Buzz"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">                res.push_back(<span class="string">"Fizz"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.push_back(<span class="built_in">std</span>::to_string(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-equal-subset-sum/</a></p>
<h2 id="解法-动态规划-3"><a href="#解法-动态规划-3" class="headerlink" title="解法: 动态规划"></a>解法: 动态规划</h2><p>先求得需要划分的子集的元素和<code>target</code>, 构建长度为<code>len(target)</code>的<code>dp</code>数组, 进行两层循环, 第一层循环<code>nums</code>, 第二层循环<code>dp</code>, <code>dp[j]</code>表示在当前<code>num</code>之前, 是否可以选取一部分数字, 其和为<code>j</code>.</p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        s = sum(nums)</span><br><span class="line">        <span class="keyword">if</span> (s % <span class="number">2</span> == <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        target = s // <span class="number">2</span></span><br><span class="line">        dp = [<span class="keyword">False</span>] * (target+<span class="number">1</span>)</span><br><span class="line">        dp [<span class="number">0</span>] = <span class="keyword">True</span> <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= num:</span><br><span class="line">                    dp[j] = dp[j] <span class="keyword">or</span> dp[j-num]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) s += num;</span><br><span class="line">        <span class="keyword">if</span> (s % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = s / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(target+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= num)</span><br><span class="line">                    dp[j] = dp[j] <span class="keyword">or</span> dp[j-num];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></p>
<h2 id="解法一-滑动窗口"><a href="#解法一-滑动窗口" class="headerlink" title="解法一: 滑动窗口"></a>解法一: 滑动窗口</h2><p>将目标字符串的值加起来, 组成<code>target</code>, 只有窗口内部的元素和等于该<code>target</code>, 说明就是字母异位词. 维持窗口大小不变, 同步移动窗口, 继续进行判断. 时间复杂度为 $O(n)$, 因为每个字母至多判断一次.</p>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findAnagrams(<span class="built_in">string</span> s, <span class="built_in">string</span> p) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : p) &#123;</span><br><span class="line">            target += <span class="keyword">int</span>(c);</span><br><span class="line">            hash[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; p.size() <span class="keyword">and</span> end &lt; s.size()) &#123; <span class="comment">// 先判断到窗口大小处, 注意, s 有可能长度小于 p, 因此也要做判断</span></span><br><span class="line">            <span class="keyword">if</span> (hash.find(s[end]) != hash.end()) &#123;</span><br><span class="line">                sum += <span class="keyword">int</span>(s[end]);</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) res.emplace_back(start); <span class="comment">// 第一个窗口内元素符合要求, 加入结果</span></span><br><span class="line">        <span class="keyword">while</span> (end &lt; s.size()) &#123; <span class="comment">// 移动窗口, 并判断窗口内元素是否符合要求</span></span><br><span class="line">            <span class="keyword">if</span> (hash.find(s[end]) != hash.end()) &#123;</span><br><span class="line">                sum += <span class="keyword">int</span>(s[end]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hash.find(s[start]) != hash.end()) &#123;</span><br><span class="line">                sum -= <span class="keyword">int</span>(s[start]);</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">            start++;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) res.emplace_back(start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>Python 实现:</strong> 注意在 Python 中如果想要获取一个字符的 ASCII 编码, 则需要使用<code>ord()</code>, 直接使用<code>int</code>强制类型转换, 无法得到 ASCII 编码, 因为在 Python 中, <code>int(&#39;5&#39;) = 5</code><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span><span class="params">(self, s: str, p: str)</span> -&gt; List[int]:</span></span><br><span class="line">        d = &#123;c:<span class="number">1</span> <span class="keyword">for</span> c <span class="keyword">in</span> p&#125;</span><br><span class="line">        target = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> p: target += ord(c)</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        cur_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (end &lt; len(p) <span class="keyword">and</span> end &lt; len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[end] <span class="keyword">in</span> d:</span><br><span class="line">                cur_sum += ord(s[end])</span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (target == cur_sum): res.append(start)</span><br><span class="line">        <span class="keyword">while</span> (end &lt; len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[end] <span class="keyword">in</span> d:</span><br><span class="line">                cur_sum += ord(s[end])</span><br><span class="line">            <span class="keyword">if</span> s[start] <span class="keyword">in</span> d:</span><br><span class="line">                cur_sum -= ord(s[start])</span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (target == cur_sum): res.append(start)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h1 id="442-数组中重复的数据"><a href="#442-数组中重复的数据" class="headerlink" title="442. 数组中重复的数据"></a>442. 数组中重复的数据</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/</a></p>
<h2 id="解法一-用当前的值作为索引"><a href="#解法一-用当前的值作为索引" class="headerlink" title="解法一: 用当前的值作为索引"></a>解法一: 用当前的值作为索引</h2><p>对于任意一个数字<code>num</code>, 我们可以用起作为索引, 然后在<code>nums</code>数组内部构建相应的哈希表, 数字第一次出现时, 将目标位置的值置为负数, 置成负数的好处是, <strong>我们仍然可以用绝对值的方式无损失的获取的该值的原始值</strong>, 这会, 第二次如果遇到已经是负数的, 说明是之前已经出现过的, 于是可以直接将其加入到结果中, 这样, 只需进行一次遍历, 同时不使用额外的空间.</p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            key = abs(num)<span class="number">-1</span> <span class="comment"># 由于下面会修改 nums 里面的值, 因此这里需要用abs获取其绝对值</span></span><br><span class="line">            <span class="keyword">if</span> nums[key] &gt; <span class="number">0</span>: <span class="comment"># 如果 "哈希" 中不存在该值</span></span><br><span class="line">                nums[key] = -nums[key] <span class="comment"># 向 "哈希" 中添加新的键</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 如果已经存在该值, 说明出现了两次</span></span><br><span class="line">                res.append(abs(num))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findDuplicates(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = <span class="built_in">std</span>::<span class="built_in">abs</span>(num)<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[key] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[key] = -nums[key];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.emplace_back(<span class="built_in">std</span>::<span class="built_in">abs</span>(num));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a>448. 找到所有数组中消失的数字</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/</a></p>
<h2 id="数字归位"><a href="#数字归位" class="headerlink" title="数字归位"></a>数字归位</h2><p>遍历第一遍把数字放到与它自身值对应的下标上, 如 3 放到 <code>nums[2]</code> 处, 遍历第二次, 如果值与下标不对应, 则说明该数字丢失.</p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDisappearedNumbers</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == i+<span class="number">1</span> <span class="keyword">or</span> nums[nums[i]<span class="number">-1</span>] == nums[i]: <span class="comment"># 如果当前位置以及符合, 或者目标位置以及符合, 则不进行交换</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 否则进行交换</span></span><br><span class="line">                target_i = nums[i] <span class="number">-1</span> <span class="comment"># 交换时, 先求得目标位置, 然后再交换, 错误写法: nums[i], nums[nums[i]-1] = nums[nums[i]-1], nums[i]</span></span><br><span class="line">                nums[i], nums[target_i] = nums[target_i], nums[i]</span><br><span class="line">        <span class="comment">#return [i for i, num in enumerate(nums, 1) if i != num] # 与下面三行等价</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums, <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i != num: res.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findDisappearedNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == i+<span class="number">1</span> <span class="keyword">or</span> nums[nums[i]<span class="number">-1</span>] == nums[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> target_i = nums[i]<span class="number">-1</span>;</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[i], nums[target_i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i+<span class="number">1</span>) res.emplace_back(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-置负数"><a href="#解法二-置负数" class="headerlink" title="解法二: 置负数"></a>解法二: 置负数</h2><p>我们将当前值所对于的下标置为负数, 这样, 一次遍历过后, 数组中正数的地方就是缺少的数字.</p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDisappearedNumbers</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            target_i = abs(nums[i])<span class="number">-1</span></span><br><span class="line">            nums[target_i] = -abs(nums[target_i])</span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums, <span class="number">1</span>) <span class="keyword">if</span> num &gt; <span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>C++ 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        std::vector&lt;int&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            int target_i = std::abs(nums[i]) - <span class="number">1</span>;</span><br><span class="line">            nums[target_i] = -std::abs(nums[target_i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) res.emplace_back(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="扩展题型"><a href="#扩展题型" class="headerlink" title="扩展题型"></a>扩展题型</h2><p>扩展: 数组中每个元素出现的可能次数是 n 次,求出数组中出现此次为偶数（奇数）次的元素（出现 0 次也算偶数次）。</p>
<p>上述的解法二可以扩展到解此题, 只需修改一行, 注意出现0次也算是出现偶数次.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDisappearedNumbers</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 将所有正数作为数组下标，置对应数组值为相反数。那么，仍为正数的位置即为出现偶数次(未出现是0次，也是偶数次)数字。</span></span><br><span class="line">        <span class="comment"># 举个例子：</span></span><br><span class="line">        <span class="comment"># 原始数组：[1, 1, 1, 1, 2, 3, 4, 5]</span></span><br><span class="line">        <span class="comment"># 重置后为：[1, -1, -1, -1, -2, 3, 4, 5]</span></span><br><span class="line">        <span class="comment"># 结论：[1,3,5,6] 分别对应的index为[1,6,7,8]（消失的数字）</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            index = abs(num) - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 保持nums[index]为相反数,唯一和上面的解法不同点就是这里，好好体会</span></span><br><span class="line">            nums[index] = -nums[index]</span><br><span class="line">        <span class="comment">#偶数次</span></span><br><span class="line">        <span class="keyword">return</span> [i + <span class="number">1</span> <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums) <span class="keyword">if</span> num &gt; <span class="number">0</span>]</span><br><span class="line">        <span class="comment">#奇数次</span></span><br><span class="line">        <span class="keyword">return</span> [i + <span class="number">1</span> <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums) <span class="keyword">if</span> num &lt; <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h1 id="454-4Sum-II"><a href="#454-4Sum-II" class="headerlink" title="454. 4Sum II"></a>454. 4Sum II</h1><h2 id="Description-4-数之和为零的可能组合数"><a href="#Description-4-数之和为零的可能组合数" class="headerlink" title="Description: 4 数之和为零的可能组合数"></a>Description: 4 数之和为零的可能组合数</h2><p>Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.</p>
<p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">A = [ 1, 2]</span><br><span class="line">B = [-2,-1]</span><br><span class="line">C = [-1, 2]</span><br><span class="line">D = [ 0, 2]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The two tuples are:</span><br><span class="line">1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-先求两两之和"><a href="#解法一-先求两两之和" class="headerlink" title="解法一: 先求两两之和"></a>解法一: 先求两两之和</h2><p><strong>时间复杂度:</strong> $O(n^2+n^2)=O(n^2)$, 前者为 A, B 两两和的复杂度, 后者为 C, D 两两和的复杂度.<br><strong>空间复杂度:</strong> $O(n^2)$, 哈希表占用的空间</p>
<p>先求 A 与 B 的两两之和, 并将和作为键存于哈希表中, 哈希表中的值为和的出现次数, 然后再求 C, D 的两两之和, 同时查询哈希表中是否存在 C, D 和的负数, 若存在, 则说明可以组成零. 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a : A)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> b : B)&#123;</span><br><span class="line">                hash[a+b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : C)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> d : D)&#123;</span><br><span class="line">                <span class="keyword">int</span> target = -(c+d);</span><br><span class="line">                res += hash[target];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="543-二叉树的路径"><a href="#543-二叉树的路径" class="headerlink" title="543. 二叉树的路径"></a>543. 二叉树的路径</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a></p>
<h2 id="解法一-递归-后序遍历"><a href="#解法一-递归-后序遍历" class="headerlink" title="解法一: 递归, 后序遍历"></a>解法一: 递归, 后序遍历</h2><p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">traverseTree</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left_len = traverseTree(root-&gt;left, res);</span><br><span class="line">        <span class="keyword">int</span> right_len = traverseTree(root-&gt;right, res);</span><br><span class="line">        res = <span class="built_in">std</span>::max(res, left_len+right_len);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(left_len, right_len) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        traverseTree(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverseTree</span><span class="params">(root, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="keyword">None</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            l = traverseTree(root.left, res)</span><br><span class="line">            r = traverseTree(root.right, res)</span><br><span class="line">            res[<span class="number">0</span>] = max(res[<span class="number">0</span>], l+r)</span><br><span class="line">            <span class="keyword">return</span> max(l, r) + <span class="number">1</span></span><br><span class="line">        res = [<span class="number">0</span>] <span class="comment"># 这里使用列表是为了将 res 作为可变对象进行传递</span></span><br><span class="line">        traverseTree(root, res)</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-迭代-后序遍历"><a href="#解法二-迭代-后序遍历" class="headerlink" title="解法二: 迭代, 后序遍历"></a>解法二: 迭代, 后序遍历</h2><p>貌似不是很好写, 较好的办法是修改树节点的结构体, 使之能够保存左右子树的最深深度. 否则, 非递归后序遍历时, 无法知道当前节点的左右子树深度, 就无法直接获取路径.</p>
<h1 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a>560. 和为 K 的子数组</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subarray-sum-equals-k/</a></p>
<h2 id="解法一-哈希表-3"><a href="#解法一-哈希表-3" class="headerlink" title="解法一: 哈希表"></a>解法一: 哈希表</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>只需遍历一次数组, 遍历的时候, 计算从第 0 个元素到当前元素的累加和, 同时用哈希表保存出现过的累加和的次数, 然后利用 sum-k 得到 target, 即为 dp[j], 那么就有 dp[i] - dp[j] = sum[i, j], 所以可以直接将哈希表中 target 的出现次数加到最终的结果变量中, 代码实现如下:</p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = <span class="number">0</span></span><br><span class="line">        sum_dict = &#123;<span class="number">0</span>: <span class="number">1</span>&#125; <span class="comment"># 首先在字典中存放一个0, 这样可以保证 0~i 的数组被考虑到</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            dp = dp + num <span class="comment"># 计算 [0~i] 的数组和</span></span><br><span class="line">            target = dp - k <span class="comment"># 计算 dp[i] 需要减去多少才能变成 k, 也就是找到 dp[j], dp[i] - dp[j] = [j+1, i]</span></span><br><span class="line">            <span class="keyword">if</span> target <span class="keyword">in</span> sum_dict: <span class="comment"># 如果字典中有 dp[j], 那么就将 dp[j] 的个数加到最终的结果中</span></span><br><span class="line">                res += sum_dict[target]</span><br><span class="line">            sum_dict[dp] = sum_dict.get(dp, <span class="number">0</span>) + <span class="number">1</span> <span class="comment"># 将 dp[i] 存入到字典中, 值为 dp[i] 的出现次数</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p><strong>C++ 实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> dp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            dp += num;</span><br><span class="line">            <span class="keyword">int</span> target = dp - k;</span><br><span class="line">            <span class="keyword">if</span> (hash.find(target) != hash.end()) &#123;</span><br><span class="line">                res += hash[target];</span><br><span class="line">            &#125;</span><br><span class="line">            hash[dp] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="621-任务调度器"><a href="#621-任务调度器" class="headerlink" title="621. 任务调度器"></a>621. 任务调度器</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/task-scheduler/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/task-scheduler/</a></p>
<h2 id="解法一-以最多的任务作为依据"><a href="#解法一-以最多的任务作为依据" class="headerlink" title="解法一: 以最多的任务作为依据"></a>解法一: 以最多的任务作为依据</h2><p>首先, 找到出现频率最高的任务, 然后在完成该任务时穿插完成其他任务, 根据任务的冷却时间不同, 分为两种情况:</p>
<ol>
<li>次数最多的任务 A 的冷却时间大于其他任务的循环时间, 那么最小时间就是任务 A 全部执行完毕的时间: $(A - 1)\times(n + 1) + count_max$</li>
<li>任务 A 的冷却时间小于其他任务的循环时间, <strong>那么这个时间连次数最多的任务 A 都没有等待时间了</strong>, 所以其他所有的任务都可以完美紧密执行, 而不需要进行等待, 因此总时间就是<code>len(tasks)</code></li>
</ol>
<p><strong>Python 实现:</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leastInterval</span><span class="params">(self, tasks: List[str], n: int)</span> -&gt; int:</span></span><br><span class="line">        task_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">            task_dict[task] = task_dict.get(task, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        time = <span class="number">0</span></span><br><span class="line">        max_num = max(task_dict.values())</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> task_dict.values():</span><br><span class="line">            <span class="keyword">if</span> v == max_num: count += <span class="number">1</span></span><br><span class="line">        min_time = (max_num<span class="number">-1</span>)*(n+<span class="number">1</span>) + count</span><br><span class="line">        <span class="keyword">return</span> max(min_time, len(tasks))</span><br></pre></td></tr></table></figure>
<p><strong>C++ 实现:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">int</span> max_num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : tasks) &#123;</span><br><span class="line">            hash[c]++;</span><br><span class="line">            max_num = <span class="built_in">std</span>::max(hash[c], max_num);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> item : hash) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.second == max_num) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max((max_num<span class="number">-1</span>) * (n+<span class="number">1</span>) + count, <span class="keyword">int</span>(tasks.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a>647. 回文子串</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindromic-substrings/</a></p>
<p>数有多少个回文子串</p>
<h2 id="解法一-扩展中心法"><a href="#解法一-扩展中心法" class="headerlink" title="解法一: 扩展中心法"></a>解法一: 扩展中心法</h2><p>时间复杂度 $O(n^2)$, 题目字符串长度不超过 1000, 因此复杂度满足题目要求, 我们将字符首尾插入两个不同的字符, 然后在所有字符中间插入相同的字符, 这样就可以避免判断回文串的奇偶长度了, 具体看下面的代码实现</p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        ss = <span class="string">'#'</span>.join(list(<span class="string">'$'</span> + s + <span class="string">'@'</span>)) <span class="comment"># 前后字符不一样可以帮助判断是否已经到了边界, 用 # 连接字符可以省去奇偶判断</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(ss)<span class="number">-1</span>):</span><br><span class="line">            l = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (ss[i+l] == ss[i-l]): l += <span class="number">1</span> <span class="comment"># 先求导回文串的长度+1</span></span><br><span class="line">            count += l // <span class="number">2</span> <span class="comment"># 取整除法, 获得包含的回文子串个数</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure></p>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        s = <span class="string">'$'</span> + s;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ss(<span class="number">2</span>*s.size()+<span class="number">1</span>, <span class="string">'@'</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ss.size()<span class="number">-1</span>; i+=<span class="number">2</span>) &#123;</span><br><span class="line">            ss[i] = s [i/<span class="number">2</span>];</span><br><span class="line">            ss[i+<span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ss.size()<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (ss[i+l] == ss[i-l]) l++;</span><br><span class="line">            count += l / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-Manacher-算法"><a href="#解法二-Manacher-算法" class="headerlink" title="解法二: Manacher 算法"></a>解法二: Manacher 算法</h2><p>Manacher 算法的时间复杂度接近于 $O(n)$</p>
<p>这道题实际上就是求最长回文串的变形, 不同之处仅在于当求出每一个回文串的长度之后, 需要将相应的回文子串的数量添加到最终的结果中, 其余地方相同. 关于 Manacher 算法的详细讲解可以查看第 005 题, 本题的代码实现如下所示:</p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        ss = <span class="string">'#'</span>.join(list(<span class="string">'$'</span> + s + <span class="string">'@'</span>)) <span class="comment"># 前后字符不一样可以帮助判断是否已经到了边界, 用 # 连接字符可以省去奇偶判断</span></span><br><span class="line">        p_len = [<span class="number">0</span>] * len(ss) <span class="comment"># 记录每个字符的回文串长度</span></span><br><span class="line">        count = <span class="number">0</span> <span class="comment"># 记录回文子串的个数</span></span><br><span class="line">        P = <span class="number">0</span> <span class="comment"># 记录回文串最右边所能到达的边界</span></span><br><span class="line">        center = <span class="number">0</span> <span class="comment"># 记录最右边回文串对应的中心</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(ss)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; P:</span><br><span class="line">                l = min(P-i, p_len[center-(i-center)]) <span class="comment"># l 为 P-i, 及center对应i的长度的较小者</span></span><br><span class="line">                <span class="keyword">while</span> (ss[i-l] == ss[i+l]): l+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 如果 i &gt; P, 就只能老老实实的使用中心扩展法</span></span><br><span class="line">                l = <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> (ss[i-l] == ss[i+l]): l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (P &lt; i+l<span class="number">-1</span>): <span class="comment"># 更新 P, center</span></span><br><span class="line">                P = i+l<span class="number">-1</span></span><br><span class="line">                center = i</span><br><span class="line">            p_len[i] = l<span class="number">-1</span> <span class="comment"># 更新 len</span></span><br><span class="line">            count += l // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure></p>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        s = <span class="string">'$'</span> + s;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ss(<span class="number">2</span>*s.size()+<span class="number">1</span>, <span class="string">'@'</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p_len(ss.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> P = <span class="number">0</span>, center = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ss.size()<span class="number">-1</span>; i+=<span class="number">2</span>) &#123;</span><br><span class="line">            ss[i] = s [i/<span class="number">2</span>];</span><br><span class="line">            ss[i+<span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ss.size()<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; P) &#123; <span class="comment">// i &lt; P, 可以利用之前的计算结果</span></span><br><span class="line">                l = <span class="built_in">std</span>::min(P-i, p_len[center - (i-center)]);</span><br><span class="line">                <span class="keyword">while</span> (ss[i+l] == ss[i-l]) l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则只能使用中心扩展法</span></span><br><span class="line">                l = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (ss[i+l] == ss[i-l]) l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (P &lt; l<span class="number">-1</span>) &#123; <span class="comment">// 更新 P 和 center</span></span><br><span class="line">                P = i+l<span class="number">-1</span>;</span><br><span class="line">                center = i;</span><br><span class="line">            &#125;</span><br><span class="line">            p_len[i] = l<span class="number">-1</span>; <span class="comment">// 更新 len</span></span><br><span class="line">            count += l / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a>714. 买卖股票的最佳时机含手续费</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p>
<h2 id="解法-通用-DP-解法-1"><a href="#解法-通用-DP-解法-1" class="headerlink" title="解法: 通用 DP 解法"></a>解法: 通用 DP 解法</h2><p>需要注意的是每次买入时需要多花费一笔手续费, 其他地方与无限次的买卖股票完全一致.</p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int], fee: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) &lt;= <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [-prices[<span class="number">0</span>]-fee, <span class="number">0</span>] <span class="comment"># base case: hold+fee, not_hold</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices[<span class="number">1</span>:]:</span><br><span class="line">            dp = [max(dp[<span class="number">0</span>], dp[<span class="number">1</span>]-price-fee), max(dp[<span class="number">1</span>], dp[<span class="number">0</span>]+price)] <span class="comment"># 不要忘了买入时的手续费</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>C++ 实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dp = &#123;-prices[<span class="number">0</span>]-fee, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> hold = <span class="built_in">std</span>::max(dp.first, dp.second-prices[i]-fee);</span><br><span class="line">            <span class="keyword">int</span> not_hold = <span class="built_in">std</span>::max(dp.second, dp.first+prices[i]);</span><br><span class="line">            dp.first = hold; dp.second = not_hold;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h1><p>题目链接: <a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/daily-temperatures/</a></p>
<h2 id="解法一-单调递增栈"><a href="#解法一-单调递增栈" class="headerlink" title="解法一: 单调递增栈"></a>解法一: 单调递增栈</h2><p>维护一个单调递增栈, 栈内元素越深, 值越大, 判断某一个的升温天数时, 逐个查看栈顶, 若栈顶小于当前温度, 则退栈, 直到栈为空, 若为空, 则说明后面的温度不会升高.</p>
<p><strong>C++ 解法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dailyTemperatures(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; stk;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(T.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">int</span>(T.size())<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (T[i] &lt; stk.top().first) &#123; <span class="comment">// 栈顶温度高于当天, 则直接计算相差的天数, 并把当天情况入栈</span></span><br><span class="line">                    res[i] = stk.top().second - i;</span><br><span class="line">                    stk.push(&#123;T[i], i&#125;);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 栈顶温度低于当天, 则退栈, 因为栈顶的元素不可能成为前面的解</span></span><br><span class="line">                    stk.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stk.empty()) &#123; <span class="comment">// 如果栈本身为空或一直退栈导致栈空, 则应该将当天情况入栈</span></span><br><span class="line">                stk.push(&#123;T[i], i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>Python 解法:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, T: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = [<span class="number">0</span>] * len(T)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(T)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> T[i] &lt; stack[<span class="number">-1</span>][<span class="number">0</span>]:</span><br><span class="line">                    res[i] = stack[<span class="number">-1</span>][<span class="number">1</span>] - i</span><br><span class="line">                    stack.append([T[i], i])</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">            <span class="keyword">if</span> len(stack) == <span class="number">0</span>:</span><br><span class="line">                stack.append([T[i], i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-利用已经求得的部分结果加速循环"><a href="#解法二-利用已经求得的部分结果加速循环" class="headerlink" title="解法二: 利用已经求得的部分结果加速循环"></a>解法二: 利用已经求得的部分结果加速循环</h2><p>实际上我们不需要额外的维护这个栈, 我们可以直接利用已经求得的部分结果来进行计算, 这样可以空间复杂度降低.</p>
<p>从后往前判断, 对于任意一天, 逐个遍历该天后的温度, 由于我们已经求得了该天后的温度提升数组<code>res</code>, 因此, 如果某天温度比该天低, 我们可以直接跳到某天温度的升高天数, 这样, 降低了循环次数, 使其少于 $O(n^2)$</p>
<p><strong>C++ 实现</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dailyTemperatures(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(T.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">int</span>(T.size())<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; T.size(); ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (T[i] &lt; T[j]) &#123; <span class="comment">// 如果温度高于当天, 则直接计算天数, 并退出该层循环</span></span><br><span class="line">                    res[i] = j - i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res[j] == <span class="number">0</span>) &#123; <span class="comment">// 如果温度低于当天, 且后面没有比此温度更高的, 则不用判断, 直接置零</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123; <span class="comment">// 否则, 直接跳过 res 求得的天数, 加速循环</span></span><br><span class="line">                    j += res[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>Python 实现:</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, T: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        res = [<span class="number">0</span>] * len(T)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(T)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; len(T)):</span><br><span class="line">                <span class="keyword">if</span> T[i] &lt; T[j]:</span><br><span class="line">                    res[i] = j - i</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> res[j] == <span class="number">0</span>:</span><br><span class="line">                    res[i] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j += res[j]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h1 id="股票问题通用解法"><a href="#股票问题通用解法" class="headerlink" title="股票问题通用解法"></a>股票问题通用解法</h1><ul>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">买卖股票的最佳时机</a></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">买卖股票的最佳时机 II</a></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">买卖股票的最佳时机 III</a></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">买卖股票的最佳时机 IV</a></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">最佳买卖股票时机含冷冻期</a></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">买卖股票的最佳时机含手续费</a></li>
</ul>
<p>框架:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stock</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 定义 base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = ...</span><br><span class="line">    <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">        <span class="comment">#更新 dp 状态</span></span><br></pre></td></tr></table></figure></p>
<p>核心思想依然是 DP, 只不过可以套用下面的状态转移方程(也可以看做是 DP 更新方程):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span><br><span class="line">              max(   选择 rest  ,           选择 sell      )</span><br><span class="line"></span><br><span class="line">解释：今天我没有持有股票，有两种可能：</span><br><span class="line">要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；</span><br><span class="line">要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。</span><br><span class="line"></span><br><span class="line">dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])</span><br><span class="line">              max(   选择 rest  ,           选择 buy         )</span><br><span class="line"></span><br><span class="line">解释：今天我持有着股票，有两种可能：</span><br><span class="line">要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；</span><br><span class="line">要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。</span><br></pre></td></tr></table></figure>
<p>这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。这样就相当于控制了可以交易的最大次数, 如果可以交易无限次, 那么就可以不记录 k.</p>
<p>现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dp[-1][k][0] = 0</span><br><span class="line">解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。</span><br><span class="line">dp[-1][k][1] = -infinity</span><br><span class="line">解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。</span><br><span class="line">dp[i][0][0] = 0</span><br><span class="line">解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。</span><br><span class="line">dp[i][0][1] = -infinity</span><br><span class="line">解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。</span><br></pre></td></tr></table></figure></p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法刷题/" rel="tag"><i class="fa fa-tag"></i> 算法刷题</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/z_post/计算机视觉-CoupleNet-ICCV2017/" rel="prev" title="CoupleNet-Coupling Global Structure with Local Parts for Object Detection">
                <i class="fa fa-chevron-left"></i> CoupleNet-Coupling Global Structure with Local Parts for Object Detection
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/z_post/机器学习-SVM深入解析/" rel="next" title="SVM深入解析">
                SVM深入解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar_zz.png"
                alt="ZeroZone" />
            
              <p class="site-author-name" itemprop="name">ZeroZone</p>
              <p class="site-description motion-element" itemprop="description">并不是什么厉害的地方<br>只是一个安静的学习角落</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">263</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/hellozhaozheng" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:hellozhaozheng@foxmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/ksws0292756" title="零域CSDN博客" target="_blank">零域CSDN博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://xinghanzzy.github.io/" title="BoXiao的博客" target="_blank">BoXiao的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://oldpan.me/" title="Oldpan的博客" target="_blank">Oldpan的博客</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#001-Two-Sum"><span class="nav-text">001. Two Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-求出能组合出目标数的两个元素"><span class="nav-text">Description: 求出能组合出目标数的两个元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-穷举"><span class="nav-text">解法一: 穷举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-哈希表-两次遍历"><span class="nav-text">解法二 : 哈希表, 两次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-哈希表-一次遍历"><span class="nav-text">解法三: 哈希表 一次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展问题"><span class="nav-text">扩展问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#002-Add-Two-Numbers"><span class="nav-text">002. Add Two Numbers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-链表数之和"><span class="nav-text">Description: 链表数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-顺序相加-注意进位"><span class="nav-text">解法一: 顺序相加, 注意进位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-顺序相加-维持原链表"><span class="nav-text">解法二: 顺序相加, 维持原链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展问题-1"><span class="nav-text">扩展问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#003-Longest-Substring-Without-Repeating-Characters"><span class="nav-text">003. Longest Substring Without Repeating Characters</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-寻找无重复字符的最长子串"><span class="nav-text">Description: 寻找无重复字符的最长子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-暴力"><span class="nav-text">解法一:暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-前后两个指示变量"><span class="nav-text">解法二: 前后两个指示变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-只需一次遍历"><span class="nav-text">解法三: 只需一次遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#004-Median-of-Two-Sorted-Arrays"><span class="nav-text">004. Median of Two Sorted Arrays</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-寻找两个有序数组的中位数"><span class="nav-text">Description: 寻找两个有序数组的中位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-根据中位数的特性"><span class="nav-text">解法一: 根据中位数的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#非递归写法"><span class="nav-text">非递归写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归写法"><span class="nav-text">递归写法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#005-最长回文子串"><span class="nav-text">005. 最长回文子串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-最长回文子串"><span class="nav-text">Description: 最长回文子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：最长公共子串"><span class="nav-text">解法一：最长公共子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：-穷举"><span class="nav-text">解法二： 穷举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三：-动态规划"><span class="nav-text">解法三： 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三：-扩展中心法"><span class="nav-text">解法三： 扩展中心法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法五-马拉车-Manacher-算法"><span class="nav-text">解法五: 马拉车(Manacher) 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-实现"><span class="nav-text">C++ 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python-实现"><span class="nav-text">Python 实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#006-Z-字形变换-中等"><span class="nav-text">006. Z 字形变换-中等</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法"><span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#007-Reverse-Integer"><span class="nav-text">007. Reverse Integer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-将数字逆置"><span class="nav-text">Description: 将数字逆置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-取余数"><span class="nav-text">解法一: 取余数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#008-String-to-Integer-atoi"><span class="nav-text">008. String to Integer (atoi)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-将字符串转换成整数"><span class="nav-text">Description: 将字符串转换成整数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-考虑多种情况"><span class="nav-text">解法一: 考虑多种情况</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#009-回文数-简单"><span class="nav-text">009. 回文数-简单</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-转换成字符串进行标准的中心扩展法进行判断"><span class="nav-text">解法一: 转换成字符串进行标准的中心扩展法进行判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-利用数学计算"><span class="nav-text">解法二: 利用数学计算</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#010-Regular-Expression-Matching"><span class="nav-text">010 Regular Expression Matching</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-正则表达式匹配"><span class="nav-text">Description: 正则表达式匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归实现-速度很慢-只超过0-97-的提交"><span class="nav-text">解法一: 递归实现( 速度很慢, 只超过0.97%的提交)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-动态规划"><span class="nav-text">解法二: 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#011-Container-With-Most-Water"><span class="nav-text">011. Container With Most Water</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-暴力-1"><span class="nav-text">解法一: 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-用两个指针"><span class="nav-text">解法二: 用两个指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#012-整数转罗马数字-中等"><span class="nav-text">012. 整数转罗马数字-中等</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-字典映射-哈希"><span class="nav-text">解法: 字典映射(哈希)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#013-Roman-to-Integer"><span class="nav-text">013. Roman to Integer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-1"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-顺序扫描"><span class="nav-text">解法一: 顺序扫描</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展问题-异常检测"><span class="nav-text">扩展问题: 异常检测</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#014-Longest-Common-Prefix"><span class="nav-text">014. Longest Common Prefix</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-最长公共前缀"><span class="nav-text">Description: 最长公共前缀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-顺序比较"><span class="nav-text">解法一: 顺序比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-垂直比较"><span class="nav-text">解法二: 垂直比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#015-3Sum"><span class="nav-text">015. 3Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-三数和为零"><span class="nav-text">Description: 三数和为零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-固定一个数-剩余两个数用双指针法求"><span class="nav-text">解法一: 固定一个数, 剩余两个数用双指针法求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-python写法"><span class="nav-text">解法二: python写法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#016-3Sum-Closest"><span class="nav-text">016. 3Sum Closest</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-2"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-排序-双指针"><span class="nav-text">解法一: 排序+双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#017-Letter-Combinations-of-a-Phone-Number"><span class="nav-text">017. Letter Combinations of a Phone Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-九键字母组合"><span class="nav-text">Description: 九键字母组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C"><span class="nav-text">C++</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法一-递归"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法二-非递归"><span class="nav-text">解法二: 非递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python"><span class="nav-text">Python</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法一-利用reduce实现"><span class="nav-text">解法一: 利用reduce实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#018-四数之和"><span class="nav-text">018. 四数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-1"><span class="nav-text">解法:</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#019-Remove-Nth-Node-From-End-of-List"><span class="nav-text">019. Remove Nth Node From End of List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-移除链表的倒数第-N-个字符"><span class="nav-text">Description: 移除链表的倒数第 N 个字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-遍历两次"><span class="nav-text">解法一: 遍历两次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-双指针-只遍历一次"><span class="nav-text">解法二: 双指针, 只遍历一次</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#020-Valid-Parentheses"><span class="nav-text">020. Valid Parentheses</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-3"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-栈"><span class="nav-text">解法一: 栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#021-Merge-Two-Sorted-Lists"><span class="nav-text">021. Merge Two Sorted Lists</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-4"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-遍历融合"><span class="nav-text">解法一: 遍历融合</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#022-Generate-Parentheses"><span class="nav-text">022. Generate Parentheses</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-5"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-暴力-2"><span class="nav-text">解法一: 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-回溯"><span class="nav-text">解法二: 回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-Closure-Number"><span class="nav-text">解法三: Closure Number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-用栈来模拟递归"><span class="nav-text">解法四: 用栈来模拟递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#023-Merge-k-Sorted-Lists"><span class="nav-text">023. Merge k Sorted Lists</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-合并-k-个有序链表"><span class="nav-text">Description: 合并 k 个有序链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-基于比较的合并"><span class="nav-text">解法一: 基于比较的合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-用小顶堆对解法一的比较操作进行优化"><span class="nav-text">解法二: 用小顶堆对解法一的比较操作进行优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-转化成双列表合并问题"><span class="nav-text">解法三: 转化成双列表合并问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-对解法三进行优化"><span class="nav-text">解法四: 对解法三进行优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#024-两两交换链表中的节点-中等"><span class="nav-text">024. 两两交换链表中的节点-中等</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-按照题目要求逻辑进行交换"><span class="nav-text">解法: 按照题目要求逻辑进行交换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#025-K-个一组翻转链表"><span class="nav-text">025. K 个一组翻转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-2"><span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#026-Remove-Duplicates-from-Sorted-Array"><span class="nav-text">026. Remove Duplicates from Sorted Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-6"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一"><span class="nav-text">解法一:</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#027-移除元素"><span class="nav-text">027. 移除元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-3"><span class="nav-text">解法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#028-Implement-strStr"><span class="nav-text">028. Implement strStr()</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#description-KMP-判断是否为子串"><span class="nav-text">description: KMP, 判断是否为子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-暴力-3"><span class="nav-text">解法一: 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-KMP"><span class="nav-text">解法二: KMP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#029-Divide-Two-Integers"><span class="nav-text">029. Divide Two Integers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-实现除法"><span class="nav-text">Description: 实现除法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-循环加法"><span class="nav-text">解法一: 循环加法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-左移法"><span class="nav-text">解法二: 左移法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展-这道题如果不允许使用-long-或者long-long-怎么解"><span class="nav-text">扩展: 这道题如果不允许使用 long 或者long long 怎么解?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#031-Next-Permutation"><span class="nav-text">031. Next Permutation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-实现-next-permutation-函数逻辑"><span class="nav-text">Description: 实现 next_permutation 函数逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-next-permutation-实现"><span class="nav-text">解法一: next_permutation 实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#033-Search-in-Rotated-Sorted-Array"><span class="nav-text">033. Search in Rotated Sorted Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-在循环有序数组中查找元素"><span class="nav-text">Description: 在循环有序数组中查找元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-二分查找"><span class="nav-text">解法一: 二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-二分查找"><span class="nav-text">解法二: 二分查找</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#034-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><span class="nav-text">034. Find First and Last Position of Element in Sorted Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-在有序数组中查找目标的开始位置和结束位置"><span class="nav-text">Description: 在有序数组中查找目标的开始位置和结束位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-二分查找-1"><span class="nav-text">解法一: 二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-二分查找-1"><span class="nav-text">解法二: 二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-STL-函数"><span class="nav-text">解法三: STL 函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#036-Valid-Sudoku"><span class="nav-text">036. Valid Sudoku</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-验证一个矩阵是否是数独数据"><span class="nav-text">Description: 验证一个矩阵是否是数独数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-利用flag数组存储判断矩阵"><span class="nav-text">解法一: 利用flag数组存储判断矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-位操作"><span class="nav-text">解法二: 位操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#038-Count-and-Say"><span class="nav-text">038. Count and Say</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-7"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-依次查看上一次的数字"><span class="nav-text">解法一: 依次查看上一次的数字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#041-First-Missing-Positive"><span class="nav-text">041. First Missing Positive</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-8"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-下标与正数对应"><span class="nav-text">解法一: 下标与正数对应</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-哈希"><span class="nav-text">解法二: 哈希</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#042-Trapping-Rain-Water"><span class="nav-text">042 Trapping Rain Water</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-9"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-左右指针"><span class="nav-text">解法一: 左右指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#044-Wildcard-Matching"><span class="nav-text">044. Wildcard Matching</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-通配符匹配"><span class="nav-text">Description: 通配符匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-迭代"><span class="nav-text">解法一: 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-DP"><span class="nav-text">解法二: DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-DP"><span class="nav-text">解法三: DP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#046-Permutations"><span class="nav-text">046. Permutations</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-不含重复数字的全排列"><span class="nav-text">Description: 不含重复数字的全排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-1"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代"><span class="nav-text">解法二: 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-利用C-的内置函数-next-permutation"><span class="nav-text">解法三: 利用C++的内置函数 next_permutation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-自己实现-next-permutation"><span class="nav-text">解法四: 自己实现 next_permutation</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#047-Permutations-II"><span class="nav-text">047. Permutations II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-带有重复元素的全排列"><span class="nav-text">Description: 带有重复元素的全排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-set"><span class="nav-text">解法一: 递归+set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-STL-的-next-permutation-函数"><span class="nav-text">解法二: STL 的 next_permutation 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-自己实现-next-permutation"><span class="nav-text">解法三: 自己实现 next_permutation()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#048-Rotate-Image"><span class="nav-text">048. Rotate Image</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-图片旋转-90-度"><span class="nav-text">Description: 图片旋转 90 度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-逆置-转置"><span class="nav-text">解法一: 逆置+转置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-转置-列逆置"><span class="nav-text">解法二: 转置+列逆置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充-逆时针旋转90度"><span class="nav-text">补充: 逆时针旋转90度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充-图片旋转-180-度-上下翻转"><span class="nav-text">补充: 图片旋转 180 度(上下翻转)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充-图片左右翻转"><span class="nav-text">补充: 图片左右翻转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#049-Group-Anagrams"><span class="nav-text">049. Group Anagrams</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-找出同字母的异序词-并按字母分组输出"><span class="nav-text">Description: 找出同字母的异序词, 并按字母分组输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希表-sort"><span class="nav-text">解法一: 哈希表+sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-哈希表-不使用sort"><span class="nav-text">解法二: 哈希表(不使用sort)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-另一种生成-key-的解法-不用sort"><span class="nav-text">解法三: 另一种生成 key 的解法(不用sort)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#050-Pow-x-n"><span class="nav-text">050. Pow(x, n)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Descriptin"><span class="nav-text">Descriptin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-2"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-非递归-1"><span class="nav-text">解法二: 非递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#053-Maximum-Subarray"><span class="nav-text">053. Maximum Subarray</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-10"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-记录当前最大值"><span class="nav-text">解法: 记录当前最大值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#054-Spiral-Matrix"><span class="nav-text">054. Spiral Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-11"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-按层次输出-由外而内"><span class="nav-text">解法: 按层次输出(由外而内)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#055-Jump-Game"><span class="nav-text">055. Jump Game</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-12"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-回溯"><span class="nav-text">解法一: 回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-top-down-动态规划-递归"><span class="nav-text">解法二: top-down 动态规划(递归)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-down-top-动态规划-非递归"><span class="nav-text">解法三: down-top 动态规划(非递归)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-贪心"><span class="nav-text">解法四: 贪心</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#056-Merge-Intervals"><span class="nav-text">056. Merge Intervals</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-13"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-sort-O-n"><span class="nav-text">解法一: sort+O(n)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-sort-O-1"><span class="nav-text">解法二: sort+O(1)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-不使用sort"><span class="nav-text">解法三: 不使用sort</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#062-不同路径"><span class="nav-text">062. 不同路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-14"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-DP"><span class="nav-text">解法一: DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-优化的DP"><span class="nav-text">解法二: 优化的DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-排列组合-最优"><span class="nav-text">解法三: 排列组合(最优)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#063-不同路径-II"><span class="nav-text">063. 不同路径 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-动态规划"><span class="nav-text">解法: 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-空间优化的动态规划"><span class="nav-text">解法二: 空间优化的动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#064-最小路径和"><span class="nav-text">064. 最小路径和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-动态规划-1"><span class="nav-text">解法: 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-动态规划空间复杂度优化"><span class="nav-text">解法: 动态规划空间复杂度优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#066-Plus-One"><span class="nav-text">066. Plus One</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-15"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-直接模拟"><span class="nav-text">解法一: 直接模拟</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-不使用加法-更快更简单-击败100"><span class="nav-text">解法二: 不使用加法(更快更简单, 击败100%)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#069-Sqrt-x"><span class="nav-text">069. Sqrt(x)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-16"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-二分法"><span class="nav-text">解法一: 二分法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-牛顿迭代法"><span class="nav-text">解法二: 牛顿迭代法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-按位检索"><span class="nav-text">解法三: 按位检索</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#070-Climbing-Stairs"><span class="nav-text">070. Climbing Stairs</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-17"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-3"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-1"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#073-Set-Matrix-Zeroes"><span class="nav-text">073. Set Matrix Zeroes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-18"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-穷举-1"><span class="nav-text">解法一: 穷举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-穷举-减少空间复杂度"><span class="nav-text">解法二: 穷举(减少空间复杂度)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-穷举-无空间复杂度"><span class="nav-text">解法三: 穷举(无空间复杂度)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-用第一行和第一列记录"><span class="nav-text">解法四: 用第一行和第一列记录</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#075-Sort-Colors"><span class="nav-text">075. Sort Colors</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-19"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-两次遍历"><span class="nav-text">解法一: 两次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-一次遍历"><span class="nav-text">解法二: 一次遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#076-Minimum-Window-Substring"><span class="nav-text">076. Minimum Window Substring</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-20"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-两个变量记录当前窗口大小"><span class="nav-text">解法: 两个变量记录当前窗口大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子串相关题目的模板解法"><span class="nav-text">子串相关题目的模板解法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#077-Combinations"><span class="nav-text">077. Combinations</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-输出所有的组合"><span class="nav-text">Description: 输出所有的组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-回溯-1"><span class="nav-text">解法一: 回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-2"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#078-Subsets"><span class="nav-text">078. Subsets</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-21"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-迭代直接求出子集"><span class="nav-text">解法一: 迭代直接求出子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-回溯-1"><span class="nav-text">解法二: 回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-bit控制"><span class="nav-text">解法三: bit控制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#079-Word-Search"><span class="nav-text">079. Word Search</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-判断指定单词是否存在于字符矩阵中"><span class="nav-text">Description: 判断指定单词是否存在于字符矩阵中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-dfs-回溯"><span class="nav-text">解法一: dfs+回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#084-柱状图中最大的矩形-困难"><span class="nav-text">084. 柱状图中最大的矩形-困难</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-22"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-穷举-2"><span class="nav-text">解法一: 穷举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-解法一的改进-空间换时间"><span class="nav-text">解法二: 解法一的改进-空间换时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-最优-栈"><span class="nav-text">解法三: 最优-栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#085-最大矩形-困难-待完善"><span class="nav-text">085. 最大矩形-困难-待完善</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-动态规划"><span class="nav-text">解法一: 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#088-Merge-Sorted-Array"><span class="nav-text">088. Merge Sorted Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-23"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-后移-插入融合"><span class="nav-text">解法一: 后移+插入融合</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#090-Subsets-II"><span class="nav-text">090. Subsets II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-含重复元素的数组的子集"><span class="nav-text">Description: 含重复元素的数组的子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-迭代-1"><span class="nav-text">解法一: 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-回溯-2"><span class="nav-text">解法二: 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#091-Decode-Ways"><span class="nav-text">091. Decode Ways</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-24"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-最优-DP-constant-space"><span class="nav-text">解法一(最优): DP constant space</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-递归"><span class="nav-text">解法二: 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#094-Binary-Tree-Inorder-Traversal"><span class="nav-text">094. Binary Tree Inorder Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-25"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-4"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-非递归-2"><span class="nav-text">解法二: 非递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#095-不同的二叉搜索树-II"><span class="nav-text">095. 不同的二叉搜索树 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-5"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-动态规划-1"><span class="nav-text">解法二: 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#096-不同的二叉搜索树"><span class="nav-text">096. 不同的二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-6"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-动态规划-2"><span class="nav-text">解法二: 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-卡特兰数"><span class="nav-text">解法三: 卡特兰数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#098-Validate-Binary-Search-Tree"><span class="nav-text">098. Validate Binary Search Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-26"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-7"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-中序"><span class="nav-text">解法二: 迭代(中序)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#101-Symmetric-Tree"><span class="nav-text">101. Symmetric Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-27"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-8"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-3"><span class="nav-text">解法二: 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-迭代"><span class="nav-text">解法三: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#102-Binary-Tree-Level-Order-Traversal"><span class="nav-text">102. Binary Tree Level Order Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-28"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-层次遍历"><span class="nav-text">解法一: 层次遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#103-Binary-Tree-Zigzag-Level-Order-Traversal"><span class="nav-text">103. Binary Tree Zigzag Level Order Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-29"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：利用reverse"><span class="nav-text">解法一：利用reverse</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-最优-不用reverse"><span class="nav-text">解法二: 最优(不用reverse)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-利用双端队列"><span class="nav-text">解法三: 利用双端队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#104-Maximum-Depth-of-Binary-Tree"><span class="nav-text">104. Maximum Depth of Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-30"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-层次遍历-1"><span class="nav-text">解法一: 层次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-递归-1"><span class="nav-text">解法二: 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><span class="nav-text">105. Construct Binary Tree from Preorder and Inorder Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-根据先序和中序遍历构造二叉树"><span class="nav-text">Description: 根据先序和中序遍历构造二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-9"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-4"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#108-Convert-Sorted-Array-to-Binary-Search-Tree"><span class="nav-text">108. Convert Sorted Array to Binary Search Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-31"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归构造"><span class="nav-text">解法一: 递归构造</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-5"><span class="nav-text">解法二: 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-迭代-只中根遍历一次"><span class="nav-text">解法三: 迭代(只中根遍历一次)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#111-minimum-depth-of-binary-tree"><span class="nav-text">111. minimum depth of binary tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述"><span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-1"><span class="nav-text">解法一:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-递归-2"><span class="nav-text">解法二(递归):</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#114-二叉树展开为链表-中等"><span class="nav-text">114. 二叉树展开为链表-中等</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-先序遍历"><span class="nav-text">解法一: 先序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-后序遍历-递归"><span class="nav-text">解法二: 后序遍历, 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-非递归-不使用辅助空间及全局变量"><span class="nav-text">解法三: 非递归, 不使用辅助空间及全局变量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#116-Populating-Next-Right-Pointers-in-Each-Node"><span class="nav-text">116. Populating Next Right Pointers in Each Node</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-32"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-层次遍历-2"><span class="nav-text">解法一: 层次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-利用-next-指针的特性"><span class="nav-text">解法二: 利用 next 指针的特性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#118-Pascal’s-Triangle"><span class="nav-text">118. Pascal’s Triangle</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-33"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-按照三角形的性质进行赋值"><span class="nav-text">解法一: 按照三角形的性质进行赋值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#121-买卖股票的最佳时机-简单"><span class="nav-text">121. 买卖股票的最佳时机-简单</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-34"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-穷举-3"><span class="nav-text">解法一: 穷举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-一次遍历-1"><span class="nav-text">解法二: 一次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-通用-DP-解法"><span class="nav-text">解法三: 通用 DP 解法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#122-买卖股票的最佳时机-II-简单"><span class="nav-text">122. 买卖股票的最佳时机 II-简单</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-35"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-用变量维护最低价格"><span class="nav-text">解法一: 用变量维护最低价格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-每两个相邻数字当做一次交易"><span class="nav-text">解法二: 每两个相邻数字当做一次交易</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-通用-DP-解法-1"><span class="nav-text">解法三: 通用 DP 解法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#123-买卖股票的最佳时机-III-困难"><span class="nav-text">123. 买卖股票的最佳时机 III-困难</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-通用-DP-解法-2"><span class="nav-text">解法三: 通用 DP 解法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#124-Binary-Tree-Maximum-Path-Sum"><span class="nav-text">124. Binary Tree Maximum Path Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-求最长路径加权和"><span class="nav-text">Description: 求最长路径加权和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-10"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-6"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#125-Valid-Palindrome"><span class="nav-text">125 Valid Palindrome</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-36"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-前后两个指示变量-向中间遍历判断"><span class="nav-text">解法一: 前后两个指示变量, 向中间遍历判断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#127-Word-Ladder"><span class="nav-text">127. Word Ladder</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-37"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-BFS"><span class="nav-text">解法一: BFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#128-Longest-Consecutive-Sequence"><span class="nav-text">128. Longest Consecutive Sequence</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-38"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-排序"><span class="nav-text">解法一: 排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-利用哈希表"><span class="nav-text">解法二: 利用哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-另一种哈希表用法"><span class="nav-text">解法三: 另一种哈希表用法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#130-Surrounded-Regions"><span class="nav-text">130. Surrounded Regions</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Descriptioin"><span class="nav-text">Descriptioin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-11"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-7"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#131-Palindrome-Partitioning"><span class="nav-text">131. Palindrome Partitioning</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-39"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-回溯-验证回文子串"><span class="nav-text">解法一: 回溯+验证回文子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-回溯-DP"><span class="nav-text">解法二: 回溯+DP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#134-Gas-Station"><span class="nav-text">134. Gas Station</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-40"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-最优"><span class="nav-text">解法: 最优</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#136-Single-Number"><span class="nav-text">136. Single Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-41"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希"><span class="nav-text">解法一: 哈希</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-数学公式"><span class="nav-text">解法二: 数学公式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-异或"><span class="nav-text">解法三: 异或</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#138-Copy-List-with-Random-Pointer"><span class="nav-text">138. Copy List with Random Pointer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-42"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-复制-拆分"><span class="nav-text">解法一: 复制+拆分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-一次遍历-2"><span class="nav-text">解法二: 一次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-递归"><span class="nav-text">解法三: 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#139-Word-Break"><span class="nav-text">139. Word Break</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-43"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-回溯-2"><span class="nav-text">解法一: 回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-DP-1"><span class="nav-text">解法二: DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-DP-1"><span class="nav-text">解法三: DP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#140-Word-Break-II"><span class="nav-text">140. Word Break II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-44"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-DP-1"><span class="nav-text">解法一: DP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#141-Linked-List-Cycle"><span class="nav-text">141. Linked List Cycle</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-45"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-Floyd-Cycle-Floyd-判圈算法"><span class="nav-text">解法一: Floyd Cycle(Floyd 判圈算法)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#142-Linked-List-Cycle-II"><span class="nav-text">142. Linked List Cycle II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-求链表中环的开始节点"><span class="nav-text">Description: 求链表中环的开始节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-Floyd-的乌龟和兔子-Floyd-判环算法"><span class="nav-text">解法一: Floyd 的乌龟和兔子(Floyd 判环算法)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#144-Binary-Tree-Preorder-Traversal"><span class="nav-text">144. Binary Tree Preorder Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-先根遍历"><span class="nav-text">Description: 先根遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-12"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-8"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#145-二叉树的后序遍历"><span class="nav-text">145. 二叉树的后序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-46"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-13"><span class="nav-text">解法一: 递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-实现-1"><span class="nav-text">C++ 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python-实现-1"><span class="nav-text">Python 实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-9"><span class="nav-text">解法二: 迭代</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-实现-2"><span class="nav-text">C++ 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python-实现-2"><span class="nav-text">Python 实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#146-LRU-Cache"><span class="nav-text">146. LRU Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-47"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-利用哈希表和双端链表"><span class="nav-text">解法一: 利用哈希表和双端链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-实现-3"><span class="nav-text">C++ 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python-实现-3"><span class="nav-text">Python 实现:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Follow-Up"><span class="nav-text">Follow Up</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-实现-4"><span class="nav-text">C++ 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python-实现-4"><span class="nav-text">Python 实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#148-Sort-List"><span class="nav-text">148. Sort List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-48"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-自顶向下"><span class="nav-text">解法一: 递归 自顶向下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-自底向上"><span class="nav-text">解法二: 迭代 自底向上</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#149-Max-Points-on-a-Line"><span class="nav-text">149. Max Points on a Line</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-最大的共线点个数"><span class="nav-text">Description 最大的共线点个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希表"><span class="nav-text">解法一: 哈希表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#150-Evaluate-Reverse-Polish-Notation"><span class="nav-text">150. Evaluate Reverse Polish Notation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-49"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-栈-1"><span class="nav-text">解法一: 栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-栈-异常"><span class="nav-text">解法二: 栈+异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-栈-lambda"><span class="nav-text">解法三: 栈+lambda</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-栈-lambda-异常"><span class="nav-text">解法四: 栈+lambda+异常</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#152-Maximum-Product-Subarray"><span class="nav-text">152. Maximum Product Subarray</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-50"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-14"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代实现"><span class="nav-text">解法二 迭代实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-DP-迭代"><span class="nav-text">解法三: DP 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#155-Min-Stack"><span class="nav-text">155. Min Stack</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-51"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-两个栈"><span class="nav-text">解法一: 两个栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#160-Intersection-of-Two-Linked-Lists"><span class="nav-text">160. Intersection of Two Linked Lists</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-52"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：栈"><span class="nav-text">解法一：栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-常数空间复杂度"><span class="nav-text">解法二: 常数空间复杂度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#162-Find-Peak-Element"><span class="nav-text">162. Find Peak Element</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-局部最大值"><span class="nav-text">Description: 局部最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-O-n-复杂度"><span class="nav-text">解法一: $O(n)$ 复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-O-logn-复杂度"><span class="nav-text">解法二: $O(logn)$ 复杂度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#166-Fraction-to-Recurring-Decimal"><span class="nav-text">166. Fraction to Recurring Decimal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-无限循环小数"><span class="nav-text">Description: 无限循环小数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-用余数作为哈希表的key"><span class="nav-text">解法一: 用余数作为哈希表的key</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#169-Majority-Element"><span class="nav-text">169 Majority Element</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-找出数组中超过一半的数字"><span class="nav-text">Description: 找出数组中超过一半的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-排序-1"><span class="nav-text">解法一: 排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-哈希-1"><span class="nav-text">解法二: 哈希</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-同增异减"><span class="nav-text">解法三: 同增异减</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-随机"><span class="nav-text">解法四: 随机</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#171-Excel-Sheet-Column-Number"><span class="nav-text">171. Excel Sheet Column Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-Excel列表数字"><span class="nav-text">Description: Excel列表数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-遍历字符串"><span class="nav-text">解法一: 遍历字符串</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#172-Factorial-Trailing-Zeroes"><span class="nav-text">172. Factorial Trailing Zeroes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-阶乘的尾部含有0的个数"><span class="nav-text">Description: 阶乘的尾部含有0的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-统计5的个数"><span class="nav-text">解法一: 统计5的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-另一个角度"><span class="nav-text">解法二: 另一个角度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#179-Largest-Number"><span class="nav-text">179. Largest Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-排列数字使其字符串形式的数字为最大"><span class="nav-text">Description: 排列数字使其字符串形式的数字为最大</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-构造比较函数-快排排序"><span class="nav-text">解法一: 构造比较函数, 快排排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-利用-STL-sort-函数"><span class="nav-text">解法二: 利用 STL sort() 函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#188-买卖股票的最佳时机-IV"><span class="nav-text">188. 买卖股票的最佳时机 IV</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-通用-DP-解法"><span class="nav-text">解法: 通用 DP 解法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#189-旋转数组"><span class="nav-text">189. 旋转数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-循环右移数组"><span class="nav-text">Description: 循环右移数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-暴力-4"><span class="nav-text">解法一: 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-使用额外数组"><span class="nav-text">解法二: 使用额外数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-循环置换"><span class="nav-text">解法三: 循环置换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-reverse"><span class="nav-text">解法四: reverse</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#190-Reverse-Bits"><span class="nav-text">190. Reverse Bits</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-按位逆置"><span class="nav-text">Description: 按位逆置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-按位进行32次操作"><span class="nav-text">解法一: 按位进行32次操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-按位二分进行5次操作"><span class="nav-text">解法二: 按位二分进行5次操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#191-Number-of-1-Bits"><span class="nav-text">191. Number of 1 Bits</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-统计二进制中1的个数"><span class="nav-text">Description: 统计二进制中1的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-逐位统计"><span class="nav-text">解法一: 逐位统计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-和-n-1-按位与"><span class="nav-text">解法二: 和 $n-1$ 按位与</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#198-打家劫舍-简单"><span class="nav-text">198. 打家劫舍-简单</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-房屋小偷获取最大收益"><span class="nav-text">Description: 房屋小偷获取最大收益</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-DP-2"><span class="nav-text">解法一: DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-根据房屋的编号奇偶性"><span class="nav-text">解法二: 根据房屋的编号奇偶性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#200-Number-of-Islands"><span class="nav-text">200. Number of Islands</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-区块的个数"><span class="nav-text">Description: 区块的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-DFS-遍历"><span class="nav-text">解法一: DFS 遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#202-Happy-Number"><span class="nav-text">202. Happy Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-判断一个数字是否是-Happer-Number"><span class="nav-text">Description: 判断一个数字是否是 Happer Number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-模拟计算过程"><span class="nav-text">解法一: 模拟计算过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-Floyd-判圈算法"><span class="nav-text">解法二: Floyd 判圈算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#204-Count-Primes"><span class="nav-text">204. Count Primes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-素数的个数"><span class="nav-text">Description: 素数的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-填充非素数"><span class="nav-text">解法一: 填充非素数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#206-Reverse-Linked-List"><span class="nav-text">206. Reverse Linked List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-逆置链表"><span class="nav-text">Description: 逆置链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-迭代-2"><span class="nav-text">解法一: 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-递归-3"><span class="nav-text">解法二: 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#207-Course-Schedule"><span class="nav-text">207. Course Schedule</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-课程表-判断有向图是否存在环"><span class="nav-text">Description: 课程表 / 判断有向图是否存在环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-BFS-拓扑排序"><span class="nav-text">解法一: BFS / 拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-DFS"><span class="nav-text">解法二: DFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#208-Implement-Trie-Prefix-Tree"><span class="nav-text">208. Implement Trie (Prefix Tree)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-实现字典树-前缀树"><span class="nav-text">Description: 实现字典树(前缀树)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-2"><span class="nav-text">解法一</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#210-Course-Schedule-II"><span class="nav-text">210. Course Schedule II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-判断有向图是否有环-若无环-则返回拓扑序列"><span class="nav-text">Description: 判断有向图是否有环, 若无环, 则返回拓扑序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-BFS-拓扑排序-1"><span class="nav-text">解法一: BFS, 拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-DFS-1"><span class="nav-text">解法二: DFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#212-Word-Search-II"><span class="nav-text">212. Word Search II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-返回字符矩阵中含有的所有单词"><span class="nav-text">Description: 返回字符矩阵中含有的所有单词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-穷举-4"><span class="nav-text">解法一: 穷举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-字典树"><span class="nav-text">解法二: 字典树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#213-打家劫舍-II-中等"><span class="nav-text">213. 打家劫舍 II-中等</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-动态规划-2"><span class="nav-text">解法: 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#215-Kth-Largest-Element-in-an-Array"><span class="nav-text">215. Kth Largest Element in an Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-找出无序数组中第k大的数"><span class="nav-text">Description: 找出无序数组中第k大的数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-小顶堆"><span class="nav-text">解法一: 小顶堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-部分排序-nth-element"><span class="nav-text">解法二: 部分排序(nth_element)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-基于-Partition"><span class="nav-text">解法三: 基于 Partition</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#217-Contains-Duplicate"><span class="nav-text">217. Contains Duplicate</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-判断数组中是否有重复元素"><span class="nav-text">Description: 判断数组中是否有重复元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-暴力-5"><span class="nav-text">解法一: 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-排序-遍历"><span class="nav-text">解法二: 排序+遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-unordered-set-哈希"><span class="nav-text">解法三: unordered_set(哈希)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#218-The-Skyline-Problem"><span class="nav-text">218. The Skyline Problem</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-天际线问题"><span class="nav-text">Description: 天际线问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-multiset"><span class="nav-text">解法一: multiset</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-priority-queue-堆"><span class="nav-text">解法二: priority_queue(堆)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#221-最大正方形"><span class="nav-text">221. 最大正方形</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-动态规划-1"><span class="nav-text">解法一: 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-优化的动态规划"><span class="nav-text">解法二: 优化的动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#226-翻转二叉树"><span class="nav-text">226. 翻转二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-15"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-10"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#227-Basic-Calculator-II"><span class="nav-text">227. Basic Calculator II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-基本计算器-二"><span class="nav-text">Description: 基本计算器(二)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-栈-2"><span class="nav-text">解法一: 栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-字符串流"><span class="nav-text">解法二: 字符串流</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#230-Kth-Smallest-Element-in-a-BST"><span class="nav-text">230. Kth Smallest Element in a BST</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-找出二叉搜索树中的最小元素"><span class="nav-text">Description: 找出二叉搜索树中的最小元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-非递归中根遍历"><span class="nav-text">解法一: 非递归中根遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-递归中根遍历"><span class="nav-text">解法二: 递归中根遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-二叉搜索"><span class="nav-text">解法三: 二叉搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解答Follow-up"><span class="nav-text">解答Follow up</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#234-Palindrome-Linked-List"><span class="nav-text">234. Palindrome Linked List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-回文链表判断"><span class="nav-text">Description: 回文链表判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-借助辅助数组"><span class="nav-text">解法一: 借助辅助数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-不借助辅助数组"><span class="nav-text">解法二: 不借助辅助数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree"><span class="nav-text">236. Lowest Common Ancestor of a Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-查找二叉树中任意两个节点的公共祖先"><span class="nav-text">Description: 查找二叉树中任意两个节点的公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-16"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-存储父节点"><span class="nav-text">解法二: 迭代(存储父节点)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-迭代-不存储父节点"><span class="nav-text">解法三: 迭代(不存储父节点)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#237-Delete-Node-in-a-Linked-List"><span class="nav-text">237. Delete Node in a Linked List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-删除链表中的某个节点"><span class="nav-text">Description: 删除链表中的某个节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-复制-跳过节点"><span class="nav-text">解法一: 复制+跳过节点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#238-Product-of-Array-Except-Self"><span class="nav-text">238. Product of Array Except Self</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-计算数组内其他元素之积-不能使用除法"><span class="nav-text">Description: 计算数组内其他元素之积(不能使用除法)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-借助辅助数组-1"><span class="nav-text">解法一: 借助辅助数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-用一个变量代替数组"><span class="nav-text">解法二: 用一个变量代替数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-用两个变量代替数组"><span class="nav-text">解法三: 用两个变量代替数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#239-Sliding-Window-Maximum"><span class="nav-text">239. Sliding Window Maximum</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-滑动窗口的最大值"><span class="nav-text">Description: 滑动窗口的最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-双端队列"><span class="nav-text">解法一: 双端队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#240-Search-a-2D-Matrix-II"><span class="nav-text">240. Search a 2D Matrix II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-矩阵搜索"><span class="nav-text">Description: 矩阵搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-从左下角开始"><span class="nav-text">解法一: 从左下角开始</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#242-Valid-Anagram"><span class="nav-text">242. Valid Anagram</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-判断变位词"><span class="nav-text">Description: 判断变位词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-排序-2"><span class="nav-text">解法一: 排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-哈希表"><span class="nav-text">解法二: 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解答-Follow-up"><span class="nav-text">解答 Follow up:</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#268-Missing-Number"><span class="nav-text">268. Missing Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-缺失的数字"><span class="nav-text">Description: 缺失的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-排序-3"><span class="nav-text">解法一: 排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-哈希表-1"><span class="nav-text">解法二: 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-异或-1"><span class="nav-text">解法三: 异或</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-高斯求和公式"><span class="nav-text">解法四: 高斯求和公式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#279-Perfect-Squares"><span class="nav-text">279. Perfect Squares</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-找到最少的平方和个数"><span class="nav-text">Description: 找到最少的平方和个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-四平方和定理-最优"><span class="nav-text">解法一: 四平方和定理(最优)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-DP-2"><span class="nav-text">解法二: DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-DP-2"><span class="nav-text">解法三: DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-递归"><span class="nav-text">解法四: 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#283-Move-Zeroes"><span class="nav-text">283. Move Zeroes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-将-0-移动到最后-保持其他元素相对位置不变"><span class="nav-text">Description: 将 0 移动到最后, 保持其他元素相对位置不变</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-交换法"><span class="nav-text">解法一: 交换法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-更简洁的交换法"><span class="nav-text">解法二: 更简洁的交换法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#287-Find-the-Duplicate-Number"><span class="nav-text">287. Find the Duplicate Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-寻找重复元素"><span class="nav-text">Description: 寻找重复元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希表-1"><span class="nav-text">解法一: 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-排序"><span class="nav-text">解法二: 排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-Floyd-的乌龟和兔子-Floy-判圈算法"><span class="nav-text">解法三: Floyd 的乌龟和兔子(Floy 判圈算法)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#289-Game-of-Life"><span class="nav-text">289. Game of Life</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-游戏人生"><span class="nav-text">Description: 游戏人生</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-状态机"><span class="nav-text">解法一: 状态机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Follow-up"><span class="nav-text">Follow up</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#295-Find-Median-from-Data-Stream"><span class="nav-text">295. Find Median from Data Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-返回数据流的中位数"><span class="nav-text">Description: 返回数据流的中位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-传统排序"><span class="nav-text">解法一: 传统排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-插入排序"><span class="nav-text">解法二: 插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-大顶堆-小顶堆"><span class="nav-text">解法三: 大顶堆+小顶堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-multiset-指示器"><span class="nav-text">解法四: multiset+指示器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Follow-Up-1"><span class="nav-text">Follow Up</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#297-Serialize-and-Deserialize-Binary-Tree"><span class="nav-text">297. Serialize and Deserialize Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-序列化和反序列化二叉树"><span class="nav-text">Description: 序列化和反序列化二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-DFS"><span class="nav-text">解法一: DFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-BFS"><span class="nav-text">解法二: BFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#300-Longest-Increasing-Subsequence"><span class="nav-text">300. Longest Increasing Subsequence</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-求最长递增序列-可以不连续-的长度"><span class="nav-text">Description: 求最长递增序列(可以不连续)的长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-暴力-6"><span class="nav-text">解法一: 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-Recursion-with-memorization-Memory-Limit-Exceeded"><span class="nav-text">解法二: Recursion with memorization [Memory Limit Exceeded]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-DP-3"><span class="nav-text">解法三: DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-DP-二分搜索-最优"><span class="nav-text">解法四: DP+二分搜索(最优)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#309-最佳买卖股票时机含冷冻期"><span class="nav-text">309. 最佳买卖股票时机含冷冻期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-动态规划-2"><span class="nav-text">解法一: 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#315-Count-of-Smaller-Numbers-After-Self"><span class="nav-text">315. Count of Smaller Numbers After Self</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-统计右边比当前数字小的个数"><span class="nav-text">Description: 统计右边比当前数字小的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-multiset-1"><span class="nav-text">解法一: multiset</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-有序数组"><span class="nav-text">解法二: 有序数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-二叉搜索树-BST"><span class="nav-text">解法三: 二叉搜索树(BST)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-归并排序"><span class="nav-text">解法四: 归并排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#322-Coin-Change"><span class="nav-text">322. Coin Change</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-硬币凑面额"><span class="nav-text">Description: 硬币凑面额</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-DP-3"><span class="nav-text">解法一: DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-DP-递归实现"><span class="nav-text">解法二: DP 递归实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-对暴力解法剪枝"><span class="nav-text">解法三: 对暴力解法剪枝</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#324-Wiggle-Sort-II"><span class="nav-text">324. Wiggle Sort II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-“驼峰”-排序"><span class="nav-text">Description: “驼峰” 排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-排序-4"><span class="nav-text">解法一: 排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-partition"><span class="nav-text">解法二: partition</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Follow-up-three-way-partition"><span class="nav-text">Follow up: three-way partition</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#326-Power-of-Three"><span class="nav-text">326. Power of Three</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-三的幂次"><span class="nav-text">Description: 三的幂次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-自下而上-超时"><span class="nav-text">解法一: 自下而上(超时)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-自上而下"><span class="nav-text">解法二: 自上而下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-进制转换-不使用循环或迭代"><span class="nav-text">解法三: 进制转换(不使用循环或迭代)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#328-Odd-Even-Linked-List"><span class="nav-text">328. Odd Even Linked List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-奇偶链表"><span class="nav-text">Description: 奇偶链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-一次遍历"><span class="nav-text">解法一: 一次遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#329-Longest-Increasing-Path-in-a-Matrix"><span class="nav-text">329. Longest Increasing Path in a Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-寻找矩阵中的最长递增序列"><span class="nav-text">Description: 寻找矩阵中的最长递增序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-DP-dfs"><span class="nav-text">解法一: DP + dfs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-DP-BFS"><span class="nav-text">解法二: DP + BFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#334-Increasing-Triplet-Subsequence"><span class="nav-text">334. Increasing Triplet Subsequence</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-递增的三元子序列"><span class="nav-text">Description: 递增的三元子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-用辅助变量指向-min-和-mid"><span class="nav-text">解法一: 用辅助变量指向 min 和 mid</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#337-打家劫舍-III-中等"><span class="nav-text">337. 打家劫舍 III-中等</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-树形动态规划"><span class="nav-text">解法: 树形动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#341-Flatten-Nested-List-Iterator"><span class="nav-text">341. Flatten Nested List Iterator</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-将嵌套的多维列表展开成一维"><span class="nav-text">Description: 将嵌套的多维列表展开成一维</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-栈-3"><span class="nav-text">解法一: 栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-deque"><span class="nav-text">解法二: deque</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#344-Reverse-String"><span class="nav-text">344. Reverse String</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-反转字符串"><span class="nav-text">Description: 反转字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-使用-reverse-函数"><span class="nav-text">解法一: 使用 reverse 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-基于-swap"><span class="nav-text">解法二: 基于 swap</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#347-Top-K-Frequent-Elements"><span class="nav-text">347. Top K Frequent Elements</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-寻找频率最高的-k-个数字"><span class="nav-text">Description: 寻找频率最高的 k 个数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希-大顶堆"><span class="nav-text">解法一: 哈希+大顶堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-哈希-小顶堆"><span class="nav-text">解法二: 哈希+小顶堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-哈希-桶"><span class="nav-text">解法三: 哈希+桶</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#350-Intersection-of-Two-Arrays-II"><span class="nav-text">350. Intersection of Two Arrays II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-求两数组的交集"><span class="nav-text">Description: 求两数组的交集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希-1"><span class="nav-text">解法一: 哈希</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-排序-1"><span class="nav-text">解法二: 排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Follow-up-1"><span class="nav-text">Follow up</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#当给定数组已经有序时"><span class="nav-text">当给定数组已经有序时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#当-nums1-远远小于-nums2-时"><span class="nav-text">当 nums1 远远小于 nums2 时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果-nums2-存放在磁盘上-同时内存不足以加载整个-nums2-数组"><span class="nav-text">如果 nums2 存放在磁盘上, 同时内存不足以加载整个 nums2 数组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#371-Sum-of-Two-Integers"><span class="nav-text">371. Sum of Two Integers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-不用加减乘除做加法"><span class="nav-text">Description: 不用加减乘除做加法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-位操作-递归"><span class="nav-text">解法一: 位操作(递归)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-位操作-迭代"><span class="nav-text">解法二: 位操作(迭代)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#378-Kth-Smallest-Element-in-a-Sorted-Matrix"><span class="nav-text">378. Kth Smallest Element in a Sorted Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-找到半有序数组中的第-k-小的元素"><span class="nav-text">Description: 找到半有序数组中的第 k 小的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-堆"><span class="nav-text">解法一: 堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-二分查找-2"><span class="nav-text">解法二: 二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-二分查找"><span class="nav-text">解法三: 二分查找</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#380-Insert-Delete-GetRandom-O-1"><span class="nav-text">380. Insert Delete GetRandom O(1)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-常数时间复杂度的插入-删除-和随机获取"><span class="nav-text">Description: 常数时间复杂度的插入,删除,和随机获取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希表-数组"><span class="nav-text">解法一: 哈希表+数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#384-Shuffle-an-Array"><span class="nav-text">384. Shuffle an Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-打乱数组"><span class="nav-text">Description: 打乱数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-随机交换"><span class="nav-text">解法一: 随机交换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#387-First-Unique-Character-in-a-String"><span class="nav-text">387. First Unique Character in a String</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-寻找字符串中的首个不重复字符"><span class="nav-text">Description: 寻找字符串中的首个不重复字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希表-2"><span class="nav-text">解法一: 哈希表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#394-字符串解码"><span class="nav-text">394. 字符串解码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-遍历"><span class="nav-text">解法一: 遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-栈"><span class="nav-text">解法二: 栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#395-Longest-Substring-with-At-Least-K-Repeating-Characters"><span class="nav-text">395. Longest Substring with At Least K Repeating Characters</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-53"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希表-位标志"><span class="nav-text">解法一: 哈希表+位标志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-分而治之-递归"><span class="nav-text">解法二: 分而治之, 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-更简洁的递归"><span class="nav-text">解法三: 更简洁的递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#399-除法求值"><span class="nav-text">399. 除法求值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-构建有向图"><span class="nav-text">解法一: 构建有向图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-并查集"><span class="nav-text">解法二: 并查集</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#406-根据身高重建队列"><span class="nav-text">406. 根据身高重建队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-排序-5"><span class="nav-text">解法一: 排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#412-Fizz-Buzz"><span class="nav-text">412. Fizz Buzz</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-输出指定字符串"><span class="nav-text">Description: 输出指定字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-条件判断直接输出"><span class="nav-text">解法一: 条件判断直接输出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#416-分割等和子集"><span class="nav-text">416. 分割等和子集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-动态规划-3"><span class="nav-text">解法: 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#438-找到字符串中所有字母异位词"><span class="nav-text">438. 找到字符串中所有字母异位词</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-滑动窗口"><span class="nav-text">解法一: 滑动窗口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#442-数组中重复的数据"><span class="nav-text">442. 数组中重复的数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-用当前的值作为索引"><span class="nav-text">解法一: 用当前的值作为索引</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#448-找到所有数组中消失的数字"><span class="nav-text">448. 找到所有数组中消失的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数字归位"><span class="nav-text">数字归位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-置负数"><span class="nav-text">解法二: 置负数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展题型"><span class="nav-text">扩展题型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#454-4Sum-II"><span class="nav-text">454. 4Sum II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-4-数之和为零的可能组合数"><span class="nav-text">Description: 4 数之和为零的可能组合数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-先求两两之和"><span class="nav-text">解法一: 先求两两之和</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#543-二叉树的路径"><span class="nav-text">543. 二叉树的路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-后序遍历"><span class="nav-text">解法一: 递归, 后序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-后序遍历"><span class="nav-text">解法二: 迭代, 后序遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#560-和为-K-的子数组"><span class="nav-text">560. 和为 K 的子数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希表-3"><span class="nav-text">解法一: 哈希表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#621-任务调度器"><span class="nav-text">621. 任务调度器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-以最多的任务作为依据"><span class="nav-text">解法一: 以最多的任务作为依据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#647-回文子串"><span class="nav-text">647. 回文子串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-扩展中心法"><span class="nav-text">解法一: 扩展中心法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-Manacher-算法"><span class="nav-text">解法二: Manacher 算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#714-买卖股票的最佳时机含手续费"><span class="nav-text">714. 买卖股票的最佳时机含手续费</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-通用-DP-解法-1"><span class="nav-text">解法: 通用 DP 解法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#739-每日温度"><span class="nav-text">739. 每日温度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-单调递增栈"><span class="nav-text">解法一: 单调递增栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-利用已经求得的部分结果加速循环"><span class="nav-text">解法二: 利用已经求得的部分结果加速循环</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#股票问题通用解法"><span class="nav-text">股票问题通用解法</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZeroZone</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">2.5m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">37:45</span>
  
</div>










  <div class="footer-custom">勤练带来力量</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  





  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


</body>
</html>
