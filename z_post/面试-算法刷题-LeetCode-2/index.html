<!DOCTYPE html>













<html class="theme-next gemini" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">

<meta name="google-site-verification" content="jgw73iXouBAJcOuff0yi9vdSNDecBSOUXacsHJszpmo" />
<meta name="baidu-site-verification" content="xyf9WD2vvl" />











<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/apple-icon-57x57.png?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_body":"slideDownIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="002. Add Two NumbersDescription: 链表数之和You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single d">
<meta name="keywords" content="算法刷题">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode算法题(Medium)">
<meta property="og:url" content="https://hellozhaozheng.github.io/z_post/面试-算法刷题-LeetCode-2/index.html">
<meta property="og:site_name" content="从零开始的BLOG">
<meta property="og:description" content="002. Add Two NumbersDescription: 链表数之和You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single d">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://wx4.sinaimg.cn/large/d7b90c85ly1fvxf2u0hrfj20h004iglr.jpg">
<meta property="og:image" content="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1ft6j20hd08kzki.jpg">
<meta property="og:image" content="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1afaj20ge08dwep.jpg">
<meta property="og:image" content="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1khnj20ie06b3yh.jpg">
<meta property="og:image" content="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fw0kh84zz9j20gh085dg5.jpg">
<meta property="og:image" content="https://wx4.sinaimg.cn/large/d7b90c85ly1fxnm0ibh7vj20jc0ggadn.jpg">
<meta property="og:updated_time" content="2019-06-27T06:09:59.752Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode算法题(Medium)">
<meta name="twitter:description" content="002. Add Two NumbersDescription: 链表数之和You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single d">
<meta name="twitter:image" content="https://wx4.sinaimg.cn/large/d7b90c85ly1fvxf2u0hrfj20h004iglr.jpg">






  <link rel="canonical" href="https://hellozhaozheng.github.io/z_post/面试-算法刷题-LeetCode-2/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>LeetCode算法题(Medium) | 从零开始的BLOG</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?21a4899cc63d3c11a3d90ac58074a19c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">从零开始的BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">与其感慨路难行，不如马上出发</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档<span class="badge">263</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-计算机视觉">
    <a href="/categories/计算机视觉/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tripadvisor"></i> <br />计算机视觉</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-深度学习">
    <a href="/categories/深度学习/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-drupal"></i> <br />深度学习</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-caffe2">
    <a href="/categories/Caffe2/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-coffee"></i> <br />Caffe2</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-pytorch">
    <a href="/categories/PyTorch/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-free-code-camp"></i> <br />PyTorch</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-c++">
    <a href="/categories/Cpp/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-codiepie"></i> <br />C++</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-python">
    <a href="/categories/Python/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-product-hunt"></i> <br />Python</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-项目">
    <a href="/categories/项目/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-connectdevelop"></i> <br />项目</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-cuda">
    <a href="/categories/CUDA/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-braille"></i> <br />CUDA</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-其他">
    <a href="/categories/其他/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />其他</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签<span class="badge">40</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于我</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />站内搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="站内搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  
  
    
      
    
    <a href="https://github.com/hellozhaozheng" class="github-corner" target="_blank" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg>
    
      </a>
    



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hellozhaozheng.github.io/z_post/面试-算法刷题-LeetCode-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZeroZone">
      <meta itemprop="description" content="并不是什么厉害的地方<br>只是一个安静的学习角落">
      <meta itemprop="image" content="/images/avatar_zz.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="从零开始的BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">LeetCode算法题(Medium)
              
            
          </h1>
        

        <div class="post-meta">
	
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-02 08:54:58" itemprop="dateCreated datePublished" datetime="2018-10-02T08:54:58+08:00">2018-10-02</time>
            

            
          </span>

	  
  	    <span class="post-updated">
    		&nbsp; | &nbsp; 更新于
    		<time itemprop="dateUpdated" datetime="2019-06-27T14:09:59+08:00" content="2019-06-27">
      		  2019-06-27
    		</time>
  	  </span>
	  

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon"
            >
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">249k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">3:47</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="002-Add-Two-Numbers"><a href="#002-Add-Two-Numbers" class="headerlink" title="002. Add Two Numbers"></a>002. Add Two Numbers</h1><h2 id="Description-链表数之和"><a href="#Description-链表数之和" class="headerlink" title="Description: 链表数之和"></a>Description: 链表数之和</h2><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Example:</p>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.</p>
<h2 id="解法一-顺序相加-注意进位"><a href="#解法一-顺序相加-注意进位" class="headerlink" title="解法一: 顺序相加, 注意进位"></a>解法一: 顺序相加, 注意进位</h2><p>从链表的第一个节点开始, 将两个节点的值和进位位想加, 如果大于10, 则当前结果节点的值对10取余, 同时将进位位置1, 如果小于10, 则直接赋值给当前结果节点, 同时将进位位置0.</p>
<p>特别注意 <code>l1</code> 和 <code>l2</code> 的长度问题, 当二者节点遇到 <code>nullptr</code> 时, 将较长的剩余部分重新赋给l1, 并继续判断</p>
<p>最后, 需要注意是否有进位位, 如果有, 则要申请一个新节点, 并将其置为1</p>
<p><strong>时间复杂度</strong>: $O(\max(m,n))$<br><strong>空间复杂度</strong>: $O(1)$  (这种做法会破坏原有链的结构)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//创建指向最终结果的头指针</span></span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="literal">nullptr</span>)  head-&gt;next = l1; <span class="comment">// 虽然题目指明为非空链表, 但是最好还是做一下判断</span></span><br><span class="line">        <span class="keyword">else</span> head-&gt;next = l2;</span><br><span class="line">        ListNode* pre=head; <span class="comment">// pre用于保存l1的上一个指针</span></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            l1-&gt;val = l1-&gt;val + l2-&gt;val + carry;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &gt; <span class="number">9</span>)&#123;</span><br><span class="line">                l1-&gt;val %= <span class="number">10</span>;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = l1;</span><br><span class="line">            l1 = l1-&gt;next; l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l2!=<span class="literal">nullptr</span>)&#123; <span class="comment">// 此时说明l2比l1长, 用l1的上一个指针指向当前l2剩余的部分,</span></span><br><span class="line">            l1 = pre;</span><br><span class="line">            l1-&gt;next =  l2;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span>)&#123;  <span class="comment">// 此时l1为剩余(l1或l2) 的部分,  只需要考虑是否有进位即可</span></span><br><span class="line">            l1-&gt;val = l1-&gt;val + carry;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &gt; <span class="number">9</span>)&#123;</span><br><span class="line">                l1-&gt;val %= <span class="number">10</span>;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                carry = <span class="number">0</span>;  <span class="comment">// 如果没有进位, 一定要将此处置0, 否则会引起错误</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;  <span class="comment">// 对应 999 + 001 的特殊情况,  此时进位会不断传递, 最终数字位数加1, 最高位为1</span></span><br><span class="line">            ListNode* newnode = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">            l1 = pre;</span><br><span class="line">            l1-&gt;next = newnode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-顺序相加-维持原链表"><a href="#解法二-顺序相加-维持原链表" class="headerlink" title="解法二: 顺序相加, 维持原链表"></a>解法二: 顺序相加, 维持原链表</h2><p><strong>时间复杂度</strong>: $O(\max(m,n))$<br><strong>空间复杂度</strong>: $O(\max(m,n))$  (这种做法需要额外申请空间, 但不会破坏原有链的结构)</p>
<p>该解法思路与解法一一致, 只不过每次都申请一个新的节点, 确保不会改变原有链表的结构.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *pre = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> || l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode *cur = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> a = l1==<span class="literal">nullptr</span> ? <span class="number">0</span> : l1-&gt;val;</span><br><span class="line">            <span class="keyword">int</span> b = l2==<span class="literal">nullptr</span> ? <span class="number">0</span> : l2-&gt;val;</span><br><span class="line">            cur-&gt;val = a + b + carry;</span><br><span class="line">            carry = cur-&gt;val / <span class="number">10</span>;</span><br><span class="line">            cur-&gt;val = cur-&gt;val % <span class="number">10</span>;</span><br><span class="line">            pre-&gt;next = cur;</span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">nullptr</span>) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="literal">nullptr</span>) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            pre-&gt;next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h2><p>What if the the digits in the linked list are stored in non-reversed order? For example:</p>
<p>$(3 \to 4 \to 2) + (4 \to 6 \to 5) = 8 \to 0 \to 7 (3→4→2)+(4→6→5)=8→0→7$</p>
<p>思路:</p>
<p>先将链表转置 , 再用上面的方法求解</p>
<p><strong>转置时间复杂度</strong>: $O(n)$<br><strong>转置空间复杂度</strong>: $O(1)$</p>
<h1 id="003-Longest-Substring-Without-Repeating-Characters"><a href="#003-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="003. Longest Substring Without Repeating Characters"></a>003. Longest Substring Without Repeating Characters</h1><h2 id="Description-寻找无重复字符的最长子串"><a href="#Description-寻找无重复字符的最长子串" class="headerlink" title="Description: 寻找无重复字符的最长子串"></a>Description: 寻找无重复字符的最长子串</h2><p>Given a string, find the length of the longest substring without repeating characters.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3.</span><br></pre></td></tr></table></figure></p>
<p>Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p>
<h2 id="解法一-暴力"><a href="#解法一-暴力" class="headerlink" title="解法一:暴力"></a>解法一:暴力</h2><p><strong>时间复杂度</strong>: $O(n^3)$ 对于每一个字符, 子串的添加以及查重过程时间复杂度为 $O(n^2)$ , 总共n个字符, 所以为 $O(n^3)$<br><strong>空间复杂度</strong>: $O(min(n,m))$ 需要将当前子串存在起来以便查询是否相等, n为字符串length, m为字符集size</p>
<h2 id="解法二-前后两个指示变量"><a href="#解法二-前后两个指示变量" class="headerlink" title="解法二: 前后两个指示变量"></a>解法二: 前后两个指示变量</h2><p><strong>时间复杂度</strong>: $O(2n) = O(n)$<br><strong>空间复杂度</strong>: $O(min(n,m))$</p>
<p>思路: 首先构造一个哈希表, 用来存储当前子串中出现的字符, 这样, 新来的字符可以直接查询哈希表来判断字符是否存在, 构建哈希表空间复杂度为 <script type="math/tex">O(min(n,m))</script> ( $m$ 为字符集合的大小,一般为26(字母), 128(ASCII), 256(ASCII), $n$ 为字符串的长度)</p>
<p>然后, 使用两个指示变量, 分别指向当前未重复子串的首字符, 和超尾字符, 进行如下几个判断:</p>
<ul>
<li>如果超尾字符与当前子串中的字符不重复, 那么将超尾字符加入到当前子串中,并将length加1</li>
<li>如果超尾字符与当前子串中的字符重复, 利用哈希表查的重复字符的所在位置, 将当前子串的首字符直接跳向该重复字符的下一个位置( <strong>这样可以保证只遍历一遍</strong> ), 并将包括重复字符在内的之前所有字符都从哈希表中删除(之前的字符不再可能组成更长的子串了), 同时将超尾字符加入, length赋予新值: 超尾位置-重复位置-1;</li>
<li>判断首字符与超尾字符是否相等, 如果相等, 将超尾字符加1, 并将length置为1</li>
<li>看当前length是否比maxlength大, 并重复以上过程,直到超尾字符超出size</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>, r=<span class="number">0</span>; r&lt;s.size(); )&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[s[r]] == <span class="number">0</span>)&#123;</span><br><span class="line">                hash[s[r]] = <span class="number">1</span>;</span><br><span class="line">                max_len = <span class="built_in">std</span>::max(max_len, r-l+<span class="number">1</span>);</span><br><span class="line">                r++;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hash[s[l]] = <span class="number">0</span>;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-只需一次遍历"><a href="#解法三-只需一次遍历" class="headerlink" title="解法三: 只需一次遍历"></a>解法三: 只需一次遍历</h2><p><strong>时间复杂度</strong>: $O(n)$, 只需一次遍历<br><strong>空间复杂度</strong>: $O(min(m,n)$, 与解法二相同</p>
<p>当我们在 <code>[i,j)</code> 之间发现了一个重复的下标为 <code>j&#39;</code> 的字符时, 我们不用一点点的增加 <code>i</code> 的值, 而是可以直接将 <code>i</code> 的值跳到 <code>j&#39;+1</code> 处. 故, 我们可以只利用一次遍历就找到最长的不重复子串.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; s_hash;      </span><br><span class="line">        <span class="keyword">int</span> max_length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ,j=<span class="number">0</span> ; j&lt; s.size() ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s_hash.count(s[j]))&#123; <span class="comment">// 这里未删除 i 之前的, 所以即使这里的哈希可以查到, 也不一定就是重复.</span></span><br><span class="line">                i = max(i,s_hash[s[j]]+<span class="number">1</span>); <span class="comment">//如果遇到重复的, 就将当前的i指向重复的下一个</span></span><br><span class="line">                <span class="comment">// (这里用max的原因是, 没有删除当前i到重复字符之间的其他字符, 这些字符</span></span><br><span class="line">                <span class="comment">//  后续还可能被检测到,  所以这里只取max的, 也就是i不会倒退)</span></span><br><span class="line">                <span class="comment">//s_hash.erase(s[j]); // 该语句是多余的</span></span><br><span class="line">            &#125;</span><br><span class="line">            s_hash[s[j]] = j;</span><br><span class="line">            max_length = max_length &gt; (j-i+<span class="number">1</span>) ? max_length : (j-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_length;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>用数组做哈希表:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">256</span>];<span class="comment">// 哈希表中存在的值代表下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;item : hash) item = <span class="number">-1</span>; <span class="comment">// 赋初值</span></span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; j &lt; s.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[s[j]] != <span class="number">-1</span>)&#123; <span class="comment">// 当哈希表中值不为-1时, 说明存在重复</span></span><br><span class="line">                i = <span class="built_in">std</span>::max(hash[s[j]] + <span class="number">1</span>, i); <span class="comment">// 注意这里必须保证 i 不会倒退, 因此要使用 max</span></span><br><span class="line">            &#125;</span><br><span class="line">            max_len = <span class="built_in">std</span>::max(max_len, j-i+<span class="number">1</span>);</span><br><span class="line">            hash[s[j]] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="005-Longest-Palindromic-Substring"><a href="#005-Longest-Palindromic-Substring" class="headerlink" title="005. Longest Palindromic Substring"></a>005. Longest Palindromic Substring</h1><h2 id="Description-最大回文子串"><a href="#Description-最大回文子串" class="headerlink" title="Description: 最大回文子串"></a>Description: 最大回文子串</h2><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p>
<p>Example 1:</p>
<p>Input: “babad”<br>Output: “bab”<br>Note: “aba” is also a valid answer.<br>Example 2:</p>
<p>Input: “cbbd”<br>Output: “bb”</p>
<h2 id="解法一：最长公共子串"><a href="#解法一：最长公共子串" class="headerlink" title="解法一：最长公共子串"></a>解法一：最长公共子串</h2><p><strong>时间复杂度:</strong> $O(n^2)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>先将字符串 <code>s</code> 利用 <code>reverse</code> 逆置成 <code>s&#39;</code>, 然后查找 <code>s</code> 和 <code>s&#39;</code> 的最长公共子串, 即为最长的回文子串.</p>
<h2 id="解法二：-穷举"><a href="#解法二：-穷举" class="headerlink" title="解法二： 穷举"></a>解法二： 穷举</h2><p><strong>时间复杂度:</strong> $O(n^3)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>对于字符串中的每一个字符, 共有 $\frac{n(n-1)}{2}$ 种包含该字符的子串, 所以如果对所有可能的子串判断, 需要 $O(n^3)$ 的时间复杂度</p>
<h2 id="解法三：-动态规划"><a href="#解法三：-动态规划" class="headerlink" title="解法三： 动态规划"></a>解法三： 动态规划</h2><p><strong>时间复杂度:</strong> $O(n^2)$<br><strong>空间复杂度:</strong> $O(n^2)$</p>
<p>我们令 DP 数组为一个 $n\times n$ 的矩阵, $dp(i,j)$ 代表从 <code>s[i]</code> 开始, 到 <code>s[j]</code> 结束的子串是否为回文串, 如果是, 则为 <code>true</code>. 那么, $dp(i,j)$ 为真的条件就是必须满足 $dp(i+1, j-1)=true$ 并且 $s[i]=s[j]$. dp 数组的初始值为: $dp(i,i)=true$, $dp(i,i+1)= s[i]==s[i+1]$. 由于需要遍历 dp 矩阵中每一个位置的值, 因此时间复杂度为 $O(n^2)$, 空间复杂度很明显为 $O(n^2)$.</p>
<h2 id="解法三：-扩展中心法"><a href="#解法三：-扩展中心法" class="headerlink" title="解法三： 扩展中心法"></a>解法三： 扩展中心法</h2><p><strong>时间复杂度:</strong> $O(n^2)$<br><strong>空间复杂度:</strong> $O(1)$ 或者 $O(n)$</p>
<p>以每一个字符为中心,  向两边扩展,  将当前能够扩展的长度 len 和最大扩展长度 max_len 作比较, 记录较大者, 同时记录较大者的所对应的中心字符的下标 max_index. 最后, 根据最大扩展的长度max_len 和中心字符的下标 max_index 计算最大回文子串的开始位置和总长度</p>
<p>此处注意, 回文子串有奇偶两种情况, 可采用以下举措之一解决:</p>
<ul>
<li>分别检查奇数和偶数的情况, 这样多检查一次(虽然多检查一次, 但和下面的检查总次数差不多, 因为下面虽然只检查一次, 但次数较多)</li>
<li>向字符内插入特殊符号 ‘#’, 这样不管偶数奇数, 都可以当做奇数处理, 缺点是占用了额外的 $O(n)$ 空间.</li>
</ul>
<p>注意: 既然已经使用了空间复杂度为 $O(n)$ 的方法, 实际上更应该将其该写成马拉车算法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空间复杂度 $O(1)$</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len1=<span class="number">0</span>,len2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> left=i, right = i;  <span class="comment">//通过left和right , 是的对奇偶的分别处理更方便</span></span><br><span class="line">            <span class="keyword">while</span>( left &gt;=<span class="number">0</span> &amp;&amp; right&lt;s.size() &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">                left--; right++;</span><br><span class="line">            &#125;</span><br><span class="line">            len1 = right-left<span class="number">-1</span>; <span class="comment">// 注意, 这里一定是-1, 而不是+1</span></span><br><span class="line"></span><br><span class="line">            left=i;</span><br><span class="line">            right=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>( left&gt;=<span class="number">0</span> &amp;&amp; right&lt;s.size() &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">                left--; right++;</span><br><span class="line">            &#125;</span><br><span class="line">            len2 = right-left<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> len = max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span>(len&gt;max_len)&#123;</span><br><span class="line">                max_len = len;</span><br><span class="line">                start = i- (len<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, max_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>另一种写法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空间复杂度 $O(1)$</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left, right;</span><br><span class="line">            left = i, right = i;</span><br><span class="line">            <span class="keyword">while</span>(s[left] == s[right])&#123; <span class="comment">// 奇数情况</span></span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">if</span>(left &lt; <span class="number">0</span> || right == s.size())&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max_len &lt; right-left<span class="number">-1</span>)&#123;</span><br><span class="line">                max_len = right-left<span class="number">-1</span>;</span><br><span class="line">                max_i = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            left = i, right = i+<span class="number">1</span>; <span class="comment">// 下面要对 right 判断, 防止越界</span></span><br><span class="line">            <span class="keyword">while</span>(right !=s.size() &amp;&amp; s[left] == s[right])&#123;<span class="comment">// 偶数</span></span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">if</span>(left &lt; <span class="number">0</span> || right == s.size())&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max_len &lt; right-left<span class="number">-1</span>)&#123;</span><br><span class="line">                max_len = right-left<span class="number">-1</span>;</span><br><span class="line">                max_i = i+<span class="number">1</span>;<span class="comment">//偶数时令max_i指向偏右的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(max_i-max_len/<span class="number">2</span>, max_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空间复杂度 $O(n)$</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>*  cs = <span class="keyword">new</span> <span class="keyword">char</span>[s.size() * <span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">        cs[<span class="number">0</span>]=<span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size() ; i++)&#123; <span class="comment">//插入 '#'</span></span><br><span class="line">            cs[i*<span class="number">2</span>+<span class="number">1</span>] = s[i];</span><br><span class="line">            cs[i*<span class="number">2</span>+<span class="number">2</span>] = <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;s.size()*<span class="number">2</span>+<span class="number">1</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len=<span class="number">0</span>; <span class="comment">//记录当前扩展长度len</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; i-j&gt;=<span class="number">0</span> &amp;&amp; i+j&lt;s.size()*<span class="number">2</span>+<span class="number">1</span> ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cs[i-j] == cs[i+j])&#123; <span class="comment">//两边字符若相等, 则len长度增1</span></span><br><span class="line">                    len++;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(len &gt; max_len)&#123;</span><br><span class="line">                max_len = len;</span><br><span class="line">                max_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = (max_index - max_len)/<span class="number">2</span>;  <span class="comment">//根据maxlen和index 计算回文子串开始坐标</span></span><br><span class="line">        <span class="keyword">int</span> len = max_len;</span><br><span class="line">        <span class="keyword">delete</span> cs;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, len);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法五-马拉车-Manacher-算法"><a href="#解法五-马拉车-Manacher-算法" class="headerlink" title="解法五: 马拉车(Manacher) 算法"></a>解法五: 马拉车(Manacher) 算法</h2><p>时间复杂度: $O(n)$<br>空间复杂度: $O(n)$</p>
<p>There is even an O(n), O(n) algorithm called Manacher’s algorithm, explained here in detail. However, it is a non-trivial algorithm, and no one expects you to come up with this algorithm in a 45 minutes coding session. But, please go ahead and understand it, I promise it will be a lot of fun.</p>
<p>马拉车算法的核心思想还是从中心扩展发出发, 不过他必须使用 ‘#’ 字符先对原始字符串插入, 如下所示:</p>
<p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fvxf2u0hrfj20h004iglr.jpg" alt=""></p>
<p>接下来, 在每一次 <code>for</code> 循环当中, 都需要保存这么几个值(命名是个人习惯, 可以用其他名字代替):</p>
<ul>
<li>P: P 为最大右边界下标值, 对应的是所有已检测的回文子串中, 右边界下标最大的那个</li>
<li>P_center: 该值是P对应的回文子串的中心下标</li>
<li>max_len: 对应当前最大回文子串的半径(aba的半径为1, a的半径为0)</li>
<li>max_index: 对应当前最大回文子串的中心下标</li>
</ul>
<p>然后, 还需要构建一个和插入’#’后的字符串长度相关的数组 <code>p_len</code>, 里面存放着对应位置的回文串半径, 用以后续的计算, 这一步是关键, 有了这个数组 ,才能实现利用之前计算结果</p>
<p>接下来, 遍历 “新字符串”(即插入’#’之后的字符串) 的每一个字符, 设当前下标为 i, 则有如下情况, 分别处理:</p>
<ul>
<li>P&gt;i, 说明 i 在 P 的范围内, 可以利用前面的计算结果</li>
<li>P&lt;=i, 说明 i 不在 P 的范围内, 无法利用前面的计算结果, 只能逐个判断</li>
</ul>
<p>对上面两种情况具体分析如下:</p>
<p>第一种情况: P&gt;i</p>
<p>找到i相对于 P_center 的对称位置, 设为j, 那么如果Len[j]&lt;P-i, 如下图所示:</p>
<p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1ft6j20hd08kzki.jpg" alt=""></p>
<p> 则以i为中心的回文串的长度至少和以j为中心的回文串一样 , 即Len [i]&gt;=Len[j] , 因此可以直接从Len[j]+1开始判断回文</p>
<p>如果Len[j]&gt;=P-i, 如下图所示:</p>
<p><img src="https://wx2.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1afaj20ge08dwep.jpg" alt=""></p>
<p>由对称性, 说明以i为中心的回文串可能会延伸到P之外, 而大于P的部分我们还没有进行匹配, 所以要从P+1位置开始一个一个进行匹配, 直到发生失配</p>
<p>第二种情况: P&lt;=i</p>
<p><img src="https://wx4.sinaimg.cn/mw690/d7b90c85ly1fvxf2u1khnj20ie06b3yh.jpg" alt=""></p>
<p>如果i比P还要大, 说明对于中点为i的回文串还一点都没有匹配, 这个时候, 就只能老老实实地一个一个匹配了</p>
<p>在这一次循环完成之前, 更新上面提及的四个变量</p>
<p>循环结束后, 根据 max_index 和 max_len 的值返回最长回文子串</p>
<p>时间复杂度分析:</p>
<p>对于每一个字符, 由于如果直接比较过, 那么就可以利用之前比较的结果直接判断, 所以每个字符都只进行了一次比较, 故而时间复杂度为 $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cs_size = s.size()*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>* cs = <span class="keyword">new</span> <span class="keyword">char</span>[cs_size];</span><br><span class="line">        cs[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.size(); i++)&#123;</span><br><span class="line">            cs[i*<span class="number">2</span> + <span class="number">1</span>] = s[i];</span><br><span class="line">            cs[i*<span class="number">2</span> + <span class="number">2</span>] = <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> P = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> P_center = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>* p_len = <span class="keyword">new</span> <span class="keyword">int</span>[cs_size];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;cs_size; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i &lt; P)&#123; <span class="comment">// 如果i&lt;P, 说明可以复用前面的计算结果</span></span><br><span class="line">                <span class="keyword">int</span> j = P_center*<span class="number">2</span> - i; <span class="comment">// j对i关于P_center的对称点</span></span><br><span class="line">                <span class="keyword">if</span>(P-i &gt; p_len[j])&#123; <span class="comment">// 如果i与P之间的距离比 j 的回文串长度还大,</span></span><br><span class="line">                    <span class="comment">//说明可以直接从p_len[j] + 1开始比较, 之前的子串一定是回文串</span></span><br><span class="line">                    <span class="keyword">int</span> k = p_len[j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(i-k&gt;=<span class="number">0</span> &amp;&amp; i+k&lt;cs_size &amp;&amp; cs[i-k] == cs[i+k])&#123;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p_len[i] = k<span class="number">-1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">// 如果距离没有p_len[j] + 1大, 则从超出P的部分开始比较</span></span><br><span class="line">                    <span class="keyword">int</span> k = P - i;</span><br><span class="line">                    <span class="keyword">while</span>(i-k&gt;=<span class="number">0</span> &amp;&amp; i+k&lt;cs_size &amp;&amp; cs[i-k] == cs[i+k])&#123;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p_len[i] = k<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果i不在P范围内, 则必须从1开始逐个比较, 无法利用之前的计算结果</span></span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(i-k&gt;=<span class="number">0</span> &amp;&amp; i+k&lt;cs_size &amp;&amp; cs[i-k] == cs[i+k])&#123;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p_len[i] = k<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(p_len[i] &gt; max_len)&#123;</span><br><span class="line">                max_len = p_len[i];</span><br><span class="line">                max_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i+p_len[i] &gt; P)&#123;</span><br><span class="line">                P = i+p_len[i];</span><br><span class="line">                P_center = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> cs;</span><br><span class="line">        <span class="keyword">delete</span> p_len;</span><br><span class="line">        <span class="keyword">int</span> start = (max_index - max_len)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> len = max_len;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="008-String-to-Integer-atoi"><a href="#008-String-to-Integer-atoi" class="headerlink" title="008. String to Integer (atoi)"></a>008. String to Integer (atoi)</h1><h2 id="Description-将字符串转换成整数"><a href="#Description-将字符串转换成整数" class="headerlink" title="Description: 将字符串转换成整数"></a>Description: 将字符串转换成整数</h2><h2 id="解法一-考虑多种情况"><a href="#解法一-考虑多种情况" class="headerlink" title="解法一: 考虑多种情况"></a>解法一: 考虑多种情况</h2><p>此题时间复杂度为 $O(n)$ , 重点考察是否考虑的全面, 主要有以下几种情况, 缺一不可:</p>
<ul>
<li>+123 dd   // 返回123</li>
<li>+123d   // 返回123</li>
<li>d-123  // 返回0</li>
<li>-123+ //返回-123</li>
<li>-123+4 // 返回-123</li>
<li>323123423423423 // 返回INT_MAX</li>
<li>-1231238923894234 // 返回INT_MIN</li>
<li>1234-5 // 返回1234</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sign =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> is_first = <span class="literal">true</span>; <span class="comment">//记录当前非数字字符是否是第一个非空格字符, 如果是, 返回0</span></span><br><span class="line">        <span class="keyword">bool</span> has_sign = <span class="literal">false</span>; <span class="comment">// 记录正负号的出现次数, 出现多于1次的, 返回0</span></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;  <span class="comment">//记录当前的int值, 要出现int范围, 返回对应的INT</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt;str.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span> &amp;&amp; is_first) <span class="keyword">continue</span>; <span class="comment">// 空格, 且没有出现任何非空格字符(如出现了, 则空格也会跟着变成循环停止的标志)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( !has_sign &amp;&amp; (str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>) )&#123; <span class="comment">// 判断符号</span></span><br><span class="line">                has_sign = <span class="literal">true</span>;</span><br><span class="line">                is_first = <span class="literal">false</span>;</span><br><span class="line">                sign = str[i]==<span class="string">'+'</span> ? <span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] &lt;= <span class="string">'9'</span> &amp;&amp; str[i] &gt;= <span class="string">'0'</span>)&#123;</span><br><span class="line">                has_sign = <span class="literal">true</span>;</span><br><span class="line">                is_first = <span class="literal">false</span>;</span><br><span class="line">                res = res*<span class="number">10</span> + <span class="keyword">int</span>(str[i] - <span class="string">'0'</span>) * sign; <span class="comment">// 数字累加, 注意这里使用了sign, 因此无需在后面判断正负, 直接加就可以</span></span><br><span class="line">                <span class="keyword">if</span> (res &gt; INT_MAX) <span class="keyword">return</span> INT_MAX; <span class="comment">// 超限</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(res &lt; INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(is_first)&#123;  <span class="comment">//首字符为非法字符, 返回0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="011-Container-With-Most-Water"><a href="#011-Container-With-Most-Water" class="headerlink" title="011. Container With Most Water"></a>011. Container With Most Water</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container and n is at least 2.</p>
<p>The below vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p><img src="https://wx1.sinaimg.cn/mw690/d7b90c85ly1fw0kh84zz9j20gh085dg5.jpg" alt=""></p>
<h2 id="解法一-暴力-1"><a href="#解法一-暴力-1" class="headerlink" title="解法一: 暴力"></a>解法一: 暴力</h2><p>时间复杂度: $O(n^2)$</p>
<p>用max_area标记当前最大容器的取值, 然后两个for循环遍历所有容器的可能取值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;height.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; height.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(max_area &lt; min( height[i],height[j] ) * (j-i))&#123;</span><br><span class="line">                    max_area = min( height[i],height[j] ) * (j-i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-用两个指针"><a href="#解法二-用两个指针" class="headerlink" title="解法二: 用两个指针"></a>解法二: 用两个指针</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>分别用两个指针指向数组的第一个元素和最后一个元素, 并计算当前的area, 然后移动指针元素值较小的一方, 移动过程中更新max_area的值</p>
<p>原理:</p>
<p>首先假设容器可以具有最大长度的宽, 也就是分别指向首尾元素,  这时候 , 我们想查看是否还有比当前最大容积更大的容器,  那么, 我们必须维持较高的垂直边不动, 而将较低的垂直边移动, 因为只有这样, 我们才 <strong>有可能</strong> (注意不是一定)获得比当前容积更大的容器, 这个时候虽然宽变小了, 但是高度却可能增加(因为新增的边有可能大于当前较低边的高).  如果移动较高的边, 那么新增的边由于受到当前较低边的作用, 只有可能减小容器的面积</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = height.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">int</span> area = min( height[low], height[high] ) * (high-low);</span><br><span class="line">            <span class="keyword">if</span>(max_area &lt; area)&#123;</span><br><span class="line">                max_area = area;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(height[low] &lt; height[high])</span><br><span class="line">                low++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="015-3Sum"><a href="#015-3Sum" class="headerlink" title="015. 3Sum"></a>015. 3Sum</h1><h2 id="Description-三数和为零"><a href="#Description-三数和为零" class="headerlink" title="Description: 三数和为零"></a>Description: 三数和为零</h2><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong><br>The solution set must <strong>not</strong> contain duplicate triplets.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-固定一个数-剩余两个数用双指针法求"><a href="#解法一-固定一个数-剩余两个数用双指针法求" class="headerlink" title="解法一: 固定一个数, 剩余两个数用双指针法求"></a>解法一: 固定一个数, 剩余两个数用双指针法求</h2><p><strong>时间复杂度:</strong> $O(n^2+nlogn)=O(n^2)$<br><strong>空间复杂度:</strong> $O(1)$, 无需额外空间</p>
<p><strong>解题步骤:</strong></p>
<ol>
<li>对整个数组排序, $O(nlogn)$;</li>
<li>固定下标 <code>i</code>, 令下标<code>j=i+1</code>, 令 <code>k=nums.size()-1</code>.</li>
<li>如果 <code>nums[i]</code> 为正数, 说明不可能组成和为零的三元组, 直接返回当前结果;</li>
<li>为了消除重复, 对于相同的相邻元素, 我们只选其中的一个参与组合. <strong>注意: 这里的重复是指三元组的值的重复, 而不是下标重复, 也就是说, 对于下标不同但值相同的元素, 也算作重复.</strong></li>
<li>重复(2)(3)(4)过程直到循环终止.</li>
</ol>
<p><strong>排序的必要性:</strong> 这里我们排序的主要目的是为了消除重复, 如果题目允许重复, 那么可以不进行排序, 而采用基于哈希表的 TwoSum 来求解.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[low] != nums[(low+high)/<span class="number">2</span>])&#123; <span class="comment">// 注意这里用异或交换的陷阱</span></span><br><span class="line">            nums[low] = nums[low] + nums[(low+high)/<span class="number">2</span>];</span><br><span class="line">            nums[(low+high)/<span class="number">2</span>] = nums[low] - nums[(low+high)/<span class="number">2</span>];</span><br><span class="line">            nums[low] = nums[low] - nums[(low+high)/<span class="number">2</span>];      </span><br><span class="line">        &#125; <span class="comment">// 主要是将中将的数字和首位交换, 个人觉得可有可无, 因为时间复杂度是一样的</span></span><br><span class="line">        <span class="keyword">int</span> P = nums[low];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P&lt;=nums[high]) high--;</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P&gt;=nums[low]) low++;</span><br><span class="line">            nums[high] = nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = P;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = partition(nums, low, high);</span><br><span class="line">        <span class="keyword">if</span>(low&lt;mid ) quickSort(nums, low, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;high) quickSort(nums, mid+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;<span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//剪枝, 如果当前数字为正, 那么后面就不可能再有符合条件的三元组, 可以提前退出</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] ) <span class="keyword">continue</span>; <span class="comment">//去除重复, 遇到除第一个外相同的三元组最小的数字, 则跳过</span></span><br><span class="line">            <span class="keyword">int</span> low = i+<span class="number">1</span>, high = nums.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">                <span class="keyword">if</span>(low&gt;i+<span class="number">1</span> &amp;&amp; nums[low] == nums[low<span class="number">-1</span>])&#123; <span class="comment">// 仍然是去除重复,</span></span><br><span class="line">                    low++; <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[low] + nums[i] + nums[high];</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;<span class="number">0</span>) high--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) low++;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp&#123;nums[low], nums[i], nums[high]&#125;;</span><br><span class="line">                    res.push_back(tmp);</span><br><span class="line">                    low++;  <span class="comment">// 这一点千万别漏了, 要继续判断, 因为以当前数字开始的三元组可能不止一个</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更好的写法:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;=<span class="number">2</span>)<span class="keyword">return</span> result;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(a &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; a == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;<span class="comment">// 这里不能用nums[i]==nums[i+1], 因为会丢掉类似于 -1,-1,2 的解.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> j = i + <span class="number">1</span>, k = nums.size() - <span class="number">1</span>; j &lt; k;) &#123;</span><br><span class="line">                <span class="keyword">int</span> b = nums[j];</span><br><span class="line">                <span class="keyword">int</span> c = nums[k];</span><br><span class="line">                <span class="keyword">int</span> value = a + b + c;</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</span><br><span class="line">                    result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;a, b, c&#125;));</span><br><span class="line">                    <span class="keyword">while</span> (j &lt; k &amp;&amp; b == nums[++j]); <span class="comment">// 主要是这里的写法很优雅, 其他地方和上面差不多</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; k &amp;&amp;c == nums[--k]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-python写法"><a href="#解法二-python写法" class="headerlink" title="解法二: python写法"></a>解法二: python写法</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        target = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> p1 <span class="keyword">in</span> range (len(nums) - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> (nums[p1] &gt; <span class="number">0</span>): <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">if</span> (p1 &gt; <span class="number">0</span> <span class="keyword">and</span> nums[p1] == nums[p1<span class="number">-1</span>]): <span class="keyword">continue</span></span><br><span class="line">            p2 = p1 + <span class="number">1</span></span><br><span class="line">            p3 = len(nums) <span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> (p2 &lt; p3):</span><br><span class="line">                <span class="keyword">if</span> (p2<span class="number">-1</span> != p1 <span class="keyword">and</span> nums[p2] == nums[p2<span class="number">-1</span>]):</span><br><span class="line">                    p2 += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                tmp = nums[p1] + nums[p2] + nums[p3]</span><br><span class="line">                <span class="keyword">if</span> (tmp &gt; <span class="number">0</span>): p3 -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> (tmp &lt; <span class="number">0</span>): p2 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[p1], nums[p2], nums[p3]])</span><br><span class="line">                    p2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="017-Letter-Combinations-of-a-Phone-Number"><a href="#017-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="017. Letter Combinations of a Phone Number"></a>017. Letter Combinations of a Phone Number</h1><h2 id="Description-九键字母组合"><a href="#Description-九键字母组合" class="headerlink" title="Description: 九键字母组合"></a>Description: 九键字母组合</h2><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.<br>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="解法一-递归"><a href="#解法一-递归" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h3><p><strong>时间复杂度:</strong> $O(n<em>4^n)$, $n$ 为数字的长度<br><em>*空间复杂度:</em></em> $O(4^n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back_tracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; digit_letters, <span class="built_in">string</span>&amp; tmp,<span class="built_in">string</span> digits, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == digits.size())&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;digit_letters[digits[index]-<span class="string">'0'</span>].size(); i++)&#123;</span><br><span class="line">                tmp.push_back(digit_letters[digits[index]-<span class="string">'0'</span>][i]);</span><br><span class="line">                back_tracking(res, digit_letters, tmp, digits, index+<span class="number">1</span>);</span><br><span class="line">                tmp.pop_back();<span class="comment">// 移除当前末尾元素, 以便可以加下一个</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(digits.size() &lt;=<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//res.push_back(""); //在递归解法中, 不需要改语句.</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; digit_letters&#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,</span><br><span class="line">                      <span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> tmp=<span class="string">""</span>;</span><br><span class="line">        back_tracking(res, digit_letters, tmp, digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解法二-非递归"><a href="#解法二-非递归" class="headerlink" title="解法二: 非递归"></a>解法二: 非递归</h3><p><strong>时间复杂度:</strong> $O(n<em>4^n)$, $n$ 为数字数组的长度<br><em>*空间复杂度:</em></em> $O(4^n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(digits.size() &lt;=<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        res.push_back(<span class="string">""</span>); <span class="comment">//对res向量初始化,以便开始, 如果不初始化, 则size为0,后面的循环无法进行</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; digit_letters&#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,</span><br><span class="line">                                          <span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;digits.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = digits[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(digit_letters[num] == <span class="string">""</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp; <span class="comment">// 申请一个临时vector, 用于存放加上当前数字字符的string集合</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; digit_letters[num].size(); k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l =<span class="number">0</span>; l &lt; res.size(); l++)&#123;</span><br><span class="line">                    tmp.push_back(res[l]+digit_letters[num][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.swap(tmp); <span class="comment">// 将res于tmp交换, swap仅仅是改变指针, 比'='更快, 因为'='包含了复制</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="解法一-利用reduce实现"><a href="#解法一-利用reduce实现" class="headerlink" title="解法一: 利用reduce实现"></a>解法一: 利用reduce实现</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> digits==<span class="string">""</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        digit_letters = &#123;<span class="string">'0'</span>:<span class="string">""</span>, <span class="string">'1'</span>:<span class="string">""</span>, <span class="string">'2'</span>:<span class="string">"abc"</span>,</span><br><span class="line">                        <span class="string">'3'</span>:<span class="string">"def"</span>, <span class="string">'4'</span>:<span class="string">"ghi"</span>, <span class="string">'5'</span>:<span class="string">"jkl"</span>,</span><br><span class="line">                        <span class="string">'6'</span>:<span class="string">"mno"</span>, <span class="string">'7'</span>:<span class="string">"pqrs"</span>, <span class="string">'8'</span>:<span class="string">"tuv"</span>, <span class="string">'9'</span>:<span class="string">"wxyz"</span>&#125;</span><br><span class="line">        <span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">        <span class="comment"># 在python3中, reduce()函数已经从全局命名空间移除, 现在存在于functools模块中,使用时需要导入</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> res,digit:[x+y <span class="keyword">for</span> x <span class="keyword">in</span> res <span class="keyword">for</span> y <span class="keyword">in</span> digit_letters[digit]], digits, [<span class="string">""</span>])</span><br></pre></td></tr></table></figure>
<p><span id="018"></span></p>
<h1 id="018-四数之和"><a href="#018-四数之和" class="headerlink" title="018. 四数之和"></a>018. 四数之和</h1><h2 id="解法"><a href="#解法" class="headerlink" title="解法:"></a>解法:</h2><p>转换成两数之和</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(nums, target, k, res, tmp_res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span>(len(nums) &lt; k <span class="keyword">or</span> nums[<span class="number">0</span>] * k &gt; target <span class="keyword">or</span> nums[<span class="number">-1</span>] * k &lt; target):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">2</span>):</span><br><span class="line">                i = <span class="number">0</span></span><br><span class="line">                j = len(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; j):</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i<span class="number">-1</span>] == nums[i]):</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    tmp = nums[i] + nums[j]</span><br><span class="line">                    <span class="keyword">if</span> (tmp &lt; target): i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> (tmp &gt; target): j -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res.append(tmp_res + [nums[i], nums[j]])</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i<span class="number">-1</span>] == nums[i]):</span><br><span class="line">                        <span class="comment">#i += 1 这里不论加不加 i 效果都一样, 为什么?</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    twoSum(nums[i+<span class="number">1</span>:], target-nums[i], k<span class="number">-1</span>, res, tmp_res+[nums[i]])</span><br><span class="line">        res = []</span><br><span class="line">        twoSum(sorted(nums), target, <span class="number">4</span>, res, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="019-Remove-Nth-Node-From-End-of-List"><a href="#019-Remove-Nth-Node-From-End-of-List" class="headerlink" title="019. Remove Nth Node From End of List"></a>019. Remove Nth Node From End of List</h1><h2 id="Description-移除链表的倒数第-N-个字符"><a href="#Description-移除链表的倒数第-N-个字符" class="headerlink" title="Description: 移除链表的倒数第 N 个字符"></a>Description: 移除链表的倒数第 N 个字符</h2><p>Given a linked list, remove the n-th node from the end of list and return its head.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>Given n will always be valid.</p>
<p><strong>Follow up:</strong><br>Could you do this in one pass?</p>
<h2 id="解法一-遍历两次"><a href="#解法一-遍历两次" class="headerlink" title="解法一: 遍历两次"></a>解法一: 遍历两次</h2><p>第一次遍历求出链表长度, 第二次遍历在对应位置删除节点</p>
<h2 id="解法二-双指针-只遍历一次"><a href="#解法二-双指针-只遍历一次" class="headerlink" title="解法二: 双指针, 只遍历一次"></a>解法二: 双指针, 只遍历一次</h2><p>时间复杂度: $O(n)$ 且只遍历一次</p>
<p>空间复杂度: $O(1)$</p>
<p>维护两个指针, 两指针之间的距离刚好相差n, 当第二个指针到达链表尾部时, 第一个指针刚好指向倒数第n个节点, 直接删除该节点即可.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* first = head;</span><br><span class="line">        ListNode* second = head;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">nullptr</span>) <span class="keyword">return</span> head-&gt;next; <span class="comment">// 链表长度为n, 删除倒数第n个节点</span></span><br><span class="line">        <span class="keyword">while</span> (first-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是有一种写法, 新申请了一个节点空间, 用于指向head节点, 可以使代码看起来更容易理解, 对边界条件的判断也更加方便</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> head; <span class="comment">//链表为空, 或者n&lt;=0时, 直接返回head</span></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* first = dummy;</span><br><span class="line">        ListNode* second = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(second == <span class="literal">nullptr</span>) <span class="keyword">return</span> dummy-&gt;next;<span class="comment">// n超出了链表的长度</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(second-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        first-&gt;next = first-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="022-Generate-Parentheses"><a href="#022-Generate-Parentheses" class="headerlink" title="022. Generate Parentheses"></a>022. Generate Parentheses</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-暴力-2"><a href="#解法一-暴力-2" class="headerlink" title="解法一: 暴力"></a>解法一: 暴力</h2><p>先求出所有可能性, 然后验证每一种可能性是否正确</p>
<h2 id="解法二-回溯"><a href="#解法二-回溯" class="headerlink" title="解法二: 回溯"></a>解法二: 回溯</h2><p>有关递归的时间空间复杂度分析起来都不太容易, 这里只上答案(//TODO 具体怎么来没搞懂)</p>
<p><strong>时间复杂度:</strong> $O(\frac{4^n}{\sqrt n})$<br><strong>空间复杂度:</strong> $O(\frac{4^n}{\sqrt n})$ 以及 $O(n)$ 的空间来存储组合序列</p>
<p>考虑合法括号组合的规律: 必须首先出现左括号, 然后才能出现右括号, 如果当前的string里面的右括号数量大于左括号数量, 那么就一定会出现<code>)(</code>这种不匹配的情况.</p>
<p>核心思路: 从头开始构建组合, 每次接入一个字符, 接入的字符只有两种可能性, 即左括号或者右括号, 而一旦接入的字符使得当前字符中右括号数量大于左括号, 就会变得不合法组合,其它均为合法. 根据此性质, 进行如下递归:</p>
<p>维护两个变量left_rest, right_rest分别代表 <strong>剩余</strong> 可以添加的括号的 <strong>数量</strong>. 采用递归算法, 每次添加一个 ‘(‘ 或者一个 ‘)’, 添加时需要考虑下面几种情况:</p>
<ul>
<li>为了保证当前string内左括号数量多于右括号数量, left_rest一定要小于right_rest</li>
<li>如果<code>left_rest = right_rest = 0</code>, 则说明此时没有可以添加的括号了.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        helper(res, <span class="string">""</span>, n, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res, <span class="built_in">string</span> out, <span class="keyword">int</span> left_rest, <span class="keyword">int</span> right_rest)</span></span>&#123; <span class="comment">//注意这里的 out 不能生命成引用形式</span></span><br><span class="line">        <span class="comment">//if(left_rest &gt; right_rest) return;</span></span><br><span class="line">        <span class="keyword">if</span>(left_rest == <span class="number">0</span> &amp;&amp; right_rest ==<span class="number">0</span>) res.push_back(out);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(left_rest&gt;<span class="number">0</span>) helper(res, out+<span class="string">'('</span>, left_rest<span class="number">-1</span>, right_rest);</span><br><span class="line">            <span class="keyword">if</span>(right_rest&gt;<span class="number">0</span> &amp;&amp; right_rest &gt; left_rest) helper(res, out+<span class="string">')'</span>, left_rest, right_rest<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-Closure-Number"><a href="#解法三-Closure-Number" class="headerlink" title="解法三: Closure Number"></a>解法三: Closure Number</h2><p><strong>时间复杂度:</strong> $O(\frac{4^n}{\sqrt n})$, 同解法4<br><strong>空间复杂度:</strong> $O(\frac{4^n}{\sqrt n})$, 同解法4</p>
<p>该方法可以看做是一种插入法, 选定一组括号 <code>()</code>, 由此便消耗了一组括号的数量, 此时还剩下 <code>n-1</code> 组括号, 我们将这 <code>n-1</code> 组括号插入到选定的括号中, 即 <code>(left)right</code>, 其中, <code>left</code> 和 <code>right</code> 都是有效的括号组合, 它们的括号组数加起来刚好为 <code>n-1</code>, 因此, <code>left</code> 的括号组数的情况共有 <code>n</code> 种情况: [0, …, n-1], 对应的 <code>right</code> 的组数有 <code>n-1-left</code> 组. 具体代码实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            res.push_back(<span class="string">""</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;n; c++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">string</span> left : generateParenthesis(c))</span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">string</span> right : generateParenthesis(n<span class="number">-1</span>-c))</span><br><span class="line">                        res.push_back(<span class="string">"("</span>+left+<span class="string">")"</span>+right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-用栈来模拟递归"><a href="#解法四-用栈来模拟递归" class="headerlink" title="解法四: 用栈来模拟递归"></a>解法四: 用栈来模拟递归</h2><p>首先是最厚的括号包裹状态, 即一开始左边是连续的左括号, 右边是连续的右括号, 然后执行以下逻辑：</p>
<ol>
<li>右括号不能比左括号多;</li>
<li>弹出右括号, 直到遇到第一个左括号, 如果左括号改成右括号仍然合法, 则把它改成右括号; 否则, 左括号继续弹出;</li>
<li>改完之后一个劲加左括号, 直到所有可以用的左括号都加完为止; 然后再一个劲的加右括号, 直到加完位置;</li>
<li>循环一直执行到不能弹出括号为止, 即直到栈为空.</li>
</ol>
<p><strong>这里刚好凸显了一件事情, 那就是要注意尽可能不要将自增或自减操作写在 <code>while()</code> 条件句里面, 否则会造成一些很难发现的错误, 下面代码中的注释会说明</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = n;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="comment">// 注意, 将left写在while里面的问题时, 当left为0时才会结束while</span></span><br><span class="line">        <span class="comment">// 但是此时会使得 left 变成 -1, 因此, 需要再left++, 或者讲left--写在 while 里面</span></span><br><span class="line">        <span class="keyword">while</span> (left--) &#123;</span><br><span class="line">            s += <span class="string">'('</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">        <span class="keyword">while</span> (right--) &#123;</span><br><span class="line">            s += <span class="string">')'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">        res.push_back(s);</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.back() == <span class="string">')'</span>) &#123;</span><br><span class="line">                s.pop_back();</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left+<span class="number">1</span> &lt; right) &#123;</span><br><span class="line">                left++; right--;</span><br><span class="line">                s.back() = <span class="string">')'</span>;</span><br><span class="line">                <span class="keyword">while</span> (left--) s.push_back(<span class="string">'('</span>);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">while</span> (right--) s.push_back(<span class="string">')'</span>);</span><br><span class="line">                right++;</span><br><span class="line">                res.push_back(s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.pop_back();</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="029-Divide-Two-Integers"><a href="#029-Divide-Two-Integers" class="headerlink" title="029. Divide Two Integers"></a>029. Divide Two Integers</h1><h2 id="Description-实现除法"><a href="#Description-实现除法" class="headerlink" title="Description: 实现除法"></a>Description: 实现除法</h2><p>Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.<br>Return the quotient after dividing dividend by divisor.<br>The integer division should truncate toward zero.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: dividend = 10, divisor = 3</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: dividend = 7, divisor = -3</span><br><span class="line">Output: -2</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>Both dividend and divisor will be 32-bit signed integers.<br>The divisor will never be 0.<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: $[−2^{31},  2^{31 − 1}]$. For the purpose of this problem, assume that your function returns 2^{31 − 1} when the division result overflows.</p>
<h2 id="解法一-循环加法"><a href="#解法一-循环加法" class="headerlink" title="解法一: 循环加法"></a>解法一: 循环加法</h2><p><strong>时间复杂度:</strong> $O(dividend)$</p>
<p>这种方法很容易时间超限: 当被除数很大(INT_MAX), 除数很小(1), 则需要循环INT_MAX次才能完成计算.</p>
<h2 id="解法二-左移法"><a href="#解法二-左移法" class="headerlink" title="解法二: 左移法"></a>解法二: 左移法</h2><p><strong>时间复杂度:</strong> $O(log(dividend))$, dividend 为被除数的大小.</p>
<p>对除数进行左移, 相当于每次乘以2, 直到左移后大于被除数, 用被除数减去左移后的数字, 记录左移对应除数的倍数, 然后再次将从除数开始左移, 直到被除数小于除数.</p>
<p>以上是除法的基本实现思路, 但是在具体实现时, 还需要特别考虑下面的情况</p>
<ul>
<li>当被除数为 INT_MIN, 除数为 -1 时, 此时的返回值为 INT_MAX+1. (根据题目要求, 溢出时刻直接返回 INT_MAX)</li>
<li>当除数为 0 时, 也应该看做是溢出情况.</li>
<li>处理上面情况最方便的方法使用 <code>long</code> 长整型, 而不是 <code>unsigned int</code> 无符号类型. 因为 <code>unsigned int</code> 类型在进行乘以 2 的操作时, 很容易也溢出, 最终造成程序的死循环, 为了防止溢出, 最好使用 <code>long</code>, 具体请看代码.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(divisor==<span class="number">0</span> || (dividend==INT_MIN&amp;&amp;divisor==<span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign = ((dividend&lt;<span class="number">0</span>) ^ (divisor&lt;<span class="number">0</span>)) ? <span class="number">-1</span>:<span class="number">1</span>;<span class="comment">// 用异或来获取符号</span></span><br><span class="line">        <span class="keyword">long</span> did = <span class="built_in">labs</span>(dividend); <span class="comment">// long与int在有些环境中字节中一样, 此时最好用long long</span></span><br><span class="line">        <span class="keyword">long</span> dis = <span class="built_in">labs</span>(divisor);</span><br><span class="line">        <span class="keyword">while</span>(did &gt;= dis)&#123;</span><br><span class="line">            <span class="keyword">long</span> temp = dis, multiple = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>( did &gt;= temp&lt;&lt;<span class="number">1</span> )&#123;</span><br><span class="line">                temp = temp&lt;&lt;<span class="number">1</span>;</span><br><span class="line">                multiple = multiple&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            did -= temp;</span><br><span class="line">            res+= multiple;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res*sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="扩展-这道题如果不允许使用-long-或者long-long-怎么解"><a href="#扩展-这道题如果不允许使用-long-或者long-long-怎么解" class="headerlink" title="扩展: 这道题如果不允许使用 long 或者long long 怎么解?"></a>扩展: 这道题如果不允许使用 long 或者long long 怎么解?</h2><h1 id="031-Next-Permutation"><a href="#031-Next-Permutation" class="headerlink" title="031. Next Permutation"></a>031. Next Permutation</h1><h2 id="Description-实现-next-permutation-函数逻辑"><a href="#Description-实现-next-permutation-函数逻辑" class="headerlink" title="Description: 实现 next_permutation 函数逻辑"></a>Description: 实现 next_permutation 函数逻辑</h2><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.<br>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).<br>The replacement must be in-place and use only constant extra memory.<br>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-next-permutation-实现"><a href="#解法一-next-permutation-实现" class="headerlink" title="解法一: next_permutation 实现"></a>解法一: next_permutation 实现</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>STL中的 <code>next_permutation</code> 函数和  <code>prev_permutation</code> 两个函数提供了对于一个特定排列P, 求出其后一个排列P+1和前一个排列P-1的功能.</p>
<p><code>next_permutation</code> 的实现方法如下:</p>
<ul>
<li>先 <strong>从后往前</strong> 找第一个小于后一个数的元素 <code>nums[i]</code>: <code>nums[i]&lt;nums[i+1]</code></li>
<li>再 <strong>从后往前</strong> 找第一个大于 <code>nums[i]</code> 的数 <code>nums[j]</code>: <code>nums[j]&gt;nums[i]</code></li>
<li>交换 <code>nums[i]</code> 和 <code>nums[j]</code></li>
<li>将 <code>i</code> 之后的元素逆置(<code>reverse</code>)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = n<span class="number">-2</span>, j = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;=nums[i+<span class="number">1</span>]) i--;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;=nums[j]) j--;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums.begin()+i+<span class="number">1</span>, nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="033-Search-in-Rotated-Sorted-Array"><a href="#033-Search-in-Rotated-Sorted-Array" class="headerlink" title="033. Search in Rotated Sorted Array"></a>033. Search in Rotated Sorted Array</h1><h2 id="Description-在循环有序数组中查找元素"><a href="#Description-在循环有序数组中查找元素" class="headerlink" title="Description: 在循环有序数组中查找元素"></a>Description: 在循环有序数组中查找元素</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Your algorithm’s runtime complexity must be in the order of $O(log n)$.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-二分查找"><a href="#解法一-二分查找" class="headerlink" title="解法一: 二分查找"></a>解法一: 二分查找</h2><p><strong>时间复杂度:</strong> $O(logn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>对于数组[4,5,6,7,0,1,2], 可以将其看成是两段: [4,5,6,7] 和 [0,1,2], 可以看出, 前一段中的任意一个数字都大于后一段中的数字, 于是, 令low=0, high=size()-1, 进行二分查找, 其中 mid 对应的数字要么落在前半段(<code>nums[low] &lt;= nums[mid]</code>), 要么落在后半段.</p>
<p>如果落在的前半段, 则看 target 的值是否在 low与mid之间. 是则 <code>high = mid-1</code>, 否则 <code>low = mid+1</code></p>
<p>反之, 如果落在后半段, 则看 <code>target</code> 的值是否在 <code>mid</code> 与 <code>high</code> 之间, 是则 <code>low=mid+1</code> , 否则<code>high = mid-1</code></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int low = <span class="number">0</span>;</span><br><span class="line">        int high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        //数组前半段的数字永远大于后半段的数字</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123; //当low==high时, mid=low=high, 如果不等于target, 则之后会退出循环</span><br><span class="line">            int mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == nums[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[low] &lt;= nums[mid])&#123; //说明当前mid落在数组的前半段(), 这里等于号必须带, 否则会漏解</span><br><span class="line">                //判断target是否在low与mid之间, 这里low需要带等于号,</span><br><span class="line">                //因为target有可能=nums[low], mid无需带等于号</span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[low] &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    high = mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    low = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; // 只有当nums[low]完全小于nums[mid]时, mid才落在后半段</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[high])</span><br><span class="line">                    low = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    high = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-二分查找"><a href="#解法二-二分查找" class="headerlink" title="解法二: 二分查找"></a>解法二: 二分查找</h2><p><strong>时间复杂度:</strong> $O(logn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>该方法同样是二分查找, 只不过与上面有一点不同, 对于数组<code>nums</code>=[4,5,6,7,0,1,2]来说, 如果 <code>target &lt; nums[0]</code>, 说明 <code>target</code> 位于数组的后半段, 那么可以将数组看做是<code>nums</code>=[INT_MIN,INT_MIN,INT_MIN,INT_MIN,0,1,2] , 这样一来, 就变成了最常规的有序数组, 反之, 如果 <code>target</code> 位于数组的前半段, 那么可以将数组看做是<code>nums</code>=[4,5,6,7,INT_MAX,INT_MAX,INT_MAX].</p>
<p>注意, 这里并不会改变数组内部的值, 我们只是利用一个临时变量<code>num</code>来代替当前的nums[mid]的值, 然后利用 <code>num</code> 与 <code>target</code> 比较进行二分查找.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int low = <span class="number">0</span>;</span><br><span class="line">        int high = nums.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            int mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            int num;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[<span class="number">0</span>])&#123; //target在后半段, 所以将前半段都看做INT_MIN</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="number">0</span>])  num = nums[mid]; // nums[mid]在后半段</span><br><span class="line">                <span class="keyword">else</span> num = INT_MIN; // nums[mid]在前半段,</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; //target在前半段, 所以将后半段都看作是INT_MAX</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="number">0</span>]) num = INT_MAX;  // nums[mid]在后半段</span><br><span class="line">                <span class="keyword">else</span> num = nums[mid]; // nums[mid]在前半段</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; num) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>更精简的写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>, high=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> num;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;nums[<span class="number">0</span>])</span><br><span class="line">                num = nums[mid]&lt;nums[<span class="number">0</span>] ? nums[mid] : INT_MIN;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num = nums[mid]&lt;nums[<span class="number">0</span>] ? INT_MAX : nums[mid];</span><br><span class="line">            <span class="keyword">if</span>(target &gt; num) low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; num) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="034-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#034-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="034. Find First and Last Position of Element in Sorted Array"></a>034. Find First and Last Position of Element in Sorted Array</h1><h2 id="Description-在有序数组中查找目标的开始位置和结束位置"><a href="#Description-在有序数组中查找目标的开始位置和结束位置" class="headerlink" title="Description: 在有序数组中查找目标的开始位置和结束位置"></a>Description: 在有序数组中查找目标的开始位置和结束位置</h2><p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>If the target is not found in the array, return [-1, -1].</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-二分查找-1"><a href="#解法一-二分查找-1" class="headerlink" title="解法一: 二分查找"></a>解法一: 二分查找</h2><p>时间复杂度: $O(logn)$<br>空间复杂度: $O(1)$</p>
<p>先用常规的二分查找找到target, 然后分别用二分查找找到最左边的target和最右边的target下标.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int low = <span class="number">0</span>;</span><br><span class="line">        int high = nums.size() - <span class="number">1</span>;</span><br><span class="line">        vector&lt;int&gt; res&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        int mid=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123; //正常的二分查找, 先找到target</span><br><span class="line">            mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid==<span class="number">-1</span> || nums[mid] != target) <span class="keyword">return</span> res; // 数组为空或者数组内没有target</span><br><span class="line">        //以mid为中心, 分别查找下标最小的target和下标最大的target</span><br><span class="line">        int llow=low, lhigh=mid; // 左边的二分查找low,high初始化</span><br><span class="line">        int rlow=mid, rhigh=high; // 右边的二分查找low,high初始化</span><br><span class="line">        <span class="keyword">while</span>(llow&lt;=lhigh)&#123;</span><br><span class="line">            int mid = (llow+lhigh)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mid==llow || nums[mid<span class="number">-1</span>] != target)&#123; //关键: 只有当等于target并且左边没有元素或者左边元素不等于target时, 当前mid才是最左边的target</span><br><span class="line">                    res[<span class="number">0</span>] = mid; <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    lhigh = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                llow = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lhigh = mid<span class="number">-1</span>;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(rlow&lt;=rhigh)&#123;</span><br><span class="line">            int mid = (rlow+rhigh)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mid==rhigh || nums[mid+<span class="number">1</span>] != target)&#123; //同理, 找最右边的target</span><br><span class="line">                    res[<span class="number">1</span>] = mid; <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    rlow = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                rlow = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rhigh = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-二分查找-1"><a href="#解法二-二分查找-1" class="headerlink" title="解法二: 二分查找"></a>解法二: 二分查找</h2><p>同样是二分查找, 更加精炼, 先找到最左边的target, 然后以最左边为low, 开始找最右边的target, 需要注意的是不能在<code>nums[mid] == target</code>时就退出循环.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int low = <span class="number">0</span>;</span><br><span class="line">        int high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        vector&lt;int&gt; res&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123; //找起始位置, 注意这里不能是 &lt;=, 而必须是=, 否则会死循环</span><br><span class="line">            int mid = (low+high)/<span class="number">2</span>; //偏向左边, 很重要, 否则会死循环</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid; //注意, 这里不是mid<span class="number">-1</span>, 因为现在是在找最左边的target, 故不能在=target时退出, 因此也不能直接令high=mid<span class="number">-1</span>, 否则会丢失mid=target的情况</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span> || nums[low] != target) <span class="keyword">return</span> res;</span><br><span class="line">        res[<span class="number">0</span>]=low;</span><br><span class="line"></span><br><span class="line">        high = nums.size()<span class="number">-1</span>;// low 已经指向起始位置, 这里只需重置high</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123; // 找终止位置</span><br><span class="line">            int mid = (low+high+<span class="number">1</span>)/<span class="number">2</span>; //使mid偏向右边, 这很重要</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">1</span>]=high;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-STL-函数"><a href="#解法三-STL-函数" class="headerlink" title="解法三: STL 函数"></a>解法三: STL 函数</h2><p><strong>时间复杂度:</strong> $O(logn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>直接利用 STL 的 <code>lower_bound()</code> 和 <code>upper_bound()</code> 函数分别找到其实位置和终止位置即可, 在使用这两个函数时, 需要注意以下几点:</p>
<ul>
<li><code>lower_bound()</code> 函数返回首个 <strong>不小于</strong> target 的迭代器, 如果数组中所有元素 <strong>都小于</strong> target, 则会返回超尾迭代器.</li>
<li><code>upper_bound()</code> 函数返回首个 <strong>大于</strong> target 的迭代器, 如果数组中所有元素 <strong>都小于等于</strong> target, 则会返回超尾迭代器.</li>
<li>注意 <code>upper_bound()</code> 返回的迭代器是首个 <strong>大于</strong> 目标值的迭代器, 因此需要将其减一才是我们要找的 target 的终止位置.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> lower = <span class="built_in">std</span>::lower_bound(nums.begin(), nums.end(), target);</span><br><span class="line">        <span class="keyword">if</span>(lower==nums.end() || *lower != target) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> upper = <span class="built_in">std</span>::upper_bound(nums.begin(), nums.end(), target);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;lower-nums.begin(), upper-nums.begin()<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="036-Valid-Sudoku"><a href="#036-Valid-Sudoku" class="headerlink" title="036. Valid Sudoku"></a>036. Valid Sudoku</h1><h2 id="Description-验证一个矩阵是否是数独数据"><a href="#Description-验证一个矩阵是否是数独数据" class="headerlink" title="Description: 验证一个矩阵是否是数独数据"></a>Description: 验证一个矩阵是否是数独数据</h2><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</p>
<p>Each row must contain the digits 1-9 without repetition.<br>Each column must contain the digits 1-9 without repetition.<br>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</p>
<h2 id="解法一-利用flag数组存储判断矩阵"><a href="#解法一-利用flag数组存储判断矩阵" class="headerlink" title="解法一: 利用flag数组存储判断矩阵"></a>解法一: 利用flag数组存储判断矩阵</h2><p><strong>时间复杂度:</strong> $O(9^2)$<br><strong>空间复杂度:</strong> $O(3\times 9^2)$  虽然要申请三个二维数组, 但都是常数级.</p>
<p>用三个 9×9 大小的矩阵, 分别储存每一行上, 每一列上, 每一个子块上1-9数字是否出现.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        // 下面三个矩阵分别存储了 行上<span class="number">1</span><span class="number">-9</span>是否出现, 列上<span class="number">1</span><span class="number">-9</span>是否出现, sub-box上<span class="number">1</span><span class="number">-9</span>是否出现的bool值</span><br><span class="line">        // 如果row_flag[<span class="number">1</span>][<span class="number">3</span>] 为真, 则说明第<span class="number">1</span>行(从第<span class="number">0</span>行算起)上已经具有数字<span class="number">4</span>(数字比下标大<span class="number">1</span>)了</span><br><span class="line">        bool row_flag[<span class="number">9</span>][<span class="number">9</span>] &#123;<span class="number">0</span>&#125;, col_flag[<span class="number">9</span>][<span class="number">9</span>] &#123;<span class="number">0</span>&#125;, sub_flag[<span class="number">9</span>][<span class="number">9</span>] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span> ; i&lt;board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j&lt;board[i].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>) <span class="keyword">continue</span>; // 如果为 <span class="string">'.'</span> 则可以直接跳过此次判断</span><br><span class="line">                int num = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>; //这里<span class="number">-1</span>主要是为了能够直接将num作为下标使用</span><br><span class="line">                int k = i/<span class="number">3</span>*<span class="number">3</span> + j/<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span>(row_flag[i][num] || col_flag[j][num] || sub_flag[k][num])</span><br><span class="line">                    <span class="keyword">return</span> false;</span><br><span class="line">                row_flag[i][num]=col_flag[j][num]=sub_flag[k][num]=true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-位操作"><a href="#解法二-位操作" class="headerlink" title="解法二: 位操作"></a>解法二: 位操作</h2><p><strong>时间复杂度:</strong> $O(n^2)=O(9^2)$<br><strong>空间复杂度:</strong> $O(3\times 9)$</p>
<p>这是目前看到的最好的方法, 核心思想就是用一个  <code>short</code> 类型变量的某一位来作为 flag, 这样, 我们可以进一步节省空间的使用, 将空间复杂度从 $O(n^2)$ 降低到 $O(n)$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; row(<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; col(<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">short</span>&gt; block(<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> idx = <span class="number">1</span> &lt;&lt; (board[i][j]-<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span>(row[i]&amp;idx || col[j]&amp;idx || block[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>]&amp;idx)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                row[i] |= idx;<span class="comment">//将对应位置为1, 标记已经出现过</span></span><br><span class="line">                col[j] |= idx;</span><br><span class="line">                block[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>] |= idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><span id="Permutations"></span></p>
<h1 id="046-Permutations"><a href="#046-Permutations" class="headerlink" title="046. Permutations"></a>046. Permutations</h1><p>全排列, 注意是distict的数字, 故而不需要进行重复检查</p>
<h2 id="Description-不含重复数字的全排列"><a href="#Description-不含重复数字的全排列" class="headerlink" title="Description: 不含重复数字的全排列"></a>Description: 不含重复数字的全排列</h2><p>Given a collection of distinct integers, return all possible permutations.</p>
<p>Example:</p>
<p>Input: [1,2,3]<br>Output:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>
<h2 id="解法一-递归-1"><a href="#解法一-递归-1" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(A^n_n)$ , 每一种情况都是 $O(1)$ , 共有 $O(A^n_n)$ 种情况. (对吗?)</p>
<p>用一个变量pos指向nums的第一个位置, 然后将pos与后面所有位置上的数字交换(包括自己), 最终会得到n种可能性, 这n种可能性就是出现在第一位置上的所有可能字符的情况集合, 然后将第一位固定, 并将pos指向下一位, 此时问题转换成了n-1个字符的全排列, 按照这种想法一致递归下去, 就可以找到所有位置上的所有组合情况(用pos==nums.size()判断)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        permute_helper(res, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permute_helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;res, <span class="keyword">int</span> pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == nums.size())</span><br><span class="line">            res.push_back(nums);  <span class="comment">// 当pos走到最后时, 说明一种情况诞生, 将其添加到res中</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i&lt;nums.size(); i++)&#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[pos], nums[i]);</span><br><span class="line">                permute_helper(res, pos+<span class="number">1</span>, nums);</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[pos], nums[i]); <span class="comment">// 能够去掉这句话的前提是对res内的字符串进行重复检查, 具体可看牛客分析</span></span><br><span class="line">                <span class="comment">//在面对含有重复字符的情况时, 最好加上这句话</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代"><a href="#解法二-迭代" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p><strong>时间复杂度:</strong> $O(n^3)$<br><strong>空间复杂度:</strong> $O(A_n^n)$ 全排列的size</p>
<p>对于n个数的全排列问题, 可以想象成已经获得了n-1个数的全排列, 然后将第n个数插入到n-1个数的n个空位上( 如将3插入到12的空位上分别为: 312,132,123).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num.size(); i++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; tmp_res(<span class="built_in">std</span>::move(res)); <span class="comment">// move之后, res内部会自动被清空, 而且move的效率较高</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;tmp_res.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;=tmp_res[<span class="number">0</span>].size(); k++)&#123; <span class="comment">// 注意这里是&lt;=, 因为还要往尾部插</span></span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(tmp_res[j]);</span><br><span class="line">                    tmp.insert(tmp.begin()+k, num[i]);</span><br><span class="line">                    res.push_back(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-利用C-的内置函数-next-permutation"><a href="#解法三-利用C-的内置函数-next-permutation" class="headerlink" title="解法三: 利用C++的内置函数 next_permutation"></a>解法三: 利用C++的内置函数 next_permutation</h2><p>关于 <code>next_permutation()</code> 的详细解析请看<a href="../面试-算法刷题-算法题集合/#permutation">这里</a></p>
<p>STL中的 <code>next_permutation</code> 函数和  <code>prev_permutation</code> 两个函数提供了对于一个特定排列P, 求出其后一个排列P+1和前一个排列P-1的功能.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(next_permutation(nums.begin(), nums.end()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这道题利用 <code>prev_permutation</code> 也可以解决, 但是这里就多了一步 <code>reverse</code> 的操作, 这里贴出来只是帮助理解 STL 函数的内部实现, 对于 Permutation2 题也是同理:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 倒序排序</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(prev_permutation(nums.begin(), nums.end()));<span class="comment">//使用 prev</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法四-自己实现-next-permutation"><a href="#解法四-自己实现-next-permutation" class="headerlink" title="解法四: 自己实现 next_permutation"></a>解法四: 自己实现 next_permutation</h2><p><strong>用迭代器作为参数:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">nextPermutation</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> i = last - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> j = last - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= first &amp;&amp; *i &gt;= *(i+<span class="number">1</span>)) i--;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= first) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= first &amp;&amp; *i &gt;= *j) j--;</span><br><span class="line">            <span class="built_in">std</span>::iter_swap(i, j);</span><br><span class="line">            <span class="built_in">std</span>::reverse(i+<span class="number">1</span>, last);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i&gt;=first ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125; <span class="keyword">while</span> (nextPermutation(nums.begin(), nums.end()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>用数组作为参数:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = n<span class="number">-2</span>, j = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;=nums[i+<span class="number">1</span>]) i--;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;=nums[j]) j--;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums.begin()+i+<span class="number">1</span>, nums.end());</span><br><span class="line">        <span class="keyword">return</span> i&gt;=<span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(nextPermutation(nums));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>prev_permutation 实现:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">prevPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = n<span class="number">-2</span>, j = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; nums[i]&lt;=nums[i+<span class="number">1</span>]) i--;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; nums[i]&lt;=nums[j]) j--;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums.begin()+i+<span class="number">1</span>, nums.end());</span><br><span class="line">        <span class="keyword">return</span> i&gt;=<span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(prevPermutation(nums));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>next_permutation</code> python 实现:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        i = n - <span class="number">2</span></span><br><span class="line">        j = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i] &gt;= nums[i+<span class="number">1</span>]): i -= <span class="number">1</span> <span class="comment"># 找到i</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">while</span> (j &gt; i <span class="keyword">and</span> nums[i] &gt;= nums[j]): j -= <span class="number">1</span> <span class="comment"># 找到 j</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i] <span class="comment"># 交换, 并将 i 之后的进行逆置</span></span><br><span class="line">        nums[i+<span class="number">1</span>:] = nums[i+<span class="number">1</span>:][::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> i != <span class="number">-1</span> <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        res.append(nums.copy()) <span class="comment"># 注意这里一定要用copy, 否则后续的更改会影响前面的nums的值</span></span><br><span class="line">        <span class="keyword">while</span>(self.nextPermutation(nums)):</span><br><span class="line">            res.append(nums.copy())</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p><code>prev_permutation</code> python 实现<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prevPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        i = n - <span class="number">2</span></span><br><span class="line">        j = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i] &lt;= nums[i+<span class="number">1</span>]): i -= <span class="number">1</span> <span class="comment"># 找到i</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">while</span> (j &gt; i <span class="keyword">and</span> nums[i] &lt;= nums[j]): j -= <span class="number">1</span> <span class="comment"># 找到 j</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i] <span class="comment"># 交换, 并将 i 之后的进行逆置</span></span><br><span class="line">        nums[i+<span class="number">1</span>:] = nums[i+<span class="number">1</span>:][::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> i != <span class="number">-1</span> <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        res = []</span><br><span class="line">        res.append(nums.copy()) <span class="comment"># 注意这里一定要用copy, 否则后续的更改会影响前面的nums的值</span></span><br><span class="line">        <span class="keyword">while</span>(self.prevPermutation(nums)):</span><br><span class="line">            res.append(nums.copy())</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h1 id="047-Permutations-II"><a href="#047-Permutations-II" class="headerlink" title="047. Permutations II"></a>047. Permutations II</h1><h2 id="Description-带有重复元素的全排列"><a href="#Description-带有重复元素的全排列" class="headerlink" title="Description: 带有重复元素的全排列"></a>Description: 带有重复元素的全排列</h2><h2 id="解法一-递归-set"><a href="#解法一-递归-set" class="headerlink" title="解法一: 递归+set"></a>解法一: 递归+set</h2><p><strong>时间复杂度:</strong><br><strong>空间复杂度:</strong></p>
<p><code>set</code> 插入元素的时间复杂度为 $O(logn)$, $n$ 为当前 <code>set</code> 的大小.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res, <span class="keyword">int</span> pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(pos==len)</span><br><span class="line">            res.insert(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=pos; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=pos &amp;&amp; nums[i]==nums[pos]) <span class="keyword">continue</span>;</span><br><span class="line">            swap(nums[pos], nums[i]);</span><br><span class="line">            helper(res, pos+<span class="number">1</span>, nums);</span><br><span class="line">            swap(nums[pos], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">set</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        helper(res, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(res.begin(), res.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-STL-的-next-permutation-函数"><a href="#解法二-STL-的-next-permutation-函数" class="headerlink" title="解法二: STL 的 next_permutation 函数"></a>解法二: STL 的 next_permutation 函数</h2><p>关于 <code>next_permutation()</code> 的详细解析请看<a href="../面试-算法刷题-算法题集合/#permutation">这里</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(next_permutation(nums.begin(), nums.end()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用 <code>prev_permutation()</code> 也可解决, 不过需要记得要倒序排序.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 倒序排序</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(prev_permutation(nums.begin(), nums.end())); <span class="comment">// prev</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法三-自己实现-next-permutation"><a href="#解法三-自己实现-next-permutation" class="headerlink" title="解法三: 自己实现 next_permutation()"></a>解法三: 自己实现 next_permutation()</h2><p>python 实现:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(nums)</span>:</span></span><br><span class="line">            n = len(nums)</span><br><span class="line">            i = n - <span class="number">2</span></span><br><span class="line">            j = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i] &gt;= nums[i+<span class="number">1</span>]): i -=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;=<span class="number">0</span>):</span><br><span class="line">                <span class="keyword">while</span> (j &gt; i <span class="keyword">and</span> nums[i] &gt;= nums[j]): j -=<span class="number">1</span></span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">            nums[i+<span class="number">1</span>:] = nums[i+<span class="number">1</span>:][::<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> i != <span class="number">-1</span> <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        res.append(nums.copy())</span><br><span class="line">        <span class="keyword">while</span> (nextPermutation(nums)):</span><br><span class="line">            res.append(nums.copy())</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p><strong>用迭代器做参数:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">nextPermutation</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> i = last - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> j = last - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= first &amp;&amp; *i &gt;= *(i+<span class="number">1</span>)) i--;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= first) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= first &amp;&amp; *i &gt;= *j) j--;</span><br><span class="line">            <span class="built_in">std</span>::iter_swap(i, j);</span><br><span class="line">            <span class="built_in">std</span>::reverse(i+<span class="number">1</span>, last);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i&gt;=first ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125; <span class="keyword">while</span>(nextPermutation(nums.begin(), nums.end()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>用数组做参数:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = n<span class="number">-2</span>, j = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;=nums[i+<span class="number">1</span>]) i--;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;=nums[j]) j--;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums.begin()+i+<span class="number">1</span>, nums.end());</span><br><span class="line">        <span class="keyword">return</span> i&gt;=<span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(nextPermutation(nums));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="048-Rotate-Image"><a href="#048-Rotate-Image" class="headerlink" title="048. Rotate Image"></a>048. Rotate Image</h1><h2 id="Description-图片旋转-90-度"><a href="#Description-图片旋转-90-度" class="headerlink" title="Description: 图片旋转 90 度"></a>Description: 图片旋转 90 度</h2><p>You are given an n x n 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise).</p>
<p>Note:</p>
<p>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p>
<p>Example 1:</p>
<p>Given input matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p>
<p>rotate the input matrix in-place such that it becomes:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]<br>Example 2:</p>
<p>Given input matrix =<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>],</p>
<p>rotate the input matrix in-place such that it becomes:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p>
<h2 id="解法一-逆置-转置"><a href="#解法一-逆置-转置" class="headerlink" title="解法一: 逆置+转置"></a>解法一: 逆置+转置</h2><p><strong>时间复杂度:</strong> $O(n^2)$, 因为转置的复杂度为 $O(n^2)$</p>
<p>将图像矩阵看做是线性代数中的行列式, 首先将所有的行逆置(行与行交换), 然后对整个矩阵转置.</p>
<p>原理: 利用线性代数行列式的运算法则可证明(数学归纳法)</p>
<p>clockwise rotate<br>first reverse up to down, then swap the symmetry<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3     7 8 9     7 4 1</span><br><span class="line">4 5 6  =&gt; 4 5 6  =&gt; 8 5 2</span><br><span class="line">7 8 9     1 2 3     9 6 3</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::reverse(matrix.begin(), matrix.end()); <span class="comment">//逆置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;matrix[i].size();j++) <span class="comment">// 转置, 注意j=i+1</span></span><br><span class="line">                <span class="built_in">std</span>::swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-转置-列逆置"><a href="#解法二-转置-列逆置" class="headerlink" title="解法二: 转置+列逆置"></a>解法二: 转置+列逆置</h2><p>先求转置, 再对列逆置(列与列交换):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;matrix[i].size();j++)</span><br><span class="line">                <span class="built_in">std</span>::swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;vec_i : matrix) <span class="built_in">std</span>::reverse(vec_i.begin(), vec_i.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="补充-逆时针旋转90度"><a href="#补充-逆时针旋转90度" class="headerlink" title="补充: 逆时针旋转90度"></a>补充: 逆时针旋转90度</h2><p>先使用列逆置(列与列交换), 然后对矩阵使用转置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3     3 2 1     3 6 9</span><br><span class="line">4 5 6  =&gt; 6 5 4  =&gt; 2 5 8</span><br><span class="line">7 8 9     9 8 7     1 4 7</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anti_rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> vi : matrix) reverse(vi.begin(), vi.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; matrix[i].size(); ++j)</span><br><span class="line">            swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="补充-图片旋转-180-度-上下翻转"><a href="#补充-图片旋转-180-度-上下翻转" class="headerlink" title="补充: 图片旋转 180 度(上下翻转)"></a>补充: 图片旋转 180 度(上下翻转)</h2><p>将所有的行逆置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3     7 8 9</span><br><span class="line">4 5 6  =&gt; 4 5 6</span><br><span class="line">7 8 9     1 2 3</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reverse(matrix.begin(), matrix.end())</span><br></pre></td></tr></table></figure>
<h2 id="补充-图片左右翻转"><a href="#补充-图片左右翻转" class="headerlink" title="补充: 图片左右翻转"></a>补充: 图片左右翻转</h2><p>将所有的列逆置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3     3 2 1</span><br><span class="line">4 5 6  =&gt; 6 5 4</span><br><span class="line">7 8 9     9 8 7</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> vi : matrix) reverse(vi.begin(), vi.end());</span><br></pre></td></tr></table></figure>
<h1 id="049-Group-Anagrams"><a href="#049-Group-Anagrams" class="headerlink" title="049. Group Anagrams"></a>049. Group Anagrams</h1><h2 id="Description-找出同字母的异序词-并按字母分组输出"><a href="#Description-找出同字母的异序词-并按字母分组输出" class="headerlink" title="Description: 找出同字母的异序词, 并按字母分组输出"></a>Description: 找出同字母的异序词, 并按字母分组输出</h2><p>Given an array of strings, group anagrams together.</p>
<p>Example:</p>
<p>Input: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Output:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]<br>Note:</p>
<p>All inputs will be in lowercase.<br>The order of your output does not matter.</p>
<h2 id="解法一-哈希表-sort"><a href="#解法一-哈希表-sort" class="headerlink" title="解法一: 哈希表+sort"></a>解法一: 哈希表+sort</h2><p>用哈希表来存, 键为有序的字符序列, 值为string数组, 里面存着各个与有序字符序列包含字符相同的其他序列</p>
<p><strong>时间复杂度:</strong> $O(nmlogm)$ , 其中, n为输入字符串数组的长度, m为每个字符串的长度, 对于n个字符串, 要进行n次哈希表的插入, 同时每次插入时, 需要对字符串进行排序, 排序复杂度为 $O(mlogm)$.</p>
<p><strong>空间复杂度:</strong> $O(mn)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res_map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str: strs)&#123;</span><br><span class="line">            <span class="built_in">string</span> str_value = str;</span><br><span class="line">            <span class="built_in">std</span>::sort(str.begin(), str.end());</span><br><span class="line">            res_map[str].push_back(str_value); <span class="comment">//key 为字母有序string, value为含有这些字母的序列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res_vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str : res_map)</span><br><span class="line">            res_vec.push_back(str.second); <span class="comment">//将map中的所有的string转移到vec返回结果中</span></span><br><span class="line">        <span class="keyword">return</span> res_vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-哈希表-不使用sort"><a href="#解法二-哈希表-不使用sort" class="headerlink" title="解法二: 哈希表(不使用sort)"></a>解法二: 哈希表(不使用sort)</h2><p><strong>时间复杂度:</strong> $O(nm)$ , 其中, n为string个数, m为每个string的字母数.<br><strong>空间复杂度:</strong> $O(nm)$</p>
<p>由于上面的解法二需要使用排序, 故而时间上不够优化, 因此, 这里我们可以设计新的键来代替sort, 基本思想是对26个字母, 分别赋予一个素数值, 然后, 计算键的时候, 将对应字母的素数 <strong>相乘</strong> 即可, 这样一来, 每一种字符串的key都是唯一的( <strong>因为最终的乘积可以唯一的表示成素数相乘的序列</strong> ).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该解法是错误的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> primer[<span class="number">26</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span> ,<span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_sum_id</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : str)&#123;</span><br><span class="line">            sum * = primer[(<span class="keyword">int</span>)(c-<span class="string">'a'</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res_map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str: strs)&#123;</span><br><span class="line">            res_map[get_sum_id(str)].push_back(str); <span class="comment">//key 为字母有序string, value为含有这些字母的序列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res_vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str : res_map)</span><br><span class="line">            res_vec.push_back(str.second); <span class="comment">//将map中的所有的string转移到vec返回结果中</span></span><br><span class="line">        <span class="keyword">return</span> res_vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-另一种生成-key-的解法-不用sort"><a href="#解法三-另一种生成-key-的解法-不用sort" class="headerlink" title="解法三: 另一种生成 key 的解法(不用sort)"></a>解法三: 另一种生成 key 的解法(不用sort)</h2><p>应该将字符count作为键, 所谓字符count就是统计每个字符出现的次数, 然后根据该信息就可以生成唯一的一个字符串, 例如, 对于 “abbb”, 来说, ‘a’ 出现了一次, ‘b’ 出现了三次, 因此, 其字符count就应该为: (1,3,0,…0), 总共有 26 个元素, 为了将其转换成字符串, 需要用一个特殊符号来做分隔符, 因此可以生成如下的字符串: <code>&quot;#1#3#0#0...#0&quot;</code>(这也是通常的内置 hash 的键的实现方法之一).<br>该解法的时间复杂度为 $O(mn)$, 其中, $n$ 为遍历字符串数组的时间, $m$ 为获取 key 的时间, 无需进行排序.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">get_key</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> str_count[<span class="number">26</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : str)</span><br><span class="line">            str_count[c-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="built_in">string</span> str_key;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : str_count)</span><br><span class="line">            str_key += <span class="string">"#"</span> + to_string(i);</span><br><span class="line">        <span class="keyword">return</span> str_key;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res_hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str : strs)&#123;</span><br><span class="line">            <span class="built_in">string</span> s = get_key(str);</span><br><span class="line">            res_hash[s].push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s : res_hash)</span><br><span class="line">            res.push_back(s.second);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="050-Pow-x-n"><a href="#050-Pow-x-n" class="headerlink" title="050. Pow(x, n)"></a>050. Pow(x, n)</h1><p>实现幂乘操作</p>
<h2 id="Descriptin"><a href="#Descriptin" class="headerlink" title="Descriptin"></a>Descriptin</h2><p>Implement pow(x, n), which calculates x raised to the power n (x^n).</p>
<p>Example 1:</p>
<p>Input: 2.00000, 10<br>Output: 1024.00000<br>Example 2:</p>
<p>Input: 2.10000, 3<br>Output: 9.26100<br>Example 3:</p>
<p>Input: 2.00000, -2<br>Output: 0.25000<br>Explanation: 2-2 = 1/22 = 1/4 = 0.25<br>Note:</p>
<p>-100.0 &lt; x &lt; 100.0<br>n is a 32-bit signed integer, within the range $[−2^{31}, 2^{31} − 1]$</p>
<h2 id="解法一-递归-2"><a href="#解法一-递归-2" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(logn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>当n为偶数时: $x^n = x^{n/2} \times x^{n/2}$<br>当n为奇数时: $x^n = x\times x^{n/2} \times x^{n/2}$</p>
<p><strong>这里需要注意一点: abs(INT_MIN) 的值仍然是负值, 因为 <code>int</code> 只有 32 位, abs(INT_MIN) 时, 仍然是 32 位, 因此不会变成正值, 解决方法是先把该值赋给 <code>long</code> 型变量, 然后对 <code>long</code> 型变量调用 <code>abs()</code> 函数, 另一种解决方法是利用 <code>unsigned int</code></strong>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> min = INT_MIN; <span class="comment">// -2147483648</span></span><br><span class="line"><span class="keyword">long</span> min_abs1 = <span class="built_in">abs</span>(min); <span class="comment">// 2147483648, 这里 min_abs1 的值仍然是 INT_MIN, 因为调用 abs 的时候, 仍然是32位</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> min_abs2 = min;</span><br><span class="line">min_abs2 = <span class="built_in">abs</span>(min_abs2); <span class="comment">// 2147483648, 这里是对64位调用 abs, 所以成功转化成正数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法二是利用 unsigned int</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> abs_min = <span class="built_in">abs</span>(min) <span class="comment">//2147483648</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> un = <span class="built_in">abs</span>(n);  <span class="comment">//注意这里必须是 unsigned类型, 就算是long , 也必须带unsigned, 主要是因为abs(INT_MIN)仍为负数INT_MIN!</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">        <span class="keyword">return</span> (un%<span class="number">2</span>==<span class="number">0</span>) ? myPow(x*x, un/<span class="number">2</span>) : x*myPow(x*x, un/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-非递归-1"><a href="#解法二-非递归-1" class="headerlink" title="解法二: 非递归"></a>解法二: 非递归</h2><p><strong>时间复杂度:</strong> $O(logn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>n 要么为偶数, 要么为奇数, 我们每一次都将 n 的值减半, 并且将 x 与自身相乘, 每次当 n 为奇数时, 我们都将 res 与 x 相乘, 最终, res 的值就是我们要求的幂乘. 举例来说,<br>对于 x=2, n=10 , 每次将x和自身相乘, 同时将 n 减半, n 和 x 的值分别为:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n: <span class="number">10</span>, <span class="number">5</span>,  <span class="number">2</span>,   <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">x: <span class="number">2</span>,  <span class="number">4</span>, <span class="number">16</span>, <span class="number">256</span>, <span class="number">65536</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到, 我们将 n 为奇数时的 x 相乘, 就是最终的幂乘: $4\times 256 = 2^{10} = 1024$. 当 n 为奇数时也是同理, 如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n: <span class="number">11</span>, <span class="number">5</span>,  <span class="number">2</span>,   <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">x: <span class="number">2</span>,  <span class="number">4</span>, <span class="number">16</span>, <span class="number">256</span>, <span class="number">65536</span></span><br></pre></td></tr></table></figure>
<p>最终幂乘: $2\times 4\times \times 256 = 2^{11} = 2048$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>) x = <span class="number">1</span>/x;</span><br><span class="line">        <span class="keyword">long</span> ln = n;</span><br><span class="line">        ln = <span class="built_in">abs</span>(ln);</span><br><span class="line">        <span class="keyword">double</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(ln&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ln%<span class="number">2</span>==<span class="number">1</span>) res *= x;</span><br><span class="line">            x = x*x;</span><br><span class="line">            ln = ln/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="054-Spiral-Matrix"><a href="#054-Spiral-Matrix" class="headerlink" title="054. Spiral Matrix"></a>054. Spiral Matrix</h1><p>以顺时针螺旋顺序返回矩阵元素, 顺时针打印矩阵</p>
<h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
<p>Example 1:</p>
<p>Input:<br>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]<br>Output: [1,2,3,6,9,8,7,4,5]<br>Example 2:</p>
<p>Input:<br>[<br>  [1, 2, 3, 4],<br>  [5, 6, 7, 8],<br>  [9,10,11,12]<br>]<br>Output: [1,2,3,4,8,12,11,10,9,5,6,7]</p>
<h2 id="解法-按层次输出-由外而内"><a href="#解法-按层次输出-由外而内" class="headerlink" title="解法: 按层次输出(由外而内)"></a>解法: 按层次输出(由外而内)</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>输出形式如下(按层次编码, 以4×6的矩阵为例), 需要注意边界控制条件:</p>
<script type="math/tex; mode=display">\begin{matrix} 1_{top}&1_{top}&1_{top}&1_{top}&1_{top}&1_{top} \\ 1_{left}&2_{top}&2_{top}&2_{top}&2_{top}&1_{right} \\ 1_{left}&2_{bottom}&2_{bottom}&2_{bottom}&2_{bottom}&1_{right} \\ 1_{bottom}&1_{bottom}&1_{bottom}&1_{bottom}&1_{bottom}&1_{bottom}  \end{matrix}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span> || matrix[<span class="number">0</span>].size() ==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> row_layer = (matrix.size()+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> col_layer = (matrix[<span class="number">0</span>].size()+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> layer = min( row_layer, col_layer); <span class="comment">// 计算总共的层数</span></span><br><span class="line">        <span class="keyword">int</span> cur_layer =<span class="number">0</span>; <span class="comment">// 用于记录当前所处哪一层</span></span><br><span class="line">        <span class="keyword">int</span> len_row = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> len_col = matrix[<span class="number">0</span>].size(); <span class="comment">//分别为行和列的size</span></span><br><span class="line">        <span class="keyword">while</span>(cur_layer &lt; layer)&#123;</span><br><span class="line">            <span class="comment">//top 输出上边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =cur_layer; j&lt;len_col-cur_layer; j++)</span><br><span class="line">                res.push_back(matrix[cur_layer][j]);</span><br><span class="line">            <span class="comment">//right 输出右边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = cur_layer+<span class="number">1</span>; i&lt;len_row<span class="number">-1</span>-cur_layer; i++)</span><br><span class="line">                res.push_back(matrix[i][len_col - <span class="number">1</span> - cur_layer]);</span><br><span class="line">            <span class="comment">//bottom  输出下边, 这里注意为了防止重复输出, 需要确保上边和下边的行数不同,即:</span></span><br><span class="line">            <span class="comment">// cur_layer!=len_row-1-cur_layer</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= len_col - <span class="number">1</span> -cur_layer; cur_layer!=len_row<span class="number">-1</span>-cur_layer &amp;&amp; j &gt;=cur_layer  ;j--)</span><br><span class="line">                res.push_back(matrix[len_row - <span class="number">1</span> -cur_layer][j]);</span><br><span class="line">            <span class="comment">//left 输出左边, 同样, 要确保左边和右边的列数不同, 即: cur_layer!=len_col-1-cur_layer</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = len_row<span class="number">-2</span>-cur_layer; cur_layer!=len_col<span class="number">-1</span>-cur_layer &amp;&amp; i&gt;cur_layer; i--)</span><br><span class="line">                res.push_back(matrix[i][cur_layer]);</span><br><span class="line">            cur_layer++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>另一种写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() <span class="keyword">or</span> matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> rowUp = <span class="number">-1</span>; <span class="comment">// 记录上边界</span></span><br><span class="line">        <span class="keyword">int</span> rowDown = n; <span class="comment">// 下边界</span></span><br><span class="line">        <span class="keyword">int</span> colLeft = <span class="number">-1</span>; <span class="comment">// 左边界</span></span><br><span class="line">        <span class="keyword">int</span> colRight = m; <span class="comment">// 右边界</span></span><br><span class="line">        <span class="keyword">while</span> (rowUp &lt; rowDown <span class="keyword">and</span> colLeft &lt; colRight) &#123;</span><br><span class="line">            rowUp++;</span><br><span class="line">            rowDown--;</span><br><span class="line">            <span class="keyword">if</span> (rowUp &gt; rowDown) <span class="keyword">break</span>; <span class="comment">// 如果越界, 则直接退出</span></span><br><span class="line">            colLeft++;</span><br><span class="line">            colRight--;</span><br><span class="line">            <span class="keyword">if</span> (colLeft &gt; colRight) <span class="keyword">break</span>; <span class="comment">// 越界则退出</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = colLeft; j &lt;= colRight; j++) &#123;</span><br><span class="line">                res.emplace_back(matrix[rowUp][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rowUp+<span class="number">1</span>; i &lt;= rowDown<span class="number">-1</span>; i++) &#123;</span><br><span class="line">                res.emplace_back(matrix[i][colRight]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = colRight; rowUp != rowDown <span class="keyword">and</span> j &gt;= colLeft; j--) &#123;</span><br><span class="line">                res.emplace_back(matrix[rowDown][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rowDown<span class="number">-1</span>; colLeft != colRight <span class="keyword">and</span> i &gt;= rowUp+<span class="number">1</span>; i--) &#123;</span><br><span class="line">                res.emplace_back(matrix[i][colLeft]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="055-Jump-Game"><a href="#055-Jump-Game" class="headerlink" title="055. Jump Game"></a>055. Jump Game</h1><p>数组的数字为最大的跳跃步数, 根据数组判断是否能跳到最后一位上</p>
<h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>Example 1:</p>
<p>Input: [2,3,1,1,4]<br>Output: true<br>Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.<br>Example 2:</p>
<p>Input: [3,2,1,0,4]<br>Output: false<br>Explanation: You will always arrive at index 3 no matter what. Its maximum<br>             jump length is 0, which makes it impossible to reach the last index.</p>
<h2 id="解法一-回溯"><a href="#解法一-回溯" class="headerlink" title="解法一: 回溯"></a>解法一: 回溯</h2><p><strong>时间复杂度:</strong> $O(2^n)$  总共有 $2^n$ 种跳法来跳到最后一个位置上(对于任意一个位置, 有经过和不经过两个种可能性)<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>试遍所有的可能性, 正常来说会超时, 并且也肯定不是最佳答案</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> final_position = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(position == final_position) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> furthest = <span class="built_in">std</span>::min(position+nums[position], final_position);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = position+<span class="number">1</span>; i&lt;=furthest; i++)&#123;</span><br><span class="line">            <span class="comment">//这里有个小小的优化, 就是令i从最大步长开始, i--, 这种优化虽然最坏情况时一样的</span></span><br><span class="line">            <span class="comment">//但在实际使用中, 会比从position+1开始要快一点(但是依然超时)</span></span><br><span class="line">            <span class="keyword">if</span>(helper(nums, i)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-top-down-动态规划-递归"><a href="#解法二-top-down-动态规划-递归" class="headerlink" title="解法二: top-down 动态规划(递归)"></a>解法二: top-down 动态规划(递归)</h2><p><strong>时间复杂度:</strong> $O(n^2)$ , 对于每个点来说, 都是要找到下一个<code>good_position</code>, 则需要进行 $(O)$ 的查找, 又因为总共有 $O(n)$个元素, 所以复杂度为 $O(n^2)$.<br><strong>空间复杂度:</strong> $O(2n)$, 递归需要 $O(n)$ , <code>memo</code>需要 $O(n)$.</p>
<p>设计一个数组, 用来记录当前下标对应位置是否可又达到终点, 如果能, 则该位置为<code>good position</code>, 如果不能, 则为<code>bad position</code>, 刚开始的时候都是<code>unknown position</code>(除了最后一个位置为<code>good</code>).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span>&#123;</span>GOOD, BAD, UNKNOWN&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Status&gt; memo;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-1</span>; i++)</span><br><span class="line">            memo.push_back(Status::UNKNOWN);</span><br><span class="line">        memo.push_back(Status::GOOD);</span><br><span class="line">        <span class="keyword">return</span> helper(nums, memo, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="built_in">vector</span>&lt;Status&gt; &amp;memo, <span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> final_position = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo[position] != Status::UNKNOWN) <span class="keyword">return</span> memo[position]==Status::GOOD ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> furthest = <span class="built_in">std</span>::min(position+nums[position], final_position);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = furthest; i&gt;position; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(helper(nums, memo, i))&#123;</span><br><span class="line">                memo[position] = Status::GOOD; <span class="comment">//注意是position, 不是i</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[position] = Status::BAD;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-down-top-动态规划-非递归"><a href="#解法三-down-top-动态规划-非递归" class="headerlink" title="解法三: down-top 动态规划(非递归)"></a>解法三: down-top 动态规划(非递归)</h2><p><strong>时间复杂度:</strong> $O(n^2)$ , 对于每个点来说, 都是要找到下一个<code>good_position</code>, 则需要进行 $(O)$ 的查找, 又因为总共有 $O(n)$个元素, 所以复杂度为 $O(n^2)$.<br><strong>空间复杂度:</strong> $O(n)$, 无需递归 , 只需要<code>memo</code>, $O(n)$.</p>
<p>动态规划的非递归版本.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span>&#123;</span>GOOD, BAD, UNKNOWN&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if(nums.size() ==0) return false;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;Status&gt; memo;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-1</span>; i++)</span><br><span class="line">            memo.push_back(Status::UNKNOWN);</span><br><span class="line">        memo.push_back(Status::GOOD);</span><br><span class="line">        <span class="keyword">int</span> final_position = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.size()<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> furthest = <span class="built_in">std</span>::min(i+nums[i], final_position);</span><br><span class="line">            <span class="comment">//for(int j = i+1; j&lt;=furthest; j++)&#123;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = furthest; j&gt;i;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(memo[j] == Status::GOOD)&#123; <span class="comment">// 只要有一个GOOD, 当前i位置就为GOOD, 而无需考虑BAD的情况</span></span><br><span class="line">                    memo[i] = memo[j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[<span class="number">0</span>] == Status::GOOD ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-贪心"><a href="#解法四-贪心" class="headerlink" title="解法四: 贪心"></a>解法四: 贪心</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>由上面的down-top递归可以看出, 当前下标位置的点是否为good点, 实际上只取决于当前点是否能够达到右边坐标中(从右往左走)最左边的good(可以看上面的break语句), 如果能够达到, 则当前点一定为good点, 因此, 我们只需要用一个变量<code>left_most_good</code>来维护当前点右边的最左good点下标即可, 无需任何其他空间和操作.(速度极快)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left_most_good = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size()<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+nums[i] &gt;= left_most_good)&#123;</span><br><span class="line">                left_most_good = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left_most_good==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>另一种贪心的形式:</strong> 记录当前能够达到的最大位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> reach=<span class="number">0</span>; i&lt;nums.size() &amp;&amp; i&lt;=reach; i++ )</span><br><span class="line">            reach = max(i+nums[i], reach);</span><br><span class="line">        <span class="keyword">return</span> i==nums.size(); <span class="comment">// 或者用 reach &gt;= nums.size()-1 判断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="056-Merge-Intervals"><a href="#056-Merge-Intervals" class="headerlink" title="056. Merge Intervals"></a>056. Merge Intervals</h1><p>融合区间</p>
<h2 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h2><p>Given a collection of intervals, merge all overlapping intervals.</p>
<p>Example 1:</p>
<p>Input: [[1,3],[2,6],[8,10],[15,18]]<br>Output: [[1,6],[8,10],[15,18]]<br>Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].<br>Example 2:</p>
<p>Input: [[1,4],[4,5]]<br>Output: [[1,5]]<br>Explanation: Intervals [1,4] and [4,5] are considerred overlapping.</p>
<h2 id="解法一-sort-O-n"><a href="#解法一-sort-O-n" class="headerlink" title="解法一: sort+O(n)"></a>解法一: sort+O(n)</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 主要是排序<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>最简单的实现方法, 先按照interval.start用sort排序, 排好序以后, 能够融合的interval都会聚到一起, 这个时候, 因为start是呈递增的, 只需要看end的大小关系就可以.</p>
<p>最简单的实现方法就是sort之后, 通过额外申请空间来存储融合后的interval, 最后返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;Interval&gt;&#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; res;</span><br><span class="line">        <span class="built_in">std</span>::sort(intervals.begin(), intervals.end(), [](Interval a, Interval b)&#123;<span class="keyword">return</span> a.start &lt; b.start;&#125;);</span><br><span class="line">        res.push_back(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iv : intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.back().end &lt; iv.start) res.push_back(iv);</span><br><span class="line">            <span class="keyword">else</span> res.back().end = <span class="built_in">std</span>::max(res.back().end, iv.end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-sort-O-1"><a href="#解法二-sort-O-1" class="headerlink" title="解法二: sort+O(1)"></a>解法二: sort+O(1)</h2><p><strong>时间复杂度:</strong> $O(nlogn)$ , 主要是排序<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>上面的方法在逻辑上不够好, 因为既然已经申请了额外的内存来存储放回结果, 说明我们不希望改变原vector内部的数据, 但是sort之后, 数据顺序已经被破坏了, 既然已经破坏了, 那最好就是直接使用原地融合的办法, 来减少内存的开销<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;Interval&gt;&#123;&#125;;</span><br><span class="line">        <span class="comment">//vector&lt;Interval&gt; res; 既然决定使用sort, 就说明已经改变了intervals, 此时不应该在额外申请空间, 而应该进行原地融合.</span></span><br><span class="line">        <span class="built_in">std</span>::sort(intervals.begin(), intervals.end(), [](Interval a, Interval b)&#123;<span class="keyword">return</span> a.start &lt; b.start;&#125;);</span><br><span class="line">        <span class="keyword">auto</span> cur_iv = intervals.begin();</span><br><span class="line">        <span class="keyword">auto</span> next_iv = intervals.begin()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; next_iv!=intervals.end(); next_iv++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (*cur_iv).end &lt; (*next_iv).start )&#123;</span><br><span class="line">                cur_iv++;</span><br><span class="line">                (*cur_iv) = (*next_iv);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                (*cur_iv).end = <span class="built_in">std</span>::max( (*cur_iv).end, (*next_iv).end );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        intervals.erase(cur_iv+<span class="number">1</span>, intervals.end());</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法三-不使用sort"><a href="#解法三-不使用sort" class="headerlink" title="解法三: 不使用sort"></a>解法三: 不使用sort</h2><p>有时, 我们要求不能改变原向量intervals的内容, 此时, 就不能使用sort (除非牺牲大量空间留副本,但单肯定不推荐).</p>
<p>//TODO, 未细看, 但时间复杂度应该会高于 O(nlogn)<br><a href="https://leetcode.com/problems/merge-intervals/discuss/153979/Elegant-c++-solutions.-One-without-modifying-intervals-and-one-inplace" target="_blank" rel="noopener">https://leetcode.com/problems/merge-intervals/discuss/153979/Elegant-c++-solutions.-One-without-modifying-intervals-and-one-inplace</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Without modifying intervals</span><br><span class="line">Since we can't sort interval, we want to instead ensure our destination <span class="built_in">vector</span> is sorted. A insertion sort is required then. Insertion should be done as follows;</span><br><span class="line"></span><br><span class="line">Find first destination interval that ends after the incoming interval starts. Called it</span><br><span class="line">If no such interval is found <span class="keyword">or</span> the incoming interval end is less than found intervals start then we can just insert <span class="keyword">and</span> be done.</span><br><span class="line">Otherwise there must be an overlap, but it could be more than one. Do another search, <span class="keyword">this</span> time <span class="keyword">for</span> the first interval whose start is greater than incoming interval end. Called last</span><br><span class="line">Everything from [it, last) can be merged together with incoming interval into a single interval</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Interval&gt; ret;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; interval : intervals) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">std</span>::lower_bound(ret.begin(), ret.end(), interval.start, [](<span class="keyword">const</span> Interval&amp; l, <span class="keyword">int</span> r) &#123; <span class="keyword">return</span> l.end &lt; r; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (it == ret.end() || interval.end &lt; it-&gt;start)</span><br><span class="line">          <span class="comment">// No overlap, insert as is</span></span><br><span class="line">          ret.insert(it, interval);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// There is an overlap, there might be more, so find the upper bound too</span></span><br><span class="line">          it-&gt;start = <span class="built_in">std</span>::min(it-&gt;start, interval.start);</span><br><span class="line">          <span class="keyword">auto</span> last = <span class="built_in">std</span>::upper_bound(it, ret.end(), interval.end, [](<span class="keyword">int</span> l, <span class="keyword">const</span> Interval&amp; r) &#123; <span class="keyword">return</span> l &lt; r.start; &#125;);</span><br><span class="line">          it-&gt;end = <span class="built_in">std</span>::max((last - <span class="number">1</span>)-&gt;end, interval.end);</span><br><span class="line">          ret.erase(it + <span class="number">1</span>, last);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="062-Unique-Paths"><a href="#062-Unique-Paths" class="headerlink" title="062. Unique Paths"></a>062. Unique Paths</h1><h2 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h2><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<h2 id="解法一-DP"><a href="#解法一-DP" class="headerlink" title="解法一: DP"></a>解法一: DP</h2><p><strong>时间复杂度:</strong> $O(mn)$<br><strong>空间复杂度:</strong> $O(mn)$</p>
<p>这是一道经典的DP问题, 当机器人处于某一点时, 它只能从上面或者左边到达该点, 因此很容易得出<code>path[i][j] = path[i-1][j] + path[i][j-1];</code>, 其中 <code>path[i][j]</code>指到达 $(i,j)$ 点的可能路径数量.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; path(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ;i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span> ; j&lt;n; j++)&#123;</span><br><span class="line">                path[i][j] = path[i<span class="number">-1</span>][j] + path[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-优化的DP"><a href="#解法二-优化的DP" class="headerlink" title="解法二: 优化的DP"></a>解法二: 优化的DP</h2><p><strong>时间复杂度:</strong> $O(mn)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>通过分析知道, 当前点的可能路径数量只与上面点和左边点的值有关, 在上面的方法中, 我们用一个 $m\times n$ 的数组来存储当前点上面和左边的值, 实际上, 我们只需要用一行数组就可以完成这个功能, 首先, 求出第一行的所有点的值, 这里只会用每个点左边的值,  然后, 对于第二行的第一个点来说, 它只会用到上面的值, 也就是第一行的第一个值, 因此可以通过行数组直接得到, 然后, 对于第二行的第二个值, 它可以从第二行的第一个值, 以及第二行的第二个值得到, 这些值都是已知的, 所以可以直接求的, 由于在求得以后, 我们就再也不需要第一行的第二个值了, 所以我们可以用这个存储空间来存储第二行的第二个值, 如此递归执行, 我们只需要 $O(n)$ 的空间即可.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path(n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                path[j] = path[j] + path[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-排列组合-最优"><a href="#解法三-排列组合-最优" class="headerlink" title="解法三: 排列组合(最优)"></a>解法三: 排列组合(最优)</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>实际上, 仔细分析该问题, 可以把该问题看成是一个典型的排列组合问题. 首先, 将机器人向右走记为 1, 将机器人向下走记为 0. 题目问有多少种不同的走法, 实际上就是在问1/0序列的不同排列有多少种, 并且, 1/0 的长度必须为 $(m -1 + n - 1)$. 因此, 这个问题可以看做是从 $(m-1+n-1)$ 个空槽位上选择 $(m-1)$ 个槽位, 将其置为1, 并将剩余的 $n-1$ 个槽位置为0, 故而就是组合问题: $C_{m-1+n-1}^{m-1}$ . 又因为 $C_{m-1+n-1}^{m-1} = C_{m-1+n-1}^{n-1}$ , 所以为了防止溢出, 我们可以选择小的进行计算</p>
<p><strong>注意, 在排列如何时, 因为涉及到出发, 所以一定要注意计算法则的先后顺序, 具体请看代码</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        long res = <span class="number">1</span>; //需要注意的是, 由于下面的计算操作是会有先乘一个数, 再初以一个数的操作, 因此很有可能乘完后超过int上限, 所以需要声明为long整型</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i&lt; std::min(m,n); i++)&#123;</span><br><span class="line">            res = res * (m<span class="number">-1</span>+n<span class="number">-1</span> - i+<span class="number">1</span>) / i;</span><br><span class="line">            // 这里如果写成 res *= (m<span class="number">-1</span>+n<span class="number">-1</span>+i+<span class="number">1</span>) / i, 则会报错, 因为这样会先计算除法, 这样有可能会出现浮点数, 但是排列组合是不会出现浮点数的, 切记!</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="073-Set-Matrix-Zeroes"><a href="#073-Set-Matrix-Zeroes" class="headerlink" title="073. Set Matrix Zeroes"></a>073. Set Matrix Zeroes</h1><h2 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h2><p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.</p>
<p>Example 1:</p>
<p>Input:<br>[<br>  [1,1,1],<br>  [1,0,1],<br>  [1,1,1]<br>]<br>Output:<br>[<br>  [1,0,1],<br>  [0,0,0],<br>  [1,0,1]<br>]<br>Example 2:</p>
<p>Input:<br>[<br>  [0,1,2,0],<br>  [3,4,5,2],<br>  [1,3,1,5]<br>]<br>Output:<br>[<br>  [0,0,0,0],<br>  [0,4,5,0],<br>  [0,3,1,0]<br>]<br>Follow up:</p>
<p>A straight forward solution using O(mn) space is probably a bad idea.<br>A simple improvement uses O(m + n) space, but still not the best solution.<br>Could you devise a constant space solution?</p>
<h2 id="解法一-穷举"><a href="#解法一-穷举" class="headerlink" title="解法一: 穷举"></a>解法一: 穷举</h2><p><strong>时间复杂度:</strong> $O(nm)$<br><strong>空间复杂度:</strong> $O(nm)$</p>
<p>记录所有出现0的位置, 然后根据这些位置坐标将对应的行和列上的值置为0.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rows;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    rows.push_back(i);</span><br><span class="line">                    cols.push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:rows)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:cols)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-穷举-减少空间复杂度"><a href="#解法二-穷举-减少空间复杂度" class="headerlink" title="解法二: 穷举(减少空间复杂度)"></a>解法二: 穷举(减少空间复杂度)</h2><p><strong>时间复杂度:</strong> $O(nm)$<br><strong>空间复杂度:</strong> $O(n+m)$</p>
<p>上面在记录位置坐标时没有进行重复检查, 实际上, 对于已经记录过的行或列, 可以不用再记录, 此时, 空间复杂度可以降为 $O(m+n)$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rows;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 记录行或列坐标之前先进行重复检查</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">std</span>::count(rows.begin(), rows.end(), i)==<span class="number">0</span>) rows.push_back(i);</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">std</span>::count(cols.begin(), cols.end(), j)==<span class="number">0</span>) cols.push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:rows)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:cols)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-穷举-无空间复杂度"><a href="#解法三-穷举-无空间复杂度" class="headerlink" title="解法三: 穷举(无空间复杂度)"></a>解法三: 穷举(无空间复杂度)</h2><p><strong>时间复杂度:</strong> $O(nm\times (m+n))$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>遍历矩阵时, 如果遇到 $(i,j)$ 上的值为0, 那么就将对应的行和列上的所有非0值全部置为一个矩阵范围外的值NAN(解答里面用的是-100000, <strong>实际上这种解法存在问题, 因为理论上矩阵中的元素可以是表示范围内的任何值</strong> ).</p>
<p>之后将所有的NAN值置为0, 就可以完成置0任务, 并且没有使用额外的空间. 由于每次找到一个0时, 都要遍历这个位置上的行和列, 因此时间复杂度较高</p>
<h2 id="解法四-用第一行和第一列记录"><a href="#解法四-用第一行和第一列记录" class="headerlink" title="解法四: 用第一行和第一列记录"></a>解法四: 用第一行和第一列记录</h2><p><strong>时间复杂度:</strong> $O(nm)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>用第一行和第一列的值记录是否应该将对应的行和列置为0, 此时由于第一行和第一列被用作了标记数组, 因此第一行和第一列的0不能用来判断是否应该置为全0, 所以需要额外设置两个变量记录.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> is_row=<span class="literal">false</span>, is_col = <span class="literal">false</span>; <span class="comment">// 用第一行和第一列的值来做标记, 因此需要额外的记录第一行和第一列本身是有应该全0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>) is_row=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">0</span>) is_col=<span class="literal">true</span>;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][j]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is_row)&#123; <span class="comment">//需要特别判断第一行和第一列是否应该置为0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt;matrix[<span class="number">0</span>].size();j++)  matrix[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is_col)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; matrix.size(); i++) matrix[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="075-Sort-Colors"><a href="#075-Sort-Colors" class="headerlink" title="075. Sort Colors"></a>075. Sort Colors</h1><p>对0,1,2 (颜色: RGB) 进行排序</p>
<h2 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h2><p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p>Note: You are not suppose to use the library’s sort function for this problem.</p>
<p>Example:</p>
<p>Input: [2,0,2,1,1,0]<br>Output: [0,0,1,1,2,2]<br>Follow up:</p>
<p>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.<br>Could you come up with a one-pass algorithm using only constant space?</p>
<h2 id="解法一-两次遍历"><a href="#解法一-两次遍历" class="headerlink" title="解法一: 两次遍历"></a>解法一: 两次遍历</h2><p><strong>时间复杂度: $O(n)$</strong><br><strong>空间复杂度: $O(1)$</strong></p>
<p>第一次遍历统计0,1,2的个数, 第二次遍历根据0,1,2的个数覆盖数组原有值</p>
<h2 id="解法二-一次遍历"><a href="#解法二-一次遍历" class="headerlink" title="解法二: 一次遍历"></a>解法二: 一次遍历</h2><p><strong>时间复杂度:</strong> 大于 $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>设置mid, low, high三个指示变量, 如果mid==0, 则将其与low交换, 如果mid==2, 则将其与high交换, 直到mid&gt;high为止.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>, mid=<span class="number">0</span>, high=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(mid&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[mid], nums[high--]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]==<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[mid++], nums[low++]);</span><br><span class="line">                <span class="comment">//这里 mid 可以直接++ 的原因是因为mid已经将0和2的情况进行处理,</span></span><br><span class="line">                <span class="comment">// 所以现在 low 指向的值只可能是 1, 因此交换后无需再对nums[mid]判断, 直接++即可</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mid++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="077-Combinations"><a href="#077-Combinations" class="headerlink" title="077. Combinations"></a>077. Combinations</h1><h2 id="Description-输出所有的组合"><a href="#Description-输出所有的组合" class="headerlink" title="Description: 输出所有的组合"></a>Description: 输出所有的组合</h2><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4, k = 2</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-回溯-1"><a href="#解法一-回溯-1" class="headerlink" title="解法一: 回溯"></a>解法一: 回溯</h2><p><strong>时间复杂度:</strong><br><strong>空间复杂度:</strong></p>
<p>标准的回溯(深度游戏遍历)解法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;out, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = out.size();</span><br><span class="line">        <span class="keyword">if</span>(count==k)&#123;</span><br><span class="line">            res.push_back(out);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=level; i&lt;n; i++)&#123;</span><br><span class="line">            out.push_back(i+<span class="number">1</span>);</span><br><span class="line">            dfs_helper(res, out, n, k, i+<span class="number">1</span>);</span><br><span class="line">            out.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">        dfs_helper(res, out, n, k, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代-1"><a href="#解法二-迭代-1" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p>TODO: 未看懂</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out(k, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            out[i]++;</span><br><span class="line">            <span class="keyword">if</span> (out[i] &gt; n) i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == k - <span class="number">1</span>) res.push_back(out);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">                out[i] = out[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="078-Subsets"><a href="#078-Subsets" class="headerlink" title="078. Subsets"></a>078. Subsets</h1><p>返回给定数字序列的子集, 序列中每个元素都不同(这是一个很重要的条件!!)</p>
<h2 id="Description-8"><a href="#Description-8" class="headerlink" title="Description"></a>Description</h2><p>Given a set of distinct integers, nums, return all possible subsets (the power set).</p>
<p>Note: The solution set must not contain duplicate subsets.</p>
<p>Example:</p>
<p>Input: nums = [1,2,3]<br>Output:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p>
<h2 id="解法一-迭代直接求出子集"><a href="#解法一-迭代直接求出子集" class="headerlink" title="解法一: 迭代直接求出子集"></a>解法一: 迭代直接求出子集</h2><p><strong>时间复杂度:</strong> $O(2^n)$ , 对于任意一个元素, 有包含和不包含两种情况<br><strong>空间复杂度:</strong> $O(2^n)$</p>
<p><strong>由于序列中的每个元素都不同</strong>, 因此, 对于任意一个元素, 只需要将其添加都前面序列所组成的子集的每一个子序列的末尾即可, 无需考虑是否包含重复元素的情况.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res &#123;vector&lt;int&gt;&#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(auto n : nums)&#123;</span><br><span class="line">            int len = res.size();</span><br><span class="line">            <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                vector&lt;int&gt; sub_item = res[i]; // c++中, =为复制赋值, move函数为移动赋值</span><br><span class="line">                sub_item.push_back(n);</span><br><span class="line">                res.push_back(sub_item);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-回溯-1"><a href="#解法二-回溯-1" class="headerlink" title="解法二: 回溯"></a>解法二: 回溯</h2><p><a href="https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning" target="_blank" rel="noopener">https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning</a>)<br>回溯法可以解决一系列相关问题, 先看Subsets的求解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sub_item;</span><br><span class="line">        back_track(res, sub_item, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back_track</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sub_item, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">        res.push_back(sub_item);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            sub_item.push_back(nums[i]);</span><br><span class="line">            back_track(res, sub_item, i+<span class="number">1</span>, nums);</span><br><span class="line">            sub_item.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>其他问题:</strong></p>
<p>Subsets II (contains duplicates) : <a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/subsets-ii/</a><br>悠悠  11:05:53<br>Permutations : <a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations/</a><br>悠悠  11:06:01<br>Permutations II (contains duplicates) : <a href="https://leetcode.com/problems/permutations-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations-ii/</a><br>悠悠  11:06:09<br>Combination Sum : <a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum/</a><br>悠悠  11:06:16<br>Combination Sum II (can’t reuse same element) : <a href="https://leetcode.com/problems/combination-sum-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum-ii/</a><br>悠悠  11:06:23<br>Palindrome Partitioning : <a href="https://leetcode.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-partitioning/</a></p>
<h2 id="解法三-bit控制"><a href="#解法三-bit控制" class="headerlink" title="解法三: bit控制"></a>解法三: bit控制</h2><p><strong>时间复杂度:</strong> $O(n\times 2^n)$ , 最慢的方法.<br><strong>空间复杂度:</strong> $O(2^n)$<br>因为对于任意一个数只有两种可能性, 出现在子序列中, 或者不出现在子序列中, 因此对于长度为 n 的(无相同元素的)序列来说, 共有 $2^n$ 个子序列, 我们先为这些子序列申请空间, 然后根据位操作(刚好有0,1两种情况)来决定对应位置上的字符出现还是不出现.</p>
<p>在实现时, 观察到, 第一个元素每隔两个子序列出现一次, 第二个元素每隔四个子序列出现两次, 第三个元素每隔八个子序列出现四次…</p>
<p>依次类推, 我们可以根据当前元素的位置来决定当前元素是否出现(间隔的前一半出现, 后一半不出现)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len_subsets = <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">2</span>,nums.size());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(len_subsets, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len_subsets; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;&gt;i &amp; <span class="number">1</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                    res[j].push_back(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="079-Word-Search"><a href="#079-Word-Search" class="headerlink" title="079. Word Search"></a>079. Word Search</h1><p>判断指定单词是否存在于字符矩阵中(可以通过上下左右邻接字符相连的才算是一个单词)</p>
<h2 id="Description-判断指定单词是否存在于字符矩阵中"><a href="#Description-判断指定单词是否存在于字符矩阵中" class="headerlink" title="Description: 判断指定单词是否存在于字符矩阵中"></a>Description: 判断指定单词是否存在于字符矩阵中</h2><p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>Example:</p>
<p>board =<br>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]</p>
<p>Given word = “ABCCED”, return true.<br>Given word = “SEE”, return true.<br>Given word = “ABCB”, return false.</p>
<h2 id="解法一-dfs-回溯"><a href="#解法一-dfs-回溯" class="headerlink" title="解法一: dfs+回溯"></a>解法一: dfs+回溯</h2><p><strong>时间复杂度:</strong> $O(mn 4^k)$, 暴力求解, $mn$ 为字符矩阵的宽和高, 也即 cell 数量, 对于 dfs 中的每个 cell, 有4个扩展方向, 一共需要扩展 $k$ 次($k$ 为单词的长度).<br><strong>空间复杂度:</strong> $O(mn)$ , 回溯时, 用<code>#</code>来记录已经遍历过的点, 无需申请额外空间来记录. 但是递归程序需要占用 $O(mn)$ 的空间复杂度.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size()==<span class="number">0</span> || board[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;board[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, word, <span class="number">0</span>, i, j)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">string</span> word, <span class="keyword">int</span> start, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> cur_c = board[x][y];</span><br><span class="line">        <span class="keyword">if</span>(cur_c != word[start]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(start == word.size()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        board[x][y]=<span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">bool</span> res=<span class="literal">false</span>, b_down=<span class="literal">false</span>, b_left=<span class="literal">false</span>, b_right=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">0</span>) res = dfs(board, word, start+<span class="number">1</span>, x<span class="number">-1</span>, y);</span><br><span class="line">        <span class="keyword">if</span>(!res &amp;&amp; x&lt;board.size()<span class="number">-1</span>) res = dfs(board, word, start+<span class="number">1</span>, x+<span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">if</span>(!res &amp;&amp; y&gt;<span class="number">0</span>) res = dfs(board, word, start+<span class="number">1</span>, x, y<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!res &amp;&amp; y&lt;board[<span class="number">0</span>].size()<span class="number">-1</span>) res = dfs(board, word, start+<span class="number">1</span>, x, y+<span class="number">1</span>);</span><br><span class="line">        board[x][y]=cur_c;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>另一种写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">string</span> &amp;word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[i][j] != word[pos]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos == word.size()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 注意是size-1</span></span><br><span class="line">        <span class="keyword">int</span> direct[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = board.size();</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">'#'</span>; <span class="comment">// 标记成已访问</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d : direct)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=i+d[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y=j+d[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt;m &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;n &amp;&amp; board[x][y]!=<span class="string">'#'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, word, x, y, pos+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = c; <span class="comment">// 退出前重置访问状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.empty() || board[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(word.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.size();</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, word, i, j, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="090-Subsets-II"><a href="#090-Subsets-II" class="headerlink" title="090. Subsets II"></a>090. Subsets II</h1><h2 id="Description-含重复元素的数组的子集"><a href="#Description-含重复元素的数组的子集" class="headerlink" title="Description: 含重复元素的数组的子集"></a>Description: 含重复元素的数组的子集</h2><p>Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).</p>
<p>Note: The solution set must not contain duplicate subsets.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-迭代"><a href="#解法一-迭代" class="headerlink" title="解法一: 迭代"></a>解法一: 迭代</h2><p><strong>时间复杂度:</strong> $O(2^n)$, 时间复杂度为子集的个数<br><strong>时间复杂度:</strong> $O(n)$, 空间复杂度为最长子集的长度</p>
<p>先排序, 然后对于一个元素, 如果这个元素与前一个元素相等, 那么在插入的时候, 就不能从第一个子集插入, 因为这样会重复, 因此要从不会造成重复的元素开始插入, 具体可看代码.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res &#123;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> pre_start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = (i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]) ? pre_start : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 从不会重复的元素开始 或者 从头开始</span></span><br><span class="line">            <span class="keyword">int</span> len = res.size();</span><br><span class="line">            <span class="keyword">for</span> ( ; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> sub_item = res[j];</span><br><span class="line">                sub_item.emplace_back(nums[i]);</span><br><span class="line">                res.emplace_back(sub_item);</span><br><span class="line">            &#125;</span><br><span class="line">            pre_start = len; <span class="comment">// 更新该值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-回溯-2"><a href="#解法二-回溯-2" class="headerlink" title="解法二: 回溯"></a>解法二: 回溯</h2><p><strong>时间复杂度:</strong> $O(2^n)$, 时间复杂度为子集的个数<br><strong>时间复杂度:</strong> $O(n)$, 空间复杂度为递归的深度</p>
<p>先排序, 然后同样, 如果遇到相等元素, 则跳过, 以避免重复</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sub_item;</span><br><span class="line">        back_trace(res, sub_item, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back_trace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; sub_item,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        res.push_back(sub_item);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; start <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            sub_item.emplace_back(nums[i]);</span><br><span class="line">            back_trace(res, sub_item, i+<span class="number">1</span>, nums);</span><br><span class="line">            sub_item.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="091-Decode-Ways"><a href="#091-Decode-Ways" class="headerlink" title="091. Decode Ways"></a>091. Decode Ways</h1><h2 id="Description-9"><a href="#Description-9" class="headerlink" title="Description"></a>Description</h2><p>A message containing letters from A-Z is being encoded to numbers using the following mapping:</p>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>Given a non-empty string containing only digits, determine the total number of ways to decode it.</p>
<p>Example 1:</p>
<p>Input: “12”<br>Output: 2<br>Explanation: It could be decoded as “AB” (1 2) or “L” (12).<br>Example 2:</p>
<p>Input: “226”<br>Output: 3<br>Explanation: It could be decoded as “BZ” (2 26), “VF” (22 6), or “BBF” (2 2 6).</p>
<h2 id="解法一-最优-DP-constant-space"><a href="#解法一-最优-DP-constant-space" class="headerlink" title="解法一(最优): DP constant space"></a>解法一(最优): DP constant space</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p><strong>存在问题:</strong> 下面的程序在面对测例:230001或230时, 输出的不是0. 但是仍然能通过OJ, <strong>但实际上下面的解法在面对上面的样例时会返回错误答案, 因为没有对 0 进行特殊处理</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span> || s.front()==<span class="string">"0"</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 注意, 不能用s.front() == "0"</span></span><br><span class="line">        <span class="keyword">int</span> f1=<span class="number">1</span>, f2=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'0'</span>) f1=<span class="number">0</span>; <span class="comment">//注意, 不能用s[i] == "0"</span></span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'1'</span> || (s[i<span class="number">-1</span>]==<span class="string">'2'</span> &amp;&amp; s[i]&lt;=<span class="string">'6'</span>))&#123;</span><br><span class="line">                f1 = f1+f2; <span class="comment">// 令f1为前i-1字符的可能组合+前i-2字符的可能组合</span></span><br><span class="line">                f2 = f1-f2; <span class="comment">// 令f2为前i-1字符的可能组合, 也就是对于下一个i来说的前i-2的可能组合</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                f2 = f1; <span class="comment">// 如果当前字符不能与前一个字符组合, 则当前字符f1不变, 而f2有变为下一个i的前i-2的可能组合, 即让新f2等于旧的f1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>修复了上述的问题, 现在遇到 0 时会进行额外的判断, 0 不能单独编码, 必须与前面的字符组合, 如果无法组合, 则应该返回0, 如 230001, 就应该返回 0, 代码如下:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || s[<span class="number">0</span>] == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//if(n==1) return 1;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'0'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] ==<span class="string">'2'</span> || s[i<span class="number">-1</span>] == <span class="string">'1'</span>) <span class="comment">// 0 不能单独编码, 必须与前面的数字组合, 因此这里是 dp[i-2]</span></span><br><span class="line">                    dp[i] = i&gt;<span class="number">1</span> ? dp[i<span class="number">-2</span>] : <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 如果 0 前面的值大于 2, 则无法组成编码, 应返回 0</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'1'</span> ||(s[i<span class="number">-1</span>]==<span class="string">'2'</span> &amp;&amp; s[i] &lt;= <span class="string">'6'</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> prev_two = i&gt;<span class="number">1</span> ? dp[i<span class="number">-2</span>] : <span class="number">1</span>;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + prev_two;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>上面的代码使用了 DP 数组, 空间复杂度为 $O(n)$, 实际上我们并不需要这么多空间, 只需要常数空间就可以完成数组, 即只需要当前 dp 值的前两个 dp 值即可. 代码如下:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || s[<span class="number">0</span>] == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//if(n==1) return 1;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> f1 = <span class="number">1</span>; <span class="comment">// 代表当前dp值之前一位的dp值</span></span><br><span class="line">        <span class="keyword">int</span> f2 = <span class="number">1</span>; <span class="comment">// 代表当前dp值之前两位的dp值</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'0'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] ==<span class="string">'2'</span> || s[i<span class="number">-1</span>] == <span class="string">'1'</span>)&#123; <span class="comment">// 0 不能单独编码, 必须与前面的数字组合, 因此这里是 dp[i-2]</span></span><br><span class="line">                    <span class="keyword">int</span> tmp = f1;</span><br><span class="line">                    f1 = f2; <span class="comment">// 令当前dp值为f2 (当前的dp值会成为下一个f1值)</span></span><br><span class="line">                    f2 = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 如果 0 前面的值大于 2, 则无法组成编码, 应返回 0</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'1'</span> ||(s[i<span class="number">-1</span>]==<span class="string">'2'</span> &amp;&amp; s[i] &lt;= <span class="string">'6'</span>))&#123;</span><br><span class="line">                f1 = f1 + f2;</span><br><span class="line">                f2 = f1 - f2;</span><br><span class="line">                <span class="comment">// 上面两个式子相当于:</span></span><br><span class="line">                <span class="comment">// int tmp = f1; f1 = f1+f2; f2 = tmp;</span></span><br><span class="line">                <span class="comment">//int prev_two = i&gt;1 ? dp[i-2] : 1;</span></span><br><span class="line">                <span class="comment">//dp[i] = dp[i-1] + prev_two;</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                f2 = f1; <span class="comment">// 当前dp值不变, 所以只需要更新 f2 即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>另一种写法, 更好理解:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty() || s[<span class="number">0</span>] == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp1 = <span class="number">1</span>; <span class="comment">// 记录当前字符前一位的可能组合数</span></span><br><span class="line">        <span class="keyword">int</span> dp2 = <span class="number">1</span>; <span class="comment">// 记录当前字符前两位的可能组合数</span></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>; <span class="comment">// 记录当前字符的可能组合数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i<span class="number">-1</span>] == <span class="string">'1'</span> <span class="keyword">or</span> s[i<span class="number">-1</span>] == <span class="string">'2'</span>) &#123; <span class="comment">// d</span></span><br><span class="line">                    res = dp2;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;d</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i<span class="number">-1</span>] == <span class="string">'1'</span></span><br><span class="line">                <span class="keyword">or</span> (s[i<span class="number">-1</span>] == <span class="string">'2'</span> <span class="keyword">and</span> s[i] &lt; <span class="string">'7'</span> <span class="keyword">and</span> s[i] &gt; <span class="string">'0'</span>)) &#123;</span><br><span class="line">                res = dp1 + dp2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = dp1;</span><br><span class="line">            &#125;</span><br><span class="line">            dp2 = dp1;</span><br><span class="line">            dp1 = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-递归"><a href="#解法二-递归" class="headerlink" title="解法二: 递归"></a>解法二: 递归</h2><p><strong>时间复杂度:</strong> $O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> recurve(<span class="number">0</span>,s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">recurve</span><span class="params">(<span class="keyword">int</span> pos, <span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos==s.size()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[pos]==<span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tmp_res = recurve(pos+<span class="number">1</span>, s);</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;s.size()<span class="number">-1</span> &amp;&amp; (s[pos]==<span class="string">'1'</span> || (s[pos]==<span class="string">'2'</span>&amp;&amp;s[pos+<span class="number">1</span>]&lt;=<span class="string">'6'</span>))) tmp_res += recurve(pos+<span class="number">2</span>, s);</span><br><span class="line">        <span class="keyword">return</span> tmp_res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="094-Binary-Tree-Inorder-Traversal"><a href="#094-Binary-Tree-Inorder-Traversal" class="headerlink" title="094. Binary Tree Inorder Traversal"></a>094. Binary Tree Inorder Traversal</h1><p>中序遍历二叉树</p>
<h2 id="Description-10"><a href="#Description-10" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure></p>
<p><strong>Follow up</strong>: Recursive solution is trivial, could you do it iteratively?</p>
<h2 id="解法一-递归-3"><a href="#解法一-递归-3" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>) inorder(root-&gt;left, res);</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>) inorder(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-非递归-2"><a href="#解法二-非递归-2" class="headerlink" title="解法二: 非递归"></a>解法二: 非递归</h2><p>标准的中序非递归遍历算法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s_tree;</span><br><span class="line">        <span class="keyword">while</span>(!s_tree.empty() || root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s_tree.push(root);</span><br><span class="line">                root= root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s_tree.empty())&#123;</span><br><span class="line">                root = s_tree.top(); s_tree.pop();</span><br><span class="line">                res.push_back(root-&gt;val);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="098-Validate-Binary-Search-Tree"><a href="#098-Validate-Binary-Search-Tree" class="headerlink" title="098. Validate Binary Search Tree"></a>098. Validate Binary Search Tree</h1><h2 id="Description-11"><a href="#Description-11" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>Example 1:</p>
<p>Input:<br>    2<br>   / \<br>  1   3<br>Output: true<br>Example 2:</p>
<pre><code>5
</code></pre><p>   / \<br>  1   4<br>     / \<br>    3   6<br>Output: false<br>Explanation: The input is: [5,1,4,null,null,3,6]. The root node’s value<br>             is 5 but its right child’s value is 4.</p>
<h2 id="解法一-递归-4"><a href="#解法一-递归-4" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p>用一个指针来指向当前节点在顺序上的前一个节点, 判断是否为BST</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* pre_node = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> isBST(root, pre_node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBST</span><span class="params">(TreeNode* root, TreeNode * &amp;pre_node)</span></span>&#123; <span class="comment">// 注意!!! 要维持递归时的pred_node, 因此必须使用 * &amp;, 否则每次的pre_node = root;实际上只是改变了pred_node的副本</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(isBST(root-&gt;left, pre_node) == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pre_node!=<span class="literal">nullptr</span> &amp;&amp; pre_node-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre_node = root;</span><br><span class="line">        <span class="keyword">if</span>(isBST(root-&gt;right, pre_node)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>下面的代码是典型错误解法:</strong> 因为, 我们不知只要考虑左子树节点值要小于当前节点值, 还要满足的另外一个条件是左子树本身也是一个二叉搜索树, 下面的代码没有进行该判断.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Input</span></span><br><span class="line"><span class="comment">[10,5,15,null,null,6,20]</span></span><br><span class="line"><span class="comment">Output</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">Expected</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> b=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            b = isValidBST(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="literal">false</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right-&gt;val &lt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            b = isValidBST(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代-中序"><a href="#解法二-迭代-中序" class="headerlink" title="解法二: 迭代(中序)"></a>解法二: 迭代(中序)</h2><p>中序遍历二叉搜索树时, 返回的是一个有序的数组, 因此, 我们可以在遍历时, 一旦发现不有序, 就返回 false, 需要注意一点的是, 本题中二叉搜索树中的节点值是唯一的.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">nullptr</span> || !s.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">                root = s.top(); s.pop();</span><br><span class="line">                <span class="keyword">if</span>(prev!=<span class="literal">nullptr</span> &amp;&amp; prev-&gt;val &gt;= root-&gt;val)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                prev = root;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a>102. Binary Tree Level Order Traversal</h1><p>按层次输出二叉树节点的值(每层的值要分开)</p>
<h2 id="Description-12"><a href="#Description-12" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-层次遍历"><a href="#解法一-层次遍历" class="headerlink" title="解法一: 层次遍历"></a>解法一: 层次遍历</h2><p><strong>时间复杂度:</strong> $O(n)$ , 每个节点遍历一次<br><strong>空间复杂度:</strong> $O(n)$ , 存储了n个节点的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode * cur_node;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; layer;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                cur_node = q.front(); q.pop();</span><br><span class="line">                layer.push_back(cur_node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;left != <span class="literal">nullptr</span>) q.push(cur_node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;right != <span class="literal">nullptr</span>) q.push(cur_node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(layer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal"></a>103. Binary Tree Zigzag Level Order Traversal</h1><p>按之字形打印二叉树</p>
<h2 id="Description-13"><a href="#Description-13" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its zigzag level order traversal as:<br>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p>
<h2 id="解法一：利用reverse"><a href="#解法一：利用reverse" class="headerlink" title="解法一：利用reverse"></a>解法一：利用reverse</h2><p>时间复杂度为 $O(n^2)$  空间复杂度为 $O(n)$</p>
<p>然后每次访问节点时, 都判断当前节点的层数, 如果为奇数层, 则将该层直接push back到结果向量中, 如果为偶数, 则将该层数据进行reverse后再push back到结果向量中. 通过while里面内置for循环, 来保证每次for循环都会将一整层的节点放进队列中, 无需额外的数组来存储depth信息<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(pRoot);</span><br><span class="line">        <span class="keyword">bool</span> even = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">//将vec声明在内部, 省去每次的clear操作, clear操作需要对vector进行遍历, 并将每个元素置为null？</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> size = que.size(); <span class="comment">//当前存的节点数目就是这一层所有的节点, 之前层的到已经被取出, 并且这一层的子节点还没有开始入队列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i)&#123; <span class="comment">//将该层所有节点的子节点入队列, 同时当到达该层最后一个节点时终止</span></span><br><span class="line">                TreeNode* tmp = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                vec.push_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                    que.push(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                    que.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(even) <span class="comment">//根据奇偶标识判断是否需要reverse</span></span><br><span class="line">                <span class="built_in">std</span>::reverse(vec.begin(), vec.end());</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">            even = !even;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-最优-不用reverse"><a href="#解法二-最优-不用reverse" class="headerlink" title="解法二: 最优(不用reverse)"></a>解法二: 最优(不用reverse)</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>在解法二中, 复杂度高的原因是因每次遇到偶数层的时候都要进行 reverse, 实际上, 当我们知道了该层的节点个数以后, 我们可以直接开辟一个指定大小的 vector, 然后根据下标随机访问来填入该层的节点值, 这样一来就不用进行 reverse, 并且空间复杂度与解法二相同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">bool</span> is_odd = <span class="literal">true</span>;</span><br><span class="line">        TreeNode* cur_node;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> layer_len = q.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur_layer(layer_len);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;layer_len; i++)&#123;</span><br><span class="line">                cur_node = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span>(is_odd==<span class="literal">true</span>)</span><br><span class="line">                    cur_layer[i] = cur_node-&gt;val;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cur_layer[layer_len<span class="number">-1</span>-i ] = cur_node-&gt;val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;left!=<span class="literal">nullptr</span>) q.push(cur_node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur_node-&gt;right!=<span class="literal">nullptr</span>) q.push(cur_node-&gt;right);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(cur_layer);</span><br><span class="line">            is_odd = !is_odd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-利用双端队列"><a href="#解法三-利用双端队列" class="headerlink" title="解法三: 利用双端队列"></a>解法三: 利用双端队列</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;TreeNode*&gt; dqTree;</span><br><span class="line">        dqTree.push_back(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!dqTree.empty()) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">int</span> len = dqTree.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmpRes;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (depth &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> node = dqTree.front();</span><br><span class="line">                    dqTree.pop_front();</span><br><span class="line">                    tmpRes.push_back(node-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) dqTree.push_back(node-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) dqTree.push_back(node-&gt;right);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">auto</span> node = dqTree.back();</span><br><span class="line">                    dqTree.pop_back();</span><br><span class="line">                    tmpRes.push_back(node-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) dqTree.push_front(node-&gt;right);</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) dqTree.push_front(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmpRes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h1><h2 id="Description-根据先序和中序遍历构造二叉树"><a href="#Description-根据先序和中序遍历构造二叉树" class="headerlink" title="Description: 根据先序和中序遍历构造二叉树"></a>Description: 根据先序和中序遍历构造二叉树</h2><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong><br>You may assume that duplicates do not exist in the tree.(如果没有该条件则通常无法还原唯一的二叉树)</p>
<p>For example, given</p>
<p>preorder = [3,9,20,15,7]<br>inorder = [9,3,15,20,7]<br>Return the following binary tree:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-递归-5"><a href="#解法一-递归-5" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(n^2)$, 在中序遍历中查找根节点的复杂度为 $O(n)$, 先序序列中总共有 $n$ 个根节点, 所以需要查找 $n$ 次<br><strong>空间复杂度:</strong> 根据树的结构, 最坏情况下的递归深度为 $O(n)$.</p>
<p>先取先序遍历中的第一个节点为根节点, 然后在中序遍历冲查找该节点, 以该节点为界限将数组分成两边, 分别为左子树和右子树, 根据左子树和右子树的长度在先序遍历中也划分对应长度的两个数组, 然后将两个数组分别作为左子树的先序和中序, 以及右子树的先序和中序进行递归构建.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;preorder, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inorder, <span class="keyword">int</span> k, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">        <span class="comment">// tree        8 4 5 3 7 3</span></span><br><span class="line">        <span class="comment">// preorder    8 [4 3 3 7] [5]</span></span><br><span class="line">        <span class="comment">// inorder     [3 3 4 7] 8 [5]</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j || k &gt;= l)&#123;<span class="comment">// 注意, 这里的 j 和 l 均为超尾下标</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root_val = preorder[i];</span><br><span class="line">        <span class="keyword">auto</span> in_index = find(inorder.begin()+k, inorder.begin()+l, root_val);</span><br><span class="line">        <span class="keyword">int</span> dis = in_index - inorder.begin() - k;</span><br><span class="line"></span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line">        root-&gt;left = helper(preorder, i+<span class="number">1</span>, i+<span class="number">1</span>+dis, inorder, k, k+dis);</span><br><span class="line">        root-&gt;right = helper(preorder, i+<span class="number">1</span>+dis, j, inorder, k+dis+<span class="number">1</span>, l);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder, <span class="number">0</span>, preorder.size(), inorder, <span class="number">0</span>, inorder.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代-2"><a href="#解法二-迭代-2" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<ol>
<li>先将 <code>preorder[i]</code> 压入栈中, 如果当前 preorder 的元素与 inorder 中的元素不匹配, 则将 preorder 中的值构造成节点压入栈中, 并且新构造的节点一定是栈顶的左孩子. 重复该过程直到元素值匹配为止: <code>preorder[i] = inorder[index]</code></li>
<li>当先序和中序的值匹配时, 则将节点出栈, 直到不再匹配为止.</li>
<li>TODO: 该解法还没彻底搞清, 暂时搁置</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt;  s;</span><br><span class="line">        <span class="keyword">if</span>(preorder.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; preorder.size(); i++)&#123;</span><br><span class="line">            TreeNode* cur = s.top();</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val != inorder[index])&#123;</span><br><span class="line">                cur-&gt;left = <span class="keyword">new</span> TreeNode(preorder[i]);</span><br><span class="line">                s.push(cur-&gt;left);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top()-&gt;val == inorder[index])&#123;</span><br><span class="line">                    cur = s.top(); s.pop(); index++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(index &lt; inorder.size())&#123;</span><br><span class="line">                    cur-&gt;right = <span class="keyword">new</span> TreeNode(preorder[i]);</span><br><span class="line">                    s.push(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="116. Populating Next Right Pointers in Each Node"></a>116. Populating Next Right Pointers in Each Node</h1><p>令每个节点中的 <code>next</code> 指针指向它的右兄弟, 如果没有右兄弟, 那么就置为 <code>nullptr</code>, <strong>注意, 题目给定的树是满二叉树</strong></p>
<h2 id="Description-14"><a href="#Description-14" class="headerlink" title="Description"></a>Description</h2><p>Given a binary tree</p>
<p>struct TreeLinkNode {<br>  TreeLinkNode <em> left;<br>  TreeLinkNode </em> right;<br>  TreeLinkNode * next;<br>}<br>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<p>Note:</p>
<p>You may only use constant extra space.<br>Recursive approach is fine, implicit stack space does not count as extra space for this problem.<br>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).<br>Example:</p>
<p>Given the following perfect binary tree,</p>
<pre><code> 1
</code></pre><p>   /  \<br>  2    3<br> / \  / \<br>4  5  6  7<br>After calling your function, the tree should look like:</p>
<pre><code> 1 -&gt; NULL
</code></pre><p>   /  \<br>  2 -&gt; 3 -&gt; NULL<br> / \  / \<br>4-&gt;5-&gt;6-&gt;7 -&gt; NULL</p>
<h2 id="解法一-层次遍历-1"><a href="#解法一-层次遍历-1" class="headerlink" title="解法一: 层次遍历"></a>解法一: 层次遍历</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<p>显而易见可以用层次遍历, 只需额外设置一个节点指针来维护当前节点的前一个节点(左兄弟节点).</p>
<p><strong>但是</strong>, 题目中要求只能使用常数空间, 因此该解法不是最优解.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; treeQ;</span><br><span class="line">        treeQ.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!treeQ.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = treeQ.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = treeQ.front();</span><br><span class="line">                treeQ.pop();</span><br><span class="line">                Node* nextNode;</span><br><span class="line">                <span class="keyword">if</span> ( i &lt; len <span class="number">-1</span>) &#123;</span><br><span class="line">                    nextNode = treeQ.front();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextNode = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node-&gt;next = nextNode;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    treeQ.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    treeQ.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-利用-next-指针的特性"><a href="#解法二-利用-next-指针的特性" class="headerlink" title="解法二: 利用 next 指针的特性"></a>解法二: 利用 <code>next</code> 指针的特性</h2><p><strong>时间复杂度:</strong> $O(n)$, 每个节点都要访问一次(仅访问一次)<br><strong>空间复杂度:</strong> $O(1)$</p>
<p><strong>由于是满二叉树</strong>, 因此我们可以轻易的利用<code>next</code>指针自身的特性来实现层次遍历.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        Node* curFirst = root;</span><br><span class="line">        <span class="keyword">while</span> (curFirst != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Node* curNode = curFirst;</span><br><span class="line">            <span class="keyword">while</span> (curNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curNode-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    curNode-&gt;left-&gt;next = curNode-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curNode-&gt;next != <span class="literal">nullptr</span> &amp;&amp; curNode-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    curNode-&gt;right-&gt;next = curNode-&gt;next-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                curNode = curNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            curFirst = curFirst-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="127-Word-Ladder"><a href="#127-Word-Ladder" class="headerlink" title="127. Word Ladder"></a>127. Word Ladder</h1><p>实际上是图的BFS(广度优先搜索)</p>
<h2 id="Description-15"><a href="#Description-15" class="headerlink" title="Description"></a>Description</h2><p>Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:</p>
<p>Only one letter can be changed at a time.<br>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.<br>Note:</p>
<p>Return 0 if there is no such transformation sequence.<br>All words have the same length.<br>All words contain only lowercase alphabetic characters.<br>You may assume no duplicates in the word list.<br>You may assume beginWord and endWord are non-empty and are not the same.<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">return its length 5.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-BFS"><a href="#解法一-BFS" class="headerlink" title="解法一: BFS"></a>解法一: BFS</h2><p><strong>时间复杂度:</strong> $O(nl)$, 其中, $l$ 为单词的长度, $n$ 是单词的数量, 因为广度优先遍历会对每个节点遍历一次, 而每个节点计算邻居时, 需要对 $l$ 个字母进行替换(替换26种, 常数级别), 另外, unordered_set 的 find 复杂度也为常数.<br><strong>空间复杂度:</strong> $O(n)$ 需要额外借助队列进行广度优先遍历, 另外还使用了 <code>unordered_set</code> 来存储单词表</p>
<p>我们可以将此题看做是图的广度优先搜索, 首先, 以 beginWord 为图的起始节点, 然后, 那些所有与 beginWord 只有一个字母不相同的单词都可以看做是 beginWord 的邻居节点, 依次类推, 直到找到一个单词, 与 endWord 相同为止, 此时, 返回当前 endWord 与 beginWord 的距离. (距离的记录方式和二叉树层次遍历时的方式差不多, 都是利用当前队列中的元素大小来控制<code>深度</code>的).</p>
<p>需要注意的地方有以下几点:</p>
<ul>
<li>这里的图和树不太一样, 这里图没有链表指针来指示, 因此, 在每次将某一个单词入队列以后, 都需要在单词列表中删除掉这个单词(或者额外设置标记也行), 以防止重复搜索</li>
<li>题目给的是没有重复单词的单词表, 因此推荐使用 set 结构来进行删除 (erase) 操作, vector 结构的删除 (erase) 操作的时间复杂度较高.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; word_dict;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : wordList)</span><br><span class="line">            word_dict.insert(word);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; to_visit;</span><br><span class="line">        <span class="comment">//word_dict.erase(beginWord); //beginWord本来就不在字典中</span></span><br><span class="line">        to_visit.push(beginWord);</span><br><span class="line">        <span class="keyword">int</span> dist = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!to_visit.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> len = to_visit.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> word = to_visit.front(); to_visit.pop();</span><br><span class="line">                <span class="keyword">if</span>(word == endWord) <span class="keyword">return</span> dist;</span><br><span class="line">                add_next_word(word, word_dict, to_visit);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            dist++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_next_word</span><span class="params">(<span class="built_in">string</span> &amp;word, <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;word_dict, <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; &amp;to_visit)</span></span>&#123;</span><br><span class="line">       <span class="comment">// word_dict.erase(word);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;word.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> letter = word[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">26</span>; k++)&#123;</span><br><span class="line">                word[i] = <span class="string">'a'</span>+k;</span><br><span class="line">                <span class="keyword">if</span>(word_dict.find(word) != word_dict.end())&#123;</span><br><span class="line">                    to_visit.push(word);</span><br><span class="line">                    word_dict.erase(word);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            word[i] = letter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="130-Surrounded-Regions"><a href="#130-Surrounded-Regions" class="headerlink" title="130. Surrounded Regions"></a>130. Surrounded Regions</h1><p>类似于围棋, 将被包裹住(4连通)的字符 <code>O</code> 全部转换成字符 <code>X</code>.</p>
<h2 id="Descriptioin"><a href="#Descriptioin" class="headerlink" title="Descriptioin"></a>Descriptioin</h2><p>Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’.</p>
<p>A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.</p>
<p>Example:</p>
<p>X X X X<br>X O O X<br>X X O X<br>X O X X<br>After running your function, the board should be:</p>
<p>X X X X<br>X X X X<br>X X X X<br>X O X X<br>Explanation:</p>
<p>Surrounded regions shouldn’t be on the border, which means that any ‘O’ on the border of the board are not flipped to ‘X’. Any ‘O’ that is not on the border and it is not connected to an ‘O’ on the border will be flipped to ‘X’. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p>
<h2 id="解法一-递归-6"><a href="#解法一-递归-6" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(n)$, n 为 <code>board</code> 中的元素个数<br><strong>空间复杂度:</strong> $O(n)$, 递归深度优先遍历的递归次数最坏情况下为 n 次.</p>
<p>根据题目的要求, 我们可以从 <code>board</code> 的四个边界开始, 每遇到一次 <code>O</code> 就执行深度优先遍历, 将其相邻的所有 <code>O</code> 都变成另一个字符(如 <code>#</code>). 然后, 在顺序遍历整个 <code>board</code>, 将 <code>board</code> 中所有的 <code>O</code> 变成 <code>X</code>, 将所有的 <code>#</code> 变成 <code>O</code>, 即得解.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size()==<span class="number">0</span> || board[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; j&lt;board[i].size(); j++)  <span class="comment">//上边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) dfs_helper(i,j,board);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>, j=board[i].size()<span class="number">-1</span>; i&lt;board.size()<span class="number">-1</span>; i++)  <span class="comment">//右边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) dfs_helper(i,j,board);  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=board.size()<span class="number">-1</span>, j=<span class="number">0</span>; j&lt;board[i].size(); j++)  <span class="comment">//下边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) dfs_helper(i,j,board);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>, j=<span class="number">0</span>; i&lt;board.size()<span class="number">-1</span>; i++)  <span class="comment">//左边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) dfs_helper(i,j,board);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;board[i].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) board[i][j]=<span class="string">'X'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j]==<span class="string">'#'</span>) board[i][j]=<span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_helper</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board)</span></span>&#123;</span><br><span class="line">        board[i][j]=<span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; board[i<span class="number">-1</span>][j]==<span class="string">'O'</span>) dfs_helper(i<span class="number">-1</span>, j, board);        </span><br><span class="line">        <span class="keyword">if</span>(j&gt;<span class="number">0</span> &amp;&amp; board[i][j<span class="number">-1</span>]==<span class="string">'O'</span>) dfs_helper(i, j<span class="number">-1</span>, board);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;board.size()<span class="number">-1</span> &amp;&amp; board[i+<span class="number">1</span>][j]==<span class="string">'O'</span>) dfs_helper(i+<span class="number">1</span>, j, board);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;board[i].size()<span class="number">-1</span> &amp;&amp; board[i][j+<span class="number">1</span>]==<span class="string">'O'</span>) dfs_helper(i, j+<span class="number">1</span>, board); <span class="comment">//注意是 j&lt;board[i].size()-1, 不是 board.size()-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代-3"><a href="#解法二-迭代-3" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><p><strong>时间复杂度:</strong> $O(n)$, n 为 <code>board</code> 中的元素个数<br><strong>空间复杂度:</strong> $O(n)$, 额外申请队列的大小为 n</p>
<p>思想和解法一相同, 不过采用 BFS 迭代实现, 利用一个队列来实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size()==<span class="number">0</span> || board[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; j&lt;board[i].size(); j++)  <span class="comment">//上边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) bfs_helper(i,j,board);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>, j=board[i].size()<span class="number">-1</span>; i&lt;board.size()<span class="number">-1</span>; i++)  <span class="comment">//右边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) bfs_helper(i,j,board);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=board.size()<span class="number">-1</span>, j=<span class="number">0</span>; j&lt;board[i].size(); j++)  <span class="comment">//下边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) bfs_helper(i,j,board);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>, j=<span class="number">0</span>; i&lt;board.size()<span class="number">-1</span>; i++)  <span class="comment">//左边界</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) bfs_helper(i,j,board);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;board[i].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>) board[i][j]=<span class="string">'X'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j]==<span class="string">'#'</span>) board[i][j]=<span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs_helper</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board)</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; bfs_q;</span><br><span class="line">        <span class="keyword">int</span> len = board[i].size();</span><br><span class="line">        bfs_q.push(i*len +j);</span><br><span class="line">        board[i][j]=<span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">while</span>(!bfs_q.empty())&#123;</span><br><span class="line">            i = bfs_q.front()/len; j = bfs_q.front()%len; bfs_q.pop();           </span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; board[i<span class="number">-1</span>][j]==<span class="string">'O'</span>)&#123;  board[i<span class="number">-1</span>][j]=<span class="string">'#'</span>;bfs_q.push( (i<span class="number">-1</span>)*len+j); &#125;  <span class="comment">//注意这里一定要更改了字符以后再存入队列, 负责可能引起字符重复入队列, 最终内存超限</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;<span class="number">0</span> &amp;&amp; board[i][j<span class="number">-1</span>]==<span class="string">'O'</span>) &#123; board[i][j<span class="number">-1</span>]=<span class="string">'#'</span>; bfs_q.push( i*len+j<span class="number">-1</span>); &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;board.size()<span class="number">-1</span> &amp;&amp; board[i+<span class="number">1</span>][j]==<span class="string">'O'</span>) &#123;  board[i+<span class="number">1</span>][j]=<span class="string">'#'</span>; bfs_q.push( (i+<span class="number">1</span>)*len + j );&#125;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;board[i].size()<span class="number">-1</span> &amp;&amp; board[i][j+<span class="number">1</span>]==<span class="string">'O'</span>) &#123;  board[i][j+<span class="number">1</span>]=<span class="string">'#'</span>; bfs_q.push( i*len + j+<span class="number">1</span>); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="131-Palindrome-Partitioning"><a href="#131-Palindrome-Partitioning" class="headerlink" title="131. Palindrome Partitioning"></a>131. Palindrome Partitioning</h1><p>划分回文子串</p>
<h2 id="Description-16"><a href="#Description-16" class="headerlink" title="Description"></a>Description</h2><h2 id="解法一-回溯-验证回文子串"><a href="#解法一-回溯-验证回文子串" class="headerlink" title="解法一: 回溯+验证回文子串"></a>解法一: 回溯+验证回文子串</h2><p><strong>时间复杂度:</strong> $O(n\times 2^n)$, 其中, 可能的 partition 情况最多有 $2^n$ 种, 而对于每一种都要进行复杂度为 $O(n)$ 的回文子串检查<br><strong>空间复杂度:</strong> $O(n\times 2^n)$ ? 数组 <code>res</code> 的大小最坏情况下可达 $(n\times 2^n)$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; part_res;</span><br><span class="line">        dfs(s, <span class="number">0</span>, part_res, res);</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;part_res, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.size())&#123;</span><br><span class="line">            res.push_back(part_res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(is_palin(start, i, s))&#123;</span><br><span class="line">                part_res.push_back(s.substr(start, i-start+<span class="number">1</span>));</span><br><span class="line">                dfs(s, i+<span class="number">1</span>, part_res, res);</span><br><span class="line">                part_res.pop_back();</span><br><span class="line"></span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_palin</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[start]!=s[end]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            start++;end--;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-回溯-DP"><a href="#解法二-回溯-DP" class="headerlink" title="解法二: 回溯+DP"></a>解法二: 回溯+DP</h2><p><strong>时间复杂度:</strong> $O(2^n)$, 利用 DP 建立一个 $n\times n$ 的 bool 数组, 其中 <code>dp[i][j]</code> 代表字符串从第 i 个字符开始, 到第 j 个字符组成的子串是否为回文串. 因此, 检查回文串时无需执行 $O(n)$ 的检查.<br><strong>空间复杂度:</strong> $O(n\times 2^n + n^2)$, 需要额外的数组空间来实现 DP.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; part_res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(s.size(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(s.size(), <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;s.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=j; i++)&#123; <span class="comment">// 注意这两个for循环的顺序和控制条件, dp算法一定要保证在计算当前元素时, 之前的元素已经计算完成并且存入到了数组当中, 否则建立出的dp数组会出现漏解</span></span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j] &amp;&amp; (j-i&lt;=<span class="number">2</span> || dp[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="literal">true</span>))</span><br><span class="line">                    dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(s, <span class="number">0</span>, part_res, res, dp);</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;part_res, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;dp )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.size())&#123;</span><br><span class="line">            res.push_back(part_res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[start][i]==<span class="literal">true</span>)&#123;</span><br><span class="line">                part_res.push_back(s.substr(start, i-start+<span class="number">1</span>));</span><br><span class="line">                dfs(s, i+<span class="number">1</span>, part_res, res, dp);</span><br><span class="line">                part_res.pop_back();</span><br><span class="line"></span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_palin</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[start]!=s[end]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            start++;end--;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="134-Gas-Station"><a href="#134-Gas-Station" class="headerlink" title="134. Gas Station"></a>134. Gas Station</h1><p>加油站问题, 根据油量和消耗量判断是否能走完一圈</p>
<h2 id="Description-17"><a href="#Description-17" class="headerlink" title="Description"></a>Description</h2><p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p>You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p>
<p>Note:</p>
<p>If there exists a solution, it is guaranteed to be unique.<br>Both input arrays are non-empty and have the same length.<br>Each element in the input arrays is a non-negative integer.<br>Example 1:</p>
<p>Input:<br>gas  = [1,2,3,4,5]<br>cost = [3,4,5,1,2]</p>
<p>Output: 3</p>
<p>Explanation:<br>Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4<br>Travel to station 4. Your tank = 4 - 1 + 5 = 8<br>Travel to station 0. Your tank = 8 - 2 + 1 = 7<br>Travel to station 1. Your tank = 7 - 3 + 2 = 6<br>Travel to station 2. Your tank = 6 - 4 + 3 = 5<br>Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.<br>Therefore, return 3 as the starting index.<br>Example 2:</p>
<p>Input:<br>gas  = [2,3,4]<br>cost = [3,4,3]</p>
<p>Output: -1</p>
<p>Explanation:<br>You can’t start at station 0 or 1, as there is not enough gas to travel to the next station.<br>Let’s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4<br>Travel to station 0. Your tank = 4 - 3 + 2 = 3<br>Travel to station 1. Your tank = 3 - 3 + 3 = 3<br>You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.<br>Therefore, you can’t travel around the circuit once no matter where you start.</p>
<h2 id="解法-最优"><a href="#解法-最优" class="headerlink" title="解法: 最优"></a>解法: 最优</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>首先要知道, 如果总油量大于总消耗量, 那么就一定存在一个起始点, 使得可以走完全程. 因此, 设置两个变量 <code>total_left</code> 和 <code>cur_left</code>, 前者存储从0点开始的总的剩余量, 后者存储从起点 <code>start</code> 开始的剩余量. 当 <code>cur_left&lt;=0</code> 时, 说明从 <code>start</code> 开始一直到当前位置之间的任何一个加油站都不能够成为起点, 因此将 <code>start</code> 置为下一个位置, 重新开始, 并令 <code>cur_left=0</code>. 在遍历完所有加油站以后, 如果总的剩余量不小于0, 则此时 <code>start</code> 所指的位置就一定是解.(由题意知, 该解是唯一解).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total_left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_left =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;gas.size(); i++)&#123;</span><br><span class="line">            total_left += gas[i]-cost[i];</span><br><span class="line">            cur_left += gas[i]-cost[i];</span><br><span class="line">            <span class="keyword">if</span>(cur_left&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                start = i+<span class="number">1</span>;</span><br><span class="line">                cur_left=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total_left &lt; <span class="number">0</span> ? <span class="number">-1</span>:start;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="138. Copy List with Random Pointer"></a>138. Copy List with Random Pointer</h1><p>复杂链表的复制, 复制带有随机指针的链表</p>
<h2 id="Description-18"><a href="#Description-18" class="headerlink" title="Description"></a>Description</h2><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
<h2 id="解法一-复制-拆分"><a href="#解法一-复制-拆分" class="headerlink" title="解法一: 复制+拆分"></a>解法一: 复制+拆分</h2><p><strong>时间复杂度:</strong> $O(n)$,  遍历三次链表<br><strong>空间复杂度:</strong> $O(1)$, 不包括复制链表占用的空间</p>
<p>先将每个节点复制到对应节点的后面, 然后给随机指针进行赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _next, Node* _random) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        random = _random;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node* node = head;</span><br><span class="line">        Node* copyNode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123; <span class="comment">// 复制节点</span></span><br><span class="line">            copyNode = <span class="keyword">new</span> Node(node-&gt;val, node-&gt;next, node-&gt;random);</span><br><span class="line">            node-&gt;next = copyNode;</span><br><span class="line">            node = node-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123; <span class="comment">// 设值 random 的值</span></span><br><span class="line">            copyNode = node-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;random != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                copyNode-&gt;random = node-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node = head;</span><br><span class="line">        Node* copyHead = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123; <span class="comment">// 拆分两个链表</span></span><br><span class="line">            copyNode = node-&gt;next;</span><br><span class="line">            node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (copyNode-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                copyNode-&gt;next = copyNode-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next; <span class="comment">// 不要忘了让 node 指向下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copyHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-一次遍历-1"><a href="#解法二-一次遍历-1" class="headerlink" title="解法二: 一次遍历"></a>解法二: 一次遍历</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(n)$, 需要申请链表长度的哈希表</p>
<p>利用一个哈希表来存储已经访问过的节点, 哈希表的键值为: <code>{cur_node, copy_node}</code>, 其中, <code>cur_node</code> 代表旧链表中的节点, <code>copy_node</code> 代表新链表中的节点. 顺序遍历旧链表, 对于旧链表中的每一个节点, 查看其 <code>next</code> 节点是否存在于哈希表 <code>visit</code> 中, 如果存在, 则将 <code>copy_node</code> 的 <code>next</code> 指针指向该节点(键)对应的复制节点(值). 对于 <code>random</code> 指针也是同理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        RandomListNode *cur_node = head;</span><br><span class="line">        RandomListNode *copy_node = <span class="keyword">new</span> RandomListNode(head-&gt;label);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;RandomListNode *, RandomListNode *&gt; visit;  <span class="comment">// key: old_node, value: copy_node</span></span><br><span class="line">        visit.insert(&#123;cur_node, copy_node&#125;); <span class="comment">//注意不要少了花括号</span></span><br><span class="line">        <span class="keyword">while</span>(cur_node!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line"></span><br><span class="line">            RandomListNode *next_node=<span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur_node-&gt;next==<span class="literal">nullptr</span>) copy_node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(visit.find(cur_node-&gt;next)==visit.end())&#123;</span><br><span class="line">                next_node = <span class="keyword">new</span> RandomListNode(cur_node-&gt;next-&gt;label);</span><br><span class="line">                copy_node-&gt;next = next_node;</span><br><span class="line">                visit.insert(&#123;cur_node-&gt;next, next_node&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                copy_node-&gt;next = visit[cur_node-&gt;next];</span><br><span class="line"></span><br><span class="line">            RandomListNode *random_node=<span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur_node-&gt;random==<span class="literal">nullptr</span>) copy_node-&gt;random = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(visit.find(cur_node-&gt;random) == visit.end())&#123;</span><br><span class="line">                random_node = <span class="keyword">new</span> RandomListNode(cur_node-&gt;random-&gt;label);</span><br><span class="line">                copy_node-&gt;random = random_node;</span><br><span class="line">                visit.insert(&#123;cur_node-&gt;random, random_node&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                copy_node-&gt;random = visit[cur_node-&gt;random];</span><br><span class="line"></span><br><span class="line">            cur_node = cur_node-&gt;next;</span><br><span class="line">            copy_node = copy_node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visit[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-递归"><a href="#解法三-递归" class="headerlink" title="解法三: 递归"></a>解法三: 递归</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$, 除了哈希表所占空间外, 递归还需额外空间, 但是可以近似看做是 $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;RandomListNode *, RandomListNode *&gt; visit;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(visit.find(head)!=visit.end())</span><br><span class="line">            <span class="keyword">return</span> visit[head];</span><br><span class="line">        RandomListNode *node = <span class="keyword">new</span> RandomListNode(head-&gt;label);</span><br><span class="line"></span><br><span class="line">        visit.insert(&#123;head, node&#125;);</span><br><span class="line">        node-&gt;next = copyRandomList(head-&gt;next);</span><br><span class="line">        node-&gt;random = copyRandomList(head-&gt;random);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="139-Word-Break"><a href="#139-Word-Break" class="headerlink" title="139. Word Break"></a>139. Word Break</h1><p>判断字符串是否可以划分成字典里面的单词</p>
<h2 id="Description-19"><a href="#Description-19" class="headerlink" title="Description"></a>Description</h2><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>Note:</p>
<p>The same word in the dictionary may be reused multiple times in the segmentation.<br>You may assume the dictionary does not contain duplicate words.<br>Example 1:</p>
<p>Input: s = “leetcode”, wordDict = [“leet”, “code”]<br>Output: true<br>Explanation: Return true because “leetcode” can be segmented as “leet code”.<br>Example 2:</p>
<p>Input: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>Output: true<br>Explanation: Return true because “applepenapple” can be segmented as “apple pen apple”.<br>             Note that you are allowed to reuse a dictionary word.<br>Example 3:</p>
<p>Input: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>Output: false</p>
<h2 id="解法一-回溯-2"><a href="#解法一-回溯-2" class="headerlink" title="解法一: 回溯"></a>解法一: 回溯</h2><p><strong>时间复杂度:</strong> 超时<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  纯回溯实现, 复杂度很高, 很容易超时</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; word_dict(wordDict.begin(), wordDict.end());</span><br><span class="line">        <span class="keyword">return</span> helper(s,<span class="number">-1</span>,word_dict);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> seg, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;word_dict)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(seg==s.size()<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">string</span> temp=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=seg+<span class="number">1</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            temp+=s[i];</span><br><span class="line">            <span class="keyword">if</span>(word_dict.find(temp) != word_dict.end() &amp;&amp; helper(s, i, word_dict)==<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-DP"><a href="#解法二-DP" class="headerlink" title="解法二: DP"></a>解法二: DP</h2><p><strong>时间复杂度:</strong> $O(n^2)$, $n$ 为字符串的长度<br><strong>空间复杂度:</strong> $O(n)$, dp 数组额外空间, unordered_set 额外空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; word_dict(wordDict.begin(), wordDict.end());</span><br><span class="line">        <span class="keyword">if</span>(wordDict.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(s.size(), <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j<span class="number">-1</span>&lt;<span class="number">0</span> || dp[j<span class="number">-1</span>]==<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="built_in">string</span> temp = s.substr(j, i-j+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(word_dict.find(temp) != word_dict.end())&#123;</span><br><span class="line">                        dp[i]=<span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// break to next i</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-DP"><a href="#解法三-DP" class="headerlink" title="解法三: DP"></a>解法三: DP</h2><p><strong>时间复杂度:</strong> $O(nm)$, $n$ 为字符串的长度, $m$ 为字典的 size<br><strong>空间复杂度:</strong> $O(n)$, dp 数组额外空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; word_dict(wordDict.begin(), wordDict.end());</span><br><span class="line">        <span class="keyword">if</span>(wordDict.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(s.size(), <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;wordDict.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=wordDict[j].size()<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> len = wordDict[j].size();</span><br><span class="line">                    <span class="built_in">string</span> temp= s.substr(i-len+<span class="number">1</span>, len);                    </span><br><span class="line">                    <span class="keyword">if</span>(temp == wordDict[j] &amp;&amp; ((i-len)&lt;<span class="number">0</span> || dp[i-len]==<span class="literal">true</span>))<span class="comment">// 这里注意, .size() 返回的类型并不是int, 如果使用i-wordDict[j].size() &lt;0, 就会造成runtime error, 正确做法是进行强制的类型转换, 或者用一个int变量代表之.</span></span><br><span class="line">                        dp[i]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>更简洁的写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(s.size(), <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; word : wordDict) &#123;</span><br><span class="line">                <span class="keyword">int</span> lenW = word.size();</span><br><span class="line">                <span class="keyword">if</span> (!dp[i] <span class="keyword">and</span> i+<span class="number">1</span> &gt;= lenW <span class="keyword">and</span> word == s.substr(i-lenW+<span class="number">1</span>, lenW)) &#123;</span><br><span class="line">                    dp[i] = (i-lenW+<span class="number">1</span> == <span class="number">0</span>) ? <span class="literal">true</span> : dp[i-lenW];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><span id="142"></span></p>
<h1 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a>142. Linked List Cycle II</h1><h2 id="Description-求链表中环的开始节点"><a href="#Description-求链表中环的开始节点" class="headerlink" title="Description: 求链表中环的开始节点"></a>Description: 求链表中环的开始节点</h2><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>Note: Do not modify the linked list.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<h2 id="解法一-Floyd-的乌龟和兔子-Floyd-判环算法"><a href="#解法一-Floyd-的乌龟和兔子-Floyd-判环算法" class="headerlink" title="解法一: Floyd 的乌龟和兔子(Floyd 判环算法)"></a>解法一: Floyd 的乌龟和兔子(Floyd 判环算法)</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>此题更多解析可以看<a href="../面试-算法刷题-剑指offer/#55">剑指offer第55题</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>) <span class="keyword">return</span> fast;<span class="comment">// 不存在环</span></span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>) <span class="keyword">return</span> fast;<span class="comment">// 不存在环</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(slow!=fast);</span><br><span class="line"></span><br><span class="line">        fast = slow;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144. Binary Tree Preorder Traversal"></a>144. Binary Tree Preorder Traversal</h1><h2 id="Description-先根遍历"><a href="#Description-先根遍历" class="headerlink" title="Description: 先根遍历"></a>Description: 先根遍历</h2><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br></pre></td></tr></table></figure></p>
<p>Output: [1,2,3]<br>Follow up: Recursive solution is trivial, could you do it iteratively?</p>
<h2 id="解法一-递归-7"><a href="#解法一-递归-7" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        preorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        preorder(root-&gt;left, res);</span><br><span class="line">        preorder(root-&gt;right, res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代-4"><a href="#解法二-迭代-4" class="headerlink" title="解法二: 迭代"></a>解法二: 迭代</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() <span class="keyword">or</span> root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                res.push_back(root-&gt;val);</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="148-Sort-List"><a href="#148-Sort-List" class="headerlink" title="148. Sort List"></a>148. Sort List</h1><p>对链表进行排序, 要求时间复杂度为 $O(nlogn)$, 空间复杂度为常数</p>
<h2 id="Description-20"><a href="#Description-20" class="headerlink" title="Description"></a>Description</h2><p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-递归-自顶向下"><a href="#解法一-递归-自顶向下" class="headerlink" title="解法一: 递归 自顶向下"></a>解法一: 递归 自顶向下</h2><p><strong>时间复杂度:</strong> $O(nlogn)$<br><strong>空间复杂度:</strong> $O(logn)$</p>
<p>首先对于链表的排序最先想到的就是归并排序, 因为题目的要求是空间复杂度为常数, 因为不能使用递归实现(递归会占用额外空间), 但是, 递归是一种很好理解的排序方法, 因此, 这里我们先给链表归并排序的递归实现.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head; <span class="comment">//链表中至少应有两个元素, 否则不能进行融合, 会产生运行时错误</span></span><br><span class="line">        ListNode *slow=head, *fast=head, *pre=head; <span class="comment">// 两指针, 找到最中间的元素, 用slow指向</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span> &amp;&amp; fast-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 将前后两个链断开</span></span><br><span class="line">        ListNode* sort1 = sortList(head); <span class="comment">// 将前一半排序</span></span><br><span class="line">        ListNode* sort2 = sortList(slow); <span class="comment">// 将后一半排序</span></span><br><span class="line">        <span class="keyword">return</span> merge_sort(sort1, sort2); <span class="comment">// 融合两个有序链表</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge_sort</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;  </span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="literal">nullptr</span>) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2!=<span class="literal">nullptr</span>) cur-&gt;next = l2; <span class="comment">// 将最后的一个非空元素加入排序链表</span></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代-自底向上"><a href="#解法二-迭代-自底向上" class="headerlink" title="解法二: 迭代 自底向上"></a>解法二: 迭代 自底向上</h2><p><strong>时间复杂度:</strong> $O(nlogn)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>先两两合并, 再四四合并, 逐渐向上, 直到完全合并. 注意这里之所以可以在 $O(1)$ 的空间复杂度内进行归并排序, 是因为采用了链表的底层结构, 使得 merge 操作可以在 $O(1)$ 的空间复杂度下进行. 但是对于一般的归并排序, 采用的是数组结构, 数组结构在进行 merge 时, 要么在 $O(n)$ 的空间复杂度下执行, 要么每次插入都需要移动其他元素, 增加时间复杂度.</p>
<p>接下来, 我们考虑如何实现归并排序的迭代算法, 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">splitList</span><span class="params">(ListNode* l1, <span class="keyword">int</span> blockSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (blockSize &gt; <span class="number">1</span> <span class="keyword">and</span> l1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            blockSize--;</span><br><span class="line">        &#125; <span class="comment">// 找到 l1 的尾部</span></span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* l2 = l1-&gt;next; <span class="comment">// l1 尾部的下一个就是 l2 的头部</span></span><br><span class="line">        l1-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// split l1 and l2</span></span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2, ListNode* dummy)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> <span class="keyword">and</span> l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = (l1 != <span class="literal">nullptr</span>) ? l1 : l2;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> cur; <span class="comment">// 该节点是下一段链表的 dummy 节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> blockSize = <span class="number">1</span>; blockSize &lt; length ; blockSize &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            ListNode* curDummy = dummy;</span><br><span class="line">            ListNode* curHead = dummy-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (curHead != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                ListNode* l1 = curHead;</span><br><span class="line">                ListNode* l2 = splitList(l1, blockSize);</span><br><span class="line">                curHead = splitList(l2, blockSize); <span class="comment">// 获取下一段链表的头节点, 并将l2的尾部置为nullptr</span></span><br><span class="line">                curDummy = mergeList(l1, l2, curDummy); <span class="comment">// 合并, 并获取当前段的最后一个非空节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="150-Evaluate-Reverse-Polish-Notation"><a href="#150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="150. Evaluate Reverse Polish Notation"></a>150. Evaluate Reverse Polish Notation</h1><p>计算逆波兰表达式</p>
<h2 id="Description-21"><a href="#Description-21" class="headerlink" title="Description"></a>Description</h2><p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p>
<p>Note:</p>
<p>Division between two integers should truncate toward zero.<br>The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation.<br>Example 1:</p>
<p>Input: [“2”, “1”, “+”, “3”, “<em>“]<br>Output: 9<br>Explanation: ((2 + 1) </em> 3) = 9<br>Example 2:</p>
<p>Input: [“4”, “13”, “5”, “/“, “+”]<br>Output: 6<br>Explanation: (4 + (13 / 5)) = 6<br>Example 3:</p>
<p>Input: [“10”, “6”, “9”, “3”, “+”, “-11”, “<em>“, “/“, “</em>“, “17”, “+”, “5”, “+”]<br>Output: 22<br>Explanation:<br>  ((10 <em> (6 / ((9 + 3) </em> -11))) + 17) + 5<br>= ((10 <em> (6 / (12 </em> -11))) + 17) + 5<br>= ((10 <em> (6 / -132)) + 17) + 5<br>= ((10 </em> 0) + 17) + 5<br>= (0 + 17) + 5<br>= 17 + 5<br>= 22</p>
<h2 id="解法一-栈"><a href="#解法一-栈" class="headerlink" title="解法一: 栈"></a>解法一: 栈</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(n)$, 需要一个额外的栈来存储中间结果</p>
<p>用栈来实现, 从到开始扫描字符串vector, 如果当前字符串不为运算符, 则直接入栈, 如果为运算符 , 则取栈顶两个元素进行运算然后将计算结果入栈. 最终, 栈中只剩一个结果值</p>
<p>需要注意的是: 首先要确保输入的逆波兰表达式是没有问题的, 其次还有要进行零除判断, 这几点本题没有考查, 但仍需注意</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;  polish;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> token : tokens)&#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,c;</span><br><span class="line">            <span class="keyword">if</span>(token.back()==<span class="string">'+'</span> || token.back()==<span class="string">'-'</span> || token.back()==<span class="string">'*'</span> || token.back()==<span class="string">'/'</span>)&#123; <span class="comment">// 用back的原因是数字有可能是 -13 这种形式</span></span><br><span class="line">                b = polish.top(); polish.pop();</span><br><span class="line">                a = polish.top(); polish.pop();</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">switch</span>(token.back())&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>: c=a+b; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>: c=a-b; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>: c=a*b; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'/'</span>: c= (b==<span class="number">0</span>) ? <span class="number">0</span> : a/b; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: c = c=<span class="built_in">std</span>::stoi(token);</span><br><span class="line">            &#125;</span><br><span class="line">            polish.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> polish.top();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-栈-异常"><a href="#解法二-栈-异常" class="headerlink" title="解法二: 栈+异常"></a>解法二: 栈+异常</h2><p>解法与上面相同, 不同借助了异常, 显得更加简洁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; rpn;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;tokens.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                rpn.push(stoi(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (exception e)&#123;</span><br><span class="line">                <span class="keyword">int</span> num1 = rpn.top(); rpn.pop();</span><br><span class="line">                <span class="keyword">int</span> num2 = rpn.top(); rpn.pop();</span><br><span class="line">                <span class="keyword">switch</span>(tokens[i][<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'+'</span>: rpn.push(num2+num1);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'-'</span>: rpn.push(num2-num1);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'*'</span>: rpn.push(num2*num1);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'/'</span>: rpn.push(num2/num1);<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rpn.size()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> rpn.top();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-栈-lambda"><a href="#解法三-栈-lambda" class="headerlink" title="解法三: 栈+lambda"></a>解法三: 栈+lambda</h2><p><strong>思路与解法一一直, 另一种写法:</strong> 借助哈希表和lambda表达式, 使程序更加整洁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; op_map=&#123;</span><br><span class="line">            &#123;<span class="string">"+"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a+b;&#125;&#125;, <span class="comment">//注意要用双引号, 因为token是stirng类型, 而不是char类型</span></span><br><span class="line">            &#123;<span class="string">"-"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a-b;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">"*"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a*b;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">"/"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> (b==<span class="number">0</span>) ? <span class="number">0</span> : a/b;&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;  polish;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> token : tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!op_map.count(token))</span><br><span class="line">                polish.push(<span class="built_in">std</span>::stoi(token));</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> b = polish.top(); polish.pop();</span><br><span class="line">                <span class="keyword">int</span> a = polish.top(); polish.pop();</span><br><span class="line">                polish.push(op_map[token](a, b));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> polish.top();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-栈-lambda-异常"><a href="#解法四-栈-lambda-异常" class="headerlink" title="解法四: 栈+lambda+异常"></a>解法四: 栈+lambda+异常</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span> &lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; op = &#123;</span><br><span class="line">            &#123;<span class="string">"+"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a+b;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">"-"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a-b;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">"*"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a*b;&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">"/"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> b == <span class="number">0</span> ? <span class="number">0</span> : a/b;&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; polish;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; token : tokens) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                polish.push(<span class="built_in">std</span>::stoi(token));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (exception e) &#123;</span><br><span class="line">                <span class="keyword">int</span> b = polish.top(); polish.pop();</span><br><span class="line">                <span class="keyword">int</span> a = polish.top(); polish.pop();</span><br><span class="line">                polish.push(op[token](a, b));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> polish.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152. Maximum Product Subarray"></a>152. Maximum Product Subarray</h1><p>求连续子序列的最大乘积</p>
<h2 id="Description-22"><a href="#Description-22" class="headerlink" title="Description"></a>Description</h2><p>Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>Example 1:</p>
<p>Input: [2,3,-2,4]<br>Output: 6<br>Explanation: [2,3] has the largest product 6.<br>Example 2:</p>
<p>Input: [-2,0,-1]<br>Output: 0<br>Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</p>
<h2 id="解法一-递归-8"><a href="#解法一-递归-8" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历一次<br><strong>空间复杂度:</strong> $O(n)$, 递归 $n$ 次</p>
<p>这道题和连续子序列的最大和比较相似, 但是更难一些, 我们需要考虑负负得正这种情况, 因此, 我们不仅仅要维护最大值, 还要维护最小值. 考虑利用递归的方法来实现, 假设我们现在已经知道了以第 <code>i-1</code> 个数为结尾的连续子序列的最大乘积值<code>max</code>和最小乘积值<code>min</code>, 那么如果数组中新来一个数 <code>nums[i]</code>, 则以第 <code>i</code> 个数为结尾的连续子序列的最大乘积就一定是<code>max * nums[i]</code>, <code>min*nums[i]</code>, <code>nums[i]</code>之中的最大者, 最小值为这三者的最小者. 由于我们还不知道最终的连续子序列是以第几个字符为结尾的, 因此我们利用一个变量<code>res</code>来维护当前找到的最大的子序列乘积, 并且随着循环的进行不断更新这个值, 最终, <code>res</code>的值就是我们要求的解, 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">        helper(nums, nums.size()<span class="number">-1</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; helper(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> index, <span class="keyword">int</span> &amp;res)&#123; <span class="comment">//注意这里要设置一个引用res来不断更新最大值</span></span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>) <span class="keyword">return</span> make_pair(nums[<span class="number">0</span>], nums[<span class="number">0</span>]);</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; max_min = helper(nums, index<span class="number">-1</span>, res);</span><br><span class="line">        <span class="keyword">int</span> a = max_min.first * nums[index];</span><br><span class="line">        <span class="keyword">int</span> b = max_min.second * nums[index];</span><br><span class="line">        <span class="keyword">int</span> c = nums[index];</span><br><span class="line">        max_min.first = max(a, max(b,c));</span><br><span class="line">        max_min.second = min(a, min(b,c));</span><br><span class="line">        res = max(res, max_min.first);</span><br><span class="line">        <span class="keyword">return</span> max_min;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-迭代实现"><a href="#解法二-迭代实现" class="headerlink" title="解法二 迭代实现"></a>解法二 迭代实现</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>思路和解法一相同, 只不过换成了迭代实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_neg = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max_pos = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">int</span> a = num * max_neg;</span><br><span class="line">            <span class="keyword">int</span> b = num * max_pos;</span><br><span class="line">            max_neg = <span class="built_in">std</span>::min(num, <span class="built_in">std</span>::min(a, b));</span><br><span class="line">            max_pos = <span class="built_in">std</span>::max(num, <span class="built_in">std</span>::max(a, b));</span><br><span class="line">            <span class="keyword">if</span> (max_pos &gt; res) res = max_pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法三-DP-迭代"><a href="#解法三-DP-迭代" class="headerlink" title="解法三: DP 迭代"></a>解法三: DP 迭代</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(n)$, 该解法需要额外数组, 实际上这是不必要的, 详细可看解法二</p>
<p>上面的递归写法, 可以转换成DP迭代, 为此需要两个dp数组, 一个用来保存以第i个元素为结尾的连续子序列的最大值, 另一个保存最小值. 代码如下:</p>
<p><strong>写法一: new数组</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> *dp_max = <span class="keyword">new</span> <span class="keyword">int</span>[nums.size()]();</span><br><span class="line">        <span class="keyword">int</span> *dp_min = <span class="keyword">new</span> <span class="keyword">int</span>[nums.size()]();</span><br><span class="line">        dp_max[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp_min[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = dp_max[i<span class="number">-1</span>]*nums[i];</span><br><span class="line">            <span class="keyword">int</span> b = dp_min[i<span class="number">-1</span>]*nums[i];</span><br><span class="line">            <span class="keyword">int</span> c = nums[i];</span><br><span class="line">            dp_max[i] = max(a, max(b,c));</span><br><span class="line">            dp_min[i] = min(a, min(b,c));</span><br><span class="line">            res = max(res, dp_max[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] dp_max;</span><br><span class="line">        <span class="keyword">delete</span>[] dp_min;</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>写法二: vector数组:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CCclass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp_max(nums.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp_min(nums.size(), <span class="number">0</span>);</span><br><span class="line">        dp_max[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp_min[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = dp_max[i<span class="number">-1</span>]*nums[i];</span><br><span class="line">            <span class="keyword">int</span> b = dp_min[i<span class="number">-1</span>]*nums[i];</span><br><span class="line">            <span class="keyword">int</span> c = nums[i];</span><br><span class="line">            dp_max[i] = max(a, max(b,c));</span><br><span class="line">            dp_min[i] = min(a, min(b,c));</span><br><span class="line">            res = max(res, dp_max[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="162-Find-Peak-Element"><a href="#162-Find-Peak-Element" class="headerlink" title="162. Find Peak Element"></a>162. Find Peak Element</h1><h2 id="Description-局部最大值"><a href="#Description-局部最大值" class="headerlink" title="Description: 局部最大值"></a>Description: 局部最大值</h2><p>A peak element is an element that is greater than its neighbors.</p>
<p>Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.</p>
<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>
<p>You may imagine that nums[-1] = nums[n] = -∞.</p>
<p>Example 1:</p>
<p>Input: nums = [1,2,3,1]<br>Output: 2<br>Explanation: 3 is a peak element and your function should return the index number 2.<br>Example 2:</p>
<p>Input: nums = [1,2,1,3,5,6,4]<br>Output: 1 or 5<br>Explanation: Your function can return either index number 1 where the peak element is 2,<br>             or index number 5 where the peak element is 6.</p>
<h2 id="解法一-O-n-复杂度"><a href="#解法一-O-n-复杂度" class="headerlink" title="解法一: $O(n)$ 复杂度"></a>解法一: $O(n)$ 复杂度</h2><p>$O(n)$ 的时间复杂度, 不合符题目要求, 仅仅记录一下.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() ==<span class="number">1</span> || nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.size()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>] &amp;&amp; nums[i] &gt; nums[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[nums.size()<span class="number">-2</span>] &lt; nums[nums.size()<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> nums.size()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-O-logn-复杂度"><a href="#解法二-O-logn-复杂度" class="headerlink" title="解法二: $O(logn)$ 复杂度"></a>解法二: $O(logn)$ 复杂度</h2><p>二分查找, 分为以下几种情况:</p>
<ul>
<li>If num[i-1] &lt; num[i] &gt; num[i+1], then num[i] is peak</li>
<li>If num[i-1] &lt; num[i] &lt; num[i+1], then num[i+1…n-1] must contains a peak</li>
<li>If num[i-1] &gt; num[i] &gt; num[i+1], then num[0…i-1] must contains a peak</li>
<li>If num[i-1] &gt; num[i] &lt; num[i+1], then both sides have peak</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;        </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.size()<span class="number">-1</span>;        </span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high<span class="number">-1</span>)&#123; <span class="comment">//避免low和high相邻, 使得mid-1或mid+1可能非法</span></span><br><span class="line">            mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid<span class="number">-1</span>] &lt; nums[mid] &amp;&amp; nums[mid] &gt; nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[mid+<span class="number">1</span>]) low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low]&gt;nums[high] ? low : high; <span class="comment">// 当low或high相邻时, 即为两端时的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>; <span class="comment">// 向下取整</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid+<span class="number">1</span>]) high = mid;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>递归实现:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low == high) &#123;</span><br><span class="line">            <span class="keyword">return</span> low;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> helper(nums, low, mid);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> helper(nums, mid+<span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="166-Fraction-to-Recurring-Decimal"><a href="#166-Fraction-to-Recurring-Decimal" class="headerlink" title="166. Fraction to Recurring Decimal"></a>166. Fraction to Recurring Decimal</h1><h2 id="Description-无限循环小数"><a href="#Description-无限循环小数" class="headerlink" title="Description: 无限循环小数"></a>Description: 无限循环小数</h2><p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p>
<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>
<p>Example 1:</p>
<p>Input: numerator = 1, denominator = 2<br>Output: “0.5”<br>Example 2:</p>
<p>Input: numerator = 2, denominator = 1<br>Output: “2”<br>Example 3:</p>
<p>Input: numerator = 2, denominator = 3<br>Output: “0.(6)”</p>
<h2 id="解法一-用余数作为哈希表的key"><a href="#解法一-用余数作为哈希表的key" class="headerlink" title="解法一: 用余数作为哈希表的key"></a>解法一: 用余数作为哈希表的key</h2><p><strong>时间复杂度:</strong> $O(logn)$, 每次都会乘以10再取余数<br><strong>空间复杂度:</strong> $O(logn)$, 余数的哈希表</p>
<p>首先, 获取最终浮点数的符号和整数部分, 此处由于可能出现分子为<code>-2147483648</code>, 而分母为<code>-1</code>的情况, 为此, 建议使用<code>long</code>长整型来避免溢出.<br>在计算小数部分时, 将余数作为<code>key</code>, 小数当前位置作为<code>value</code>存入哈希表中, 然后将余数乘以10, 再计算当前小数位的值, 并将取余得到新的余数.<br>题目指明浮点数是无限循环小数, 则如果小数部分没有循环, 那么一定会出现余数为0的情况, 此时, 返回当前的<code>res</code>即可. 如果小数存在循环, 那么循环一定出现在余数相同的时刻, 此时, 将添加后扩号, 并根据哈希表中的<code>value</code>添加前括号.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numerator == <span class="number">0</span> || denominator == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">if</span>(numerator&lt;<span class="number">0</span> ^ denominator&lt;<span class="number">0</span>) res+=<span class="string">"-"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> numer = (numerator &lt; <span class="number">0</span>) ? (<span class="keyword">long</span>)(numerator)*<span class="number">-1</span> : (<span class="keyword">long</span>)numerator; <span class="comment">// 注意, 不能写成 (long)(numerator*-1)</span></span><br><span class="line">        <span class="keyword">long</span> denom = (denominator &lt; <span class="number">0</span>) ? (<span class="keyword">long</span>)(denominator)*<span class="number">-1</span> : (<span class="keyword">long</span>)denominator;</span><br><span class="line">        <span class="keyword">long</span> integral = numer/denom;</span><br><span class="line">        res += <span class="built_in">std</span>::to_string(integral); <span class="comment">// 添加整数部分</span></span><br><span class="line">        <span class="keyword">long</span> rmd = numer % denom;</span><br><span class="line">        <span class="keyword">if</span>(rmd!=<span class="number">0</span>)</span><br><span class="line">            res += <span class="string">"."</span>; <span class="comment">// 存在小数</span></span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">long</span>, <span class="keyword">long</span>&gt; hash;</span><br><span class="line">        <span class="keyword">while</span>(rmd!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.find(rmd) != hash.end())&#123; <span class="comment">// 判断余数</span></span><br><span class="line">                res.insert(hash[rmd], <span class="string">"("</span>);</span><br><span class="line">                res += <span class="string">")"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[rmd] = res.size();</span><br><span class="line">            rmd = rmd*<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">long</span> quotient = rmd/denom;</span><br><span class="line">            res += <span class="built_in">std</span>::to_string(quotient);</span><br><span class="line">            rmd = rmd%denom;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="179-Largest-Number"><a href="#179-Largest-Number" class="headerlink" title="179. Largest Number"></a>179. Largest Number</h1><h2 id="Description-排列数字使其字符串形式的数字为最大"><a href="#Description-排列数字使其字符串形式的数字为最大" class="headerlink" title="Description: 排列数字使其字符串形式的数字为最大"></a>Description: 排列数字使其字符串形式的数字为最大</h2><p>Given a list of non negative integers, arrange them such that they form the largest number.</p>
<p>Example 1:</p>
<p>Input: [10,2]<br>Output: “210”<br>Example 2:</p>
<p>Input: [3,30,34,5,9]<br>Output: “9534330”</p>
<h2 id="解法一-构造比较函数-快排排序"><a href="#解法一-构造比较函数-快排排序" class="headerlink" title="解法一: 构造比较函数, 快排排序"></a>解法一: 构造比较函数, 快排排序</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 快排时间复杂度<br><strong>空间复杂度:</strong> $O(logn)$, 快排空间复杂度, <strong>如果使用其他排序算法, 可将空间复杂度降为 $O(1)$</strong></p>
<p>我们可以构造一个新的比较函数来决定两个元素的先后关系, 对于任意两个元素 <code>a</code> 和 <code>b</code>, 首先将其转换成字符串形式 <code>s_a</code> 和 <code>s_b</code>, 我们知道, 若整形 a&gt;b, 则一定有 <code>s_a</code> &gt; <code>s_b</code>, 因此我们可以比较 <code>s_a+s_b</code> 和 <code>s_b+s_a</code> 的大小关系, 根据题目要求, 我们要进行递减排序. 得到比较函数以后, 利用快排排序即可.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        q_sort(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);        </span><br><span class="line">        <span class="keyword">if</span>(nums.size()!=<span class="number">0</span> &amp;&amp; nums[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>; <span class="comment">// 对于输入[0, 0, 0] 应该返回 "0", 而不是"000", 必须要放在排序后, nums[0] == 0 说明所有元素均为0</span></span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num: nums)&#123;</span><br><span class="line">            res += <span class="built_in">std</span>::to_string(num);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">str_geq</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s_a = <span class="built_in">std</span>::to_string(a);</span><br><span class="line">        <span class="built_in">string</span> s_b = <span class="built_in">std</span>::to_string(b);</span><br><span class="line">        <span class="keyword">if</span>(s_a+s_b &gt;= s_b+s_a) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//注意是递减排序, 所以为 &gt;=</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> P = nums[low];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; str_geq(P, nums[high])) high--;</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; str_geq(nums[low], P)) low++;</span><br><span class="line">            nums[high] = nums[low];                  </span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = P;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">q_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = partition(nums, low, high);</span><br><span class="line">        <span class="keyword">if</span>(mid&gt;low) q_sort(nums, low, mid<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(mid&lt;high) q_sort(nums, mid+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-利用-STL-sort-函数"><a href="#解法二-利用-STL-sort-函数" class="headerlink" title="解法二: 利用 STL sort() 函数"></a>解法二: 利用 STL sort() 函数</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 快排时间复杂度<br><strong>空间复杂度:</strong> $O(logn)$, 快排空间复杂度, <strong>如果使用其他排序算法, 可将空间复杂度降为 $O(1)$</strong></p>
<p>思路与解法一一致, 只不过省略了排序算法的实现, 使用了 STL 的 <code>sort</code> 函数.</p>
<p><strong>需要注意, 在 C++ STL 的 sort 函数中, bool 返回真的时候, 必须是绝对大于或者绝对小于, 对于等于的情况, 只能返回 false</strong>(因为当返回 true 时, 元素会继续下一个, 这样对于极端情况, 如所有元素都一样时, 会出现越界, 从而导致段错误)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">str_geq</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;    </span><br><span class="line">    <span class="built_in">string</span> s_a = <span class="built_in">std</span>::to_string(a);</span><br><span class="line">    <span class="built_in">string</span> s_b = <span class="built_in">std</span>::to_string(b);</span><br><span class="line">    <span class="keyword">if</span>(s_a+s_b &gt; s_b+s_a) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 这里用 &gt;= 会产生运行时错误, 用 &gt; 则可以通过, 为什么?</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end(), str_geq);     </span><br><span class="line">        <span class="keyword">if</span>(nums.size()!=<span class="number">0</span> &amp;&amp; nums[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>; <span class="comment">// 对于输入[0, 0, 0] 应该返回 "0", 而不是"000", 必须要放在排序后, nums[0] == 0 说明所有元素均为0</span></span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num: nums)&#123;</span><br><span class="line">            res += <span class="built_in">std</span>::to_string(num);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="200-Number-of-Islands"><a href="#200-Number-of-Islands" class="headerlink" title="200. Number of Islands"></a>200. Number of Islands</h1><h2 id="Description-区块的个数"><a href="#Description-区块的个数" class="headerlink" title="Description: 区块的个数"></a>Description: 区块的个数</h2><p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p>Example 1:</p>
<p>Input:<br>11110<br>11010<br>11000<br>00000</p>
<p>Output: 1<br>Example 2:</p>
<p>Input:<br>11000<br>11000<br>00100<br>00011</p>
<p>Output: 3</p>
<h2 id="解法一-DFS-遍历"><a href="#解法一-DFS-遍历" class="headerlink" title="解法一: DFS 遍历"></a>解法一: DFS 遍历</h2><p><strong>时间复杂度:</strong> $O(n)$, 至多遍历两次 grid<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>遍历 grid 中的每一个元素, 如果为1, 则将与之相连的所有的1都置为0, 并且区块个数加1, 这样, 最坏的情况就是 grid 中的所有数字均为1, 此时, 需要遍历两边数组.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;grid.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;grid[i].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    fill(grid, i, j);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        grid[i][j] = <span class="string">'2'</span>;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;=<span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;=<span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; grid[x][y] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                fill(grid, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="207-Course-Schedule"><a href="#207-Course-Schedule" class="headerlink" title="207. Course Schedule"></a>207. Course Schedule</h1><h2 id="Description-课程表-判断有向图是否存在环"><a href="#Description-课程表-判断有向图是否存在环" class="headerlink" title="Description: 课程表 / 判断有向图是否存在环"></a>Description: 课程表 / 判断有向图是否存在环</h2><p>There are a total of n courses you have to take, labeled from 0 to n-1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<p>Example 1:<br>Input: 2, [[1,0]]<br>Output: true<br>Explanation:<br>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p>
<p>Example 2:<br>Input: 2, [[1,0],[0,1]]<br>Output: false<br>Explanation:<br>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p>
<h2 id="解法一-BFS-拓扑排序"><a href="#解法一-BFS-拓扑排序" class="headerlink" title="解法一: BFS / 拓扑排序"></a>解法一: BFS / 拓扑排序</h2><p><strong>时间复杂度:</strong> $O(V+E)$, 统计入度时需要 $O(V)$, 处理队列需要 $O(E)$, 其中 $V$ 为节点个数, $E$ 为边的个数<br><strong>空间复杂度:</strong> $O(V+E)$, 入度数组和队列分别需要 $(V)$, 邻接表需要 $O(V+E)$.</p>
<p>首先将图的边表示结构转换成邻接表形式(用<code>vector</code>来实现邻接表, 使其支持随机访问). 然后再申请一个 $O(V)$ 大小的数组来存储每个节点的入度. 在拓扑排序时, 先将所有入度为0的节点添加都一个队列当中, 然后从队列顶端拿出一个节点, 将该节点的所有直接后序节点的入度都减1, 然后再将所有入度为0的节点入队列. 如此迭代下去, 直至所有队列为空. 此时, 如果还有某个节点的入度不为0, 则说明存在环, 应该返回 false, 否则, 返回 true.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph_c(numCourses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in_degree(numCourses, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : prerequisites)&#123;</span><br><span class="line">            graph_c[p.second].push_back(p.first);</span><br><span class="line">            in_degree[p.first]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">// 入度为0的节点队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in_degree[i]==<span class="number">0</span>) q.push(i); <span class="comment">//将所有入度为0的节点入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> cur_c = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> next_c : graph_c[cur_c])&#123; <span class="comment">// next_c为cur_c的直接后序课程</span></span><br><span class="line">                in_degree[next_c]--; <span class="comment">// 后序节点的入度减1</span></span><br><span class="line">                <span class="keyword">if</span>(in_degree[next_c]==<span class="number">0</span>) q.push(next_c);<span class="comment">//如果减为0, 则入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> in : in_degree)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-DFS"><a href="#解法二-DFS" class="headerlink" title="解法二: DFS"></a>解法二: DFS</h2><p><strong>时间复杂度:</strong> $O(V+E)$, 复杂度和 BFS 算法近似, 其中 $V$ 为节点个数, $E$ 为边的个数<br><strong>空间复杂度:</strong> $O(V+E)$, <code>visit</code>数组和递归栈分别需要 $(V)$, 邻接表需要 $O(V+E)$.</p>
<p>首先, 和 BFS 一样, 建立关于图的邻接表结构, 然后, 申请 $O(V)$ 大小的访问数组<code>visit</code>, 初始值全部为0, 表示所有节点均为访问. 然后, 根据 DFS 算法的执行过程. 将当前正在访问的节点置为<code>-1</code>, 将已经访问过且确认无环的节点置为<code>1</code>. 则则DFS过程中, 如果访问到了一个已经被置为<code>-1</code>的节点, 则说明该节点是当前循环内的正在访问的节点, 因此, 构成了一个环, 返回 <code>false</code>. 如果遇到了一个被置为<code>1</code>的节点, 因为已经确认该节点无环, 因此可以直接返回 <code>true</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph_c(numCourses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visit(numCourses, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : prerequisites)</span><br><span class="line">            graph_c[p.second].push_back(p.first);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numCourses; i++)&#123; <span class="comment">// 因为当前的图并不是一个连通图, 所以必须遍历所有的节点</span></span><br><span class="line">            <span class="keyword">if</span>(canFinishDFS(graph_c, visit, i) == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinishDFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph_c, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;visit, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(visit[i] == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        visit[i] = <span class="number">-1</span>; <span class="comment">// 将当前节点置为正在访问状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> node : graph_c[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(canFinishDFS(graph_c, visit, node) == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 当前节点上存在环</span></span><br><span class="line">        &#125;</span><br><span class="line">        visit[i] = <span class="number">1</span>; <span class="comment">// 将当前节点置为已经访问过且确认无环状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 确认节点i无环, 返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="208-Implement-Trie-Prefix-Tree"><a href="#208-Implement-Trie-Prefix-Tree" class="headerlink" title="208. Implement Trie (Prefix Tree)"></a>208. Implement Trie (Prefix Tree)</h1><h2 id="Description-实现字典树-前缀树"><a href="#Description-实现字典树-前缀树" class="headerlink" title="Description: 实现字典树(前缀树)"></a>Description: 实现字典树(前缀树)</h2><p>Implement a trie with insert, search, and startsWith methods.</p>
<p>Example:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(<span class="string">"apple"</span>);</span><br><span class="line">trie.search(<span class="string">"apple"</span>);   <span class="comment">// returns true</span></span><br><span class="line">trie.search(<span class="string">"app"</span>);     <span class="comment">// returns false</span></span><br><span class="line">trie.startsWith(<span class="string">"app"</span>); <span class="comment">// returns true</span></span><br><span class="line">trie.insert(<span class="string">"app"</span>);   </span><br><span class="line">trie.search(<span class="string">"app"</span>);     <span class="comment">// returns true</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://wx4.sinaimg.cn/large/d7b90c85ly1fxnm0ibh7vj20jc0ggadn.jpg" alt=""></p>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p><a href="https://www.cnblogs.com/grandyang/p/4491665.html" target="_blank" rel="noopener">https://www.cnblogs.com/grandyang/p/4491665.html</a></p>
<p><strong>时间复杂度:</strong> $O(k)$, 插入, 查找, 找前缀均只需要 $O(k)$复杂度, $k$ 为字符串长度<br><strong>空间复杂度:</strong> 与字符串的公共部分的多少有关, 公共部分越多, 越节省空间, 反之, 空间复杂度较高. 最差情况下为 $O(wk)$, 其中, $w$ 为单词的个数, $k$ 为单词的最长长度.</p>
<p>字母字典树是一个26叉树, 树的根节点没有字符, 其他节点有且仅有一个字符, 我们模仿二叉树的定义, 构建一个26叉树的数据结构, 用子节点的编号代表字母(即0号节点代表字母a, 1号代表b,…,25号代表z), 另外需要定义一个布尔值来标识当前节点是否构成一个单词. 插入时, 根据字符串遍历树, 如果当前字符不存在, 则新建一个. 查找和找前缀时, 如果不存在则直接返回<code>false</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> is_word;</span><br><span class="line">    TrieNode():is_word(<span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : child)&#123; <span class="comment">// 对c进行改动, 需要用引用&amp;</span></span><br><span class="line">            c = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> letter : word)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = letter - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;child[i] == <span class="literal">nullptr</span>) p-&gt;child[i]=<span class="keyword">new</span> TrieNode();</span><br><span class="line">            p = p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;is_word = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> letter : word)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = letter - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;child[i]==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (p-&gt;is_word == <span class="literal">true</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> letter : prefix)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = letter - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;child[i]==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="210-Course-Schedule-II"><a href="#210-Course-Schedule-II" class="headerlink" title="210. Course Schedule II"></a>210. Course Schedule II</h1><h2 id="Description-判断有向图是否有环-若无环-则返回拓扑序列"><a href="#Description-判断有向图是否有环-若无环-则返回拓扑序列" class="headerlink" title="Description: 判断有向图是否有环, 若无环, 则返回拓扑序列"></a>Description: 判断有向图是否有环, 若无环, 则返回拓扑序列</h2><p>There are a total of n courses you have to take, labeled from 0 to n-1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</p>
<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>
<p>Example 1:<br>Input: 2, [[1,0]]<br>Output: [0,1]<br>Explanation:<br>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] .</p>
<p>Example 2:<br>Input: 4, [[1,0],[2,0],[3,1],[3,2]]<br>Output: [0,1,2,3] or [0,2,1,3]<br>Explanation:<br>There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .</p>
<h2 id="解法一-BFS-拓扑排序-1"><a href="#解法一-BFS-拓扑排序-1" class="headerlink" title="解法一: BFS, 拓扑排序"></a>解法一: BFS, 拓扑排序</h2><p><strong>时间复杂度:</strong> $O(V+E)$, 统计入度时需要 $O(V)$, 处理队列需要 $O(E)$, 其中 $V$ 为节点个数, $E$ 为边的个数<br><strong>空间复杂度:</strong> $O(V+E)$, 入度数组和队列分别需要 $(V)$, 邻接表需要 $O(V+E)$, 相比于第207题, 多了一个拓扑序列的数组, 大小为 $O(V)$.</p>
<p>和第207题差不多, 不过在判断是否有环的同时, 还要记录正确的拓扑序列并返回.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph_c(numCourses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 构建图的邻接表</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in_degree(numCourses);<span class="comment">// 构建入度数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c_pair : prerequisites)&#123;</span><br><span class="line">            graph_c[c_pair.second].push_back(c_pair.first);</span><br><span class="line">            in_degree[c_pair.first]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">//入度为0的队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in_degree[i]==<span class="number">0</span>) q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res; <span class="comment">// 记录拓扑序列        </span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> cur_c = q.front(); q.pop();</span><br><span class="line">            res.push_back(cur_c);            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;next_c : graph_c[cur_c])&#123;</span><br><span class="line">                in_degree[next_c]--; <span class="comment">// 后修课的入度减1</span></span><br><span class="line">                <span class="keyword">if</span>(in_degree[next_c]==<span class="number">0</span>) q.push(next_c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.size() == numCourses) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-DFS-1"><a href="#解法二-DFS-1" class="headerlink" title="解法二: DFS"></a>解法二: DFS</h2><p><strong>时间复杂度:</strong> $O(V+E)$, 复杂度和 BFS 算法近似, 其中 $V$ 为节点个数, $E$ 为边的个数<br><strong>空间复杂度:</strong> $O(V+E)$, <code>visit</code>数组和递归栈分别需要 $(V)$, 邻接表需要 $O(V+E)$, 拓扑序列需要 $O(V)$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph_c(numCourses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 构建图的邻接表</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visit(numCourses, <span class="number">0</span>);<span class="comment">// 构建入度数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c_pair : prerequisites)&#123;</span><br><span class="line">            graph_c[c_pair.second].push_back(c_pair.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numCourses; i++)&#123; <span class="comment">//非连通图, 需要遍历所有节点</span></span><br><span class="line">            <span class="keyword">if</span>(findOrderDFS(graph_c, i, visit, res)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();            </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="built_in">std</span>::reverse(res.begin(), res.end()); <span class="comment">//等于dfs来说, 最后的课程会先加入结果数组, 因此, res中的序列逆置后才是最终的拓扑序列.</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findOrderDFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph_c, <span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;visit, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i]==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 重复访问, 存在环</span></span><br><span class="line">        <span class="keyword">if</span>(visit[i]==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 已经访问过且确认无环, 可直接返回</span></span><br><span class="line">        visit[i] = <span class="number">-1</span>; <span class="comment">// 置为正在访问状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> next_c : graph_c[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(findOrderDFS(graph_c, next_c, visit, res) == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[i] = <span class="number">1</span>; <span class="comment">//确认无环</span></span><br><span class="line">        res.push_back(i); <span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="215-Kth-Largest-Element-in-an-Array"><a href="#215-Kth-Largest-Element-in-an-Array" class="headerlink" title="215. Kth Largest Element in an Array"></a>215. Kth Largest Element in an Array</h1><h2 id="Description-找出无序数组中第k大的数"><a href="#Description-找出无序数组中第k大的数" class="headerlink" title="Description: 找出无序数组中第k大的数"></a>Description: 找出无序数组中第k大的数</h2><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>Example 1:</p>
<p>Input: [3,2,1,5,6,4] and k = 2<br>Output: 5<br>Example 2:</p>
<p>Input: [3,2,3,1,2,4,5,5,6] and k = 4<br>Output: 4</p>
<h2 id="解法一-小顶堆"><a href="#解法一-小顶堆" class="headerlink" title="解法一: 小顶堆"></a>解法一: 小顶堆</h2><p><strong>时间复杂度:</strong> $O(nlogk)$, 堆的插入复杂度为 $O(logk)$, 最多需要进行 $n$ 次插入.<br><strong>空间复杂度:</strong> $O(k)$, 堆的大小</p>
<p>构建一个大小为 $k$ 的小顶堆, 对于任意一个新来的元素, 如果该元素大于堆顶, 将则堆顶退出, 并将该元素插入. 最终, 堆内的元素就是数组的最大的前 $k$ 个元素, 而堆顶刚好为第 $k$ 大的元素.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; heap_k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;        </span><br><span class="line">            <span class="keyword">if</span>(heap_k.size() &lt; k)&#123;</span><br><span class="line">                heap_k.push(num);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt; heap_k.top())&#123;</span><br><span class="line">                heap_k.pop();</span><br><span class="line">                heap_k.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap_k.top();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-部分排序-nth-element"><a href="#解法二-部分排序-nth-element" class="headerlink" title="解法二: 部分排序(nth_element)"></a>解法二: 部分排序(nth_element)</h2><p><a href="http://www.voidcn.com/article/p-qyrpnkse-gx.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-qyrpnkse-gx.html</a></p>
<p><strong>最优解法</strong></p>
<p><strong>时间复杂度:</strong> 平均为 $O(n)$. nth_element 的时间复杂度为 $T(n) = T(n/2) + O(n) = O(n) + O(n/2) + O(n/4) + …$, 也就是 $O(n)$.<br><strong>空间复杂度:</strong> $O(1)$, 不占用额外空间</p>
<p>直接调用 STL 的部分排序算法<code>nth_element</code>.<br><code>nth_element</code>算法将重新排列区间[first, last)的序列元素, 算法执行完毕后, 会使得</p>
<ul>
<li>第 $k$ 个位置的元素在最终的算法执行完毕后, 和整个区间完全排序后该位置的元素相同.</li>
<li>这个新的<code>nth</code>元素之前的所有元素均 &lt;= (&gt;=) <code>nth</code>元素之后的所有元素.<br>但是该算法并不保证位于第 $k$ 个元素两边区间的元素有序. 该算法和 <code>partial_sort</code> 算法之间一个很大的区别在于: <code>nth_element</code>对于除第 $k$ 位置的元素之外的区间元素的顺序不做保证, 而<code>partial_sort</code>排序后会使得前 $m$ 个数的子区间是有序的. 正因为如此, <strong>在需要无序的前 <code>top_k</code> 个值时, <code>nth_element</code> 相对于 <code>partial_sort</code> 要更快.(只需要找第 $k$ 个值, 其前面的元素即为 top_k, 时间复杂度为 $O(n)$). 如果需要有序, 也可以先使用 <code>nth_element</code>, 再对前 k 个数组排序, 总的复杂度为 $O(n+klogk)$</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::nth_element(nums.begin(), nums.begin()+k<span class="number">-1</span>, nums.end(), <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">return</span> nums[k<span class="number">-1</span>];    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-基于-Partition"><a href="#解法三-基于-Partition" class="headerlink" title="解法三: 基于 Partition"></a>解法三: 基于 Partition</h2><p><strong>时间复杂度:</strong> $O(n)$<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>该解法和解法二思路相同, 只不过是我们自己手动实现 Partition 的算法逻辑, 而不是调用 STL 函数.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>, high=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> pth = Partition(nums, low, high);</span><br><span class="line">        <span class="keyword">while</span>(pth != k<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pth &gt; k<span class="number">-1</span>)</span><br><span class="line">                high = pth<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = pth+<span class="number">1</span>;</span><br><span class="line">            pth = Partition(nums, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[pth];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> P = nums[low];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P&gt;= nums[high]) high--;</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P&lt;=nums[low]) low++;</span><br><span class="line">            nums[high] = nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = P;</span><br><span class="line">        <span class="keyword">return</span> low;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="227-Basic-Calculator-II"><a href="#227-Basic-Calculator-II" class="headerlink" title="227. Basic Calculator II"></a>227. Basic Calculator II</h1><h2 id="Description-基本计算器-二"><a href="#Description-基本计算器-二" class="headerlink" title="Description: 基本计算器(二)"></a>Description: 基本计算器(二)</h2><p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.</p>
<p>Example 1:</p>
<p>Input: “3+2*2”<br>Output: 7<br>Example 2:</p>
<p>Input: “ 3/2 “<br>Output: 1<br>Example 3:</p>
<p>Input: “ 3+5 / 2 “<br>Output: 5</p>
<h2 id="解法一-栈-1"><a href="#解法一-栈-1" class="headerlink" title="解法一: 栈"></a>解法一: 栈</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历字符串一遍, 遍历栈一遍<br><strong>空间复杂度:</strong> $O(n)$, 栈的大小</p>
<p>因为本题没有带括号, 因此优先级关系比较明朗, 可以简单的用栈来实现. 对于任意一个符号, 如果是加号或者减号, 就直接将其后面的数字入栈, 其中减号的情况需要给入栈数字加负号. 如果是乘号或除号, 将先从栈顶取出一个数字, 然后将该数字与符号后的数字进行计算, 并将计算结果入栈. 如此遍历, 直到遍历完所有字符, 最终将栈中的所有数字相加.<br>此题需要注意两个地方, 一是对于第一个数字, 需要在特别的将该数字前的符号对应成加号. 二是需要处理字符串中出现的空格.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; cal_s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); )&#123;</span><br><span class="line">            <span class="keyword">while</span>(i!=s.size() &amp;&amp; s[i] == <span class="string">' '</span>) i++; <span class="comment">// 跳过空格</span></span><br><span class="line">            <span class="keyword">if</span>(i==s.size()) <span class="keyword">break</span>; <span class="comment">// 达到字符串尾部, 直接跳出</span></span><br><span class="line">            <span class="keyword">char</span> op;</span><br><span class="line">            <span class="keyword">if</span>(cal_s.empty()) op = <span class="string">'+'</span>;</span><br><span class="line">            <span class="keyword">else</span>  op = s[i++];</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s[i] == <span class="string">' '</span>) i++; <span class="comment">// 跳过空格</span></span><br><span class="line">            <span class="keyword">while</span>( i!=s.size() &amp;&amp; s[i] &lt;= <span class="string">'9'</span> &amp;&amp; s[i] &gt;= <span class="string">'0'</span>)&#123;</span><br><span class="line">                num = num*<span class="number">10</span> + s[i++] - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> pre_num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>: cal_s.push(num); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>: cal_s.push(-num); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                    pre_num = cal_s.top(); cal_s.pop();</span><br><span class="line">                    cal_s.push(pre_num * num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                    pre_num = cal_s.top(); cal_s.pop();</span><br><span class="line">                    cal_s.push(pre_num / num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> op; <span class="comment">//error</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!cal_s.empty())&#123;</span><br><span class="line">            res += cal_s.top();</span><br><span class="line">            cal_s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-字符串流"><a href="#解法二-字符串流" class="headerlink" title="解法二: 字符串流"></a>解法二: 字符串流</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历每个字符<br><strong>空间复杂度:</strong> $O(1)$, 无需额外空间</p>
<p>字符串流可以自动的格式化读取字符串信息, 简化了代码编写量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(<span class="string">"+"</span>+s+<span class="string">"+"</span>)</span></span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>, pre_num = <span class="number">0</span>, num;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        <span class="keyword">while</span>(in&gt;&gt;op) &#123;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="string">'+'</span> <span class="keyword">or</span> op == <span class="string">'-'</span>) &#123;</span><br><span class="line">                sum += pre_num;</span><br><span class="line">                in &gt;&gt; pre_num;</span><br><span class="line">                <span class="keyword">int</span> sign = (op == <span class="string">'+'</span> ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">                pre_num *= sign;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                in &gt;&gt; num;</span><br><span class="line">                <span class="keyword">if</span> (op == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    pre_num *= num;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'/'</span>) &#123;</span><br><span class="line">                    pre_num /= num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="230-Kth-Smallest-Element-in-a-BST"><a href="#230-Kth-Smallest-Element-in-a-BST" class="headerlink" title="230. Kth Smallest Element in a BST"></a>230. Kth Smallest Element in a BST</h1><h2 id="Description-找出二叉搜索树中的最小元素"><a href="#Description-找出二叉搜索树中的最小元素" class="headerlink" title="Description: 找出二叉搜索树中的最小元素"></a>Description: 找出二叉搜索树中的最小元素</h2><p>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</p>
<p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p><strong>Follow up:</strong><br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>
<h2 id="解法一-非递归中根遍历"><a href="#解法一-非递归中根遍历" class="headerlink" title="解法一: 非递归中根遍历"></a>解法一: 非递归中根遍历</h2><p><strong>时间复杂度:</strong> $O(k)$, 遍历到第 $k$ 个元素为止<br><strong>空间复杂度:</strong> $O(k)$, 栈中最多存储 $k$ 个元素.</p>
<p>非递归中根遍历二叉搜索树, 当遍历到第k个元素时, 将其返回.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">1</span>) <span class="keyword">return</span> INT_MIN;<span class="comment">// error</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span> || !s.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">                cur = s.top(); s.pop();</span><br><span class="line">                <span class="keyword">if</span>(++count == k)&#123;</span><br><span class="line">                    <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INT_MIN;<span class="comment">// error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-递归中根遍历"><a href="#解法二-递归中根遍历" class="headerlink" title="解法二: 递归中根遍历"></a>解法二: 递归中根遍历</h2><p><strong>时间复杂度:</strong> $O(k)$<br><strong>空间复杂度:</strong> $O(k)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        helper(root, count, k, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode *root, <span class="keyword">int</span> &amp;count, <span class="keyword">int</span> &amp;k, <span class="keyword">int</span> &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==k || root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; <span class="comment">// 如果已经统计了k个, 则直接返回</span></span><br><span class="line">        helper(root-&gt;left, count, k, res);</span><br><span class="line">        <span class="keyword">if</span>(count==k) <span class="keyword">return</span>; <span class="comment">// 如果已经统计了k个, 则直接返回 // 加上该语句可省去后面的过程, 加速迭代结束, 当然不加也可以</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(++count == k)&#123; <span class="comment">// 访问当前节点</span></span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count!=k) helper(root-&gt;right, count, k, res); <span class="comment">// 如果已经统计了k个, 则不再遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>更简洁的写法:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; count, <span class="keyword">int</span> k, <span class="keyword">int</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        helper(root-&gt;left, count, k, res);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(k == count) &#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root-&gt;right, count, k, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        helper(root, count, k, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-二叉搜索"><a href="#解法三-二叉搜索" class="headerlink" title="解法三: 二叉搜索"></a>解法三: 二叉搜索</h2><p><strong>时间复杂度:</strong> $O(logn)+ O(n)$, 搜索的复杂度为树的高度, 但是计算count的复杂度为 $O(n)$.<br><strong>空间复杂度:</strong> $O(logn)$, 递归占用的空间, 若采用非递归实现, 则空间复杂度为 $O(1)$.</p>
<p>二叉搜索, 统计当前节点之前的元素个数, 如果大于 $k$, 则继续在左子树中搜索第 $k$ 小的元素, 如果 count 小于 $k$ , 则在右子树中搜索第 $k-count-1$ 小的元素.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = countNode(root-&gt;left); <span class="comment">// 左子树元素个数</span></span><br><span class="line">        <span class="keyword">if</span>(count+<span class="number">1</span> &gt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> kthSmallest(root-&gt;left, k);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count+<span class="number">1</span> &lt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> kthSmallest(root-&gt;right, k - count - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNode</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+countNode(root-&gt;left)+countNode(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解答Follow-up"><a href="#解答Follow-up" class="headerlink" title="解答Follow up"></a>解答Follow up</h2><p><strong>方法一:</strong></p>
<p>根据解法三我们可以知道, 在计算子树节点个数的时候 <code>int count = countNode(root-&gt;left);</code>, 有很多的重复计算, 因此, 我们可以修改树的结构定义, 使得每个节点都持有其左子树中的节点个数, 那么在查找第 $k$ 小的元素的时候, 就可以用 $O(1)$ 的时间复杂度获取到左子树的节点个数, 因此, 最终查询第 $k$ 小的时间复杂度变为 $O(logn)$.</p>
<p><strong>方法二:</strong></p>
<p>在中根遍历的同时, 用一个大小为 $k$ 的大顶堆(<code>priority_queue</code>), 这些可以将二叉搜索树中最小的 $k$ 个数存储起来, 并且可以用 $O(1)$ 的时间复杂度获取到第 $k$ 小的元素. (二叉搜索树的中根遍历下, 未遍历到的都是较大的元素, 因此无需遍历整个树, 只需要遍历到第 $k$ 个元素即可). 在对树进行修改时, 同步更新大顶堆, 前者时间复杂度为 $O(logn)$, 后者为 $O(logk)$.</p>
<h1 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a>236. Lowest Common Ancestor of a Binary Tree</h1><h2 id="Description-查找二叉树中任意两个节点的公共祖先"><a href="#Description-查找二叉树中任意两个节点的公共祖先" class="headerlink" title="Description: 查找二叉树中任意两个节点的公共祖先"></a>Description: 查找二叉树中任意两个节点的公共祖先</h2><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p>
<p>Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______3______</span><br><span class="line">    /              \</span><br><span class="line"> __5__           __1__</span><br><span class="line">/      \        /      \</span><br><span class="line">6       2       0       8</span><br><span class="line">       /  \</span><br><span class="line">      7   4</span><br></pre></td></tr></table></figure></p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of nodes 5 and 1 is 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>All of the nodes values will be unique.</li>
<li>p and q are different and both values will exist in the binary tree.</li>
</ul>
<h2 id="解法一-递归-9"><a href="#解法一-递归-9" class="headerlink" title="解法一: 递归"></a>解法一: 递归</h2><p><strong>时间复杂度:</strong> $O(n)$, 需遍历 $n$ 个节点.(任何情况下都需遍历n个节点)<br><strong>空间复杂度:</strong> $O(n)$, 需进行 $n$ 次递归调用.( $n$ 包含空节点)</p>
<p>对于最小公共祖先来说, 它相对于其他祖先有一个特点, 即节点 <code>p</code> 和 <code>q</code> 只可能是以下面三种情况分布在树中:</p>
<ul>
<li><code>p</code>和<code>q</code>分别处于当前节点的左子树 <strong>和</strong> 右子树之中.</li>
<li><code>p</code>为当前节点, <code>q</code>处于当前节点的左子树 <strong>或</strong> 右子树之中</li>
<li><code>q</code>为当前节点, <code>p</code>处于当前节点的左子树 <strong>或</strong> 右子树之中</li>
</ul>
<p>而对于其他祖先来说, <strong>绝对不可能出现上面三种情况</strong>, 因为 <strong><code>p</code>和<code>q</code>一定处于其他祖先的同一侧子树之中.</strong>, 即要么都处在右子树中, 要么都处在左子树中. 因此我们可以用<code>p</code>和<code>q</code>在当前节点构成的子树中的分布情况来判断是否为最小祖先.</p>
<p>**注意, 题目中说了<code>p, q</code>一定存在, 并且树中节点都是唯一的, 因此, 下面的代码无需对<code>p, q</code>进行存在性检查.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* res = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        res = <span class="literal">nullptr</span>;</span><br><span class="line">        recurseHelper(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">recurseHelper</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)  <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 遇到空节点, 说明没有目标节点               </span></span><br><span class="line">        <span class="keyword">int</span> left = recurseHelper(root-&gt;left, p, q) ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 左子树中有p或q</span></span><br><span class="line">        <span class="keyword">int</span> right = recurseHelper(root-&gt;right, p, q) ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 右子树中有p或q</span></span><br><span class="line">        <span class="keyword">int</span> mid =  (root==p || root==q) ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 找到了p或q, 这里相当于做了存在性检查</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( left+right+mid &gt;= <span class="number">2</span>) res = root; <span class="comment">// 如果左,右或当前节点中有两个以上为true, 则说明当前节点为最小公共祖先</span></span><br><span class="line">        <span class="keyword">return</span> (left+right+mid)&gt;<span class="number">0</span>; <span class="comment">// 只要不是空节点, 就可以返回 true.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面用了是将<code>res</code>作为成员函数进行赋值, 更好的做法是用指针引用.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        TreeNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">        lcaHelper(root, p, q, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lcaHelper</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q, TreeNode*&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> left= lcaHelper(root-&gt;left, p, q, res) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = lcaHelper(root-&gt;right, p, q, res) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (root == p || root == q) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left+right+mid &gt;= <span class="number">2</span>) res = root;</span><br><span class="line">        <span class="keyword">return</span> (left+right+mid) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="解法二-迭代-存储父节点"><a href="#解法二-迭代-存储父节点" class="headerlink" title="解法二: 迭代(存储父节点)"></a>解法二: 迭代(存储父节点)</h2><p><strong>时间复杂度:</strong> $O(n)$, 最坏需遍历 $n$ 个节点.<br><strong>空间复杂度:</strong> $O(n+n+n) = O(n)$, 栈, 哈希表, 集合的空间复杂度在最坏情况下均为 $O(n)$</p>
<p>如果我们能够获取到父节点, 那么我们就可以反向遍历<code>q</code>和<code>p</code>来访问他们的祖先节点. 那么, 第一个公共的祖先节点就一定是 LCA node. 我们可以将节点的父节点指针保存在一个字典(hash)当中. 具体的算法流程如下所示:</p>
<ol>
<li>从根节点开始遍历整个树(任意一种遍历算法都可以, 只要能找到<code>p</code>和<code>q</code>即可);</li>
<li>直到找到节点<code>p</code>和<code>q</code>之前, 将所有节点的父节点都保存在字典(hash)中;</li>
<li>一旦我们找到了<code>q</code>和<code>q</code>, 我们就将所有<code>p</code>的祖先节点放入了一个集合(set)当中;</li>
<li>然后, 我们反向遍历<code>q</code>的祖先节点, 当找到一个存在时集合中的祖先节点时, 该节点就是第一个公共的租店节点, 也就是 LCA node, 将其返回.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;TreeNode*, TreeNode*&gt; hash;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;TreeNode*&gt; ancestors;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            s.push(root);</span><br><span class="line">            hash.insert(&#123;root, <span class="literal">nullptr</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(hash.find(p) == hash.end() || hash.find(q) == hash.end()) &#123;</span><br><span class="line">            TreeNode* node = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                hash.insert(&#123;node-&gt;left, node&#125;);   </span><br><span class="line">                s.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                hash.insert(&#123;node-&gt;right, node&#125;);</span><br><span class="line">                s.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* parent = p;</span><br><span class="line">        <span class="keyword">while</span> (parent != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ancestors.insert(parent);</span><br><span class="line">            parent = hash[parent];   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* lcaNode = q;</span><br><span class="line">        <span class="keyword">while</span> (ancestors.find(lcaNode) == ancestors.end()) &#123;</span><br><span class="line">            lcaNode = hash[lcaNode];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lcaNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-迭代-不存储父节点"><a href="#解法三-迭代-不存储父节点" class="headerlink" title="解法三: 迭代(不存储父节点)"></a>解法三: 迭代(不存储父节点)</h2><p><strong>时间复杂度:</strong> $O(n)$, 最坏需遍历 $n$ 个节点.<br><strong>空间复杂度:</strong> $O(n)$, 采用后序遍历, 只需维护一个栈, 空间复杂度在最坏情况下为 $O(n)$</p>
<p>在解法二中, 我们是通过反向遍历的方法来查找 LCA 的, 实际上我们可以省去这一步, 直接要一个指针时刻指向可能的 LCA, 当我们找到<code>p</code>和<code>q</code>两个节点时, 我们可以直接返回当前的 LCA. 具体算法步骤如下:</p>
<ol>
<li>从根节点开始;</li>
<li>将<code>(root, root_state)</code>压入栈中, <code>root_state</code>定义了根节点的剩余的子节点是否可以被遍历;</li>
<li>当栈非空时, 查看栈顶元素<code>(parent_node, parent_state)</code>;</li>
<li>在遍历<code>parent_node</code>的任何子节点之前, 首先确认<code>parent_node</code>是否是节点<code>p</code>或<code>q</code>;</li>
<li>当首次找到<code>p</code>或<code>q</code>时, 将标志变量<code>one_node_found</code>设置为<code>True</code>. 同时根据栈中的节点跟踪 LCA (栈中的所有元素都是当前节点的祖先);</li>
<li>当再次找到<code>p</code>或<code>q</code>时, 说明我们已经将两个节点都找到了, 此时返回 LCA node.</li>
<li>无论何时访问<code>parent_node</code>的子节点, 都需要将<code>(parent_node, updated_parent_state)</code>更新到栈中.</li>
<li>A node finally gets popped off from the stack when the state becomes BOTH_DONE implying both left and right subtrees have been pushed onto the stack and processed. If one_node_found is True then we need to check if the top node being popped could be one of the ancestors of the found node. In that case we need to reduce LCA_index by one. Since one of the ancestors was popped off</li>
</ol>
<p>Whenever both p and q are found, LCA_index would be pointing to an index in the stack which would contain all the common ancestors between p and q. And the LCA_index element has the lowest ancestor common between p and q.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> &#123;</span></span><br><span class="line">        BOTH_PENDING = <span class="number">2</span>, <span class="comment">// 代表左右子节点均未访问</span></span><br><span class="line">        LEFT_DONE = <span class="number">1</span>, <span class="comment">// 代表已经访问了一个节点</span></span><br><span class="line">        BOTH_DONE = <span class="number">0</span> <span class="comment">// 代表两个子节点都已经访问, 当前节点可以出栈</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="built_in">std</span>::pair&lt;TreeNode*, State&gt; &gt; s;</span><br><span class="line">        s.push(<span class="built_in">std</span>::make_pair(root, State::BOTH_PENDING));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> one_node_found = <span class="literal">false</span>; <span class="comment">// 标记是否找到p或q</span></span><br><span class="line">        TreeNode* LCA = <span class="literal">nullptr</span>; <span class="comment">// 跟踪LCA</span></span><br><span class="line">        TreeNode* child_node = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> top  = s.top();</span><br><span class="line">            TreeNode* parent_node = top.first;</span><br><span class="line">            State parent_state = top.second;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (parent_state != State::BOTH_DONE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent_state == State::BOTH_PENDING) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent_node == p || parent_node == q) &#123;</span><br><span class="line">                        <span class="comment">// 找到了 p 或 q 中的一个, 如果是第二次找到, 则可以返回LCA</span></span><br><span class="line">                        <span class="comment">// 如果是第一次找到, 则更新 LCA.</span></span><br><span class="line">                        <span class="keyword">if</span> (one_node_found) &#123;</span><br><span class="line">                            <span class="keyword">return</span> LCA;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            one_node_found = <span class="literal">true</span>;</span><br><span class="line">                            LCA = parent_node;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 当状态为 BOTH_PENDING, 说明左右子树都没遍历, 应先遍历左子树</span></span><br><span class="line">                    child_node = parent_node-&gt;left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果状态为 LEFT_DONE, 说明已经遍历完左子树, 该遍历右子树</span></span><br><span class="line">                    child_node = parent_node-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                s.pop();</span><br><span class="line">                parent_state = <span class="keyword">static_cast</span>&lt;State&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(parent_state) - <span class="number">1</span>);</span><br><span class="line">                s.push(<span class="built_in">std</span>::make_pair(parent_node, parent_state));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (child_node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    s.push(<span class="built_in">std</span>::make_pair(child_node, State::BOTH_PENDING));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// state 为　BOTH_DONE, 说明当前节点可以出栈</span></span><br><span class="line">                <span class="comment">// 如果当前节点为LCA, 则需要更新LCA</span></span><br><span class="line">                <span class="keyword">auto</span> node = s.top().first;</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">if</span> (LCA == node &amp;&amp; one_node_found) &#123;</span><br><span class="line">                    LCA = s.top().first;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="238-Product-of-Array-Except-Self"><a href="#238-Product-of-Array-Except-Self" class="headerlink" title="238. Product of Array Except Self"></a>238. Product of Array Except Self</h1><h2 id="Description-计算数组内其他元素之积-不能使用除法"><a href="#Description-计算数组内其他元素之积-不能使用除法" class="headerlink" title="Description: 计算数组内其他元素之积(不能使用除法)"></a>Description: 计算数组内其他元素之积(不能使用除法)</h2><p>Given an array nums of n integers where n &gt; 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  [1,2,3,4]</span><br><span class="line">Output: [24,12,8,6]</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong> Please solve it without division and in O(n).</p>
<p><strong>Follow up:</strong><br>Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)</p>
<h2 id="解法一-借助辅助数组"><a href="#解法一-借助辅助数组" class="headerlink" title="解法一: 借助辅助数组"></a>解法一: 借助辅助数组</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历两次数组<br><strong>空间复杂度:</strong> $O(n)$, 额外申请 $n$ size 的数组(不计算 res 的空间占用)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; productExceptSelf(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; from_begin(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; from_end(n);</span><br><span class="line">        from_begin[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        from_end[n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            from_begin[i] = from_begin[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>]; <span class="comment">// from_begin[i] 为 nums[i] 之前的所有元素的乘积</span></span><br><span class="line">            from_end[ n-i<span class="number">-1</span>] = from_end[n-i] * nums[n-i]; <span class="comment">// from_end[i] 为 nums[i] 之后所有元素的乘积</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;n ; i++)&#123;</span><br><span class="line">            from_end[i] = from_begin[i] * from_end[i]; <span class="comment">// 用 nums[i] 之前的所有元素的乘积和 nums[i] 之后所有元素的乘积相乘</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> from_end;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-用一个变量代替数组"><a href="#解法二-用一个变量代替数组" class="headerlink" title="解法二: 用一个变量代替数组"></a>解法二: 用一个变量代替数组</h2><p><strong>时间复杂度:</strong> $O(n)$, 两次遍历<br><strong>空间复杂度:</strong> $O(1)$, 用变量代替数组</p>
<p>对解法一进行改写, 具体的做法是用一个变量来维护 from_begin 数组中的值(当然也可以选择代替 from_end)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; productExceptSelf(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="comment">// vector&lt;int&gt; from_begin(n);</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; from_end(n);</span><br><span class="line">        <span class="comment">// from_begin[0] = 1;</span></span><br><span class="line">        from_end[n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="comment">// from_begin[i] = from_begin[i-1] * nums[i-1]; // from_begin[i] 为 nums[i] 之前的所有元素的乘积</span></span><br><span class="line">            from_end[ n-i<span class="number">-1</span>] = from_end[n-i] * nums[n-i]; <span class="comment">// from_end[i] 为 nums[i] 之后所有元素的乘积</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> from_begin = <span class="number">1</span>; <span class="comment">// 用一个变量代替 from_begin 数组的作用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;n ; i++)&#123;</span><br><span class="line">            from_end[i] = from_begin * from_end[i]; <span class="comment">// 用 nums[i] 之前的所有元素的乘积和 nums[i] 之后所有元素的乘积相乘, 作为结果</span></span><br><span class="line">            from_begin = from_begin * nums[i]; <span class="comment">// 维护 from_begin的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> from_end;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-用两个变量代替数组"><a href="#解法三-用两个变量代替数组" class="headerlink" title="解法三: 用两个变量代替数组"></a>解法三: 用两个变量代替数组</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(1)$, 不计算结果数组的空间</p>
<p>观察到解法二的做法, 虽然将空间复杂度压缩到 $O(1)$, 但是仍然使用了两次<code>for</code>循环, 实际上, 我们可以同时用变量<code>from_begin</code>和变量<code>from_end</code>替换掉对应的数组, 并且同一个<code>for</code>循环中更新这两个变量, 如下所示.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; productExceptSelf(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> from_begin = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> from_end = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123; <span class="comment">// 同时从前后分别计算, from_begin记录i之前的元素之和, from_end记录i之后的元素之和</span></span><br><span class="line">            res[i] = from_begin * res[i];</span><br><span class="line">            from_begin = from_begin * nums[i];</span><br><span class="line">            res[n-i<span class="number">-1</span>] = from_end * res[n-i<span class="number">-1</span>];</span><br><span class="line">            from_end = from_end * nums[n-i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="240-Search-a-2D-Matrix-II"><a href="#240-Search-a-2D-Matrix-II" class="headerlink" title="240. Search a 2D Matrix II"></a>240. Search a 2D Matrix II</h1><h2 id="Description-矩阵搜索"><a href="#Description-矩阵搜索" class="headerlink" title="Description: 矩阵搜索"></a>Description: 矩阵搜索</h2><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<p>Integers in each row are sorted in ascending from left to right.<br>Integers in each column are sorted in ascending from top to bottom.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Consider the following matrix:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>Given target = 5, return true.</p>
<p>Given target = 20, return false.</p>
<h2 id="解法一-从左下角开始"><a href="#解法一-从左下角开始" class="headerlink" title="解法一: 从左下角开始"></a>解法一: 从左下角开始</h2><p><strong>时间复杂度:</strong> $O(n+m)$, 最多走 $n+m$ 步, $n$ 和 $m$ 分别为矩阵的宽和高<br><strong>空间复杂度:</strong> $O(1)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span> || matrix[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i=matrix.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>; <span class="comment">// 从左下角开始搜索</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&lt;matrix[<span class="number">0</span>].size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &lt; target) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &gt; target) i--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="279-Perfect-Squares"><a href="#279-Perfect-Squares" class="headerlink" title="279. Perfect Squares"></a>279. Perfect Squares</h1><h2 id="Description-找到最少的平方和个数"><a href="#Description-找到最少的平方和个数" class="headerlink" title="Description: 找到最少的平方和个数"></a>Description: 找到最少的平方和个数</h2><p>Given a positive integer n, find the <strong>least</strong> number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 12</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 12 = 4 + 4 + 4.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 13</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 13 = 4 + 9.</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-四平方和定理-最优"><a href="#解法一-四平方和定理-最优" class="headerlink" title="解法一: 四平方和定理(最优)"></a>解法一: 四平方和定理(最优)</h2><p><strong>时间复杂度:</strong> $O(\sqrt n)$, 最坏情况为 $O(\sqrt n)$, 最好情况为 $O(1)$.<br><strong>空间复杂度:</strong> $O(1)$, 无需额外空间</p>
<p><strong>四平方和定理:</strong>  任何一个正整数, 都可以表示成四个整数的平方和(如果不算 0 的话, 就是可以用小于等于 4 个整数的平方和来表示任意一个整数).</p>
<p>对于题目, 要求我们返回组合平方和的数字的 <strong>最少</strong> 个数(不算0), 因此, 这里还可以使用到两个特别的性质来加速计算:</p>
<ul>
<li>如果 $n$ 可以被 4 整除, 那么 $n$ 和 $n/4$ 的最少平方和数字个数相同.</li>
<li>如果 $n \% 8=7$, 那么 $n$ 的最少平方和个数一定为 4.</li>
</ul>
<p>因此, 本题的解法流程如下:</p>
<ol>
<li>循环整除 4, 降低 $n$ 的大小;</li>
<li>判断是否有 $n \% 8 =7$, 如果有, 则直接返回 4;</li>
<li>查看 $n$ 是否能够拆分成两个数(其中一个可以为0), 如果可以, 则返回 <code>!!i + !!j</code>, 即返回正整数的个数. 此处需要注意, <code>i</code> 需要从 0 开始遍历, 因为对于 $3^2+4^2 = 0^2 + 5^2 = 25$ 来说, 我们希望返回的是后者(即返回最少的平方和个数);</li>
<li>如果上面都不行, 则只可能反正 3(因为 $n&gt;0$).</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(n%<span class="number">4</span> == <span class="number">0</span>) n = n/<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">8</span> == <span class="number">7</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i*i&lt;=n; i++)&#123; <span class="comment">// i必须从0开始, 否则会找到其他组合, eg: 3^2 + 4^2 = 0^2 + 5^2</span></span><br><span class="line">            <span class="keyword">int</span> j = <span class="built_in">sqrt</span>(n - i * i);</span><br><span class="line">            <span class="keyword">if</span>(i*i + j*j == n)</span><br><span class="line">                <span class="keyword">return</span> !!i+!!j; <span class="comment">// 返回1(只有一个正整数)或2(两个都是正整数)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>; <span class="comment">//既不是4, 也不是1,2, 返回3(因为n&gt;0, 所以不可能返回0)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-DP-1"><a href="#解法二-DP-1" class="headerlink" title="解法二: DP"></a>解法二: DP</h2><p><strong>时间复杂度:</strong> $O(n\sqrt n)$, 外层循环约为 $n$ 次, 内层循环约为 $\sqrt n$ 次.<br><strong>空间复杂度:</strong> $O(n)$, 需要额外申请 $n+1$ 大小的 DP 数组.</p>
<p>对于解法一来说, 虽然它的时间和空间复杂度最优, 但是其中使用到了很多不常用的定理和性质, 如果不知道这些定理和性质, 很难想到解法一的实现. 因此, 我们更容易想到的是使用动态规划来解决这道题, 具体解题步骤如下:</p>
<ol>
<li>申请 $n+1$ 大小的 DP 数组, 并令 <code>dp[0]=0</code>, 令其他元素为 <code>INT_MAX</code>, <code>dp[i]</code> 的值代表组成数字 $i$ 所需的最少的平方和数字个数;</li>
<li>由于我们已经求得 <code>dp[0]</code> 的值, 因此, 对于 <code>j=1, 2, ...</code> 来说, 我们可以顺势求得 <code>dp[0+j*j] = dp[0]+1=1</code>.</li>
<li>对于已经求得的 <code>dp[i]</code>, 我们可以求得 <code>dp[i+j*j] = min(dp[i+j*j], dp[i]+1)</code>, 这里的 <code>min</code> 是为了保证组成数字的平方和个数最少.</li>
<li>最终, 返回 <code>dp.back()</code> 即为组成 $n$ 的最少的平方和个数.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>, INT_MAX);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>; <span class="comment">// 赋初值        </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; i+j*j &lt; n+<span class="number">1</span>; j++)&#123;</span><br><span class="line">                dp[i+j*j] = <span class="built_in">std</span>::min(dp[i+j*j], dp[i]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-DP-1"><a href="#解法三-DP-1" class="headerlink" title="解法三: DP"></a>解法三: DP</h2><p><strong>时间复杂度:</strong> $O(n\sqrt n)$, 外层循环约为 $n$ 次, 内层循环约为 $\sqrt n$ 次.<br><strong>空间复杂度:</strong> $O(n)$, 需要额外申请 $n+1$ 大小的 DP 数组.</p>
<p>复杂度和解法二没有区别, 但是我们可以从另一个角度来实现 DP 算法, 具体流程如下:</p>
<ol>
<li>申请只含有一个元素的 DP 数组 <code>dp[0]=0</code>;</li>
<li>根据 <code>dp[0]</code> 的值计算 <code>dp[1]</code>.(计算方法和解法二类似, 具体请看代码)</li>
<li>根据 <code>dp[0]~dp[i-1]</code> 的值计算 <code>dp[i]</code>.</li>
<li>当 <code>i==n</code> 时, 返回 <code>dp[i]</code>.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(dp.size()&lt;=n)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = dp.size(); <span class="keyword">int</span> val = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j*j &lt;= m; j++)&#123; <span class="comment">//这里必须 &lt;= m, 否则会缺少 dp[0]+1 的情况.</span></span><br><span class="line">                val = <span class="built_in">std</span>::min(val, dp[m - j*j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dp.push_back(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-递归"><a href="#解法四-递归" class="headerlink" title="解法四: 递归"></a>解法四: 递归</h2><p><a href="http://www.cnblogs.com/grandyang/p/4800552.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/4800552.html</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recrusion</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = n, num = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (num * num &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = n / (num * num), b = n % (num * num);</span><br><span class="line">            res = min(res, a + numSquares(b));</span><br><span class="line">            ++num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="287-Find-the-Duplicate-Number"><a href="#287-Find-the-Duplicate-Number" class="headerlink" title="287. Find the Duplicate Number"></a>287. Find the Duplicate Number</h1><h2 id="Description-寻找重复元素"><a href="#Description-寻找重复元素" class="headerlink" title="Description: 寻找重复元素"></a>Description: 寻找重复元素</h2><p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,4,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,3,4,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong></p>
<ul>
<li>You must not modify the array (assume the array is read only).</li>
<li>You must use only constant, O(1) extra space.</li>
<li>Your runtime complexity should be less than O(n2).</li>
<li>There is only one duplicate number in the array, but it could be repeated more than once.</li>
</ul>
<h2 id="解法一-哈希表"><a href="#解法一-哈希表" class="headerlink" title="解法一: 哈希表"></a>解法一: 哈希表</h2><p><strong>时间复杂度:</strong> $O(n)$, 一次遍历<br><strong>空间复杂度:</strong> $O(n)$, 哈希表额外空间</p>
<p>这道题用哈希表很容易解, 但是这是最简单的解法之一(更简单的还有暴力法), 因此这里贴出来只用做参考.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; nums_set;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums_set.find(num) != nums_set.end())</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            nums_set.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另一种解法是不建立哈希表, 而是利用数组的元素值和元素下标建立对应关系, 即将所有的数字放置在数字对应的下标位置上, 这样, 最终重复的元素就会出现的下标为 0 的位置上, 当然, 期间如果已经发现重复, 则可以直接返回, 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>] != nums[nums[<span class="number">0</span>]]) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[<span class="number">0</span>], nums[nums[<span class="number">0</span>]]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-排序"><a href="#解法二-排序" class="headerlink" title="解法二: 排序"></a>解法二: 排序</h2><p><strong>时间复杂度:</strong> $O(nlogn)$<br><strong>空间复杂度:</strong> $O(1)$ 或者 $O(n)$</p>
<p>先对数组排序, 然后遍历查找重复元素, 但是这种解法会改变原有数组中的元素分布, 题目要是数组是只读的, 因此该解法也只作为参考贴出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i+<span class="number">1</span>]) <span class="keyword">return</span> nums[i]; <span class="comment">// 一定存在重复元素, 因此 i+1 不会越界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-Floyd-的乌龟和兔子-Floy-判圈算法"><a href="#解法三-Floyd-的乌龟和兔子-Floy-判圈算法" class="headerlink" title="解法三: Floyd 的乌龟和兔子(Floy 判圈算法)"></a>解法三: Floyd 的乌龟和兔子(Floy 判圈算法)</h2><p>Floyd’s Tortoise and Hare, 该算法是用来判断链表中是否含有环的. 对于此题, 我们换一个角度来解读, 数组中总共有 $n+1$ 个数, 这些数都是 $[1,n]$ 中的正整数, 因此, 至少会存在一个重复的数, 根据题目的假设, 有且仅有一个重复的数字, 那么, 我们假设该数字为 $k$, 于是, 我们可以将该数组表示成下面的形式(表中的 $x$ 代表该元素的值不为 $k$ ):</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>下标</th>
<th>$0$</th>
<th>$1$</th>
<th>$2$</th>
<th>…</th>
<th>$k$</th>
<th>…</th>
<th>$n$</th>
</tr>
</thead>
<tbody>
<tr>
<td>元素</td>
<td>$x$</td>
<td>$k$</td>
<td>…</td>
<td>$k$</td>
<td>$x$</td>
<td>…</td>
<td>$x$</td>
</tr>
</tbody>
</table>
</div>
<p>如果我们将上面的 <code>(下标, 元素)</code> 看做是链表结构中的 <code>(val, next)</code>, 那么可以看出, 当某一个节点(上面假设为节点 1)的 <code>next</code> 指向 <code>k</code> 以后, <code>k</code> 又会重新指向另一个元素, 但是, 经过一定步数以后, <strong>一定</strong> 又会重新指向 <code>k</code> (因为元素存在重复), 这在链表中称之为 “环”, 因此, 这道题就变成了求链表中环的开始节点, 该题正好是<a href="../面试-算法刷题-剑指offer/#55">剑指offer第55题</a>和 <a href="#142">LeetCode第142题</a></p>
<p><strong>这道题有一个很关键的条件就是, 元素的值是在1~n之间, 因此, 下标 0 位置上的元素值一定不为 0, 只有这样, 我们才可以将下标 0 选做起点, 如果选取其他的下标坐标起点, 那么有可能在第一步就死循环了.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>; <span class="comment">// 实际上 fast 和 slow 可以指向环前的任意节点, 不影响最终结果.</span></span><br><span class="line">        <span class="keyword">do</span>&#123; <span class="comment">// 因为一定存在环, 所以fast不会越界</span></span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow!=fast);</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>; <span class="comment">// 求环长度</span></span><br><span class="line">        fast = nums[fast];</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">            len ++;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">            fast = nums[fast]; <span class="comment">// 先让fast走环长的距离</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123; <span class="comment">// 再次相遇时即为环的开始节点</span></span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>更简洁的写法:</strong><br>上面在求环的开始节点时, 是先求环长, 再让 <code>fast</code> 走环长距离, 然后 <code>slow</code> 和 <code>fast</code> 同步前进, 最终相遇点即为开始点, 这么写比较容易理解, 但难免有些繁琐. 实际上, 我们只需要令 <code>slow</code> 从头开始, 即 <code>slow=0</code>, 接着令 <code>fast</code> 和 <code>slow</code> 同步前进, 那么相遇点就是开始节点. 原因是因为, 二者是从同一点出发的, fast 的步长较快, 当二者相遇时, 他们一定是在环中的某一点相遇, 这个时候再把slow重新放回起点, 那么fast领先slow的距离就等于: 环外的距离 + 若干圈 + 当前圈内已经走的距离. 而此时 fast 距离环入口还有一段距离, 因为第一次相遇点的位置, 因此, 我们如果此时从起点出发, 最终正好可以弥补这一部分距离, 因此, 最终会在环入口相遇.</p>
<p><strong>一句话总结: 令fast和slow一起开始, fast步长是slow步长的二者, 找到二者相遇的点, 然后令slow重新回到起点, 此时步长一致, 再次相遇时即为环的入口点</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>; <span class="comment">// head;</span></span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>; <span class="comment">// head-&gt;next; 指向head也没错, 因为, 最终仍会slow=fast</span></span><br><span class="line">        <span class="keyword">do</span>&#123; <span class="comment">// 因为一定存在环, 所以fast不会越界</span></span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow!=fast);</span><br><span class="line"></span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="289-Game-of-Life"><a href="#289-Game-of-Life" class="headerlink" title="289. Game of Life"></a>289. Game of Life</h1><h2 id="Description-游戏人生"><a href="#Description-游戏人生" class="headerlink" title="Description: 游戏人生"></a>Description: 游戏人生</h2><p>According to the Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”</p>
<p>Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p>
<ol>
<li>Any live cell with fewer than two live neighbors dies, as if caused by under-population.</li>
<li>Any live cell with two or three live neighbors lives on to the next generation.</li>
<li>Any live cell with more than three live neighbors dies, as if by over-population..</li>
<li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</li>
</ol>
<p>Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,1],</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,1,1],</span><br><span class="line">  [0,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p><strong>Follow up:</strong></p>
<ol>
<li>Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.</li>
<li>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?</li>
</ol>
<h2 id="解法一-状态机"><a href="#解法一-状态机" class="headerlink" title="解法一: 状态机"></a>解法一: 状态机</h2><p><strong>时间复杂度:</strong> $O(mn)$, 遍历两次二维数组<br><strong>空间复杂度:</strong> $O(1)$, 无需额外空间</p>
<p>根据细胞的更新规则, 我们可以设计出下面的状态转移:<br>0: 从 0 到 0;<br>1: 从 1 到 1:<br>2: 从 1 到 0;<br>3: 从 0 到 1;</p>
<p>因此, 本解法需要遍历两边 <code>board</code> 矩阵, 第一遍先计算每个 cell 的状态, 第二遍根据状态赋予 cell 不同的值, 具体来说就是如果当前状态 <code>board[i][j]%2==0</code>, 那么就令 <code>board[i][j]=0</code>, 反之, 令 <code>board[i][j]=1</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size()==<span class="number">0</span> || board[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> n = board.size();</span><br><span class="line">        <span class="keyword">int</span> m = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> direct[<span class="number">8</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                          &#123; <span class="number">0</span>,<span class="number">-1</span>&#125;,          &#123; <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                          &#123; <span class="number">1</span>,<span class="number">-1</span>&#125;, &#123; <span class="number">1</span>, <span class="number">0</span>&#125;, &#123; <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> count_1 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">8</span>; k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> i_k = i+direct[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> j_k = j+direct[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(i_k&gt;=<span class="number">0</span> &amp;&amp; i_k&lt;n &amp;&amp; j_k&gt;=<span class="number">0</span> &amp;&amp; j_k&lt;m</span><br><span class="line">                       &amp;&amp; (board[i_k][j_k]==<span class="number">1</span> || board[i_k][j_k]==<span class="number">2</span>) )</span><br><span class="line">                        count_1++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( (count_1&lt;<span class="number">2</span> || count_1&gt;<span class="number">3</span>) &amp;&amp; board[i][j]==<span class="number">1</span>)</span><br><span class="line">                    board[i][j] = <span class="number">2</span>; <span class="comment">// 2:1-&gt;0, 0:0-&gt;0</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(count_1==<span class="number">3</span> &amp;&amp; board[i][j]==<span class="number">0</span>)</span><br><span class="line">                    board[i][j] = <span class="number">3</span>; <span class="comment">// 3:0-&gt;1</span></span><br><span class="line">                <span class="comment">// 剩余情况维持不变</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;cells : board)&#123; <span class="comment">// 如果要对board进行修改, 需要使用引用号 &amp;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;cell : cells)</span><br><span class="line">                <span class="keyword">if</span>(cell%<span class="number">2</span>==<span class="number">1</span>) cell=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> cell=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up"></a>Follow up</h2><ol>
<li>常数空间复杂度: 正如解法一</li>
<li>无边界限制: 修改边界空间条件, 使其变成 “循环” 二维矩阵.</li>
</ol>
<h1 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a>300. Longest Increasing Subsequence</h1><h2 id="Description-求最长递增序列-可以不连续-的长度"><a href="#Description-求最长递增序列-可以不连续-的长度" class="headerlink" title="Description: 求最长递增序列(可以不连续)的长度"></a>Description: 求最长递增序列(可以不连续)的长度</h2><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [10,9,2,5,3,7,101,18]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong></p>
<ul>
<li>There may be more than one LIS combination, it is only necessary for you to return the length.</li>
<li>Your algorithm should run in O(n2) complexity.</li>
</ul>
<p><strong>Follow up:</strong><br>Could you improve it to O(n log n) time complexity?</p>
<h2 id="解法一-暴力-3"><a href="#解法一-暴力-3" class="headerlink" title="解法一: 暴力"></a>解法一: 暴力</h2><p><strong>时间复杂度:</strong> $O(2^n)$<br><strong>空间复杂度:</strong> $O(n^2)$</p>
<p>对于任意一个数字, 只有两种情况, 即处于最长递增数组内, 或者不处于最长递增数组内, 需要同时将这两种情况考虑, 然后选择最长的情况. 该方法时间超限.</p>
<h2 id="解法二-Recursion-with-memorization-Memory-Limit-Exceeded"><a href="#解法二-Recursion-with-memorization-Memory-Limit-Exceeded" class="headerlink" title="解法二: Recursion with memorization [Memory Limit Exceeded]"></a>解法二: Recursion with memorization [Memory Limit Exceeded]</h2><h2 id="解法三-DP-2"><a href="#解法三-DP-2" class="headerlink" title="解法三: DP"></a>解法三: DP</h2><p>分析题目可以得出, 第 $i$ 个下标对应的数字是否存在于递增序列中, 与该下标之后的元素是无关的, 因此, 很自然的想到利用 DP 的方法来解决这道题. 我们令 <code>dp[i]</code> 代表 <strong>包含第 $i$ 个下标对应元素的递增序列的长度.</strong> 在求取 <code>dp[i+1]</code> 时, 我们需要遍历前面 <code>dp[0~i]</code> 个数组元素才能决定 <code>dp[i+1]</code> 的值, 因此, 时间复杂度为 $O(n^2)$, 空间复杂度为 $O(n)$. (比递归方法好很多).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(nums.size(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res_max=<span class="number">1</span>; <span class="comment">// 记录最长的递增序列长度, 因为最少有一个元素, 所以长度最少为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> max_val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123; <span class="comment">// 只有当当前元素大于前面的元素时, 才能构成递增序列</span></span><br><span class="line">                    max_val = <span class="built_in">std</span>::max(max_val, dp[j]);<span class="comment">//当前元素与nums[j]可以组成递增序列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = max_val+<span class="number">1</span>; <span class="comment">// 将当前元素加入, 因此, 长度增1</span></span><br><span class="line">            res_max = <span class="built_in">std</span>::max(res_max, dp[i]); <span class="comment">//用当前长度更新最长长度的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res_max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法四-DP-二分搜索-最优"><a href="#解法四-DP-二分搜索-最优" class="headerlink" title="解法四: DP+二分搜索(最优)"></a>解法四: DP+二分搜索(最优)</h2><p><strong>时间复杂度:</strong> $O(nlogn)$, 每次搜索的复杂度为 $O(logn)$, 总共需要搜索 $n$ 次<br><strong>空间复杂度:</strong> $O(m)$, $m$ 为最长递增序列的长度.</p>
<p>同样还是 DP 解法, 但是我们重新赋予 <code>dp[]</code> 数组另一个含义, 我们令 <code>dp[]</code> 数组内储存的元素的数量刚好等于当前最长递增序列的数量, <strong>注意, <code>dp[]</code> 数组内的值不一定是递增序列的值</strong>. 核心算过过程如下所示:</p>
<ol>
<li>初始时, 令 <code>dp[]</code> 数组为空, 即 <code>dp=[]</code>;</li>
<li>对于每一个元素 <code>num</code>, 我们查找 <code>num</code> 在 <code>dp</code> 数组中的 <code>upper_bound</code> 迭代器(首个大于 <code>num</code> 的元素的迭代器), 假设取名为 <code>upper</code>;(<strong>注意</strong>, <code>dp</code> 数组是有序的, 所以这里的查询复杂度为 $O(logn)$)</li>
<li>查看 <code>upper-1</code> 指向的元素是否和 <code>num</code> 相等, 如果相等, 则说明该元素已经存在, 那么就跳过该元素, 重新回到步骤2;</li>
<li>如果 <code>num</code> 大于 <code>dp</code> 数组内的所有元素, 则将 <code>num</code> 添加进 <code>dp</code> 数组; 否则, 就将 <code>dp</code> 数组中大于 <code>num</code> 的第一个元素的值赋为 <code>num</code>.</li>
<li>重复步骤2,3,4, 直到遍历完数组为止.</li>
</ol>
<p>为了更好的解释这种解法, 我们通过举例进行说明, 假定输入的数字序列为: <code>[4,10,3,4,10,3,2]</code>, 那么我们的 <code>dp[]</code> 数组的变化情况如下:</p>
<p><code>dp=[]</code>,初始时, 数组为空;<br><code>dp=[4]</code>, 遍历元素4, 加入到数组中;<br><code>dp=[4,10]</code>, 遍历元素10, 10大于所有元素, 将其添加到数组中;<br><code>dp=[3,10]</code>, 遍历元素3, 发现第一个大于3的值为4, 将其赋值为3;<br><code>dp=[3,4]</code>, 遍历元素4, 发现第一个大于4的的值为10, 将其赋值为4;<br><code>dp=[3,4,10]</code>, 遍历元素10, 10大于所有元素, 将其添加到数组中;<br><code>dp=[3,4,10]</code>, 遍历元素3, 3在数组中已经存在, 跳过该元素;<br><code>dp=[2,4,10]</code>, 遍历元素2, 发现第一个大于2个值为3, 将其赋值为2.</p>
<p>综上, 我们可以看到, <code>dp</code> 数组的长度始终等于当前数组的最长子序列的长度, 故而, 直接返回 <code>dp.size()</code> 即为最终的结果. <strong>注意, <code>dp</code> 内的值不一定为递增子序列的值.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">auto</span> upper = <span class="built_in">std</span>::upper_bound(dp.begin(), dp.end(), num);</span><br><span class="line">            <span class="keyword">if</span>(upper!=dp.begin() &amp;&amp; *(upper<span class="number">-1</span>) == num) <span class="keyword">continue</span>; <span class="comment">// 如果num在dp数组中已经存在, 则跳过该num.</span></span><br><span class="line">            <span class="keyword">if</span>(upper==dp.end())&#123;</span><br><span class="line">                    dp.push_back(num); <span class="comment">// 当前num比dp数组内的所有值都大, 则添加进dp数组</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                *upper = num; <span class="comment">// 用更小的值替代当前dp数组内的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.size(); <span class="comment">// 最终, dp数组的长度即为最长递增序列的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a>322. Coin Change</h1><h2 id="Description-硬币凑面额"><a href="#Description-硬币凑面额" class="headerlink" title="Description: 硬币凑面额"></a>Description: 硬币凑面额</h2><p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: coins = [1, 2, 5], amount = 11</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: coins = [2], amount = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-DP-1"><a href="#解法一-DP-1" class="headerlink" title="解法一: DP"></a>解法一: DP</h2><p><strong>时间复杂度:</strong> $O(nm)$, $n$ 为总面额的大小, $m$ 为硬币的数量.<br><strong>空间复杂度:</strong> $O(n)$, DP 数组的大小为总面额的大小.</p>
<p>当我们求组成面额 $i$ 时所需的最少硬币数时, 我们可以用面额 $j$ 和面额 $i-j$ ($j\in[0,i]$)所需的硬币数之和来代替, 因此, 也就是说只与 $i$ 之前的面额数有关, 所以我们可以考虑使用 DP 算法来求解. 我们令 <code>dp[i]</code> 代表组成面额 $i$ 时所需的最少的硬币数, 要求 <code>dp[i]</code>, 我们可以根据硬币的面额来求解, 假设硬币的面额是 $j$, 那么就有 <code>dp[i] = min(dp[j] + dp[i-j])</code>, 其中 <code>dp[j]=1</code>, 因为组成这种面额只需要一个硬币就可以了, 我们根据此公式就可以写出相应的 DP 代码, 如下所示.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为不可能为负值, 所以使用无符号整数, 防止溢出</span></span><br><span class="line">        <span class="comment">// 额外多了一个0面额, 初值也可以设置为 amount+1, 因为最多的硬币数就是amount个1元.</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; dp(amount+<span class="number">1</span>, amount+<span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 为面额0赋初值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;amount+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> ci=<span class="number">0</span>; ci&lt;coins.size(); ci++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = coins[ci];</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= j) dp[i] = <span class="built_in">std</span>::min(dp[i], <span class="number">1</span>+dp[i-j]); <span class="comment">// 注意不能少了if语句, 否则会运行时错误</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span> : dp[amount];        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你可能会觉得我们进行了一些无用计算, 例如如果 $i$ 为 11, 而 <code>coins</code> 为 [1,5], 那么我们是否只需要计算 dp[6] 就可以了呢? 实际上, 如果有面额为 1 的硬币存在, 那么我们就必须计算所有的小于 $i$ 的dp值, 因为这些都是解, 至于是否为最小数量, 则需要利用 min 来不断筛选.</p>
<h2 id="解法二-DP-递归实现"><a href="#解法二-DP-递归实现" class="headerlink" title="解法二: DP 递归实现"></a>解法二: DP 递归实现</h2><p><strong>时间复杂度:</strong> $O(nm)$, $n$ 为总面额的大小, $m$ 为硬币的数量.<br><strong>空间复杂度:</strong> $O(n+n)=O(n)$, DP 数组的大小为总面额的大小, 另外, 递归还需额外占用一定空间.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount+<span class="number">1</span>, INT_MAX);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> coin_dfs(coins, amount, dp);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coin_dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;coins, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// invalid combination</span></span><br><span class="line">        <span class="keyword">if</span>(dp[target] != INT_MAX) <span class="keyword">return</span> dp[target]; <span class="comment">// already computed, return it</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;coins.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = coin_dfs(coins, target-coins[i], dp);</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;=<span class="number">0</span>) dp[target] = min(dp[target], <span class="number">1</span>+tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[target] = (dp[target] == INT_MAX) ? <span class="number">-1</span> : dp[target];</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-对暴力解法剪枝"><a href="#解法三-对暴力解法剪枝" class="headerlink" title="解法三: 对暴力解法剪枝"></a>解法三: 对暴力解法剪枝</h2><p><strong>时间复杂度:</strong> $O(logn+mlogm)$, 每次都用当前面额除以硬币面额, 故时间复杂度为 $O(logn)$, $O(mlogm)$ 为对硬币面额的排序复杂度, 当 $m&lt;&lt;n$ 时, 可忽略不计.<br><strong>空间复杂度:</strong> $O(logn)$, 无需申请额外空间, 仅仅是递归过程需要占用空间.</p>
<p>下面的方法利用余数对暴力解法进行剪枝, 剪枝后的程序运行速度十分快, 远远快于前两个算法.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX; <span class="comment">// results count</span></span><br><span class="line">        <span class="keyword">int</span> n = coins.size();</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>; <span class="comment">// current count</span></span><br><span class="line">        <span class="built_in">std</span>::sort(coins.begin(), coins.end()); <span class="comment">// sort from small to large</span></span><br><span class="line">        helper(coins, amount, n<span class="number">-1</span>, cur, res);</span><br><span class="line">        <span class="keyword">return</span> res==INT_MAX ? <span class="number">-1</span> : res;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;coins, <span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="keyword">int</span> cur, <span class="keyword">int</span> &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target%coins[start]==<span class="number">0</span>)&#123; <span class="comment">// 如果可以整除, 说明找到了合适的组合</span></span><br><span class="line">            res = min(res, cur+target/coins[start]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=target/coins[start]; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur+i &gt;= res<span class="number">-1</span>)</span><br><span class="line">                <span class="comment">// 如果当前的硬币数已经超过了 res-1, 说明之后肯定需要更多的硬币,</span></span><br><span class="line">                <span class="comment">// 因为后面的硬币面额变小了, 所以需要至少cur+i+1个硬币才能凑齐</span></span><br><span class="line">                <span class="comment">// 因此, 无需再进行循环, 直接跳出即可</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(start&gt;<span class="number">0</span>) <span class="comment">// start不能为负值, 因此start要大于0才能继续递归</span></span><br><span class="line">                helper(coins, target-i*coins[start], start<span class="number">-1</span>, cur+i, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于此算法的更详细解释(<a href="http://www.cnblogs.com/grandyang/p/5138186.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/5138186.html</a>):<br>难道这题一定要DP来做吗, 我们来看网友hello_world00提供的一种解法, 这其实是对暴力搜索的解法做了很好的优化, 不仅不会TLE, 而且击败率相当的高！对比Brute Force的方法, 这里在递归函数中做了很好的优化. 首先是判断start是否小于0, 因为我们需要从coin中取硬币, 不能越界. 下面就是优化的核心了, 看target是否能整除coins[start], 这是相当叼的一步, 比如假如我们的目标值是15, 如果我们当前取出了大小为5的硬币, 我们做除法, 可以立马知道只用大小为5的硬币就可以组成目标值target, 那么我们用cur + target/coins[start] 来更新结果res. 之后的for循环也相当叼, 不像暴力搜索中的那样从start位置开始往前遍历coins中的硬币, 而是遍历 target/coins[start] 的次数, 由于不能整除, 我们只需要对余数调用递归函数, 而且我们要把次数每次减1, 并且再次求余数. 举个例子, 比如coins=[1,2,3], amount=11, 那么 11除以3, 得3余2, 那么我们的i从3开始遍历, 这里有一步非常有用的剪枝操作, 没有这一步, 还是会TLE, 而加上了这一步, 直接击败百分之九十九以上, 可以说是天壤之别. 那就是判断若 cur + i &gt;= res - 1 成立, 直接break, 不调用递归. 这里解释一下, cur + i 自不必说, 是当前硬币个数cur 加上新加的i个硬币, 我们都是知道cur+i如果大于等于res的话, 那么res是不会被更新的, 那么为啥这里是大于等于res-1呢？因为能运行到这一步, 说明之前是无法整除的, 那么余数一定存在, 所以再次调用递归函数的target不为0, 那么如果整除的话, cur至少会加上1, 所以又跟res相等了, 还是不会使得res变得更小.</p>
<h1 id="324-Wiggle-Sort-II"><a href="#324-Wiggle-Sort-II" class="headerlink" title="324. Wiggle Sort II"></a>324. Wiggle Sort II</h1><h2 id="Description-“驼峰”-排序"><a href="#Description-“驼峰”-排序" class="headerlink" title="Description: “驼峰” 排序"></a>Description: “驼峰” 排序</h2><p>Given an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]….</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1, 5, 1, 1, 6, 4]</span><br><span class="line">Output: One possible answer is [1, 4, 1, 5, 1, 6].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1, 3, 2, 2, 3, 1]</span><br><span class="line">Output: One possible answer is [2, 3, 1, 3, 1, 2].</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>You may assume all input has valid answer.</p>
<p><strong>Follow Up:</strong><br>Can you do it in O(n) time and/or in-place with O(1) extra space?</p>
<h2 id="解法一-排序"><a href="#解法一-排序" class="headerlink" title="解法一: 排序"></a>解法一: 排序</h2><p><strong>时间复杂度:</strong> $O(nlogn + n)$, 排序的时间复杂度为 $O(nlogn)$, 构造 “驼峰” 数组的复杂度为 $O(n)$<br><strong>空间复杂度:</strong> $O(n)$, 额外数组需要占用 $O(n)$ 空间</p>
<p>该问题的解法可能有多个, 我们只需要找到其中一个即可, 核心思路是将一个数组分成两半, 其中前一半的元素都小于后一半的元素, 然后我们只需要依次从两个数组中取值组成新数组, 就可以满足 “驼峰” 排序.<br>首先, 对数组中的元素排序, 这样, 任意的相邻元素, 都满足 <code>nums[i] &lt;= nums[i+1]</code>, 我们将数组分成两半, 这样, 前半段的元素都小于等于后半段的元素, <strong>注意, 题目中已经指明数组是合法的有效数组, 所以一定可以组成驼峰</strong>, 因此, 我们先取前半段的最后一个元素, 再取后半段的最后一个元素, 这两个元素一定满足绝对小于关系(否则无法形成 “驼峰”), 然后我们再取倒数第二个, 依次类推, 直至取完. <strong>注意, 我们不能从前往后取, 因为不能保证前半段的第二个元素绝对小于后半段的第一个元素, 例如[4,5,5,6], 从前往后取就会变成[4,5,5,6], 不符合驼峰, 从后往前取为[5,6,4,5], 符合驼峰</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> mid = (nums.size()+<span class="number">1</span>)/<span class="number">2</span>; <span class="comment">// 令mid指向中间的位置</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid<span class="number">-1</span>, j=nums.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span> ; i--, j--)&#123; <span class="comment">// 从后往前选择元素, 分别放到tmp中</span></span><br><span class="line">            tmp.push_back(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=mid) tmp.push_back(nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        nums = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-partition"><a href="#解法二-partition" class="headerlink" title="解法二: partition"></a>解法二: partition</h2><p><strong>时间复杂度:</strong> $O(n+n)= O(n)$, 查找中位数需要 $O(n)$, 填充数组需要 $O(n)$.<br><strong>空间复杂度:</strong> $O(n)$, 填充时使用了额外的数组空间来辅助.</p>
<p>如果当数组中的元素不含有重复时, 此题很容易就用基于 partition 的方法解决, 因为, 我们可以找到将数组分成两个具有绝对小于关系的数组, 然后依次用两个数组填充即可, 但是, 此题的元素是可重复的, 所以必须考虑重复元素的影响.<br>首先我们利用 <code>nth_element()</code> 找到中位数, 虽然 <code>nth_element()</code> 的时间复杂度已经不是 $O(n)$, 但是这里我们为了简化代码, 仍然使用 <code>nth_element()</code> 来查找中位数 <code>mid</code>(后面也会更多稍复杂一点的 partition 算法, 面试时建议使用 <code>nth_element</code>, 注意要向面试官说明复杂度问题), 之后, 对于其他的任意一个数组元素, 都有三种不同的情况:</p>
<ul>
<li>大于 <code>mid</code>, 将大于 <code>mid</code> 的元素放在数组开始的奇数位上面;</li>
<li>小于 <code>mid</code>, 将小于 <code>mid</code> 的元素放在数组的偶数位上面;</li>
<li>等于 <code>mid</code>, 用所有等于 <code>mid</code> 的元素填充剩下的位置.</li>
</ul>
<p>由于题目指明输入的数组一定是有效的, 因此当我们进行了上面遍历后, 数组一定会变成 “驼峰” 数组, 因为当和 <code>mid</code> 相等的元素处于 “驼峰” 底部时, 它一定位于偶数位(奇数位都是大于 <code>mid</code> 的元素), 同理, 当 <code>mid</code> 处于 “驼峰” 顶部时, 它一定位于奇数位, 因为偶数位都被小于 <code>mid</code> 的元素填充. 故最终的数组是 “驼峰” 数组.</p>
<p><strong>nth_element()</strong>(该函数在 C++17 后不是 $O(n)$, 而是 $O(nlogn)$, 但是在 C++11 中仍然是 $O(n)$):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">std</span>::nth_element(nums.begin(), nums.begin()+n/<span class="number">2</span>, nums.end());</span><br><span class="line">        <span class="keyword">int</span> mid = nums[n/<span class="number">2</span>]; <span class="comment">// 找到中位数</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, mid); <span class="comment">// 先将所有元素置为中位数</span></span><br><span class="line">        <span class="keyword">int</span> even_i = (n<span class="number">-1</span>)/<span class="number">2</span>*<span class="number">2</span>; <span class="comment">// 令 even_i 指向数组的最后一个偶数位</span></span><br><span class="line">        <span class="keyword">int</span> odd_i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; mid)&#123; <span class="comment">// 将大于中位数的放到前面的奇数位上</span></span><br><span class="line">                res[odd_i] = nums[i];</span><br><span class="line">                odd_i += <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; mid)&#123; <span class="comment">//将小于中位数的放到后面的偶数位上</span></span><br><span class="line">                res[even_i] = nums[i];</span><br><span class="line">                even_i -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// 剩下的位置都是中位数</span></span><br><span class="line">        nums = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>自己利用partition实现 $O(n)$ 的中位数查找:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> P = nums[low];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P &lt;= nums[high]) high--;</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P &gt;= nums[low]) low++;</span><br><span class="line">            nums[high] = nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = P;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> target = n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = partition(nums, low, high);</span><br><span class="line">            <span class="keyword">if</span>(m &lt; target) low = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m &gt; target) high = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = nums[target]; <span class="comment">// 找到中位数</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, mid); <span class="comment">// 先将所有元素置为中位数</span></span><br><span class="line">        <span class="keyword">int</span> even_i = (n<span class="number">-1</span>)/<span class="number">2</span>*<span class="number">2</span>; <span class="comment">// 令 even_i 指向数组的最后一个偶数位</span></span><br><span class="line">        <span class="keyword">int</span> odd_i = <span class="number">1</span>; <span class="comment">// 指向第一个奇数位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; mid)&#123; <span class="comment">// 将大于中位数的放到前面的奇数位上</span></span><br><span class="line">                res[odd_i] = nums[i];</span><br><span class="line">                odd_i += <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; mid)&#123; <span class="comment">//将小于中位数的放到后面的偶数位上</span></span><br><span class="line">                res[even_i] = nums[i];</span><br><span class="line">                even_i -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// 剩下的位置都是中位数</span></span><br><span class="line">        nums = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Follow-up-three-way-partition"><a href="#Follow-up-three-way-partition" class="headerlink" title="Follow up: three-way partition"></a>Follow up: three-way partition</h2><p><strong>时间复杂度:</strong> $O(n+n) = O(n)$, 找中位数时的复杂度为 $O(n)$, 调整数组的复杂度为 $O(n)$.<br><strong>空间复杂度:</strong> $O(1)$, 无需占用额外空间</p>
<p>解法二的时间复杂度满足要求, 问题在于我们如何能够在 $O(1)$ 的空间复杂度限制下, 完成数组的填充工作, 很自然的我们可以想到利用 <code>swap</code> 来实现, 具体流程如下所示:</p>
<ol>
<li>先令 <code>even_i</code> 指向数组的最后一个偶数位(从0位开始, 0算作偶数位), 令 <code>odd_i</code> 指向第一个奇数位(下标为1). 我们从最后一个偶数位元素(用下标 <code>i</code> 指示)开始进行判断;</li>
<li>如果 <code>nums[i]&lt;mid</code>, 则将 <code>nums[i]</code> 与 <code>nums[even_i]</code> 交换, 交换后, <code>even_i</code> 不可再被访问, 令 <code>even_i -= 2</code>, <strong>同时注意, 由于刚开始的时候 <code>i</code> 与 <code>even_i</code> 是相等的, 故也要令 <code>i -= 2</code>, 当 <code>i&lt;0</code> 以后, 要令 <code>i</code> 指向最后一个奇数位</strong>.</li>
<li>如果 <code>nums[i]&gt;mid</code>, 则将 <code>nums[i]</code> 与 <code>nums[odd_i]</code> 交换, 同时令 <code>odd_i += 2</code>, 注意, 此时, <code>i</code> 指向的数字是交换后的原来 <code>odd_i</code> 指向的数字, 因此, 我们需要对该数字进行判断, <strong>故不能改变 <code>i</code> 的值.</strong></li>
<li>如果和 <code>mid</code> 相等, 则无需进行交换填充, 令其保存原值即可, 判断下一个元素, 令 <code>i -=2</code>, 同时还要判断 <code>i</code> 是否小于 0, 若小于, 则需令 <code>i</code> 指向最后的奇数位.</li>
</ol>
<p><strong>nth_element():</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">std</span>::nth_element(nums.begin(), nums.begin()+n/<span class="number">2</span>, nums.end());</span><br><span class="line">        <span class="keyword">int</span> mid = nums[n/<span class="number">2</span>]; <span class="comment">// 找到中位数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(1) 空间复杂度填充数组</span></span><br><span class="line">        <span class="keyword">int</span> even_i = (n<span class="number">-1</span>)/<span class="number">2</span>*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> odd_i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = even_i; <span class="comment">// 令i指向最后一个偶数位</span></span><br><span class="line">        <span class="keyword">int</span> count = n;</span><br><span class="line">        <span class="keyword">while</span>(count--)&#123; <span class="comment">//每次都会判断一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; mid)&#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[i], nums[even_i]);</span><br><span class="line">                even_i -= <span class="number">2</span>;</span><br><span class="line">                i -= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">0</span>) i = n/<span class="number">2</span>*<span class="number">2</span> - <span class="number">1</span>; <span class="comment">// 令 i 指向最后一个奇数位</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; mid)&#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[i], nums[odd_i]);</span><br><span class="line">                odd_i += <span class="number">2</span>; <span class="comment">// 奇数位增加</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 保持原值不变, 判断下一个值</span></span><br><span class="line">                i -= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">0</span>) i = n/<span class="number">2</span>*<span class="number">2</span> - <span class="number">1</span>; <span class="comment">// 令 i 指向最后一个奇数位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>partition:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> P = nums[low];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P &lt;= nums[high]) high--;</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; P &gt;= nums[low]) low++;</span><br><span class="line">            nums[high] = nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = P;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> target = n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = partition(nums, low, high);</span><br><span class="line">            <span class="keyword">if</span>(m &lt; target) low = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m &gt; target) high = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = nums[target]; <span class="comment">// 找到中位数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(1) 空间复杂度填充数组</span></span><br><span class="line">        <span class="keyword">int</span> even_i = (n<span class="number">-1</span>)/<span class="number">2</span>*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> odd_i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = even_i; <span class="comment">// 令i指向最后一个偶数位</span></span><br><span class="line">        <span class="keyword">int</span> count = n;</span><br><span class="line">        <span class="keyword">while</span>(count--)&#123; <span class="comment">//每次都会判断一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; mid)&#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[i], nums[even_i]);</span><br><span class="line">                even_i -= <span class="number">2</span>;</span><br><span class="line">                i -= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">0</span>) i = n/<span class="number">2</span>*<span class="number">2</span> - <span class="number">1</span>; <span class="comment">// 令 i 指向最后一个奇数位</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; mid)&#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[i], nums[odd_i]);</span><br><span class="line">                odd_i += <span class="number">2</span>; <span class="comment">// 奇数位增加</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 保持原值不变, 判断下一个值</span></span><br><span class="line">                i -= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">0</span>) i = n/<span class="number">2</span>*<span class="number">2</span> - <span class="number">1</span>; <span class="comment">// 令 i 指向最后一个奇数位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="328-Odd-Even-Linked-List"><a href="#328-Odd-Even-Linked-List" class="headerlink" title="328. Odd Even Linked List"></a>328. Odd Even Linked List</h1><h2 id="Description-奇偶链表"><a href="#Description-奇偶链表" class="headerlink" title="Description: 奇偶链表"></a>Description: 奇偶链表</h2><p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>
<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL</span><br><span class="line">Output: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>The relative order inside both the even and odd groups should remain as it was in the input.<br>The first node is considered odd, the second node even and so on …</p>
<h2 id="解法一-一次遍历"><a href="#解法一-一次遍历" class="headerlink" title="解法一: 一次遍历"></a>解法一: 一次遍历</h2><p><strong>时间复杂度:</strong> $O(n)$, 遍历每个节点一次<br><strong>空间复杂度:</strong> $O(1)$, 未使用任何额外空间</p>
<p>我们利用两个变量分别来维护奇数链表和偶数链表, 最后令奇数链表的最后一个节点的 <code>next</code> 指针指向偶数链表的头结点, 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *odd_head = head; <span class="comment">// 奇数链表头</span></span><br><span class="line">        ListNode *even_head = head-&gt;next; <span class="comment">// 偶数链表头</span></span><br><span class="line">        ListNode *odd_node = odd_head; <span class="comment">// 奇数链表节点</span></span><br><span class="line">        ListNode *even_node = even_head; <span class="comment">// 偶数链表节点</span></span><br><span class="line">        ListNode *node = head-&gt;next-&gt;next; <span class="comment">// 令当前节点指向第三个节点</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">3</span>; <span class="comment">// 记录节点编号(从1开始)</span></span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="literal">nullptr</span>)&#123;            </span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span> == <span class="number">1</span>)&#123; <span class="comment">// 奇数链表</span></span><br><span class="line">                odd_node-&gt;next = node;</span><br><span class="line">                odd_node = odd_node-&gt;next;</span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 偶数链表</span></span><br><span class="line">                even_node-&gt;next = node;</span><br><span class="line">                even_node = even_node-&gt;next;</span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;           </span><br><span class="line">        &#125;</span><br><span class="line">        odd_node-&gt;next = even_head;</span><br><span class="line">        even_node-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 少了这句话会超时, 原因是even_node会指向前面的某个节点, 形成环, 使得程序判断时无法终止</span></span><br><span class="line">        <span class="keyword">return</span> odd_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>更简洁的写法:</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == null) <span class="keyword">return</span> null;</span><br><span class="line">        ListNode odd = head, even = head.next, evenHead = even;</span><br><span class="line">        <span class="keyword">while</span> (even != null &amp;&amp; even.next != null) &#123;</span><br><span class="line">            odd.next = even.next;</span><br><span class="line">            odd = odd.next;</span><br><span class="line">            even.next = odd.next;</span><br><span class="line">            even = even.next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd.next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="334-Increasing-Triplet-Subsequence"><a href="#334-Increasing-Triplet-Subsequence" class="headerlink" title="334. Increasing Triplet Subsequence"></a>334. Increasing Triplet Subsequence</h1><h2 id="Description-递增的三元子序列"><a href="#Description-递增的三元子序列" class="headerlink" title="Description: 递增的三元子序列"></a>Description: 递增的三元子序列</h2><p>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.</p>
<p>Formally the function should:</p>
<p>Return true if there exists i, j, k<br>such that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.<br><strong>Note:</strong> Your algorithm should run in O(n) time complexity and O(1) space complexity.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,4,3,2,1]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-用辅助变量指向-min-和-mid"><a href="#解法一-用辅助变量指向-min-和-mid" class="headerlink" title="解法一: 用辅助变量指向 min 和 mid"></a>解法一: 用辅助变量指向 min 和 mid</h2><p><strong>时间复杂度:</strong> $O(n)$, 每个元素之遍历一次<br><strong>空间复杂度:</strong> $O(1)$, 无需额外空间</p>
<p>我们利用两个变量 <code>min</code> 和 <code>mid</code> 分别指向三元子序列中的最小元素和中间元素, 最开始时, 二者赋初值为 <code>INT_MAX</code>, 然后遍历数组, 对于数组中的每一个数 <code>num</code>, 进行如下判断:</p>
<ol>
<li>是否小于等于 <code>min</code>, 若满足, 则令 <code>min=num</code>;</li>
<li>若不满足(1), 则说明 <code>num &gt; min</code>, 判断 <code>num</code> 是否小于等于 <code>mid</code>, 若满足, 责令 <code>mid=num</code>;(此时 <code>mid</code> 一定大于 <code>min</code>, 且下标也大于 <code>min</code> 下标)</li>
<li>若不满足(1)(2), 则说明 <code>num</code> 不仅大于 <code>min</code>, 而且大于 <code>mid</code>, 同时 <code>num</code> 的下标也大于前两者, 由此, 我们找到了一个满足条件的递增三元组子序列, 可直接返回 <code>true</code>. 否则, 重复以上步骤直至遍历完数组</li>
<li>如果遍历完整个数组后, 仍然找不到符合条件的序列, 则说明不存在这样的序列, 返回 false.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">increasingTriplet</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> min=INT_MAX, mid=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &lt;= min) <span class="comment">// 等于号不能少, 否则会跳到最后的else中, 直接返回true</span></span><br><span class="line">                min = num;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &lt;= mid) <span class="comment">// 如输入为 11111111 时, 若没有等于号, 则会跳到else中返回true</span></span><br><span class="line">                mid = num;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//当前数字比min和mid都大, 所以找到了一个三元组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="341-Flatten-Nested-List-Iterator"><a href="#341-Flatten-Nested-List-Iterator" class="headerlink" title="341. Flatten Nested List Iterator"></a>341. Flatten Nested List Iterator</h1><h2 id="Description-将嵌套的多维列表展开成一维"><a href="#Description-将嵌套的多维列表展开成一维" class="headerlink" title="Description: 将嵌套的多维列表展开成一维"></a>Description: 将嵌套的多维列表展开成一维</h2><p>Given a nested list of integers, implement an iterator to flatten it.</p>
<p>Each element is either an integer, or a list — whose elements may also be integers or other lists.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1],2,[1,1]]</span><br><span class="line">Output: [1,1,2,1,1]</span><br><span class="line">Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,[4,[6]]]</span><br><span class="line">Output: [1,4,6]</span><br><span class="line">Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-栈-2"><a href="#解法一-栈-2" class="headerlink" title="解法一: 栈"></a>解法一: 栈</h2><p><strong>PS: 这道题可以在初始化时将列表全部展开并存储, 这样 <code>hasNext()</code> 就可以达到 $O(1)$ 的时间复杂度, 但是, 这是很不好的! 因为实际实现迭代器时, 我们往往只在需要的时候才会对元素进行展开, 这样可以获得最大的平均效率</strong></p>
<p><strong>时间复杂度:</strong> $O(n)$, 每个节点至多遍历一次, 其中, <code>next()</code> 复杂度为 $O(1)$, 初始化和 <code>hasNext()</code> 的复杂度均为 $O(n)$<br><strong>空间复杂度:</strong> $O(n)$, 栈所需空间</p>
<p>先将数组中的所有元素从后往前的放进栈中, 这样栈顶元素即为数组中的第一个元素, 然后对栈顶元素进行判断, 如果 <code>isInteger()</code> 为真, 则直接返回 <code>true</code>, 否则, 就获取栈顶对应的 <code>vector&lt;NestedInteger&gt;</code> 数组, 并将栈顶 <code>pop()</code>, 然后将数组从后往前再放到栈中, 重复以上操作直至栈为空, 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;NestedInteger&gt; s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NestedIterator(<span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nestedList.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            s.push(nestedList[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">return</span> res.getInteger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            NestedInteger top = s.top();</span><br><span class="line">            <span class="keyword">if</span>(top.isInteger()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="built_in">vector</span>&lt;NestedInteger&gt; <span class="built_in">list</span> = top.getList();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">list</span>.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">                    s.push(<span class="built_in">list</span>[i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NestedIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NestedIterator i(nestedList);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="解法二-deque"><a href="#解法二-deque" class="headerlink" title="解法二: deque"></a>解法二: deque</h2><p><strong>时间复杂度:</strong> $O(n)$, 每个节点至多遍历一次, 其中, <code>next()</code> 复杂度为 $O(1)$, 初始化和 <code>hasNext()</code> 的复杂度均为 $O(n)$<br><strong>空间复杂度:</strong> $O(n)$, 双端队列所需空间</p>
<p>同样的思路, 也可以用双端队列解决.(栈有的功能双端队列也有)</p>
<h1 id="347-Top-K-Frequent-Elements"><a href="#347-Top-K-Frequent-Elements" class="headerlink" title="347. Top K Frequent Elements"></a>347. Top K Frequent Elements</h1><h2 id="Description-寻找频率最高的-k-个数字"><a href="#Description-寻找频率最高的-k-个数字" class="headerlink" title="Description: 寻找频率最高的 k 个数字"></a>Description: 寻找频率最高的 k 个数字</h2><p>Given a non-empty array of integers, return the k most frequent elements.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1], k = 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure></p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ number of unique elements.<br>Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size.</p>
<h2 id="解法一-哈希-大顶堆"><a href="#解法一-哈希-大顶堆" class="headerlink" title="解法一: 哈希+大顶堆"></a>解法一: 哈希+大顶堆</h2><p><strong>时间复杂度:</strong> $O(n+nlogn)=O(nlogn)$, 遍历复杂度为 $O(n)$, 堆排序复杂度为 $O(nlogn)$<br><strong>空间复杂度:</strong> $O(n+n) = O(n)$, <code>unordered_map</code> 和 <code>priority_queue</code> 各占 $O(n)$ 大小的空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">            hash[num]++; <span class="comment">//对于不存在的关键字, 其值默认为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:hash)</span><br><span class="line">            q.push(&#123;it.second, it.first&#125;); <span class="comment">// 注意, sceond在前作为排序依据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;k; i++)&#123;</span><br><span class="line">            res.push_back(q.top().second); q.pop();</span><br><span class="line">            <span class="comment">// 注意, 因为插入的时候将first插在了第二位, 因此, 获取时应该用second获取数字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-哈希-小顶堆"><a href="#解法二-哈希-小顶堆" class="headerlink" title="解法二: 哈希+小顶堆"></a>解法二: 哈希+小顶堆</h2><p><strong>时间复杂度:</strong> $O(n+nlogk)=O(nlogk)$, 遍历复杂度为 $O(n)$, 堆排序时, 用小顶堆, 只保存最大的 k 个元素即可.<br><strong>空间复杂度:</strong> $O(n+n) = O(n)$, <code>unordered_map</code> 和 <code>priority_queue</code> 各占 $O(n)$ 大小的空间</p>
<p>整体思路和解法一相同, 只不过我们需要得到最大的 $k$ 个元素即可, 因此无需维护 $n$ 大小的大顶堆. 相反, 我们选择维护 $k$ 大小的小顶堆, 对于任意一个新来的元素, 如果它大于堆顶, 则将堆顶退出, 然后将新来元素加入堆中. 因为小顶堆的堆顶是最小的元素, 因此堆中用于 $k-1$ 个比堆顶大的元素, 故这 $k$ 个元素就是最大的 $k$ 个元素, 最终我们只需要将堆中数据依次取出, 然后执行一次 <code>reverse()</code> 即可.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这里小顶堆的定义, 其元素是 pair 类型</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;, <span class="built_in">std</span>::greater&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;&gt; q; <span class="comment">// 小顶堆</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">            hash[num]++; <span class="comment">//对于不存在的关键字, 其值默认为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : hash)&#123; <span class="comment">// 注意, 必须是遍历哈希表, 而不能遍历原数组, 因为原数组存在重复数字</span></span><br><span class="line">            <span class="keyword">if</span>(q.size() &lt; k)</span><br><span class="line">                q.push(&#123;it.second, it.first&#125;);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(q.top().first &lt; it.second)&#123;</span><br><span class="line">                q.pop();</span><br><span class="line">                q.push(&#123;it.second, it.first&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;k; i++)&#123;</span><br><span class="line">            res.push_back(q.top().second); q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::reverse(res.begin(), res.end()); <span class="comment">//因为结果是从小顶堆中得到的, 所以需要逆置一下, 也可以不逆置</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-哈希-桶"><a href="#解法三-哈希-桶" class="headerlink" title="解法三: 哈希+桶"></a>解法三: 哈希+桶</h2><p><strong>时间复杂度:</strong> $O(n+n+k)=O(n)$, 构建哈希表, 构建桶, 从桶找到 $k$ 个最大数字的复杂度分别为: $O(n)$, $O(n)$, 和 $O(k)$.<br><strong>空间复杂度:</strong> $O(n+n) = O(n)$, 哈希表和桶各占 $O(n)$</p>
<p>当我们拥有关于元素频率的哈希表以后, 我们可以利用此表构建桶结构, 桶的 “关键字” 为元素频率, 之后, 我们可以用 $O(n)$ 的复杂度对桶进行遍历, 当找到 $k$ 个最大元素时, 跳出遍历循环, 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash; <span class="comment">// 哈希</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num : nums) hash[num]++;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; buckets(nums.size()+<span class="number">1</span>); <span class="comment">// 根据数组的大小申请桶的空间, 多申请一个是为了方便下标对齐</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> h : hash) buckets[h.second].push_back(h.first); <span class="comment">// 用频率来做桶的索引, 并且对应数字放入桶中</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=buckets.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123; <span class="comment">// 最后往前遍历, 寻找频率最高的k个元素</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bucket = buckets[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; num : bucket)&#123;</span><br><span class="line">                res.push_back(num);</span><br><span class="line">                <span class="keyword">if</span>(res.size() &gt;= k) <span class="keyword">return</span> res; <span class="comment">// 找到k个元素, 直接返回并退出</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="378-Kth-Smallest-Element-in-a-Sorted-Matrix"><a href="#378-Kth-Smallest-Element-in-a-Sorted-Matrix" class="headerlink" title="378. Kth Smallest Element in a Sorted Matrix"></a>378. Kth Smallest Element in a Sorted Matrix</h1><h2 id="Description-找到半有序数组中的第-k-小的元素"><a href="#Description-找到半有序数组中的第-k-小的元素" class="headerlink" title="Description: 找到半有序数组中的第 k 小的元素"></a>Description: 找到半有序数组中的第 k 小的元素</h2><p>Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>
<p>Note that it is the kth smallest element in the sorted order, not the kth distinct element.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">   [ 1,  5,  9],</span><br><span class="line">   [10, 11, 13],</span><br><span class="line">   [12, 13, 15]</span><br><span class="line">],</span><br><span class="line">k = 8,</span><br><span class="line"></span><br><span class="line">return 13.</span><br></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ n2.</p>
<h2 id="解法一-堆"><a href="#解法一-堆" class="headerlink" title="解法一: 堆"></a>解法一: 堆</h2><p><strong>基于堆的 baseline 解法:</strong><br>最简单的堆解法就是不使用矩阵的有序性质, 直接当成无序数组来做, 我们申请一个 $k$ 大小的大顶堆, 然后遍历矩阵中的所有元素, 如果某元素小于堆顶就将堆顶弹出, 并压入该元素, 最终, 大顶堆的堆顶就是整个矩阵中第 $k$ 小的元素. 该解法的时间复杂度为 $O(nmlogk)$, 空间复杂度为 $O(k)$, 由于没有使用到有序矩阵的性质, 故不做讨论.</p>
<p><strong>更优的基于堆的解法(超屌的解法!):</strong></p>
<p><strong>时间复杂度:</strong> $O(klogn)$, $k$ 代表 kth, $n$ 代表矩阵的行数<br><strong>空间复杂度:</strong> $O(n)$, 堆的大小, $n$ 代表矩阵的行数</p>
<p>我们需要利用矩阵行列分别有序的性质, 首先, 具体思路如下:</p>
<ol>
<li>利用将矩阵中每一行的首元素(也就是第一列元素, 同理, 这里也可以用第一行元素)构造一个最小堆(这一步的复杂度小于 $O(nlogn)$), 堆中的元素是一个 <code>pair</code>, 其中 <code>first</code> 为元素的值, <code>second</code> 又是一个 <code>pair</code>, 存储着值的行列坐标 <code>(i, j)</code></li>
<li>将最小堆中的一个元素弹出(弹出的是当前堆最小的元素), 然后再将弹出元素的同一行的下一个元素(通过元素坐标获取)压入堆, 压入后, 堆会自动排序, 使得最小的元素位于堆顶.</li>
<li>重复步骤(2) k-1 次以后. 我们已经弹出了整个矩阵的最小的 k-1 个元素, 那么现在堆顶中的元素就是第 k 小的元素, 将其返回即可</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pair&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; &amp;a, pair&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; &amp;b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a.first &gt; b.first; <span class="comment">// 小顶堆</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span> || matrix[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m=matrix[<span class="number">0</span>].size();</span><br><span class="line">        priority_queue&lt; pair&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;, cmp&gt; min_heap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123; <span class="comment">// 用矩阵每一行的首元素构建堆, 堆的元素组成为&lt;(val, (i,j))&gt;</span></span><br><span class="line">            min_heap.push(make_pair(matrix[i][<span class="number">0</span>], make_pair(i, <span class="number">0</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = min_heap.top().first;</span><br><span class="line">            <span class="keyword">int</span> i = min_heap.top().second.first;</span><br><span class="line">            <span class="keyword">int</span> j = min_heap.top().second.second;</span><br><span class="line">            min_heap.pop(); <span class="comment">// 弹出堆</span></span><br><span class="line">            res = val;</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span>&lt;m) <span class="comment">// 将同行的下一个元素放入堆</span></span><br><span class="line">                min_heap.push(make_pair(matrix[i][j+<span class="number">1</span>], make_pair(i, j+<span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-二分查找-2"><a href="#解法二-二分查找-2" class="headerlink" title="解法二: 二分查找"></a>解法二: 二分查找</h2><p><strong>时间复杂度:</strong> $O(nlogm\times logD$, $n$ 为矩阵的行数, $m$ 为矩阵的列数, $D$ 为矩阵中最大元素与最小元素之间的差值.<br><strong>空间复杂度:</strong> $O(1)$, 没有利用额外空间</p>
<p>算法利用了每一行中, 元素都是有序的这个性质(但是没有用到列有序的性质), 步骤如下:</p>
<ol>
<li>获取矩阵中元素的最小值 <code>low</code> 和最大值 <code>high</code></li>
<li>令 <code>mid = (high+low)/2</code>, 然后我们利用 <code>upper_bound()</code> 函数来查找矩阵中第一个大于 <code>mid</code> 的元素(耗时 $O(logn)$), 接着计算这个元素之前的元素数量. 对矩阵的每一行重复这个步骤, 并将所有的元素数量累加起来</li>
<li>如果累加元素数 <code>count &lt; k</code>, 说明, <code>mid</code> 的值较小, 我们令 <code>low=mid+1</code>, 否则, 说明 <code>count&gt;=k</code>, 我们令 <code>high=mid</code>, <strong>注意, 这里的赋值关系最好不要改动, 并且要知道为什么令 <code>high=mid</code>, 而不是 <code>mid-1</code>.</strong></li>
<li>重复上述过程直至 <code>low=high</code>, 此时, <code>low</code> 或 <code>high</code> 的值就是矩阵中第 k 小的值</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span> || matrix[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> low = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> high = matrix[n<span class="number">-1</span>][m<span class="number">-1</span>]; <span class="comment">//题目中是方阵, 这里故意写成nm的矩阵, 以适应更普通的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low+high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">                <span class="comment">// 找到第一个大于 mid 的数, 然后计算这之前的元素个数</span></span><br><span class="line">                <span class="keyword">int</span> row_count = <span class="built_in">std</span>::upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();</span><br><span class="line">                count += row_count;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(count &lt; k)&#123; <span class="comment">// 注意, 这里不能令小于号来包括等于号时的情况, 因为 (low+high)/2 是偏向左边的, 这样会造成死循环</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 当 count&gt;=k 时, 说明 mid之前就能满足 k 个元素, 故令 high=mid;  注意, 这里不要尝试令low=mid</span></span><br><span class="line">                high = mid;</span><br><span class="line">            &#125; <span class="comment">// 这里的二分查找不同于普通的数组, 因为 mid 有可能不是数组中的值, 所以即使count=k时, 也不能直接返回mid</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> low; <span class="comment">// 最终, 当 low=high时, 即为第k小的元素. 因为当, high指向第k小的元素时, 它就不可能再减小, 而只能是low一点点靠近high, 直至相等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-二分查找"><a href="#解法三-二分查找" class="headerlink" title="解法三: 二分查找"></a>解法三: 二分查找</h2><p><strong>时间复杂度:</strong> $O((n+m)logD)$, $n$ 为矩阵行数, $m$ 为矩阵列数, $D$ 为矩阵中元素的最大差值<br><strong>空间复杂度:</strong> $O(1)$</p>
<p>解法二中并没有完全使用到矩阵所有的性质, 考虑到矩阵在列上也是有序的, 我们可以进一步优化算法. 我们应该还记得在剑指offer的第一题中, 考察了这种行列有序数组的元素查找算法, 我们可以在 $O(n+m)$ 的时间里找到指定的元素, 因此, 我们可以利用该算法替换解法二中对每一行执行二分查找的算法, 故而时间复杂度就变成了 $O((n+m)logD)$, 其中, $n$ 为矩阵行数, $m$ 为矩阵列数, $D$ 为矩阵中元素的最大差值, 代码如下.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span> || matrix[<span class="number">0</span>].size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> low = matrix[<span class="number">0</span>][<span class="number">0</span>], high = matrix[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low+high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> count = search(matrix, mid); <span class="comment">// 查找小于等于mid的元素数量</span></span><br><span class="line">            <span class="keyword">if</span>(count &lt; k)</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> i = n<span class="number">-1</span>, j=<span class="number">0</span>;  <span class="comment">// 从左下角开始</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>; <span class="comment">// 记录小于等于 target 的元素数量</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&lt;m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &lt;= target)&#123;</span><br><span class="line">                j++;</span><br><span class="line">                count += i+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="380-Insert-Delete-GetRandom-O-1"><a href="#380-Insert-Delete-GetRandom-O-1" class="headerlink" title="380. Insert Delete GetRandom O(1)"></a>380. Insert Delete GetRandom O(1)</h1><h2 id="Description-常数时间复杂度的插入-删除-和随机获取"><a href="#Description-常数时间复杂度的插入-删除-和随机获取" class="headerlink" title="Description: 常数时间复杂度的插入,删除,和随机获取"></a>Description: 常数时间复杂度的插入,删除,和随机获取</h2><p>Design a data structure that supports all following operations in average O(1) time.</p>
<ul>
<li>insert(val): Inserts an item val to the set if not already present.</li>
<li>remove(val): Removes an item val from the set if present.</li>
<li>getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.</li>
</ul>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Init an empty set.</span><br><span class="line">RandomizedSet randomSet = new RandomizedSet();</span><br><span class="line"></span><br><span class="line">// Inserts 1 to the set. Returns true as 1 was inserted successfully.</span><br><span class="line">randomSet.insert(1);</span><br><span class="line"></span><br><span class="line">// Returns false as 2 does not exist in the set.</span><br><span class="line">randomSet.remove(2);</span><br><span class="line"></span><br><span class="line">// Inserts 2 to the set, returns true. Set now contains [1,2].</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">// getRandom should return either 1 or 2 randomly.</span><br><span class="line">randomSet.getRandom();</span><br><span class="line"></span><br><span class="line">// Removes 1 from the set, returns true. Set now contains [2].</span><br><span class="line">randomSet.remove(1);</span><br><span class="line"></span><br><span class="line">// 2 was already in the set, so return false.</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">// Since 2 is the only number in the set, getRandom always return 2.</span><br><span class="line">randomSet.getRandom();</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-哈希表-数组"><a href="#解法一-哈希表-数组" class="headerlink" title="解法一: 哈希表+数组"></a>解法一: 哈希表+数组</h2><p><strong>时间复杂度:</strong> $O(1)$, 符合题意<br><strong>空间复杂度:</strong> $O(n)$, 数组和哈希表的大小各为 $O(n)$.</p>
<p>解题思路:</p>
<ul>
<li>插入: 用数组的 <code>push_back()</code> 存储新来的元素, 同时存入哈希表, <code>key</code> 为元素值, <code>val</code> 为元素在数组中的下标;</li>
<li>删除: 先用哈希表获取元素的下标, 然后将数组中的该元素和数组的最后一个元素交换, 接着用 <code>pop_back()</code> 删除该元素, 然后用 <code>erase()</code> 从哈希表中删除该元素, 最后在哈希表中更新被交换元素的下标;</li>
<li>获取随机元素: 利用 C++ 的内置随机函数 <code>rand()</code> 来获取随机数. <strong>但是注意, rand() 对生成的随机数质量无法保证, 在 C++11 中, 已经建议使用<a href="https://zh.cppreference.com/w/cpp/numeric/random" target="_blank" rel="noopener">随机数生成设施</a>来替换 rand().</strong> 另外注意: 如果想要使用 <code>srand()</code> 来播种, 那么不能将该语句放在 <code>getRandom()</code> 函数中, 因为重复播种会使得每次生成的随机数都一样, 正确的做法是将其放在构造函数中, 只进行一次播种.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    RandomizedSet() &#123;</span><br><span class="line">        srand(time(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.find(val) != hash.end()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        vec.push_back(val);</span><br><span class="line">        hash[val] = vec.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.find(val) == hash.end()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = hash[val];</span><br><span class="line">        <span class="keyword">int</span> j = vec.size() - <span class="number">1</span>;</span><br><span class="line">        swap(vec[i], vec[j]);</span><br><span class="line">        vec.pop_back(); <span class="comment">// 将元素和最后一位元素交换, 然后在删除, 满足 O(1) 复杂度</span></span><br><span class="line">        hash[vec[i]] = i;</span><br><span class="line">        hash.erase(val); <span class="comment">// 在哈希表中删除指定键值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// srand(time(0)); // 不能放在这里, 要放只能放在构造函数中</span></span><br><span class="line">        <span class="keyword">return</span> vec[rand()%vec.size()];</span><br><span class="line">        <span class="comment">// rand 无法保证生成的随机数质量, C++11推荐用随机数生成设施来替换该函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj.insert(val);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj.remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="384-Shuffle-an-Array"><a href="#384-Shuffle-an-Array" class="headerlink" title="384. Shuffle an Array"></a>384. Shuffle an Array</h1><h2 id="Description-打乱数组"><a href="#Description-打乱数组" class="headerlink" title="Description: 打乱数组"></a>Description: 打乱数组</h2><p>Shuffle a set of numbers without duplicates.</p>
<p>Example:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init an array with set 1, 2, and 3.</span></span><br><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Solution solution = <span class="keyword">new</span> Solution(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.</span></span><br><span class="line">solution.shuffle();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Resets the array back to its original configuration [1,2,3].</span></span><br><span class="line">solution.reset();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the random shuffling of array [1,2,3].</span></span><br><span class="line">solution.shuffle();</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-随机交换"><a href="#解法一-随机交换" class="headerlink" title="解法一: 随机交换"></a>解法一: 随机交换</h2><p><strong>时间复杂度:</strong> $O(n)$, 打乱需要 $O(n)$, <code>reset</code> 为 $O(1)$<br><strong>空间复杂度:</strong> $O(n)$</p>
<ul>
<li>shuffle: 打乱时, 遍历数组的下标, 然后随机生成一个下标, 令二者指向的元素交换. 更多分析请看<a href="../面试-KnuthShuffle算法">Knuth shuffle算法</a></li>
<li>reset: 直接返回缓存的原始数组</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums): v(nums)&#123;</span><br><span class="line">        <span class="built_in">std</span>::srand(<span class="built_in">std</span>::time(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Resets the array to its original configuration and return it. */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; reset() &#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns a random shuffling of the array. */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shuffle() &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sv(v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sv.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + rand() % (sv.size()-i); <span class="comment">//这里生成的 j 只可能在 i 之后</span></span><br><span class="line">            swap(sv[i], sv[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_1 = obj.reset();</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj.shuffle();</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<h1 id="395-Longest-Substring-with-At-Least-K-Repeating-Characters"><a href="#395-Longest-Substring-with-At-Least-K-Repeating-Characters" class="headerlink" title="395. Longest Substring with At Least K Repeating Characters"></a>395. Longest Substring with At Least K Repeating Characters</h1><h2 id="Description-23"><a href="#Description-23" class="headerlink" title="Description"></a>Description</h2><p>Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;aaabb&quot;, k = 3</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">The longest substring is &quot;aaa&quot;, as &apos;a&apos; is repeated 3 times.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;ababbc&quot;, k = 2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">The longest substring is &quot;ababb&quot;, as &apos;a&apos; is repeated 2 times and &apos;b&apos; is repeated 3 times.</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-哈希表-位标志"><a href="#解法一-哈希表-位标志" class="headerlink" title="解法一: 哈希表+位标志"></a>解法一: 哈希表+位标志</h2><p><strong>时间复杂度:</strong> 平均情况下为 $O(n)$, 最坏情况(待查找子串不存在)下为 $O(n^2)$<br><strong>空间复杂度:</strong> $O(26 + 1)$, 26 为哈希表的大小, 1 为 <code>mask</code> 的大小.</p>
<p>对于字母集, 可以利用哈希表来实现 $O(n)$ 复杂度的字符数量统计, 我们设置一个变量 <code>mask</code>, 该变量每一个比特位上的值有两种含义: 当某比特位为 1 时, 代表该比特位对应的字母在当前字符子串中的数量小于 k, 反之, 则该比特位为 0. 那么, 只要当 <code>mask=0</code>, 就说明此时的子串符合题目的要求, 我们计算当前子串的长度, 并更新最长长度值, 由于子串必须是连续的, 所以下一个子串的开始字符一定不会在当前子串的结束字符之前, 因为如果这样的话, 就一定会在当前子串的结束字符处终止, 故判断下一个子串时, 我们可以从当前子串结束字符的下一位开始判断. 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+k &lt;= n; )&#123; <span class="comment">// i 代表其实字符的位置</span></span><br><span class="line">            <span class="keyword">int</span> max_end = i; <span class="comment">// 注意要把这三行放在第一个for循环内部, 每次都要初始化一次</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> hash[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;n; j++)&#123; <span class="comment">// j 代表终止字符的位置, 从 i 开始</span></span><br><span class="line">                <span class="keyword">int</span> t = s[j] - <span class="string">'a'</span>;</span><br><span class="line">                hash[t]++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(hash[t] &lt; k) mask |= (<span class="number">1</span>&lt;&lt;t); <span class="comment">// set t bit to 1</span></span><br><span class="line">                <span class="keyword">else</span> mask &amp;=  (~(<span class="number">1</span>&lt;&lt;t)); <span class="comment">//这里外边的括号可以省, 但是位操作最好显式加括号</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(mask == <span class="number">0</span>)&#123; <span class="comment">// 如果mask=0, 说明所有的字符要么没有出现, 要么数量&gt;=k.</span></span><br><span class="line">                    <span class="keyword">int</span> length = j-i+<span class="number">1</span>;</span><br><span class="line">                    res = <span class="built_in">std</span>::max(res, length);</span><br><span class="line">                    max_end = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i = max_end + <span class="number">1</span>; <span class="comment">// 下一个最长的子串的开始一定不会在 i 与 max_end 之间,</span></span><br><span class="line">            <span class="comment">// 因为如果在这之间, 那么就一定会在 max_end 处终止</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-分而治之-递归"><a href="#解法二-分而治之-递归" class="headerlink" title="解法二: 分而治之, 递归"></a>解法二: 分而治之, 递归</h2><p><strong>时间复杂度:</strong> $O(n)$, 最坏情况下为 $O(n)$, 因为递归调用的深度最多为 26, 而每一层的复杂度约为 $O(n)$. <strong>(这种说法是网上的说法, 但是这里我个人觉得最坏情况是 $O(n^2), 只不过有的递归调用很快退出, 是的程序运行时间很短)</strong><br><strong>空间复杂度:</strong> $O(26+log_{26}n)$, 哈希表空间为, 递归占用空间为 $O(log_{26}n)$.</p>
<p>对于任意的字符串, 我们都执行下面的算法步骤:</p>
<ol>
<li>根据当前的字符串, 构建相应的哈希表, 表内数据为没一个字符的出现次数, 所以哈希表的大小为 26(或 256);</li>
<li>如果哈希表内所有字符的出现次数都满足条件(出现 0 次出现 k 次以上), 那么当前字符串满足条件, 可直接输出长度</li>
<li>如果字符串中存在不满足条件的字符, 那么就以这些字符</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l; i&lt;=r; i++)&#123; <span class="comment">// 构建 l,r 范围内的字符数哈希表</span></span><br><span class="line">            hash[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l; i&lt;=r; i++)&#123; <span class="comment">// 如果当前 l, r范围内的字符满足要求, 则直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(hash[s[i]] &amp;&amp; hash[s[i]] &lt; k)&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">return</span> (r-l+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = l;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=l; j&lt;=r; j++)&#123;</span><br><span class="line">            <span class="comment">//以所有不满足条件的字符为分界线, 递归获取前半段和后半段的最长子串长度</span></span><br><span class="line">            <span class="keyword">if</span>(hash[s[j]] &amp;&amp; hash[s[j]] &lt; k)&#123;</span><br><span class="line">                res = <span class="built_in">std</span>::max(res, helper(s, i, j<span class="number">-1</span>, k));</span><br><span class="line">                i = j+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 这里虽然对于多个相同的不满足条件的字符会进行多次调用</span></span><br><span class="line">                <span class="comment">// 但是由于传入的子串很短, 所以会很快接结束调用, 故可忽略不计此次调用</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(res, helper(s, i, r, k));<span class="comment">// i, r 为最后一段</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(s, l, r, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-更简洁的递归"><a href="#解法三-更简洁的递归" class="headerlink" title="解法三: 更简洁的递归"></a>解法三: 更简洁的递归</h2><p><strong>时间复杂度:</strong> $O(n)$, 最差情况下为 $O(kn)$, 详细见下面的分析<br><strong>空间复杂度:</strong> $O(n)$, 哈希+递归</p>
<p><strong>真正的 $O(n)$ 复杂度的实现:</strong> 和上面的思路一致, 也是利用不满足条件的字符作为分隔(因为只有符合条件的字符组成的字符串从 <strong>有可能</strong> 具有正确的长度), 但是不同于上面程序的是, 此次我们只对满足条件的子串进行递归, 故而那些重复的不满足条件的字符不会被重复用于递归(上面的代码就是重复调用了, 因为是在发现 &lt;k 时就进行调用), 下面的代码更加精炼易懂, 我们首先会跳过所有不满足条件的字符, 然后从满足条件的字符开始, 找到连续的满足条件的子串的最后一个字符, 然后对这个子串进行递归调用, 也就是说, <strong>我们最多会进行不超过 k 次递归调用</strong>, 因为最坏的情况是 26 个字符中, 只有一个字符不满足条件, 而这个字符最多将字符串分割成 k 段, 如果分割成 k+1 段, 那么就必须用 k 个字符, 此时与假设矛盾.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l; i&lt;=r; i++) hash[s[i]-<span class="string">'a'</span>]++; <span class="comment">// 构建哈希</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l; i&lt;=r; )&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;=r &amp;&amp; hash[s[i]-<span class="string">'a'</span>]&lt;k) i++; <span class="comment">// 跳过不符合的字符, 注意也要跳过未出现的字符, 所以=0也要跳过</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;r) <span class="keyword">break</span>; <span class="comment">// 如果所有字符都不符合, 则直接break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;=r &amp;&amp; hash[s[j]-<span class="string">'a'</span>]&gt;=k) j++; <span class="comment">// 找到当前子串中符合条件的最后一个连续字符</span></span><br><span class="line">            j--; <span class="comment">// 此时 j 指向的是符合条件字符的下一个位置, 因此, 我们要令 j--</span></span><br><span class="line">            <span class="comment">//if(j&gt;r) j=r; // j如果超限, 说明所有字符都符合, 则令 j 指向尾部字符即可</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i==l &amp;&amp; j==r) <span class="keyword">return</span> r-l+<span class="number">1</span>; <span class="comment">// 当前范围所有字符满足条件, 直接返回长度</span></span><br><span class="line">            res = <span class="built_in">std</span>::max(res, helper(s, i, j, k)); <span class="comment">// 对符合条件的子串进行调用, 最多会进行不超过 k 次调用</span></span><br><span class="line">            i = j+<span class="number">1</span>; <span class="comment">// 开始下一个子串的查询</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(s, l, r, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>上面的边界控制比较麻烦, 下面我们用超尾的方式来进行边界控制, 会使程序更加简洁, 如下所示:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=begin; i&lt;end; i++) hash[s[i]-<span class="string">'a'</span>]++; <span class="comment">// 构建哈希</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=begin; i&lt;end; )&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;end &amp;&amp; hash[s[i]-<span class="string">'a'</span>]&lt;k) i++; <span class="comment">// 跳过不符合的字符, 注意也要跳过未出现的字符, 所以=0也要跳过</span></span><br><span class="line">            <span class="keyword">if</span>(i==end) <span class="keyword">break</span>; <span class="comment">// 如果所有字符都不符合, 则直接break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;end &amp;&amp; hash[s[j]-<span class="string">'a'</span>]&gt;=k) j++; <span class="comment">// 找到当前子串中符合条件的最后一个连续字符</span></span><br><span class="line">            <span class="comment">//当使用超尾时, 无需对j特殊处理</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i==begin &amp;&amp; j==end) <span class="keyword">return</span> end-begin; <span class="comment">// 当前范围所有字符满足条件, 直接返回长度</span></span><br><span class="line">            res = <span class="built_in">std</span>::max(res, helper(s, i, j, k)); <span class="comment">// 对符合条件的子串进行调用, 最多会进行不超过 k 次调用</span></span><br><span class="line">            i = j+<span class="number">1</span>; <span class="comment">// 开始下一个子串的查询</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, end = s.size();</span><br><span class="line">        <span class="keyword">return</span> helper(s, begin, end, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="454-4Sum-II"><a href="#454-4Sum-II" class="headerlink" title="454. 4Sum II"></a>454. 4Sum II</h1><h2 id="Description-4-数之和为零的可能组合数"><a href="#Description-4-数之和为零的可能组合数" class="headerlink" title="Description: 4 数之和为零的可能组合数"></a>Description: 4 数之和为零的可能组合数</h2><p>Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.</p>
<p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">A = [ 1, 2]</span><br><span class="line">B = [-2,-1]</span><br><span class="line">C = [-1, 2]</span><br><span class="line">D = [ 0, 2]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The two tuples are:</span><br><span class="line">1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</span><br></pre></td></tr></table></figure></p>
<h2 id="解法一-先求两两之和"><a href="#解法一-先求两两之和" class="headerlink" title="解法一: 先求两两之和"></a>解法一: 先求两两之和</h2><p><strong>时间复杂度:</strong> $O(n^2+n^2)=O(n^2)$, 前者为 A, B 两两和的复杂度, 后者为 C, D 两两和的复杂度.<br><strong>空间复杂度:</strong> $O(n^2)$, 哈希表占用的空间</p>
<p>先求 A 与 B 的两两之和, 并将和作为键存于哈希表中, 哈希表中的值为和的出现次数, 然后再求 C, D 的两两之和, 同时查询哈希表中是否存在 C, D 和的负数, 若存在, 则说明可以组成零. 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a : A)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> b : B)&#123;</span><br><span class="line">                hash[a+b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : C)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> d : D)&#123;</span><br><span class="line">                <span class="keyword">int</span> target = -(c+d);</span><br><span class="line">                res += hash[target];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法刷题/" rel="tag"><i class="fa fa-tag"></i> 算法刷题</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/z_post/面试-Cpp面试总结/" rel="prev" title="C++ 面试总结">
                <i class="fa fa-chevron-left"></i> C++ 面试总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/z_post/面试-个人简历总结/" rel="next" title="个人简历总结">
                个人简历总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar_zz.png"
                alt="ZeroZone" />
            
              <p class="site-author-name" itemprop="name">ZeroZone</p>
              <p class="site-description motion-element" itemprop="description">并不是什么厉害的地方<br>只是一个安静的学习角落</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">263</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/hellozhaozheng" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:hellozhaozheng@foxmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/ksws0292756" title="零域CSDN博客" target="_blank">零域CSDN博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://xinghanzzy.github.io/" title="BoXiao的博客" target="_blank">BoXiao的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://oldpan.me/" title="Oldpan的博客" target="_blank">Oldpan的博客</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#002-Add-Two-Numbers"><span class="nav-text">002. Add Two Numbers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-链表数之和"><span class="nav-text">Description: 链表数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-顺序相加-注意进位"><span class="nav-text">解法一: 顺序相加, 注意进位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-顺序相加-维持原链表"><span class="nav-text">解法二: 顺序相加, 维持原链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展问题"><span class="nav-text">扩展问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#003-Longest-Substring-Without-Repeating-Characters"><span class="nav-text">003. Longest Substring Without Repeating Characters</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-寻找无重复字符的最长子串"><span class="nav-text">Description: 寻找无重复字符的最长子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-暴力"><span class="nav-text">解法一:暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-前后两个指示变量"><span class="nav-text">解法二: 前后两个指示变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-只需一次遍历"><span class="nav-text">解法三: 只需一次遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#005-Longest-Palindromic-Substring"><span class="nav-text">005. Longest Palindromic Substring</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-最大回文子串"><span class="nav-text">Description: 最大回文子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：最长公共子串"><span class="nav-text">解法一：最长公共子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二：-穷举"><span class="nav-text">解法二： 穷举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三：-动态规划"><span class="nav-text">解法三： 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三：-扩展中心法"><span class="nav-text">解法三： 扩展中心法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法五-马拉车-Manacher-算法"><span class="nav-text">解法五: 马拉车(Manacher) 算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#008-String-to-Integer-atoi"><span class="nav-text">008. String to Integer (atoi)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-将字符串转换成整数"><span class="nav-text">Description: 将字符串转换成整数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-考虑多种情况"><span class="nav-text">解法一: 考虑多种情况</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#011-Container-With-Most-Water"><span class="nav-text">011. Container With Most Water</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-暴力-1"><span class="nav-text">解法一: 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-用两个指针"><span class="nav-text">解法二: 用两个指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#015-3Sum"><span class="nav-text">015. 3Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-三数和为零"><span class="nav-text">Description: 三数和为零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-固定一个数-剩余两个数用双指针法求"><span class="nav-text">解法一: 固定一个数, 剩余两个数用双指针法求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-python写法"><span class="nav-text">解法二: python写法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#017-Letter-Combinations-of-a-Phone-Number"><span class="nav-text">017. Letter Combinations of a Phone Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-九键字母组合"><span class="nav-text">Description: 九键字母组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C"><span class="nav-text">C++</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法一-递归"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法二-非递归"><span class="nav-text">解法二: 非递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python"><span class="nav-text">Python</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法一-利用reduce实现"><span class="nav-text">解法一: 利用reduce实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#018-四数之和"><span class="nav-text">018. 四数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解法"><span class="nav-text">解法:</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#019-Remove-Nth-Node-From-End-of-List"><span class="nav-text">019. Remove Nth Node From End of List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-移除链表的倒数第-N-个字符"><span class="nav-text">Description: 移除链表的倒数第 N 个字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-遍历两次"><span class="nav-text">解法一: 遍历两次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-双指针-只遍历一次"><span class="nav-text">解法二: 双指针, 只遍历一次</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#022-Generate-Parentheses"><span class="nav-text">022. Generate Parentheses</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-1"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-暴力-2"><span class="nav-text">解法一: 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-回溯"><span class="nav-text">解法二: 回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-Closure-Number"><span class="nav-text">解法三: Closure Number</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-用栈来模拟递归"><span class="nav-text">解法四: 用栈来模拟递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#029-Divide-Two-Integers"><span class="nav-text">029. Divide Two Integers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-实现除法"><span class="nav-text">Description: 实现除法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-循环加法"><span class="nav-text">解法一: 循环加法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-左移法"><span class="nav-text">解法二: 左移法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展-这道题如果不允许使用-long-或者long-long-怎么解"><span class="nav-text">扩展: 这道题如果不允许使用 long 或者long long 怎么解?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#031-Next-Permutation"><span class="nav-text">031. Next Permutation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-实现-next-permutation-函数逻辑"><span class="nav-text">Description: 实现 next_permutation 函数逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-next-permutation-实现"><span class="nav-text">解法一: next_permutation 实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#033-Search-in-Rotated-Sorted-Array"><span class="nav-text">033. Search in Rotated Sorted Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-在循环有序数组中查找元素"><span class="nav-text">Description: 在循环有序数组中查找元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-二分查找"><span class="nav-text">解法一: 二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-二分查找"><span class="nav-text">解法二: 二分查找</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#034-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><span class="nav-text">034. Find First and Last Position of Element in Sorted Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-在有序数组中查找目标的开始位置和结束位置"><span class="nav-text">Description: 在有序数组中查找目标的开始位置和结束位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-二分查找-1"><span class="nav-text">解法一: 二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-二分查找-1"><span class="nav-text">解法二: 二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-STL-函数"><span class="nav-text">解法三: STL 函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#036-Valid-Sudoku"><span class="nav-text">036. Valid Sudoku</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-验证一个矩阵是否是数独数据"><span class="nav-text">Description: 验证一个矩阵是否是数独数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-利用flag数组存储判断矩阵"><span class="nav-text">解法一: 利用flag数组存储判断矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-位操作"><span class="nav-text">解法二: 位操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#046-Permutations"><span class="nav-text">046. Permutations</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-不含重复数字的全排列"><span class="nav-text">Description: 不含重复数字的全排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-1"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代"><span class="nav-text">解法二: 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-利用C-的内置函数-next-permutation"><span class="nav-text">解法三: 利用C++的内置函数 next_permutation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-自己实现-next-permutation"><span class="nav-text">解法四: 自己实现 next_permutation</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#047-Permutations-II"><span class="nav-text">047. Permutations II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-带有重复元素的全排列"><span class="nav-text">Description: 带有重复元素的全排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-set"><span class="nav-text">解法一: 递归+set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-STL-的-next-permutation-函数"><span class="nav-text">解法二: STL 的 next_permutation 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-自己实现-next-permutation"><span class="nav-text">解法三: 自己实现 next_permutation()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#048-Rotate-Image"><span class="nav-text">048. Rotate Image</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-图片旋转-90-度"><span class="nav-text">Description: 图片旋转 90 度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-逆置-转置"><span class="nav-text">解法一: 逆置+转置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-转置-列逆置"><span class="nav-text">解法二: 转置+列逆置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充-逆时针旋转90度"><span class="nav-text">补充: 逆时针旋转90度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充-图片旋转-180-度-上下翻转"><span class="nav-text">补充: 图片旋转 180 度(上下翻转)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充-图片左右翻转"><span class="nav-text">补充: 图片左右翻转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#049-Group-Anagrams"><span class="nav-text">049. Group Anagrams</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-找出同字母的异序词-并按字母分组输出"><span class="nav-text">Description: 找出同字母的异序词, 并按字母分组输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希表-sort"><span class="nav-text">解法一: 哈希表+sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-哈希表-不使用sort"><span class="nav-text">解法二: 哈希表(不使用sort)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-另一种生成-key-的解法-不用sort"><span class="nav-text">解法三: 另一种生成 key 的解法(不用sort)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#050-Pow-x-n"><span class="nav-text">050. Pow(x, n)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Descriptin"><span class="nav-text">Descriptin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-2"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-非递归-1"><span class="nav-text">解法二: 非递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#054-Spiral-Matrix"><span class="nav-text">054. Spiral Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-2"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-按层次输出-由外而内"><span class="nav-text">解法: 按层次输出(由外而内)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#055-Jump-Game"><span class="nav-text">055. Jump Game</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-3"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-回溯"><span class="nav-text">解法一: 回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-top-down-动态规划-递归"><span class="nav-text">解法二: top-down 动态规划(递归)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-down-top-动态规划-非递归"><span class="nav-text">解法三: down-top 动态规划(非递归)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-贪心"><span class="nav-text">解法四: 贪心</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#056-Merge-Intervals"><span class="nav-text">056. Merge Intervals</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-4"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-sort-O-n"><span class="nav-text">解法一: sort+O(n)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-sort-O-1"><span class="nav-text">解法二: sort+O(1)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-不使用sort"><span class="nav-text">解法三: 不使用sort</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#062-Unique-Paths"><span class="nav-text">062. Unique Paths</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-5"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-DP"><span class="nav-text">解法一: DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-优化的DP"><span class="nav-text">解法二: 优化的DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-排列组合-最优"><span class="nav-text">解法三: 排列组合(最优)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#073-Set-Matrix-Zeroes"><span class="nav-text">073. Set Matrix Zeroes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-6"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-穷举"><span class="nav-text">解法一: 穷举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-穷举-减少空间复杂度"><span class="nav-text">解法二: 穷举(减少空间复杂度)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-穷举-无空间复杂度"><span class="nav-text">解法三: 穷举(无空间复杂度)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-用第一行和第一列记录"><span class="nav-text">解法四: 用第一行和第一列记录</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#075-Sort-Colors"><span class="nav-text">075. Sort Colors</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-7"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-两次遍历"><span class="nav-text">解法一: 两次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-一次遍历"><span class="nav-text">解法二: 一次遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#077-Combinations"><span class="nav-text">077. Combinations</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-输出所有的组合"><span class="nav-text">Description: 输出所有的组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-回溯-1"><span class="nav-text">解法一: 回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-1"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#078-Subsets"><span class="nav-text">078. Subsets</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-8"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-迭代直接求出子集"><span class="nav-text">解法一: 迭代直接求出子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-回溯-1"><span class="nav-text">解法二: 回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-bit控制"><span class="nav-text">解法三: bit控制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#079-Word-Search"><span class="nav-text">079. Word Search</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-判断指定单词是否存在于字符矩阵中"><span class="nav-text">Description: 判断指定单词是否存在于字符矩阵中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-dfs-回溯"><span class="nav-text">解法一: dfs+回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#090-Subsets-II"><span class="nav-text">090. Subsets II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-含重复元素的数组的子集"><span class="nav-text">Description: 含重复元素的数组的子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-迭代"><span class="nav-text">解法一: 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-回溯-2"><span class="nav-text">解法二: 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#091-Decode-Ways"><span class="nav-text">091. Decode Ways</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-9"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-最优-DP-constant-space"><span class="nav-text">解法一(最优): DP constant space</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-递归"><span class="nav-text">解法二: 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#094-Binary-Tree-Inorder-Traversal"><span class="nav-text">094. Binary Tree Inorder Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-10"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-3"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-非递归-2"><span class="nav-text">解法二: 非递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#098-Validate-Binary-Search-Tree"><span class="nav-text">098. Validate Binary Search Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-11"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-4"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-中序"><span class="nav-text">解法二: 迭代(中序)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#102-Binary-Tree-Level-Order-Traversal"><span class="nav-text">102. Binary Tree Level Order Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-12"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-层次遍历"><span class="nav-text">解法一: 层次遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#103-Binary-Tree-Zigzag-Level-Order-Traversal"><span class="nav-text">103. Binary Tree Zigzag Level Order Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-13"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一：利用reverse"><span class="nav-text">解法一：利用reverse</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-最优-不用reverse"><span class="nav-text">解法二: 最优(不用reverse)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-利用双端队列"><span class="nav-text">解法三: 利用双端队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><span class="nav-text">105. Construct Binary Tree from Preorder and Inorder Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-根据先序和中序遍历构造二叉树"><span class="nav-text">Description: 根据先序和中序遍历构造二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-5"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-2"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#116-Populating-Next-Right-Pointers-in-Each-Node"><span class="nav-text">116. Populating Next Right Pointers in Each Node</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-14"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-层次遍历-1"><span class="nav-text">解法一: 层次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-利用-next-指针的特性"><span class="nav-text">解法二: 利用 next 指针的特性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#127-Word-Ladder"><span class="nav-text">127. Word Ladder</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-15"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-BFS"><span class="nav-text">解法一: BFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#130-Surrounded-Regions"><span class="nav-text">130. Surrounded Regions</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Descriptioin"><span class="nav-text">Descriptioin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-6"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-3"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#131-Palindrome-Partitioning"><span class="nav-text">131. Palindrome Partitioning</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-16"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-回溯-验证回文子串"><span class="nav-text">解法一: 回溯+验证回文子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-回溯-DP"><span class="nav-text">解法二: 回溯+DP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#134-Gas-Station"><span class="nav-text">134. Gas Station</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-17"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法-最优"><span class="nav-text">解法: 最优</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#138-Copy-List-with-Random-Pointer"><span class="nav-text">138. Copy List with Random Pointer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-18"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-复制-拆分"><span class="nav-text">解法一: 复制+拆分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-一次遍历-1"><span class="nav-text">解法二: 一次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-递归"><span class="nav-text">解法三: 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#139-Word-Break"><span class="nav-text">139. Word Break</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-19"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-回溯-2"><span class="nav-text">解法一: 回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-DP"><span class="nav-text">解法二: DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-DP"><span class="nav-text">解法三: DP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#142-Linked-List-Cycle-II"><span class="nav-text">142. Linked List Cycle II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-求链表中环的开始节点"><span class="nav-text">Description: 求链表中环的开始节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-Floyd-的乌龟和兔子-Floyd-判环算法"><span class="nav-text">解法一: Floyd 的乌龟和兔子(Floyd 判环算法)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#144-Binary-Tree-Preorder-Traversal"><span class="nav-text">144. Binary Tree Preorder Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-先根遍历"><span class="nav-text">Description: 先根遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-7"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-4"><span class="nav-text">解法二: 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#148-Sort-List"><span class="nav-text">148. Sort List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-20"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-自顶向下"><span class="nav-text">解法一: 递归 自顶向下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-自底向上"><span class="nav-text">解法二: 迭代 自底向上</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#150-Evaluate-Reverse-Polish-Notation"><span class="nav-text">150. Evaluate Reverse Polish Notation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-21"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-栈"><span class="nav-text">解法一: 栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-栈-异常"><span class="nav-text">解法二: 栈+异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-栈-lambda"><span class="nav-text">解法三: 栈+lambda</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-栈-lambda-异常"><span class="nav-text">解法四: 栈+lambda+异常</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#152-Maximum-Product-Subarray"><span class="nav-text">152. Maximum Product Subarray</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-22"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-8"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代实现"><span class="nav-text">解法二 迭代实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-DP-迭代"><span class="nav-text">解法三: DP 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#162-Find-Peak-Element"><span class="nav-text">162. Find Peak Element</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-局部最大值"><span class="nav-text">Description: 局部最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-O-n-复杂度"><span class="nav-text">解法一: $O(n)$ 复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-O-logn-复杂度"><span class="nav-text">解法二: $O(logn)$ 复杂度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#166-Fraction-to-Recurring-Decimal"><span class="nav-text">166. Fraction to Recurring Decimal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-无限循环小数"><span class="nav-text">Description: 无限循环小数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-用余数作为哈希表的key"><span class="nav-text">解法一: 用余数作为哈希表的key</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#179-Largest-Number"><span class="nav-text">179. Largest Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-排列数字使其字符串形式的数字为最大"><span class="nav-text">Description: 排列数字使其字符串形式的数字为最大</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-构造比较函数-快排排序"><span class="nav-text">解法一: 构造比较函数, 快排排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-利用-STL-sort-函数"><span class="nav-text">解法二: 利用 STL sort() 函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#200-Number-of-Islands"><span class="nav-text">200. Number of Islands</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-区块的个数"><span class="nav-text">Description: 区块的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-DFS-遍历"><span class="nav-text">解法一: DFS 遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#207-Course-Schedule"><span class="nav-text">207. Course Schedule</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-课程表-判断有向图是否存在环"><span class="nav-text">Description: 课程表 / 判断有向图是否存在环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-BFS-拓扑排序"><span class="nav-text">解法一: BFS / 拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-DFS"><span class="nav-text">解法二: DFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#208-Implement-Trie-Prefix-Tree"><span class="nav-text">208. Implement Trie (Prefix Tree)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-实现字典树-前缀树"><span class="nav-text">Description: 实现字典树(前缀树)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一"><span class="nav-text">解法一</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#210-Course-Schedule-II"><span class="nav-text">210. Course Schedule II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-判断有向图是否有环-若无环-则返回拓扑序列"><span class="nav-text">Description: 判断有向图是否有环, 若无环, 则返回拓扑序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-BFS-拓扑排序-1"><span class="nav-text">解法一: BFS, 拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-DFS-1"><span class="nav-text">解法二: DFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#215-Kth-Largest-Element-in-an-Array"><span class="nav-text">215. Kth Largest Element in an Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-找出无序数组中第k大的数"><span class="nav-text">Description: 找出无序数组中第k大的数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-小顶堆"><span class="nav-text">解法一: 小顶堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-部分排序-nth-element"><span class="nav-text">解法二: 部分排序(nth_element)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-基于-Partition"><span class="nav-text">解法三: 基于 Partition</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#227-Basic-Calculator-II"><span class="nav-text">227. Basic Calculator II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-基本计算器-二"><span class="nav-text">Description: 基本计算器(二)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-栈-1"><span class="nav-text">解法一: 栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-字符串流"><span class="nav-text">解法二: 字符串流</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#230-Kth-Smallest-Element-in-a-BST"><span class="nav-text">230. Kth Smallest Element in a BST</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-找出二叉搜索树中的最小元素"><span class="nav-text">Description: 找出二叉搜索树中的最小元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-非递归中根遍历"><span class="nav-text">解法一: 非递归中根遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-递归中根遍历"><span class="nav-text">解法二: 递归中根遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-二叉搜索"><span class="nav-text">解法三: 二叉搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解答Follow-up"><span class="nav-text">解答Follow up</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree"><span class="nav-text">236. Lowest Common Ancestor of a Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-查找二叉树中任意两个节点的公共祖先"><span class="nav-text">Description: 查找二叉树中任意两个节点的公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-递归-9"><span class="nav-text">解法一: 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-迭代-存储父节点"><span class="nav-text">解法二: 迭代(存储父节点)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-迭代-不存储父节点"><span class="nav-text">解法三: 迭代(不存储父节点)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#238-Product-of-Array-Except-Self"><span class="nav-text">238. Product of Array Except Self</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-计算数组内其他元素之积-不能使用除法"><span class="nav-text">Description: 计算数组内其他元素之积(不能使用除法)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-借助辅助数组"><span class="nav-text">解法一: 借助辅助数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-用一个变量代替数组"><span class="nav-text">解法二: 用一个变量代替数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-用两个变量代替数组"><span class="nav-text">解法三: 用两个变量代替数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#240-Search-a-2D-Matrix-II"><span class="nav-text">240. Search a 2D Matrix II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-矩阵搜索"><span class="nav-text">Description: 矩阵搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-从左下角开始"><span class="nav-text">解法一: 从左下角开始</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#279-Perfect-Squares"><span class="nav-text">279. Perfect Squares</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-找到最少的平方和个数"><span class="nav-text">Description: 找到最少的平方和个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-四平方和定理-最优"><span class="nav-text">解法一: 四平方和定理(最优)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-DP-1"><span class="nav-text">解法二: DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-DP-1"><span class="nav-text">解法三: DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-递归"><span class="nav-text">解法四: 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#287-Find-the-Duplicate-Number"><span class="nav-text">287. Find the Duplicate Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-寻找重复元素"><span class="nav-text">Description: 寻找重复元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希表"><span class="nav-text">解法一: 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-排序"><span class="nav-text">解法二: 排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-Floyd-的乌龟和兔子-Floy-判圈算法"><span class="nav-text">解法三: Floyd 的乌龟和兔子(Floy 判圈算法)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#289-Game-of-Life"><span class="nav-text">289. Game of Life</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-游戏人生"><span class="nav-text">Description: 游戏人生</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-状态机"><span class="nav-text">解法一: 状态机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Follow-up"><span class="nav-text">Follow up</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#300-Longest-Increasing-Subsequence"><span class="nav-text">300. Longest Increasing Subsequence</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-求最长递增序列-可以不连续-的长度"><span class="nav-text">Description: 求最长递增序列(可以不连续)的长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-暴力-3"><span class="nav-text">解法一: 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-Recursion-with-memorization-Memory-Limit-Exceeded"><span class="nav-text">解法二: Recursion with memorization [Memory Limit Exceeded]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-DP-2"><span class="nav-text">解法三: DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法四-DP-二分搜索-最优"><span class="nav-text">解法四: DP+二分搜索(最优)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#322-Coin-Change"><span class="nav-text">322. Coin Change</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-硬币凑面额"><span class="nav-text">Description: 硬币凑面额</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-DP-1"><span class="nav-text">解法一: DP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-DP-递归实现"><span class="nav-text">解法二: DP 递归实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-对暴力解法剪枝"><span class="nav-text">解法三: 对暴力解法剪枝</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#324-Wiggle-Sort-II"><span class="nav-text">324. Wiggle Sort II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-“驼峰”-排序"><span class="nav-text">Description: “驼峰” 排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-排序"><span class="nav-text">解法一: 排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-partition"><span class="nav-text">解法二: partition</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Follow-up-three-way-partition"><span class="nav-text">Follow up: three-way partition</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#328-Odd-Even-Linked-List"><span class="nav-text">328. Odd Even Linked List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-奇偶链表"><span class="nav-text">Description: 奇偶链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-一次遍历"><span class="nav-text">解法一: 一次遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#334-Increasing-Triplet-Subsequence"><span class="nav-text">334. Increasing Triplet Subsequence</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-递增的三元子序列"><span class="nav-text">Description: 递增的三元子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-用辅助变量指向-min-和-mid"><span class="nav-text">解法一: 用辅助变量指向 min 和 mid</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#341-Flatten-Nested-List-Iterator"><span class="nav-text">341. Flatten Nested List Iterator</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-将嵌套的多维列表展开成一维"><span class="nav-text">Description: 将嵌套的多维列表展开成一维</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-栈-2"><span class="nav-text">解法一: 栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-deque"><span class="nav-text">解法二: deque</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#347-Top-K-Frequent-Elements"><span class="nav-text">347. Top K Frequent Elements</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-寻找频率最高的-k-个数字"><span class="nav-text">Description: 寻找频率最高的 k 个数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希-大顶堆"><span class="nav-text">解法一: 哈希+大顶堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-哈希-小顶堆"><span class="nav-text">解法二: 哈希+小顶堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-哈希-桶"><span class="nav-text">解法三: 哈希+桶</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#378-Kth-Smallest-Element-in-a-Sorted-Matrix"><span class="nav-text">378. Kth Smallest Element in a Sorted Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-找到半有序数组中的第-k-小的元素"><span class="nav-text">Description: 找到半有序数组中的第 k 小的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-堆"><span class="nav-text">解法一: 堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-二分查找-2"><span class="nav-text">解法二: 二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-二分查找"><span class="nav-text">解法三: 二分查找</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#380-Insert-Delete-GetRandom-O-1"><span class="nav-text">380. Insert Delete GetRandom O(1)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-常数时间复杂度的插入-删除-和随机获取"><span class="nav-text">Description: 常数时间复杂度的插入,删除,和随机获取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希表-数组"><span class="nav-text">解法一: 哈希表+数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#384-Shuffle-an-Array"><span class="nav-text">384. Shuffle an Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-打乱数组"><span class="nav-text">Description: 打乱数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-随机交换"><span class="nav-text">解法一: 随机交换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#395-Longest-Substring-with-At-Least-K-Repeating-Characters"><span class="nav-text">395. Longest Substring with At Least K Repeating Characters</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-23"><span class="nav-text">Description</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-哈希表-位标志"><span class="nav-text">解法一: 哈希表+位标志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法二-分而治之-递归"><span class="nav-text">解法二: 分而治之, 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法三-更简洁的递归"><span class="nav-text">解法三: 更简洁的递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#454-4Sum-II"><span class="nav-text">454. 4Sum II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-4-数之和为零的可能组合数"><span class="nav-text">Description: 4 数之和为零的可能组合数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解法一-先求两两之和"><span class="nav-text">解法一: 先求两两之和</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZeroZone</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">2.5m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">37:45</span>
  
</div>










  <div class="footer-custom">勤练带来力量</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  





  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


</body>
</html>
